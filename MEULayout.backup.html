<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEU Layout</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Ultra High-Contrast Color Palette */
            --primary: #3730a3;
            --primary-light: #4f46e5;
            --primary-dark: #1e1b4b;
            --accent: #0284c7;
            --background: #ffffff;
            --surface: #ffffff;
            --surface-elevated: #ffffff;
            --text-primary: #000000;
            --text-secondary: #1f2937;
            --text-tertiary: #374151;
            --border: #9ca3af;
            --border-light: #d1d5db;
            --success: #15803d;
            --warning: #b45309;
            --error: #b91c1c;
            
            /* Ultra High-Contrast Gradients */
            --gradient-primary: linear-gradient(135deg, #3730a3 0%, #1e1b4b 100%);
            --gradient-surface: linear-gradient(145deg, #ffffff 0%, #ffffff 100%);
            --gradient-background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            
            /* Refined Spacing System */
            --space-1: 0.25rem;  /* 4px */
            --space-2: 0.5rem;   /* 8px */
            --space-3: 0.75rem;  /* 12px */
            --space-4: 1rem;     /* 16px */
            --space-5: 1.25rem;  /* 20px */
            --space-6: 1.5rem;   /* 24px */
            --space-8: 2rem;     /* 32px */
            --space-10: 2.5rem;  /* 40px */
            --space-12: 3rem;    /* 48px */
            --space-16: 4rem;    /* 64px */
            
            /* Professional Border Radius */
            --radius-xs: 0.125rem; /* 2px */
            --radius-sm: 0.25rem;  /* 4px */
            --radius-md: 0.375rem; /* 6px */
            --radius-lg: 0.5rem;   /* 8px */
            --radius-xl: 0.75rem;  /* 12px */
            --radius-2xl: 1rem;   /* 16px */
            --radius-3xl: 1.5rem; /* 24px */
            
            /* Smooth Shadows */
            --shadow-xs: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            
            /* Typography Scale */
            --text-xs: 0.75rem;   /* 12px */
            --text-sm: 0.875rem;  /* 14px */
            --text-base: 1rem;    /* 16px */
            --text-lg: 1.125rem;  /* 18px */
            --text-xl: 1.25rem;   /* 20px */
            --text-2xl: 1.5rem;   /* 24px */
            --text-3xl: 1.875rem; /* 30px */
            --text-4xl: 2.25rem;  /* 36px */
            
            /* Transition System */
            --transition-fast: 150ms ease-out;
            --transition-base: 300ms ease-out;
            --transition-slow: 500ms ease-out;
            
            /* Ultra High-Contrast Input and Select */
            --input-bg: #ffffff;
            --input-border: #6b7280;
            --input-hover-bg: #f9fafb;
            --input-hover-border: #374151;
            --input-focus-bg: white;
            --input-focus-border: #3730a3;
            --input-focus-shadow: rgba(55, 48, 163, 0.25);
            
            /* Gray Scale with High Contrast */
            --gray-100: #f3f4f6;
            --gray-200: #d1d5db;
            --gray-300: #9ca3af;
            --gray-400: #6b7280;
            --gray-500: #4b5563;
            --gray-600: #374151;
            --gray-700: #1f2937;
            --gray-800: #111827;
            --gray-900: #000000;
            
            /* Utility Colors */
            --text-dark: var(--text-primary);
            --text-light: var(--text-secondary);
            --primary-600: var(--primary);
            --primary-blue: var(--primary);
            --dark-blue: var(--primary-dark);
        }

        /* Global input and select styling for consistency */
        input[type="text"],
        input[type="number"],
        input[type="email"],
        input[type="password"],
        select,
        textarea {
            background: var(--input-bg) !important;
            border: 2px solid var(--input-border) !important;
            border-radius: 6px !important;
            padding: 8px 12px !important;
            transition: all 0.2s ease !important;
            font-size: 14px !important;
        }

        input[type="text"]:hover,
        input[type="number"]:hover,
        input[type="email"]:hover,
        input[type="password"]:hover,
        select:hover,
        textarea:hover {
            border-color: var(--input-hover-border) !important;
            background: var(--input-hover-bg) !important;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="email"]:focus,
        input[type="password"]:focus,
        select:focus,
        textarea:focus {
            outline: none !important;
            border-color: var(--input-focus-border) !important;
            background: var(--input-focus-bg) !important;
            box-shadow: 0 0 0 3px var(--input-focus-shadow) !important;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Lexend', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-weight: 500;
            line-height: 1.7;
            background: var(--gradient-background);
            min-height: 100vh;
            padding: var(--space-4);
            color: var(--text-primary);
            font-size: var(--text-base);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--surface);
            border-radius: var(--radius-2xl);
            box-shadow: var(--shadow-xl), 0 0 0 1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            border: 3px solid var(--border);
        }

        .header {
            background: var(--gradient-primary);
            color: white;
            padding: var(--space-10) var(--space-6);
            text-align: center;
            position: relative;
        }

        .header-content {
            max-width: 800px;
            margin: 0 auto;
        }

        .header h1 {
            font-size: var(--text-4xl);
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.025em;
            text-shadow: 0 2px 8px rgba(0,0,0,0.2);
            line-height: 1.1;
        }

        .header-subtitle {
            font-size: var(--text-lg);
            font-weight: 500;
            margin-top: var(--space-3);
            opacity: 0.95;
            letter-spacing: 0.5px;
        }

        .main-content {
            padding: var(--space-12) var(--space-8);
            max-width: 100%;
            margin: 0 auto;
            background: var(--surface);
        }

        /* Balanced Navigation Tabs */
        .function-tabs {
            display: flex;
            gap: var(--space-2);
            margin-bottom: var(--space-16);
            justify-content: center;
            background: var(--background);
            padding: var(--space-2);
            border-radius: var(--radius-2xl);
            border: 2px solid var(--border);
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            box-shadow: var(--shadow-md);
        }

        .tab-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-5) var(--space-4);
            border: 3px solid var(--border);
            border-radius: var(--radius-xl);
            background: var(--surface);
            cursor: pointer;
            transition: var(--transition-base);
            flex: 1;
            justify-content: center;
            text-align: center;
            color: var(--text-primary);
            font-weight: 600;
            min-height: 88px;
        }

        .tab-button:hover {
            color: var(--primary-dark);
            border-color: var(--primary);
            background: var(--surface-elevated);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg), 0 0 0 1px var(--primary);
        }

        .tab-button.active {
            color: white;
            background: var(--primary-dark);
            border-color: var(--primary-dark);
            box-shadow: var(--shadow-lg), inset 0 2px 4px rgba(0, 0, 0, 0.1);
            font-weight: 700;
        }

        .tab-button.active:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .tab-icon {
            font-size: var(--text-2xl);
            margin: 0;
            transition: var(--transition-base);
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }

        .tab-text {
            font-size: var(--text-sm);
            font-weight: 600;
            margin: 0;
            transition: var(--transition-base);
            text-shadow: none;
        }

        .tab-button.active .tab-text {
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .tab-desc {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .tab-button.active .tab-desc {
            opacity: 1;
        }

        /* Function Sections */
        .function-section {
            display: none !important;
        }

        .function-section.active {
            display: block !important;
            position: relative;
            z-index: 1;
        }

        /* Crop Size Selection */
        /* Old crop styles removed - using new crop-container styles */

        .input-group input {
            padding: 8px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            text-align: center;
            width: 80px;
        }


        /* Convert Controls - Cân đối và chuyên nghiệp */
        .controls {
            margin: var(--space-8) auto;
            padding: var(--space-8);
            background: var(--surface);
            border-radius: var(--radius-2xl);
            border: 2px solid var(--border);
            max-width: 800px;
            box-shadow: var(--shadow-md);
        }

        .controls-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            align-items: start;
            gap: var(--space-8);
            margin-bottom: var(--space-6);
        }

        .controls-row:last-child {
            grid-template-columns: 1fr auto;
            align-items: end;
            margin-bottom: 0;
            gap: var(--space-6);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }

        .control-group label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: var(--text-base);
            margin-bottom: var(--space-1);
        }

        .control-group select {
            padding: var(--space-4) var(--space-5);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            background: var(--surface);
            font-size: var(--text-base);
            font-weight: 500;
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition-base);
            width: 100%;
        }

        .control-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.15);
        }

        .control-group input[type="text"] {
            padding: var(--space-4) var(--space-5);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            background: var(--surface);
            font-size: var(--text-base);
            font-weight: 500;
            color: var(--text-primary);
            transition: var(--transition-base);
            width: 100%;
        }

        .control-group input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.15);
        }

        .quality-container {
            display: flex;
            align-items: center;
            gap: var(--space-4);
            width: 100%;
            padding: var(--space-4);
            background: var(--background);
            border-radius: var(--radius-lg);
            border: 2px solid var(--border);
        }

        .quality-slider {
            flex: 1;
            height: 6px;
            background: var(--border);
            border-radius: var(--radius-sm);
            outline: none;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
        }

        .quality-slider::-webkit-slider-thumb {
            appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: var(--shadow-sm);
        }

        .quality-slider::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: var(--shadow-sm);
        }

        .quality-value {
            min-width: 45px;
            font-weight: 600;
            color: var(--primary);
            text-align: center;
        }

        .naming-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .naming-control label {
            font-weight: 600;
            color: #374151;
        }

        .naming-control select {
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            background: #f9fafb;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        .naming-control select:hover {
            border-color: #9ca3af;
            background: #f3f4f6;
        }

        .naming-control select:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .format-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .format-selector label {
            font-weight: 600;
            color: #374151;
        }

        .format-selector select {
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            background: #f9fafb;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        .format-selector select:hover {
            border-color: #9ca3af;
            background: #f3f4f6;
        }

        .format-selector select:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .quality-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .quality-control label {
            font-weight: 600;
            color: #374151;
        }

        .quality-slider {
            width: 120px;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            outline: none;
        }

        .quality-value {
            font-weight: 600;
            color: #667eea;
            min-width: 35px;
        }

        .convert-btn {
            background: var(--primary);
            color: white;
            border: 2px solid var(--primary);
            padding: var(--space-4) var(--space-8);
            border-radius: var(--radius-xl);
            font-size: var(--text-lg);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-base);
            min-width: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            box-shadow: var(--shadow-md);
        }

        .convert-btn:hover:not(:disabled) {
            background: var(--primary-dark);
            border-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .convert-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: var(--shadow-sm);
        }

        .file-list {
            margin: var(--spacing-lg) auto 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: var(--spacing-lg);
            max-width: 1000px;
        }

        @media (max-width: 768px) {
            .file-list {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 16px;
            }
        }

        @media (max-width: 480px) {
            .file-list {
                grid-template-columns: 1fr;
                gap: 12px;
            }
        }

        .file-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .file-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: var(--primary-blue);
        }

        .file-preview {
            width: 100%;
            background: #f8fafc;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            aspect-ratio: 1;
            min-height: 100px;
        }

        .file-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.3s ease;
        }

        .file-preview:hover img {
            transform: scale(1.02);
        }

        .file-preview .file-icon {
            font-size: 3rem;
            color: var(--primary-blue);
            opacity: 0.7;
        }

        .file-preview .file-icon.heic-placeholder {
            font-size: 2rem;
            color: #8B5CF6;
            text-align: center;
            line-height: 1.2;
        }

        .file-preview .file-icon.heic-placeholder small {
            font-size: 0.7rem;
            display: block;
            margin-top: 4px;
            font-weight: 600;
        }

        .file-content {
            padding: 12px;
        }

        .file-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            color: var(--text-dark);
            font-size: 0.9rem;
            margin-bottom: 4px;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .file-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .file-size {
            font-size: 0.85rem;
            color: var(--text-light);
            font-weight: 500;
        }

        .file-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .file-status.pending {
            background: #FEF3C7;
            color: #92400E;
        }

        .file-status.converting {
            background: #DBEAFE;
            color: #1E40AF;
        }

        .file-status.success {
            background: #D1FAE5;
            color: #065F46;
        }

        .file-status.error {
            background: #FEE2E2;
            color: #991B1B;
        }

        .file-dimensions {
            font-size: 0.8rem;
            color: var(--primary);
            font-weight: 600;
            margin: 4px 0;
            padding: 2px 6px;
            background: rgba(79, 70, 229, 0.1);
            border-radius: 6px;
            display: inline-block;
            font-family: 'Courier New', monospace;
        }

        /* Progress bar for file conversion */
        .file-progress {
            margin: 8px 0;
            display: none;
        }

        .file-progress.show {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%);
            border-radius: 3px;
            transition: width 0.5s ease-out;
            width: 0%;
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
            animation: progressShimmer 2s infinite;
        }

        @keyframes progressShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Upload Progress Overlay */
        .upload-progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .upload-progress-overlay.show {
            display: flex;
        }

        .upload-progress-modal {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .upload-progress-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 20px;
        }

        .upload-current-file {
            font-size: 0.9rem;
            color: #374151;
            margin-bottom: 16px;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f9fafb;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
            word-break: break-word;
        }

        .upload-current-file.processing {
            background: #eff6ff;
            border-color: #3b82f6;
            color: #1d4ed8;
        }

        .upload-current-file.success {
            background: #f0fdf4;
            border-color: #16a34a;
            color: #15803d;
        }

        .upload-current-file.error {
            background: #fef2f2;
            border-color: #dc2626;
            color: #991b1b;
        }

        .upload-overall-progress {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
        }

        .upload-overall-text {
            font-size: 1rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 10px;
        }

        .progress-text {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 4px;
            text-align: center;
        }

        .progress-time {
            font-size: 0.7rem;
            color: #9ca3af;
            margin-top: 2px;
            text-align: right;
        }

        .file-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .file-action-btn {
            padding: 8px 14px;
            border: 2px solid transparent;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            max-width: 80px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .file-action-btn.download {
            background: var(--primary-blue);
            color: white;
        }

        .file-action-btn.download:hover {
            background: var(--dark-blue);
            border-color: var(--dark-blue);
            box-shadow: 0 2px 8px rgba(55, 48, 163, 0.3);
            transform: translateY(-1px);
        }

        .file-action-btn.delete {
            background: var(--error);
            color: white;
        }

        .file-action-btn.delete:hover {
            background: #991b1b;
            border-color: #991b1b;
            box-shadow: 0 2px 8px rgba(185, 28, 28, 0.3);
            transform: translateY(-1px);
        }

        .file-dimensions {
            font-size: 0.8rem;
            color: var(--primary-blue);
            font-weight: 600;
            margin-bottom: 5px;
        }

        .conversion-info {
            font-size: 0.8rem;
            color: var(--text-dark);
            font-weight: 600;
            margin-bottom: 10px;
            padding: 4px 8px;
            background: var(--light-yellow);
            border-radius: 8px;
            text-align: center;
        }

        /* Crop Modal Styles */
        .crop-modal-content {
            max-width: 900px;
            width: 90vw;
            max-height: 90vh;
        }

        .crop-modal-body {
            padding: 25px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .crop-config {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .crop-section {
            background: var(--white);
            border: 2px solid var(--primary-yellow);
            border-radius: 16px;
            padding: 20px;
        }

        .crop-section h3 {
            margin: 0 0 15px 0;
            color: var(--text-dark);
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* Template Grid */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(7.5rem, 100%), 1fr));
            gap: clamp(0.5rem, 1.5vw, 1rem); /* 8px - 16px responsive */
            margin-bottom: 1.25rem; /* 20px */
        }

        .template-card {
            background: #f8fafc;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .template-card:hover {
            border-color: var(--primary-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .template-card.active {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
        }

        .template-preview {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 60px;
            margin-bottom: 8px;
        }

        .ratio-box {
            background: var(--primary-blue);
            border-radius: 4px;
            position: relative;
        }

        .ratio-6x9 { width: 30px; height: 45px; }
        .ratio-55x85 { width: 28px; height: 42px; }
        .ratio-10x15 { width: 32px; height: 48px; }
        .ratio-13x18 { width: 34px; height: 46px; }
        .ratio-20x25 { width: 36px; height: 45px; }

        .custom-box {
            width: 40px;
            height: 40px;
            background: #6B7280;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .template-info {
            text-align: center;
        }

        .template-name {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 0.9rem;
            margin-bottom: 2px;
        }

        .template-size {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .size-details {
            background: var(--light-yellow);
            border-radius: 12px;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(9.375rem, 100%), 1fr));
            gap: clamp(0.75rem, 2vw, 1.25rem); /* 12px - 20px responsive */
        }

        .detail-item {
            text-align: center;
        }

        .detail-label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-light);
            margin-bottom: 4px;
        }

        .detail-value {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 1rem;
        }

        .custom-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .input-row {
            display: flex;
            gap: 10px;
        }

        .input-row input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 0.9rem;
        }

        .input-with-unit {
            display: flex;
            border: 2px solid var(--primary-blue);
            border-radius: 10px;
            overflow: hidden;
        }

        .input-with-unit input {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid #d1d5db;
            font-size: 1rem;
            background: #f9fafb;
            color: var(--text-primary);
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .input-with-unit input:hover {
            border-color: #9ca3af;
            background: #f3f4f6;
        }

        .input-with-unit input:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .input-with-unit input:focus {
            outline: none;
        }

        /* Disabled input styling */
        .input-with-unit input:disabled,
        .config-section input:disabled,
        .custom-input input:disabled {
            background-color: #f1f5f9 !important;
            color: #64748b !important;
            cursor: not-allowed !important;
            opacity: 0.7 !important;
        }

        .input-with-unit input:disabled::placeholder,
        .config-section input:disabled::placeholder,
        .custom-input input:disabled::placeholder {
            color: #94a3b8 !important;
        }

        .input-with-unit .unit {
            background: var(--primary-blue);
            color: white;
            padding: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
        }

        .settings-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-item label {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 0.9rem;
        }

        .modern-select {
            padding: 12px 15px;
            border: 2px solid #d1d5db;
            border-radius: 10px;
            background: #f9fafb;
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modern-select:hover {
            border-color: #9ca3af;
            background: #f3f4f6;
        }

        .modern-select:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .modern-select:focus {
            outline: none;
            border-color: var(--dark-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .setting-help {
            font-size: 0.85rem;
            color: var(--text-light);
            font-style: italic;
            margin-top: 4px;
        }

        .process-modes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .mode-card {
            background: #f8fafc;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
        }

        .mode-card input[type="radio"] {
            position: absolute;
            opacity: 0;
        }

        .mode-card:hover {
            border-color: var(--primary-blue);
            transform: translateY(-2px);
        }

        .mode-card.active,
        .mode-card:has(input:checked) {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
        }

        .mode-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .mode-name {
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 4px;
        }

        .mode-desc {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .naming-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .naming-section label {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 0.9rem;
        }

        /* Crop Page Styles */
        .crop-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #f8fafc;
            z-index: 1000;
            overflow: hidden;
        }

        .crop-header {
            background: var(--white);
            border-bottom: 2px solid var(--primary-yellow);
            padding: 15px 25px;
        }

        .crop-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1400px;
            margin: 0 auto;
        }

        .nav-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--primary-blue);
            color: var(--white);
            border: none;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            background: var(--dark-blue);
            transform: translateY(-1px);
        }

        .nav-icon {
            font-size: 1.2rem;
        }

        .crop-header h1 {
            margin: 0;
            color: var(--text-dark);
            font-size: 1.5rem;
            font-weight: 600;
        }

        .crop-progress {
            background: var(--light-yellow);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .crop-body {
            display: flex;
            height: calc(100vh - 80px);
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            gap: 25px;
        }

        .crop-sidebar {
            width: 350px;
            height: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .crop-main {
            flex: 1;
            background: var(--white);
            border-radius: 16px;
            border: 2px solid var(--primary-yellow);
            overflow: hidden;
        }

        .crop-preview-area {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .preview-header {
            padding: 20px 25px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-header h3 {
            margin: 0;
            color: var(--text-dark);
            font-size: 1.2rem;
        }

        .preview-stats {
            font-size: 0.9rem;
            color: var(--text-light);
            font-weight: 600;
        }

        .crop-file-grid {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            align-content: start;
        }

        .crop-file-item {
            background: #f8fafc;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .crop-file-item:hover {
            border-color: var(--primary-blue);
            transform: translateY(-2px);
        }

        .crop-file-item.selected {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
        }

        .crop-file-preview {
            width: 100%;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .crop-file-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .crop-file-info {
            padding: 10px;
            text-align: center;
        }

        .crop-file-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 4px;
            line-height: 1.2;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .crop-file-size {
            font-size: 0.75rem;
            color: var(--text-light);
        }

        .crop-actions {
            margin-top: auto;
            padding-top: 20px;
        }

        .crop-btn {
            width: 100%;
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .crop-btn.primary {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: var(--white);
        }

        .crop-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }

        .btn-icon {
            font-size: 1.2rem;
        }

        .btn-text {
            font-size: 1rem;
        }

        .quality-info {
            font-size: 0.8rem;
            color: #4b5563;
            margin-top: 2px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .dimensions {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }

        .conversion-info {
            font-size: 0.8rem;
            color: #059669;
            font-weight: 600;
            margin-top: 2px;
        }

        .file-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
            min-width: 80px;
        }

        .status-pending {
            background: #fef3c7;
            color: #d97706;
        }

        .status-processing {
            background: #dbeafe;
            color: #2563eb;
        }

        .status-success {
            background: #d1fae5;
            color: #059669;
        }

        .status-error {
            background: #fecaca;
            color: #dc2626;
        }

        .download-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .download-btn:hover {
            background: #059669;
            transform: scale(1.05);
        }

        .download-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .remove-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .remove-btn:hover {
            background: #dc2626;
            transform: scale(1.05);
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        /* New Actions Layout */
        .actions {
            margin: 0 auto var(--spacing-lg) auto;
            padding: var(--spacing-lg);
            background: #f8fafc;
            border-radius: var(--radius-lg);
            border: 1px solid #e2e8f0;
            max-width: 700px;
        }

        .actions-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
            align-items: center;
            justify-content: flex-start;
        }

        .actions-group:last-child {
            margin-bottom: 0;
        }

        .actions-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-md);
        }

        @media (min-width: 640px) {
            .actions-container {
                grid-template-columns: 1fr 1fr;
                gap: var(--spacing-lg);
            }

            .actions-group.utility-actions {
                grid-column: 1 / -1;
                justify-content: center;
            }
        }

        /* Enhanced Crop Section Styles */
        .crop-container-enhanced {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-8);
        }

        /* Modern Section Header */
        .section-header-modern {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 20px;
            padding: var(--space-12);
            margin-bottom: var(--space-8);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.2);
            position: relative;
            overflow: hidden;
        }

        .section-header-modern::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -20%;
            width: 200px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            transform: rotate(45deg);
        }

        .header-content {
            display: flex;
            align-items: center;
            gap: var(--space-6);
            margin-bottom: var(--space-6);
        }

        .header-icon {
            font-size: 3rem;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .header-text h2 {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header-text p {
            font-size: 1.1rem;
            opacity: 0.9;
            margin: var(--space-2) 0 0;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        /* Progress Steps */
        .progress-steps {
            display: flex;
            justify-content: center;
            gap: var(--space-8);
        }

        .step {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.3s ease;
        }

        .step.active {
            color: white;
            transform: scale(1.1);
        }

        .step-number {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .step.active .step-number {
            background: white;
            color: var(--primary-600);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        }

        /* Modern Size Selection */
        .size-selection-modern {
            background: white;
            border-radius: 20px;
            padding: var(--space-8);
            margin-bottom: var(--space-6);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .selection-header {
            text-align: center;
            margin-bottom: var(--space-8);
        }

        .selection-header h3 {
            font-size: 1.8rem;
            color: var(--gray-800);
            margin-bottom: var(--space-3);
            font-weight: 600;
        }

        .selection-hint {
            color: var(--gray-600);
            font-size: 1rem;
            line-height: 1.6;
        }

        /* Size Grid */
        .size-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--space-6);
        }

        .size-card {
            background: white;
            border: 2px solid var(--gray-200);
            border-radius: 16px;
            padding: var(--space-6);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .size-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-500), var(--primary-600));
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .size-card:hover {
            border-color: var(--primary-300);
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(102, 126, 234, 0.15);
        }

        .size-card.active {
            border-color: var(--primary-500);
            background: linear-gradient(135deg, #f8faff 0%, #e8f0fe 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.2);
        }

        .size-card.active::before {
            transform: scaleX(1);
        }

        .size-preview {
            display: flex;
            justify-content: center;
            margin-bottom: var(--space-4);
        }

        .ratio-box {
            width: 60px;
            background: linear-gradient(135deg, var(--primary-100), var(--primary-200));
            border: 2px solid var(--primary-300);
            border-radius: 8px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .size-card.active .ratio-box {
            background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
            border-color: var(--primary-700);
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .custom-ratio {
            aspect-ratio: 1;
        }

        .custom-icon {
            font-size: 1.5rem;
        }

        .size-info {
            text-align: center;
        }

        .size-title {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--gray-800);
            margin-bottom: var(--space-2);
        }

        .size-dimensions {
            font-size: 1rem;
            color: var(--primary-600);
            font-weight: 500;
            margin-bottom: var(--space-1);
        }

        .size-pixels {
            font-size: 0.85rem;
            color: var(--gray-500);
            margin-bottom: var(--space-2);
        }

        .size-usage {
            font-size: 0.8rem;
            color: var(--gray-400);
            font-style: italic;
        }

        .size-badge {
            position: absolute;
            top: var(--space-2);
            right: var(--space-2);
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            padding: var(--space-1) var(--space-2);
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(238, 90, 82, 0.3);
        }

        /* Enhanced Custom Dimensions */
        .custom-dimensions-modern {
            background: linear-gradient(135deg, #f8fffe 0%, #f0fdfc 100%);
            border: 2px solid var(--teal-200);
            border-radius: 16px;
            padding: var(--space-6);
            margin-top: var(--space-6);
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .custom-header {
            text-align: center;
            margin-bottom: var(--space-6);
        }

        .custom-header h4 {
            font-size: 1.4rem;
            color: var(--teal-700);
            margin-bottom: var(--space-2);
            font-weight: 600;
        }

        .custom-header p {
            color: var(--teal-600);
            font-size: 0.9rem;
        }

        .dimension-inputs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-4);
            margin-bottom: var(--space-4);
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-weight: 500;
            color: var(--gray-700);
            margin-bottom: var(--space-2);
        }

        .label-icon {
            font-size: 1rem;
        }

        .input-with-unit {
            position: relative;
            display: flex;
            align-items: center;
        }

        .input-with-unit input {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            padding-right: 40px;
            border: 2px solid var(--gray-200);
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .input-with-unit input:focus {
            outline: none;
            border-color: var(--teal-500);
            box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
        }

        .unit {
            position: absolute;
            right: var(--space-3);
            color: var(--gray-500);
            font-weight: 500;
            pointer-events: none;
        }

        .dpi-select {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            border: 2px solid var(--gray-200);
            border-radius: 12px;
            font-size: 1rem;
            background: white;
            transition: all 0.3s ease;
        }

        .dpi-select:focus {
            outline: none;
            border-color: var(--teal-500);
            box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
        }

        .dimension-preview {
            background: white;
            border: 1px solid var(--teal-200);
            border-radius: 12px;
            padding: var(--space-4);
            text-align: center;
        }

        .preview-info {
            display: flex;
            justify-content: center;
            gap: var(--space-6);
            flex-wrap: wrap;
        }

        .preview-size,
        .preview-pixels {
            color: var(--teal-700);
        }

        /* Modern Upload Area */
        .upload-area-modern {
            margin-bottom: var(--space-6);
        }

        .upload-zone {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border: 3px dashed var(--gray-300);
            border-radius: 20px;
            padding: var(--space-12);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .upload-zone:hover {
            border-color: var(--primary-400);
            background: linear-gradient(135deg, #f0f7ff 0%, #e6f3ff 100%);
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(102, 126, 234, 0.15);
        }

        .upload-zone.dragover {
            border-color: var(--primary-500);
            background: linear-gradient(135deg, #e6f3ff 0%, #cce7ff 100%);
            transform: scale(1.02);
        }

        .upload-visual {
            position: relative;
            margin-bottom: var(--space-4);
        }

        .upload-icon {
            font-size: 4rem;
            margin-bottom: var(--space-2);
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        .upload-zone:hover .upload-icon {
            opacity: 1;
            transform: scale(1.1);
        }

        .upload-animation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border: 3px solid var(--primary-200);
            border-top: 3px solid var(--primary-500);
            border-radius: 50%;
            opacity: 0;
            animation: spin 1s linear infinite;
        }

        .upload-zone.uploading .upload-animation {
            opacity: 1;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .upload-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--gray-800);
            margin-bottom: var(--space-2);
        }

        .upload-subtitle {
            font-size: 1rem;
            color: var(--gray-600);
            margin-bottom: var(--space-4);
        }

        .upload-formats {
            display: flex;
            justify-content: center;
            gap: var(--space-2);
            margin-bottom: var(--space-3);
            flex-wrap: wrap;
        }

        .format-badge {
            background: var(--primary-100);
            color: var(--primary-700);
            padding: var(--space-1) var(--space-3);
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            border: 1px solid var(--primary-200);
        }

        .upload-limit {
            font-size: 0.85rem;
            color: var(--gray-500);
        }

        /* Processing Area */
        .processing-area {
            background: white;
            border-radius: 20px;
            padding: var(--space-8);
            margin-bottom: var(--space-6);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.05);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .processing-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-6);
            flex-wrap: wrap;
            gap: var(--space-4);
        }

        .processing-header h3 {
            font-size: 1.5rem;
            color: var(--gray-800);
            margin: 0;
            font-weight: 600;
        }

        .processing-count {
            background: var(--orange-100);
            color: var(--orange-700);
            padding: var(--space-2) var(--space-4);
            border-radius: 20px;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .processing-progress {
            margin-bottom: var(--space-6);
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--gray-200);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: var(--space-3);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--green-500), var(--green-400));
            border-radius: 6px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.4) 50%, transparent 100%);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            text-align: center;
            color: var(--gray-600);
            font-weight: 500;
        }

        .processing-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: var(--space-4);
            margin-top: var(--space-4);
        }

        .processing-thumbnail {
            background: var(--gray-100);
            border-radius: 12px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .processing-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
        }

        .processing-thumbnail.processing::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Results Section */
        .crop-results {
            background: linear-gradient(135deg, #f0fff4 0%, #ecfdf5 100%);
            border: 2px solid var(--green-200);
            border-radius: 20px;
            padding: var(--space-8);
            margin-bottom: var(--space-6);
            animation: slideIn 0.5s ease-out 0.2s both;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: var(--space-8);
            flex-wrap: wrap;
            gap: var(--space-6);
        }

        .results-summary h3 {
            font-size: 1.8rem;
            color: var(--green-700);
            margin: 0 0 var(--space-2);
            font-weight: 600;
        }

        .results-summary p {
            color: var(--green-600);
            margin: 0;
            font-size: 1rem;
        }

        .results-stats {
            display: flex;
            gap: var(--space-6);
        }

        .stat-item {
            text-align: center;
            background: white;
            padding: var(--space-4);
            border-radius: 12px;
            border: 1px solid var(--green-200);
            min-width: 120px;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--green-700);
            margin-bottom: var(--space-1);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--green-600);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        /* Action Grid */
        .action-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--space-4);
            margin-bottom: var(--space-6);
        }

        .action-card {
            background: white;
            border: 2px solid var(--gray-200);
            border-radius: 16px;
            padding: var(--space-6);
            display: flex;
            align-items: center;
            gap: var(--space-4);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: left;
        }

        .action-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
        }

        .action-card.primary {
            border-color: var(--blue-300);
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        }

        .action-card.primary:hover {
            border-color: var(--blue-500);
            box-shadow: 0 12px 24px rgba(59, 130, 246, 0.2);
        }

        .action-card.secondary {
            border-color: var(--purple-300);
            background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
        }

        .action-card.secondary:hover {
            border-color: var(--purple-500);
            box-shadow: 0 12px 24px rgba(147, 51, 234, 0.2);
        }

        .action-card.tertiary {
            border-color: var(--green-300);
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        }

        .action-card.tertiary:hover {
            border-color: var(--green-500);
            box-shadow: 0 12px 24px rgba(34, 197, 94, 0.2);
        }

        .action-card.quaternary {
            border-color: var(--orange-300);
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
        }

        .action-card.quaternary:hover {
            border-color: var(--orange-500);
            box-shadow: 0 12px 24px rgba(249, 115, 22, 0.2);
        }

        .action-icon {
            font-size: 2.5rem;
            flex-shrink: 0;
        }

        .action-content {
            flex: 1;
        }

        .action-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--gray-800);
            margin-bottom: var(--space-1);
        }

        .action-subtitle {
            font-size: 0.9rem;
            color: var(--gray-600);
            line-height: 1.4;
        }

        /* Results Gallery */
        .results-gallery {
            background: white;
            border-radius: 16px;
            padding: var(--space-6);
            border: 1px solid var(--green-200);
        }

        .results-gallery h4 {
            color: var(--green-700);
            margin-bottom: var(--space-4);
            font-weight: 600;
        }

        .results-thumbnails {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: var(--space-4);
        }

        .result-thumbnail {
            background: var(--gray-50);
            border-radius: 12px;
            aspect-ratio: 1;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-thumbnail:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
        }

        .result-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .thumbnail-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent 0%, rgba(0, 0, 0, 0.7) 100%);
            color: white;
            padding: var(--space-2);
            font-size: 0.8rem;
            text-align: center;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .crop-container-enhanced {
                padding: var(--space-4);
            }

            .size-grid {
                grid-template-columns: 1fr;
            }

            .dimension-inputs-grid {
                grid-template-columns: 1fr;
            }

            .results-header {
                flex-direction: column;
                text-align: center;
            }

            .results-stats {
                justify-content: center;
            }

            .action-grid {
                grid-template-columns: 1fr;
            }
        }

        .section-header {
            text-align: center;
            margin-bottom: var(--space-16);
            padding: var(--space-8) 0;
            position: relative;
        }

        .section-header h2 {
            font-size: var(--text-3xl);
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--space-4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-4);
            letter-spacing: -0.025em;
            line-height: 1.2;
        }
        
        .section-header h2::before {
            font-size: var(--text-2xl);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .section-header p {
            font-size: var(--text-lg);
            color: var(--text-secondary);
            font-weight: 500;
            max-width: 700px;
            margin: 0 auto;
            line-height: 1.7;
        }
        
        .section-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 4px;
            background: var(--gradient-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
        }

        .section-label {
            display: block;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: var(--space-4);
            font-size: var(--text-sm);
        }

        /* ========== COMPREHENSIVE BUTTON SYSTEM ========== */
        
        /* Base Button Styles */
        button, .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            padding: var(--space-3) var(--space-5);
            border: 1px solid transparent;
            border-radius: var(--radius-lg);
            font-family: inherit;
            font-size: var(--text-sm);
            font-weight: 500;
            line-height: 1.5;
            text-decoration: none;
            cursor: pointer;
            transition: var(--transition-base);
            position: relative;
            overflow: hidden;
            white-space: nowrap;
        }

        button:disabled, .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Primary Button */
        .btn-primary, button[type="submit"], button.primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            box-shadow: var(--shadow-md);
            font-weight: 600;
        }

        .btn-primary:hover, button[type="submit"]:hover, button.primary:hover {
            background: var(--primary-dark);
            border-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        /* Secondary Button */
        .btn-secondary, button.secondary {
            background: var(--surface);
            color: var(--text-primary);
            border-color: var(--border);
            border-width: 2px;
            font-weight: 600;
        }

        .btn-secondary:hover, button.secondary:hover {
            background: var(--background);
            border-color: var(--primary);
            color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        /* Success Button */
        .btn-success, button.success {
            background: var(--success);
            color: white;
            border-color: var(--success);
        }

        .btn-success:hover, button.success:hover {
            background: #059669;
            border-color: #059669;
            transform: translateY(-1px);
        }

        /* Warning Button */
        .btn-warning, button.warning {
            background: var(--warning);
            color: white;
            border-color: var(--warning);
        }

        .btn-warning:hover, button.warning:hover {
            background: #d97706;
            border-color: #d97706;
            transform: translateY(-1px);
        }

        /* Danger Button */
        .btn-danger, button.danger {
            background: var(--error);
            color: white;
            border-color: var(--error);
        }

        .btn-danger:hover, button.danger:hover {
            background: #dc2626;
            border-color: #dc2626;
            transform: translateY(-1px);
        }

        /* Ghost Button */
        .btn-ghost, button.ghost {
            background: transparent;
            color: var(--text-primary);
            border-color: transparent;
        }

        .btn-ghost:hover, button.ghost:hover {
            background: var(--background);
            color: var(--primary);
        }

        /* Button Sizes */
        .btn-xs, button.xs {
            padding: var(--space-1) var(--space-3);
            font-size: var(--text-xs);
        }

        .btn-sm, button.sm {
            padding: var(--space-2) var(--space-4);
            font-size: var(--text-sm);
        }

        .btn-lg, button.lg {
            padding: var(--space-4) var(--space-8);
            font-size: var(--text-lg);
            font-weight: 600;
        }

        .btn-xl, button.xl {
            padding: var(--space-5) var(--space-10);
            font-size: var(--text-xl);
            font-weight: 600;
        }

        /* Icon Buttons */
        .btn-icon, button.icon {
            padding: var(--space-3);
            aspect-ratio: 1;
            min-width: auto;
        }

        .btn-icon.sm, button.icon.sm {
            padding: var(--space-2);
        }

        .btn-icon.lg, button.icon.lg {
            padding: var(--space-4);
        }

        /* Full Width Button */
        .btn-block, button.block {
            width: 100%;
        }

        /* Button Groups */
        .btn-group {
            display: inline-flex;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
        }

        .btn-group button, .btn-group .btn {
            border-radius: 0;
            border-right-width: 0;
        }

        .btn-group button:first-child, .btn-group .btn:first-child {
            border-top-left-radius: var(--radius-lg);
            border-bottom-left-radius: var(--radius-lg);
        }

        .btn-group button:last-child, .btn-group .btn:last-child {
            border-top-right-radius: var(--radius-lg);
            border-bottom-right-radius: var(--radius-lg);
            border-right-width: 1px;
        }

        /* ========== FORM CONTROLS ========== */
        
        input, textarea, select {
            display: block;
            width: 100%;
            padding: var(--space-4) var(--space-5);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            background: var(--surface);
            color: var(--text-primary);
            font-family: inherit;
            font-size: var(--text-base);
            font-weight: 500;
            line-height: 1.5;
            transition: var(--transition-base);
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.15);
            background: var(--surface-elevated);
        }

        input::placeholder, textarea::placeholder {
            color: var(--text-tertiary);
        }

        /* Checkbox and Radio */
        input[type="checkbox"], input[type="radio"] {
            width: auto;
            margin-right: var(--space-2);
        }

        /* Range Slider */
        input[type="range"] {
            padding: 0;
            background: transparent;
            border: none;
        }

        input[type="range"]::-webkit-slider-track {
            background: var(--border);
            height: 6px;
            border-radius: var(--radius-lg);
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        /* ========== ANIMATIONS & TRANSITIONS ========== */
        
        /* Smooth Motion Preferences */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Keyframe Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                opacity: 0; 
                transform: translateY(20px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        @keyframes slideDown {
            from { 
                opacity: 0; 
                transform: translateY(-20px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        @keyframes slideLeft {
            from { 
                opacity: 0; 
                transform: translateX(20px); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }

        @keyframes slideRight {
            from { 
                opacity: 0; 
                transform: translateX(-20px); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }

        @keyframes scaleIn {
            from { 
                opacity: 0; 
                transform: scale(0.9); 
            }
            to { 
                opacity: 1; 
                transform: scale(1); 
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes bounce {
            0%, 100% { 
                transform: translateY(0); 
                animation-timing-function: cubic-bezier(0.8, 0, 1, 1); 
            }
            50% { 
                transform: translateY(-25%); 
                animation-timing-function: cubic-bezier(0, 0, 0.2, 1); 
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
            20%, 40%, 60%, 80% { transform: translateX(2px); }
        }

        /* Animation Utility Classes */
        .animate-fadeIn { animation: fadeIn 0.3s ease-out; }
        .animate-slideUp { animation: slideUp 0.3s ease-out; }
        .animate-slideDown { animation: slideDown 0.3s ease-out; }
        .animate-slideLeft { animation: slideLeft 0.3s ease-out; }
        .animate-slideRight { animation: slideRight 0.3s ease-out; }
        .animate-scaleIn { animation: scaleIn 0.3s ease-out; }
        .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        .animate-spin { animation: spin 1s linear infinite; }
        .animate-bounce { animation: bounce 1s infinite; }
        .animate-shake { animation: shake 0.5s ease-in-out; }

        /* Staggered Animation Delays */
        .animate-delay-75 { animation-delay: 75ms; }
        .animate-delay-100 { animation-delay: 100ms; }
        .animate-delay-150 { animation-delay: 150ms; }
        .animate-delay-200 { animation-delay: 200ms; }
        .animate-delay-300 { animation-delay: 300ms; }
        .animate-delay-500 { animation-delay: 500ms; }
        .animate-delay-700 { animation-delay: 700ms; }
        .animate-delay-1000 { animation-delay: 1000ms; }

        /* Loading States */
        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-dots {
            display: inline-flex;
            gap: var(--space-1);
        }

        .loading-dots span {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--primary);
            animation: bounce 1.4s ease-in-out infinite both;
        }

        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }
        .loading-dots span:nth-child(3) { animation-delay: 0s; }

        /* Hover Effects */
        .hover-lift {
            transition: var(--transition-base);
        }

        .hover-lift:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .hover-scale {
            transition: var(--transition-base);
        }

        .hover-scale:hover {
            transform: scale(1.05);
        }

        .hover-brightness {
            transition: var(--transition-base);
        }

        .hover-brightness:hover {
            filter: brightness(1.1);
        }

        /* ========== RESPONSIVE DESIGN SYSTEM ========== */
        
        /* Breakpoint System */
        /* xs: 0px and up (default) */
        /* sm: 640px and up */
        /* md: 768px and up */
        /* lg: 1024px and up */
        /* xl: 1280px and up */
        /* 2xl: 1536px and up */

        /* Container Responsive */
        .container {
            width: 100%;
        }

        @media (min-width: 640px) {
            .container { max-width: 640px; }
        }

        @media (min-width: 768px) {
            .container { max-width: 768px; }
        }

        @media (min-width: 1024px) {
            .container { max-width: 1024px; }
        }

        @media (min-width: 1280px) {
            .container { max-width: 1280px; }
        }

        @media (min-width: 1536px) {
            .container { max-width: 1536px; }
        }

        /* Mobile-First Responsive Utilities */
        
        /* Display */
        .hidden { display: none; }
        .block { display: block; }
        .inline { display: inline; }
        .inline-block { display: inline-block; }
        .flex { display: flex; }
        .inline-flex { display: inline-flex; }
        .grid { display: grid; }
        .inline-grid { display: inline-grid; }

        @media (min-width: 640px) {
            .sm\\:hidden { display: none; }
            .sm\\:block { display: block; }
            .sm\\:flex { display: flex; }
            .sm\\:grid { display: grid; }
        }

        @media (min-width: 768px) {
            .md\\:hidden { display: none; }
            .md\\:block { display: block; }
            .md\\:flex { display: flex; }
            .md\\:grid { display: grid; }
        }

        @media (min-width: 1024px) {
            .lg\\:hidden { display: none; }
            .lg\\:block { display: block; }
            .lg\\:flex { display: flex; }
            .lg\\:grid { display: grid; }
        }

        /* Flex Direction */
        .flex-row { flex-direction: row; }
        .flex-col { flex-direction: column; }

        @media (min-width: 640px) {
            .sm\\:flex-row { flex-direction: row; }
            .sm\\:flex-col { flex-direction: column; }
        }

        @media (min-width: 768px) {
            .md\\:flex-row { flex-direction: row; }
            .md\\:flex-col { flex-direction: column; }
        }

        /* Text Alignment */
        .text-left { text-align: left; }
        .text-center { text-align: center; }
        .text-right { text-align: right; }

        @media (min-width: 640px) {
            .sm\\:text-left { text-align: left; }
            .sm\\:text-center { text-align: center; }
            .sm\\:text-right { text-align: right; }
        }

        @media (min-width: 768px) {
            .md\\:text-left { text-align: left; }
            .md\\:text-center { text-align: center; }
            .md\\:text-right { text-align: right; }
        }

        /* Spacing */
        .p-0 { padding: 0; }
        .p-2 { padding: var(--space-2); }
        .p-4 { padding: var(--space-4); }
        .p-6 { padding: var(--space-6); }
        .p-8 { padding: var(--space-8); }

        .m-0 { margin: 0; }
        .m-2 { margin: var(--space-2); }
        .m-4 { margin: var(--space-4); }
        .m-6 { margin: var(--space-6); }
        .m-8 { margin: var(--space-8); }

        @media (min-width: 768px) {
            .md\\:p-2 { padding: var(--space-2); }
            .md\\:p-4 { padding: var(--space-4); }
            .md\\:p-6 { padding: var(--space-6); }
            .md\\:p-8 { padding: var(--space-8); }
            .md\\:p-10 { padding: var(--space-10); }
            .md\\:p-12 { padding: var(--space-12); }
        }

        /* Grid Columns */
        .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        .grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        .grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }

        @media (min-width: 640px) {
            .sm\\:grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
            .sm\\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
            .sm\\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
            .sm\\:grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        }

        @media (min-width: 768px) {
            .md\\:grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
            .md\\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
            .md\\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
            .md\\:grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
            .md\\:grid-cols-5 { grid-template-columns: repeat(5, minmax(0, 1fr)); }
            .md\\:grid-cols-6 { grid-template-columns: repeat(6, minmax(0, 1fr)); }
        }

        /* Enhanced Mobile Breakpoints */
        @media (max-width: 767px) {
            /* Mobile-specific adjustments */
            body {
                padding: var(--space-3);
            }

            .container {
                border-radius: var(--radius-xl);
                border-width: 1px;
            }

            .header {
                padding: var(--space-8) var(--space-5);
            }

            .header h1 {
                font-size: var(--text-3xl);
            }

            .header-subtitle {
                font-size: var(--text-base);
            }

            .main-content {
                padding: var(--space-8) var(--space-5);
            }

            .function-tabs {
                flex-direction: column;
                max-width: 100%;
                gap: var(--space-2);
                padding: var(--space-3);
            }

            .tab-button {
                flex-direction: row;
                justify-content: flex-start;
                text-align: left;
                padding: var(--space-4) var(--space-5);
                min-height: 64px;
                gap: var(--space-4);
            }

            .tab-icon {
                font-size: var(--text-xl);
            }

            .tab-text {
                font-size: var(--text-base);
            }

            .section-header h2 {
                font-size: var(--text-2xl);
            }

            .section-header p {
                font-size: var(--text-base);
            }

            .convert-content {
                max-width: 100%;
                padding: 0 var(--space-2);
            }

            .upload-zone {
                padding: var(--space-12) var(--space-6);
                border-width: 2px;
            }

            .upload-icon {
                font-size: var(--text-3xl);
                margin-bottom: var(--space-3);
            }

            .upload-text {
                font-size: var(--text-lg);
            }

            .upload-subtext {
                font-size: var(--text-sm);
            }

            .btn-group {
                flex-direction: column;
                width: 100%;
            }

            .btn-group button,
            .btn-group .btn {
                border-radius: var(--radius-lg);
                border-right-width: 1px;
                border-bottom-width: 0;
            }

            .btn-group button:not(:last-child),
            .btn-group .btn:not(:last-child) {
                border-bottom-width: 0;
            }

            .btn-group button:last-child,
            .btn-group .btn:last-child {
                border-bottom-width: 1px;
            }
        }

        /* Tablet Adjustments */
        @media (min-width: 768px) and (max-width: 1023px) {
            .function-tabs {
                max-width: 90%;
            }

            .main-content {
                padding: var(--space-8) var(--space-6);
            }

            .convert-content {
                max-width: 700px;
            }

            .upload-zone {
                padding: var(--space-14) var(--space-8);
            }
        }

        /* Large Screen Optimizations */
        @media (min-width: 1024px) {
            .main-content {
                padding: var(--space-10) var(--space-8);
            }

            .function-tabs {
                max-width: 800px;
            }

            .tab-button:hover {
                transform: translateY(-2px);
            }

            .convert-content {
                max-width: 900px;
            }

            .upload-zone {
                padding: var(--space-20) var(--space-10);
                max-width: 600px;
                margin: 0 auto;
            }

            .upload-icon {
                font-size: 4.5rem;
                margin-bottom: var(--space-6);
            }

            .upload-text {
                font-size: var(--text-2xl);
                margin-bottom: var(--space-3);
            }

            .upload-subtext {
                font-size: var(--text-lg);
                margin-bottom: var(--space-4);
            }
        }

        .size-selection-container {
            margin-bottom: var(--spacing-xl);
        }

        /* ========== FINAL POLISH & CARD STYLES ========== */
        
        /* Modern Card System */
        .card, .panel, .config-panel {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius-2xl);
            box-shadow: var(--shadow-md);
            overflow: hidden;
            transition: var(--transition-base);
        }

        .card:hover, .panel:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
            border-color: var(--primary);
        }

        .card-header, .panel-header {
            padding: var(--space-6);
            border-bottom: 1px solid var(--border-light);
            background: var(--gradient-surface);
        }

        .card-body, .panel-body {
            padding: var(--space-6);
        }

        .card-footer, .panel-footer {
            padding: var(--space-6);
            border-top: 1px solid var(--border-light);
            background: var(--background);
        }

        /* Enhanced Function Sections */
        .function-section {
            animation: fadeIn 0.5s ease-out;
        }

        /* Stats and Info Cards */
        .stats-card {
            background: var(--gradient-surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-xl);
            padding: var(--space-6);
            text-align: center;
            box-shadow: var(--shadow-sm);
            transition: var(--transition-base);
        }

        .stats-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .stats-number {
            font-size: var(--text-3xl);
            font-weight: 700;
            color: var(--primary);
            margin-bottom: var(--space-2);
        }

        .stats-label {
            font-size: var(--text-sm);
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Convert Section Styles */
        .convert-content {
            max-width: 800px;
            margin: 0 auto;
        }

        /* Upload Zones */
        .upload-zone {
            border: 3px dashed var(--border);
            border-radius: var(--radius-2xl);
            background: var(--surface);
            transition: var(--transition-base);
            position: relative;
            padding: var(--space-16) var(--space-8);
            text-align: center;
            cursor: pointer;
            margin: 0 auto;
        }

        .upload-zone:hover {
            border-color: var(--primary);
            background: var(--background);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            border-style: solid;
        }

        .upload-zone.dragover {
            border-color: var(--primary);
            border-style: solid;
            background: rgba(79, 70, 229, 0.05);
            box-shadow: var(--shadow-xl);
        }

        .upload-icon {
            font-size: var(--text-4xl);
            margin-bottom: var(--space-4);
            color: var(--primary);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .upload-text {
            font-size: var(--text-xl);
            color: var(--text-primary);
            margin-bottom: var(--space-2);
            font-weight: 600;
        }

        .upload-subtext {
            color: var(--text-secondary);
            font-size: var(--text-base);
            margin-bottom: var(--space-3);
            font-weight: 500;
        }

        .upload-hint {
            color: var(--text-tertiary);
            font-size: var(--text-sm);
            font-style: italic;
        }

        .file-input {
            display: none;
        }

        /* Gallery Grid Improvements */
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--space-4);
            animation: fadeIn 0.5s ease-out;
        }

        .gallery-item {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-xl);
            overflow: hidden;
            transition: var(--transition-base);
            animation: scaleIn 0.3s ease-out;
        }

        .gallery-item:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px) scale(1.02);
        }

        /* Toast Notifications Enhancement */
        .toast {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(20px);
            animation: slideRight 0.3s ease-out;
        }

        /* Progress Bars */
        .progress-bar {
            background: var(--border-light);
            border-radius: var(--radius-lg);
            overflow: hidden;
            height: 8px;
        }

        .progress-fill {
            background: var(--primary);
            height: 100%;
            transition: width 0.3s ease-out;
            border-radius: var(--radius-lg);
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: pulse 2s infinite;
        }

        /* Focus States for Accessibility */
        button:focus-visible,
        .tab-button:focus-visible,
        input:focus-visible,
        textarea:focus-visible,
        select:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        /* Smooth Page Transitions */
        .page-transition {
            animation: fadeIn 0.4s ease-out;
        }

        /* Loading States */
        .loading-skeleton {
            background: linear-gradient(90deg, var(--border-light) 25%, var(--border) 50%, var(--border-light) 75%);
            background-size: 200% 100%;
            animation: shimmer 2s infinite;
            border-radius: var(--radius-lg);
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .size-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .size-option {
            padding: var(--spacing-lg);
            border: 2px solid #d1d5db;
            border-radius: var(--radius-lg);
            background: #f8fafc;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .size-option:hover {
            border-color: var(--primary-blue);
            background: #e2e8f0;
            transform: translateY(-2px);
        }

        .size-option.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        .size-main {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
        }

        .size-description {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .custom-dimensions {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
        }

        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-lg);
        }

        .input-field {
            display: flex;
            flex-direction: column;
        }

        .input-field label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-dark);
            margin-bottom: var(--spacing-sm);
        }

        .input-field input {
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: var(--radius-md);
            font-size: 0.95rem;
            transition: border-color 0.2s ease;
        }

        .input-field input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .upload-area {
            border: 2px dashed #cbd5e0;
            border-radius: var(--radius-lg);
            padding: var(--spacing-2xl) var(--spacing-lg);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #f8fafc;
            margin-bottom: var(--spacing-xl);
        }

        .upload-area:hover {
            border-color: var(--primary-blue);
            background: #eff6ff;
        }

        .upload-content {
            max-width: 400px;
            margin: 0 auto;
        }

        .upload-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: var(--spacing-sm);
        }

        .upload-subtitle {
            color: var(--text-light);
            margin-bottom: var(--spacing-md);
        }

        .upload-formats {
            font-size: 0.85rem;
            color: var(--text-light);
            font-style: italic;
        }

        .crop-actions {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
        }

        .action-section {
            margin-bottom: var(--spacing-lg);
        }

        .action-section:last-child {
            margin-bottom: 0;
        }

        .download-options,
        .tool-options {
            display: flex;
            gap: var(--spacing-md);
            flex-wrap: wrap;
        }

        .download-btn,
        .tool-btn {
            padding: 12px 20px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            min-width: 140px;
        }

        .download-btn.primary {
            background: var(--primary-blue);
            color: white;
        }

        .download-btn.primary:hover {
            background: var(--dark-blue);
        }

        .download-btn.secondary {
            background: #6b7280;
            color: white;
        }

        .download-btn.secondary:hover {
            background: #4b5563;
        }

        .tool-btn {
            background: #f1f5f9;
            color: var(--text-primary);
            border: 2px solid #cbd5e1;
        }

        .tool-btn:hover {
            background: #e2e8f0;
            border-color: var(--primary-blue);
            transform: translateY(-1px);
        }

        /* Gallery Styles */
        .gallery-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .gallery-controls {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: var(--spacing-lg);
            align-items: center;
            margin-bottom: var(--spacing-lg);
            padding: var(--spacing-lg);
            background: white;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid #e5e7eb;
        }

        .search-section {
            display: flex;
            align-items: center;
            gap: 12px;
            justify-content: center;
        }

        .search-box {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-input {
            padding: 8px 40px 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: var(--white);
            font-size: 0.9rem;
            min-width: 200px;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .search-icon {
            position: absolute;
            right: 12px;
            color: #6b7280;
            pointer-events: none;
        }

        .filter-select {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: var(--white);
            font-size: 0.9rem;
            color: var(--text-dark);
            min-width: 120px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Gallery image preview tooltip */
        .gallery-image-tooltip {
            position: absolute;
            top: -250px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 2px solid var(--primary-blue);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .gallery-item:hover .gallery-image-tooltip {
            opacity: 1;
        }

        .tooltip-image {
            width: 200px;
            height: 150px;
            object-fit: cover;
            border-radius: 4px;
        }

        .tooltip-info {
            padding: 8px 0 0 0;
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-dark);
        }

        /* Duplex Preview Controls */
        .duplex-preview-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-left: 16px;
            padding-left: 16px;
            border-left: 2px solid #e2e8f0;
        }

        .side-toggle {
            display: flex;
            background: #f1f5f9;
            border-radius: 8px;
            padding: 2px;
            border: 1px solid #e2e8f0;
        }

        .side-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .side-btn:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        .side-btn.active {
            background: var(--primary-blue);
            color: white;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }

        .side-icon {
            font-size: 1rem;
        }

        .side-text {
            font-size: 0.8rem;
        }

        .page-side-indicator {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-dark);
            padding: 8px 12px;
            background: #fef3cd;
            border: 1px solid #fde047;
            border-radius: 6px;
        }

        /* Duplex Slot Management */
        .duplex-slot-management {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-lg);
            padding: 20px;
            margin-bottom: 20px;
        }

        .slot-management-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e2e8f0;
        }

        .slot-management-header h3 {
            margin: 0;
            color: var(--text-dark);
            font-size: 1.1rem;
        }

        .slot-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .slot-info span {
            font-size: 0.85rem;
        }

        .slot-instructions {
            color: #6b7280;
            font-style: italic;
        }

        .slot-grid-container {
            background: white;
            border-radius: 8px;
            padding: 16px;
            border: 1px solid #e2e8f0;
        }

        .slot-grid-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e2e8f0;
        }

        .current-page-info {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
        }

        .current-side {
            background: var(--primary-blue);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .slot-actions {
            display: flex;
            gap: 8px;
        }

        .slot-action-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            background: #f8fafc;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .slot-action-btn:hover {
            background: #e2e8f0;
            border-color: var(--primary-blue);
            transform: translateY(-1px);
        }

        .slot-grid {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
        }

        .slot-item {
            aspect-ratio: 1;
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #f9fafb;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            min-height: 80px;
        }

        .slot-item:hover {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .slot-item.filled {
            border-style: solid;
            border-color: #10b981;
            background: white;
        }

        .slot-item.drag-over {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
            transform: scale(1.02);
        }

        .slot-number {
            position: absolute;
            top: 4px;
            left: 4px;
            background: var(--text-dark);
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slot-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }

        .slot-empty-icon {
            font-size: 1.5rem;
            color: #9ca3af;
        }

        .slot-remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .slot-item.filled:hover .slot-remove-btn {
            opacity: 1;
        }

        /* Duplex Classification System */
        .duplex-classification-section {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-lg);
            padding: 20px;
            margin-bottom: 20px;
        }

        .duplex-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e2e8f0;
        }

        .duplex-header h3 {
            margin: 0 0 8px 0;
            color: var(--text-dark);
            font-size: 1.2rem;
        }

        .duplex-info {
            color: #6b7280;
            font-size: 0.9rem;
        }

        .duplex-classification-controls {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
        }

        .classification-actions {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .classify-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .front-classify {
            border-color: #3b82f6;
            background: #eff6ff;
            color: #3b82f6;
        }

        .front-classify:hover, .front-classify.active {
            background: #3b82f6;
            color: white;
        }

        .back-classify {
            border-color: #10b981;
            background: #ecfdf5;
            color: #10b981;
        }

        .back-classify:hover, .back-classify.active {
            background: #10b981;
            color: white;
        }

        .exit-classify {
            border-color: #ef4444;
            background: #fef2f2;
            color: #ef4444;
        }

        .exit-classify:hover {
            background: #ef4444;
            color: white;
        }

        .duplex-stats {
            display: flex;
            justify-content: center;
            gap: 24px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            display: block;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-blue);
        }

        .stat-label {
            font-size: 0.8rem;
            color: #6b7280;
        }

        .duplex-classification-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .classification-column {
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }

        .column-header {
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .front-header {
            background: linear-gradient(135deg, #dbeafe, #bfdbfe);
        }

        .back-header {
            background: linear-gradient(135deg, #d1fae5, #a7f3d0);
        }

        .column-header h4 {
            margin: 0;
            font-size: 1rem;
            color: var(--text-dark);
        }

        .clear-column-btn {
            padding: 4px 8px;
            border: 2px solid #d1d5db;
            background: #f8fafc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .clear-column-btn:hover {
            background: #e2e8f0;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .classification-list {
            min-height: 200px;
            padding: 16px;
        }

        .empty-classification {
            text-align: center;
            color: #9ca3af;
            padding: 32px 16px;
        }

        .empty-icon {
            font-size: 3rem;
            margin-bottom: 12px;
        }

        .empty-text {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .empty-hint {
            font-size: 0.8rem;
            font-style: italic;
        }

        .classified-image {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            margin-bottom: 8px;
            background: #f9fafb;
            transition: all 0.2s ease;
        }

        .classified-image:hover {
            background: white;
            border-color: var(--primary-blue);
        }

        .classified-image-thumb {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
        }

        .classified-image-info {
            flex: 1;
            min-width: 0;
        }

        .classified-image-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-dark);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .classified-image-size {
            font-size: 0.7rem;
            color: #6b7280;
        }

        .classified-image-remove {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .classified-image-remove:hover {
            opacity: 1;
        }

        /* Slot Selection Modal */
        .slot-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .slot-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        }

        .slot-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
        }

        .slot-modal-header h3 {
            margin: 0;
            color: var(--text-dark);
        }

        .close-slot-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 4px;
            border-radius: 4px;
        }

        .close-slot-modal:hover {
            background: #e5e7eb;
        }

        .slot-modal-body {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .slot-gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 12px;
        }

        .slot-gallery-item {
            aspect-ratio: 1;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .slot-gallery-item:hover {
            border-color: var(--primary-blue);
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }

        .slot-gallery-item img {
            width: 100%;
            height: 80%;
            object-fit: cover;
        }

        .slot-image-name {
            padding: 4px 6px;
            font-size: 0.7rem;
            text-align: center;
            color: var(--text-dark);
            background: #f9fafb;
            border-top: 1px solid #e2e8f0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .gallery-status {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .gallery-count {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--text-dark);
        }

        .gallery-info {
            font-size: 0.8rem;
            color: var(--text-light);
            background: #f0f9ff;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            border: 1px solid #e0f2fe;
        }

        /* Quick Selection Section */
        .quick-selection-section {
            margin: var(--spacing-xl) 0;
            padding: var(--spacing-lg);
            background: #f8fafc;
            border-radius: var(--radius-lg);
            border: 1px solid #e2e8f0;
        }

        .quick-select-controls {
            display: flex;
            gap: var(--spacing-md);
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .quick-select-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 120px;
            justify-content: center;
        }

        .quick-select-btn:hover {
            border-color: var(--primary-blue);
            background: #f8fafc;
            transform: translateY(-1px);
        }

        .quick-select-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        .quick-select-btn.front-type {
            border-color: #10b981;
        }

        .quick-select-btn.front-type:hover,
        .quick-select-btn.front-type.active {
            border-color: #10b981;
            background: #10b981;
            color: white;
        }

        .quick-select-btn.back-type {
            border-color: #ef4444;
        }

        .quick-select-btn.back-type:hover,
        .quick-select-btn.back-type.active {
            border-color: #ef4444;
            background: #ef4444;
            color: white;
        }

        .quick-select-btn.apply-btn {
            border-color: #059669;
            background: #059669;
            color: white;
            font-weight: 600;
        }

        .quick-select-btn.apply-btn:hover {
            border-color: #047857;
            background: #047857;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
        }

        .quick-select-btn.cancel-btn {
            border-color: #6b7280;
            background: #6b7280;
            color: white;
        }

        .quick-select-btn.cancel-btn:hover {
            border-color: #4b5563;
            background: #4b5563;
            transform: translateY(-1px);
        }

        /* Selection Mode Styles - Simple checkbox approach */
        .gallery-item.selection-mode,
        .source-grid .gallery-item.selection-mode {
            position: relative;
            cursor: pointer;
        }

        /* Simple Checkbox Styles */
        .selection-checkbox,
        .source-grid .selection-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 4px;
            background: rgba(100, 100, 100, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            font-size: 12px;
            font-weight: bold;
            color: white;
            opacity: 0;
        }

        /* Show checkbox when in selection mode - Force visibility */
        .gallery-item.selection-mode .selection-checkbox,
        .source-grid .gallery-item.selection-mode .selection-checkbox {
            opacity: 1 !important;
            display: flex !important;
        }

        /* Selected Front - Green checkbox */
        .gallery-item.selection-mode.selected-front .selection-checkbox,
        .source-grid .gallery-item.selection-mode.selected-front .selection-checkbox {
            background: #10b981;
            border-color: white;
            color: white;
        }

        /* Selected Back - Red checkbox */
        .gallery-item.selection-mode.selected-back .selection-checkbox,
        .source-grid .gallery-item.selection-mode.selected-back .selection-checkbox {
            background: #ef4444;
            border-color: white;
            color: white;
        }

        /* DEBUG: Force show all checkboxes for testing */
        .source-grid .selection-checkbox {
            opacity: 0.3 !important;
            display: flex !important;
        }

        .selection-status {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 0.9rem;
            font-weight: 600;
            padding: 8px 12px;
            background: var(--light-yellow);
            border-radius: var(--radius-md);
            border: 1px solid var(--primary-yellow);
        }

        .selection-counter {
            color: var(--primary-blue);
        }

        .download-section {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-sm) var(--spacing-md);
            background: #fafbfc;
            border-radius: var(--radius-md);
            border: 1px solid #e5e7eb;
        }

        .section-label {
            font-weight: 500;
            color: var(--text-light);
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .control-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: var(--spacing-sm) var(--spacing-md);
            border: none;
            border-radius: var(--radius-md);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 90px;
            text-align: center;
            position: relative;
        }

        .control-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-icon {
            font-size: 1.2rem;
            margin-bottom: 2px;
        }

        .btn-text {
            font-weight: 600;
            line-height: 1;
        }

        .btn-desc {
            font-size: 0.7rem;
            color: currentColor;
            opacity: 0.8;
            line-height: 1;
            margin-top: 2px;
        }

        /* Download buttons styling */
        .control-btn.download-individual {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
        }

        .control-btn.download-individual:hover:not(:disabled) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.4);
        }

        .control-btn.download-zip {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }

        .control-btn.download-zip:hover:not(:disabled) {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
        }

        /* Management buttons styling */
        .control-btn.classify {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3);
        }

        .control-btn.classify:hover:not(:disabled) {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(245, 158, 11, 0.4);
        }

        .control-btn.clear {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
        }

        .control-btn.clear:hover:not(:disabled) {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.4);
        }

        .control-btn.auto-classify {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(139, 92, 246, 0.3);
        }

        .control-btn.auto-classify:hover:not(:disabled) {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(139, 92, 246, 0.4);
        }

        .management {
            display: flex;
            gap: var(--spacing-sm);
        }

        .upload-section {
            position: relative;
        }

        .control-btn.upload-btn {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(139, 92, 246, 0.3);
        }

        .control-btn.upload-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(139, 92, 246, 0.4);
        }

        /* Upload Progress Bar */
        .upload-progress {
            margin: var(--spacing-md) 0;
            padding: var(--spacing-md);
            background: #f8fafc;
            border-radius: var(--radius-md);
            border: 1px solid #e5e7eb;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .progress-text {
            font-weight: 500;
            color: var(--text-dark);
        }

        .progress-count {
            font-size: 0.9rem;
            color: var(--text-light);
            background: white;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
        }

        .progress-bar {
            height: 8px;
            background: #e5e7eb;
            border-radius: var(--radius-sm);
            overflow: hidden;
            margin-bottom: var(--spacing-sm);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6, #7c3aed);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: var(--radius-sm);
        }

        .progress-details {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            min-height: 300px;
            padding: 24px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .empty-gallery {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 24px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
            border-radius: 12px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
        }

        .empty-icon {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: var(--spacing-sm);
        }

        .empty-text {
            margin-bottom: var(--spacing-xs);
        }

        .empty-hint {
            font-size: 0.85rem;
            font-style: italic;
        }

        .gallery-item {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: grab;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            position: relative;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .gallery-item:hover {
            border-color: rgba(59, 130, 246, 0.5);
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.2), 0 4px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.95);
        }

        .gallery-item.dragging {
            opacity: 0.7;
            transform: rotate(5deg);
            cursor: grabbing;
        }

        .gallery-item-image-container {
            position: relative;
            overflow: hidden;
        }

        .gallery-item-image {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            transition: transform 0.3s ease;
            background-color: #f3f4f6;
            background-image: 
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%),
                linear-gradient(-45deg, #e5e7eb 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #e5e7eb 75%),
                linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        
        .gallery-item-image[src]:not([src=""]) {
            background: none;
        }
        
        /* Gallery Loading States */
        .gallery-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #6b7280;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e5e7eb;
            border-top: 4px solid var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        .loading-text {
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Image lazy loading placeholder */
        .gallery-item-image[data-src] {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading-shimmer 1.5s infinite;
        }
        
        @keyframes loading-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .gallery-item:hover .gallery-item-image {
            transform: scale(1.02);
        }

        .gallery-item-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 6px;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateY(-4px);
        }

        .gallery-item:hover .gallery-item-actions {
            opacity: 1;
            transform: translateY(0);
        }

        .gallery-action-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .gallery-action-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 1);
        }

        .gallery-action-btn.delete-btn:hover {
            background: #fee2e2;
            color: #dc2626;
        }

        .gallery-action-btn.rename-btn:hover {
            background: #fef3c7;
            color: #d97706;
        }

        .gallery-action-btn.download-btn:hover {
            background: #dcfce7;
            color: #16a34a;
        }

        .gallery-item-info {
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 250, 252, 0.9) 100%);
        }

        .gallery-item-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-dark);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
            letter-spacing: -0.02em;
        }

        .gallery-item-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 4px;
        }

        .gallery-item-size {
            font-size: 0.75rem;
            color: var(--text-light);
        }

        .gallery-item-type {
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 600;
            background: linear-gradient(135deg, #e0f2fe 0%, #bfdbfe 100%);
            color: #0369a1;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(3, 105, 161, 0.1);
        }

        /* Classification Mode */
        .classification-mode {
            margin-top: var(--spacing-xl);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: var(--spacing-md);
        }

        .source-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
            padding: 24px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .classification-areas {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 32px;
        }

        .classification-panel {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .panel-header {
            padding: 20px 24px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(59, 130, 246, 0.05) 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .panel-header h3 {
            margin: 0 0 var(--spacing-sm) 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .panel-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .panel-controls input {
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: var(--radius-sm);
            font-size: 0.85rem;
            width: 80px;
        }

        .rename-pattern {
            font-size: 0.8rem;
            color: var(--text-light);
            font-style: italic;
        }

        .drop-zone {
            min-height: 200px;
            padding: var(--spacing-md);
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: var(--spacing-sm);
            position: relative;
        }

        .drop-zone.empty {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .drop-zone.drag-over {
            background: #eff6ff;
            border-color: var(--primary-blue);
        }

        .drop-hint {
            color: var(--text-light);
            text-align: center;
            font-style: italic;
        }

        .classified-item {
            position: relative;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-md);
            overflow: hidden;
            background: white;
        }

        .classified-item-image {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
        }

        .classified-item-controls {
            position: absolute;
            top: 4px;
            right: 4px;
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
            max-width: 50px;
        }

        .item-control-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .item-control-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        .classified-item-name {
            padding: 4px;
            font-size: 0.7rem;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .classification-controls {
            display: flex;
            justify-content: center;
            gap: var(--spacing-md);
        }

        .download-options {
            margin-top: var(--spacing-xl);
            background: white;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid #e5e7eb;
            overflow: hidden;
        }

        .download-header {
            padding: var(--spacing-lg);
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-bottom: 1px solid #e5e7eb;
            text-align: center;
        }

        .download-header h3 {
            margin: 0 0 4px 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .download-header p {
            margin: 0;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .download-methods-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
        }

        .download-method-card {
            padding: var(--spacing-lg);
            border-right: 1px solid #e5e7eb;
        }

        .download-method-card:last-child {
            border-right: none;
        }

        .method-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid #f1f5f9;
        }

        .method-icon {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: var(--radius-md);
            background: #f8fafc;
        }

        .method-info h4 {
            margin: 0 0 2px 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .method-info p {
            margin: 0;
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .method-buttons {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .method-btn {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) var(--spacing-md);
            border: 1px solid #e5e7eb;
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .method-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-label {
            font-weight: 500;
            color: var(--text-dark);
        }

        .btn-count {
            font-size: 0.8rem;
            color: var(--text-light);
            background: #f1f5f9;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
        }

        /* Individual download buttons */
        .individual-btn:hover:not(:disabled) {
            border-color: #10b981;
            background: #f0fdf4;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
        }

        .individual-btn:hover:not(:disabled) .btn-count {
            background: #dcfce7;
            color: #166534;
        }

        .individual-btn.all {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .individual-btn.all .btn-label {
            color: #166534;
            font-weight: 600;
        }

        .individual-btn.all .btn-count {
            background: #dcfce7;
            color: #166534;
        }

        /* ZIP download buttons */
        .zip-btn:hover:not(:disabled) {
            border-color: #3b82f6;
            background: #f0f9ff;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
        }

        .zip-btn:hover:not(:disabled) .btn-count {
            background: #dbeafe;
            color: #1e40af;
        }

        .zip-btn.all {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .zip-btn.all .btn-label {
            color: #1e40af;
            font-weight: 600;
        }

        .zip-btn.all .btn-count {
            background: #dbeafe;
            color: #1e40af;
        }

        /* Legacy styles for backward compatibility */
        .download-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--spacing-md);
        }

        .download-option {
            padding: var(--spacing-md);
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .download-option:hover:not(:disabled) {
            border-color: var(--primary-blue);
            background: #f8fafc;
        }

        .download-option:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Responsive */
        /* Image Action Modal */
        .image-action-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid #e5e7eb;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }

        .modal-header h4 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-light);
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: var(--text-dark);
        }

        .modal-body {
            padding: 25px;
        }

        .selected-image-preview {
            text-align: center;
            margin-bottom: var(--spacing-lg);
        }

        .selected-image-preview img {
            width: 120px;
            height: 120px;
            object-fit: cover;
            border-radius: var(--radius-md);
            border: 1px solid #e2e8f0;
        }

        .selected-image-preview div {
            margin-top: var(--spacing-sm);
            font-size: 0.9rem;
            color: var(--text-dark);
            font-weight: 500;
        }

        .action-buttons {
            display: flex;
            gap: var(--spacing-md);
            flex-direction: column;
        }

        .add-to-btn {
            padding: 12px 20px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
        }

        .add-to-btn.front-btn {
            background: var(--primary-blue);
            color: white;
        }

        .add-to-btn.front-btn:hover {
            background: var(--dark-blue);
        }

        .add-to-btn.back-btn {
            background: #10b981;
            color: white;
        }

        .add-to-btn.back-btn:hover {
            background: #047857;
        }

        .instruction-hint {
            font-size: 0.85rem;
            color: var(--text-light);
            font-weight: 400;
            font-style: italic;
        }

        .source-grid .gallery-item {
            cursor: pointer;
            position: relative;
        }

        .source-grid .gallery-item:hover {
            transform: scale(1.02);
        }

        .source-grid .gallery-item::after {
            content: '+';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(59, 130, 246, 0.9);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .source-grid .gallery-item:hover::after {
            opacity: 1;
        }

        /* Classification Hover Actions */
        .classification-hover-actions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 100;
            pointer-events: none;
        }

        .source-grid .gallery-item:hover .classification-hover-actions {
            opacity: 1;
            pointer-events: auto;
        }

        /* Force show hover actions when NOT in active selection */
        .print-container:not(.active-selection) .source-grid .gallery-item:hover .classification-hover-actions {
            opacity: 1 !important;
            pointer-events: auto !important;
            display: flex !important;
        }

        /* Hide hover actions only when actively selecting (selectionMode is true) */
        .print-container.active-selection .source-grid .gallery-item .classification-hover-actions {
            display: none !important;
        }

        .classification-action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 12px;
            border: none;
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8rem;
            font-weight: 500;
            min-width: 70px;
        }

        .classification-action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        .classification-action-btn.front-action {
            border: 2px solid #10b981;
            color: #047857;
        }

        .classification-action-btn.front-action:hover {
            background: #f0fdf4;
            border-color: #047857;
        }

        .classification-action-btn.back-action {
            border: 2px solid #3b82f6;
            color: #1e40af;
        }

        .classification-action-btn.back-action:hover {
            background: #eff6ff;
            border-color: #1e40af;
        }

        .classification-action-btn.rotation-action {
            border: 2px solid #f59e0b;
            color: #d97706;
            min-width: 60px;
        }

        .classification-action-btn.rotation-action:hover {
            background: #fef3c7;
            border-color: #d97706;
        }

        .classification-action-btn.duplicate-action {
            border: 2px solid #8b5cf6;
            color: #7c3aed;
            min-width: 70px;
        }

        .classification-action-btn.duplicate-action:hover {
            background: #f3e8ff;
            border-color: #7c3aed;
        }

        .action-icon {
            font-size: 1.2rem;
            line-height: 1;
        }

        .action-text {
            line-height: 1;
            white-space: nowrap;
        }

        /* Hide the old + indicator when we have buttons */
        .source-grid .gallery-item:hover::after {
            opacity: 0;
        }

        @media (max-width: 768px) {
            .size-options {
                grid-template-columns: 1fr;
            }

            .dimension-inputs {
                grid-template-columns: 1fr;
            }

            .download-options,
            .tool-options {
                flex-direction: column;
            }

            .download-btn,
            .tool-btn {
                width: 100%;
            }

            .gallery-controls {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
                text-align: center;
            }

            .download-section {
                flex-direction: column;
                gap: var(--spacing-sm);
                padding: var(--spacing-sm);
            }

            .control-btn {
                min-width: 80px;
                padding: var(--spacing-xs) var(--spacing-sm);
            }

            .btn-desc {
                font-size: 0.65rem;
            }

            .management {
                justify-content: center;
                flex-wrap: wrap;
            }

            .download-methods-grid {
                grid-template-columns: 1fr;
            }

            .download-method-card {
                border-right: none;
                border-bottom: 1px solid #e5e7eb;
            }

            .download-method-card:last-child {
                border-bottom: none;
            }

            .classification-areas {
                grid-template-columns: 1fr;
            }

            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }

            .action-buttons {
                flex-direction: column;
            }

            .modal-content {
                width: 95%;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 16px;
            }

            .function-tabs {
                margin-bottom: 24px;
                max-width: 100%;
            }

            .upload-zone {
                max-width: 100%;
                padding: 32px 16px;
            }

            .controls {
                max-width: 100%;
                padding: 16px;
            }

            .controls-row {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .controls-row:last-child {
                grid-template-columns: 1fr;
                justify-items: center;
            }

            .actions {
                max-width: 100%;
                padding: 16px;
            }

            .actions-container {
                grid-template-columns: 1fr;
            }

            .actions-group {
                justify-content: center;
                gap: 8px;
            }

            .action-btn {
                min-width: 120px;
                font-size: 0.85rem;
                height: 36px;
            }

            .stats {
                max-width: 100%;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
        }

        @media (max-width: 480px) {
            .main-content {
                padding: 12px;
            }

            .function-tabs {
                flex-direction: column;
                gap: 4px;
            }

            .tab-button {
                padding: 12px 16px;
            }

            .upload-zone {
                padding: 24px 12px;
            }

            .stats {
                grid-template-columns: 1fr 1fr;
            }

            .actions-container {
                grid-template-columns: 1fr;
                gap: var(--spacing-sm);
            }

            .actions-group {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
                margin-bottom: 12px;
            }

            .action-btn {
                min-width: auto;
                width: 100%;
                font-size: 0.85rem;
            }
        }

        /* Enhanced Gallery Responsive Design */
        @media (max-width: 1200px) {
            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
                gap: 18px;
                padding: 20px;
            }
            
            .classification-areas {
                gap: 20px;
            }
        }

        @media (max-width: 768px) {
            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 16px;
                padding: 16px;
                min-height: 250px;
            }
            
            .gallery-item-info {
                padding: 10px 12px;
            }
            
            .gallery-item-name {
                font-size: 0.8rem;
            }
            
            .gallery-action-btn {
                width: 28px;
                height: 28px;
                font-size: 0.8rem;
            }
            
            .classification-areas {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .source-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 12px;
                padding: 16px;
            }
        }

        @media (max-width: 480px) {
            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
                gap: 12px;
                padding: 12px;
                min-height: 200px;
            }
            
            .gallery-item-info {
                padding: 8px 10px;
            }
            
            .gallery-item-name {
                font-size: 0.75rem;
                margin-bottom: 2px;
            }
            
            .gallery-item-size {
                font-size: 0.7rem;
            }
            
            .gallery-item-type {
                font-size: 0.65rem;
                padding: 2px 6px;
            }
            
            .gallery-action-btn {
                width: 24px;
                height: 24px;
                font-size: 0.75rem;
            }
            
            .gallery-item-actions {
                top: 6px;
                right: 6px;
                gap: 4px;
            }
            
            .source-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 10px;
                padding: 12px;
            }
            
            .panel-header {
                padding: 16px 16px;
            }
            
            .empty-gallery {
                padding: 40px 16px;
            }
        }

        /* Dark mode enhancements for gallery */
        @media (prefers-color-scheme: dark) {
            .gallery-grid {
                background: rgba(0, 0, 0, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .gallery-item {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(255, 255, 255, 0.15);
            }
            
            .gallery-item:hover {
                background: rgba(0, 0, 0, 0.4);
                border-color: rgba(59, 130, 246, 0.6);
            }
            
            .gallery-item-info {
                background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(31, 41, 55, 0.4) 100%);
            }
            
            .classification-panel {
                background: rgba(0, 0, 0, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.15);
            }
            
            .panel-header {
                background: linear-gradient(135deg, rgba(0, 0, 0, 0.2) 0%, rgba(59, 130, 246, 0.1) 100%);
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
        }

        .actions-group:last-child {
            margin-bottom: 0;
        }

        .action-btn {
            padding: 10px 16px;
            border: 2px solid #d1d5db;
            border-radius: var(--radius-md);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 140px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            flex: 0 0 auto;
            background: #f8fafc;
        }

        .action-btn.download {
            background: var(--primary-blue);
            color: var(--white);
        }

        .action-btn.download:hover {
            background: var(--dark-blue);
        }

        .action-btn.tool {
            background: var(--primary-yellow);
            color: var(--text-dark);
        }

        .action-btn.tool:hover {
            background: #F59E0B;
        }

        .action-btn.utility {
            background: #6B7280;
            color: var(--white);
        }

        .action-btn.utility:hover {
            background: #4B5563;
            transform: translateY(-2px);
        }

        .action-btn.clear {
            background: #EF4444;
        }

        .action-btn.clear:hover {
            background: #DC2626;
        }

        .quick-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-lg);
            font-size: var(--text-sm);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-base);
            height: 40px;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-sm);
        }

        .quick-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .stat-card {
            background: #f8fafc;
            padding: 16px 12px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary-blue);
            margin-bottom: 4px;
        }

        .stat-label {
            color: #64748b;
            font-size: 0.8rem;
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.error {
            background: #ef4444;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        /* Preview Modal Specific Styles */
        .preview-modal-content {
            background: var(--white);
            border-radius: 16px;
            width: 90%;
            max-width: 800px;
            max-height: 95vh;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary-yellow);
        }

        .preview-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 2px solid var(--primary-yellow);
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: var(--white);
        }

        .preview-modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-modal-body {
            padding: 25px;
            max-height: calc(95vh - 200px);
            overflow-y: auto;
        }

        .preview-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .preview-image-container {
            position: relative;
            max-width: 100%;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: 2px solid var(--light-yellow);
        }

        .preview-image {
            max-width: 100%;
            max-height: 60vh;
            width: auto;
            height: auto;
            display: block;
            border-radius: 10px;
        }

        .preview-image-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
            color: white;
            padding: 15px 20px 20px;
            font-size: 0.9rem;
        }

        .preview-details {
            background: var(--light-yellow);
            border: 2px solid var(--primary-yellow);
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 500px;
        }

        .preview-details h3 {
            margin: 0 0 15px 0;
            color: var(--text-dark);
            font-size: 1.2rem;
            text-align: center;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .detail-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .detail-label {
            font-weight: 600;
            color: var(--text-light);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .detail-value {
            font-weight: 700;
            color: var(--text-dark);
            font-size: 1rem;
        }

        .preview-modal-footer {
            padding: 20px 25px;
            border-top: 2px solid var(--primary-yellow);
            background: var(--light-yellow);
            display: flex;
            justify-content: space-between;
            gap: 15px;
        }

        .preview-btn {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .preview-btn.cancel {
            background: #6b7280;
            color: var(--white);
        }

        .preview-btn.cancel:hover {
            background: #4b5563;
            transform: translateY(-2px);
        }

        .preview-btn.download {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: var(--white);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .preview-btn.download:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .preview-modal-content {
                width: 95%;
                max-height: 90vh;
            }

            .preview-modal-header {
                padding: 15px 20px;
            }

            .preview-modal-header h2 {
                font-size: 1.2rem;
            }

            .preview-modal-body {
                padding: 20px;
                max-height: calc(90vh - 160px);
            }

            .preview-image {
                max-height: 50vh;
            }

            .detail-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .preview-modal-footer {
                padding: 15px 20px;
                flex-direction: column;
            }

            .preview-btn {
                padding: 12px 18px;
                font-size: 0.95rem;
            }
        }

        /* Loading Animation */
        .preview-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 40px;
            color: var(--text-light);
        }

        .preview-loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--light-yellow);
            border-top: 4px solid var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .close {
            font-size: 24px;
            cursor: pointer;
            background: none;
            border: none;
            color: white;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        .close:hover {
            opacity: 1;
        }

        .pdf-config {
            display: grid;
            gap: 20px;
        }

        .config-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-section label {
            font-weight: 600;
            color: #374151;
            font-size: 0.95rem;
        }

        .config-section select,
        .config-section input[type="text"],
        .config-section input[type="number"],
        .config-section textarea {
            padding: 10px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .config-section select:focus,
        .config-section input:focus,
        .config-section textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .config-section textarea {
            resize: vertical;
            font-family: inherit;
        }

        .config-section input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .modal-footer {
            padding: 20px 25px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-btn.cancel {
            background: #6b7280;
            color: white;
        }

        .modal-btn.cancel:hover {
            background: #4b5563;
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .modal-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        /* Crop Editor Styles */
        .crop-editor-content {
            max-width: 90vw;
            max-height: 95vh;
        }

        .crop-editor-body {
            padding: 15px;
        }

        .template-selector {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .template-preview {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ratio-preview {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .ratio-box {
            width: 30px;
            height: 45px;
            border: 2px solid #667eea;
            border-radius: 3px;
            background: rgba(102, 126, 234, 0.1);
            transition: all 0.3s ease;
        }

        .ratio-text {
            font-size: 0.8rem;
            font-weight: 600;
            color: #667eea;
        }

        .size-info {
            font-size: 0.85rem;
            color: #6b7280;
            background: #f3f4f6;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .custom-size {
            margin-top: 15px;
        }

        .size-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .size-input {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .preview-info {
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .preview-info h3 {
            margin: 0 0 10px 0;
            color: #374151;
        }

        .info-grid {
            display: grid;
            gap: 8px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .crop-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .crop-info-panel {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            align-items: center;
        }

        .crop-target-info, .crop-current-info, .crop-ratio-info, .crop-tip-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .crop-tip-info span:last-child {
            font-size: 0.85rem;
            color: #059669;
            font-style: italic;
        }

        .info-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #4b5563;
        }

        #targetSizeInfo, #selectionSize, #cropRatioStatus {
            font-size: 0.9rem;
            font-weight: 500;
            color: #667eea;
        }

        .crop-canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f8fafc;
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            min-height: 400px;
            overflow: hidden;
        }

        .crop-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        .crop-selection {
            position: absolute;
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
            cursor: move;
            pointer-events: all;
            transition: box-shadow 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .crop-selection:hover {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            transform: scale(1.002);
        }

        .crop-selection.dragging {
            cursor: grabbing;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
            transform: scale(1.005);
        }

        .crop-selection.resizing {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        /* REMOVED ALL RESIZE HANDLES - Only move handle allowed */
        .crop-handle {
            display: none !important; /* DISABLE ALL RESIZE HANDLES */
            pointer-events: none !important;
        }

        .crop-handle.corner,
        .crop-handle.edge,
        .crop-handle.top-left,
        .crop-handle.top-right,
        .crop-handle.bottom-left,
        .crop-handle.bottom-right,
        .crop-handle.top,
        .crop-handle.bottom,
        .crop-handle.left,
        .crop-handle.right {
            display: none !important; /* FORCE HIDE ALL RESIZE HANDLES */
            pointer-events: none !important;
        }

        .crop-move-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px; /* Larger for easier grabbing */
            height: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: grab;
            user-select: none;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            pointer-events: all;
            transition: all 0.3s ease;
        }

        .crop-move-handle:hover {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.15);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #5a67d8 0%, #6a4c93 100%);
        }

        .crop-move-handle:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.05);
        }

        .crop-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 5;
        }

        .crop-grid.visible {
            opacity: 0.4;
        }

        .crop-grid .grid-line {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 1px rgba(0,0,0,0.3);
        }

        .crop-grid .grid-line.vertical {
            width: 1px;
            height: 100%;
            top: 0;
        }

        .crop-grid .grid-line.vertical:nth-child(1) { left: 33.33%; }
        .crop-grid .grid-line.vertical:nth-child(2) { left: 66.66%; }

        .crop-grid .grid-line.horizontal {
            width: 100%;
            height: 1px;
            left: 0;
        }

        .crop-grid .grid-line.horizontal:nth-child(3) { top: 33.33%; }
        .crop-grid .grid-line.horizontal:nth-child(4) { top: 66.66%; }

        .crop-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            background: #f8fafc;
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .crop-zoom-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px 12px;
            background: var(--light-yellow);
            border: 2px solid var(--primary-yellow);
            border-radius: 25px;
        }

        .crop-zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--primary-blue);
            color: white;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .crop-zoom-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            background: var(--dark-blue);
        }

        .crop-zoom-btn:active {
            transform: translateY(0);
        }

        .crop-zoom-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.1);
        }

        .crop-zoom-info {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-dark);
            min-width: 60px;
            text-align: center;
        }

        .crop-btn {
            padding: 8px 16px;
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .crop-btn:hover {
            background: #4b5563;
            transform: translateY(-1px);
        }

        .crop-btn.toggle {
            background: #e5e7eb;
            color: #374151;
        }

        .crop-btn.toggle:hover {
            background: #d1d5db;
        }

        .crop-btn.toggle.active {
            background: #667eea;
            color: white;
        }

        .crop-preview-mini {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .crop-preview-mini canvas {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: #f9fafb;
        }

        .crop-preview-mini span {
            font-size: 0.8rem;
            color: #6b7280;
            font-weight: 500;
        }

        .crop-mode-selector {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 12px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .radio-option:hover {
            background: #e2e8f0;
            border-color: #cbd5e1;
        }

        .radio-option input[type="radio"] {
            margin: 0;
            cursor: pointer;
        }

        .radio-option input[type="radio"]:checked + span {
            color: #667eea;
            font-weight: 600;
        }

        .radio-option:has(input[type="radio"]:checked) {
            background: #eef2ff;
            border-color: #667eea;
        }

        .crop-info {
            background: #f3f4f6;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .crop-progress {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        /* Preview Gallery Styles */
        .crop-preview-content {
            max-width: 95vw;
            max-height: 95vh;
            width: 1200px;
        }

        .preview-gallery-body {
            padding: 20px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .preview-controls-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .template-info {
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            color: #4b5563;
        }

        .batch-controls {
            display: flex;
            gap: 10px;
        }

        .preview-btn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .preview-btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .preview-btn.secondary {
            background: #6b7280;
        }

        .preview-btn.secondary:hover {
            background: #4b5563;
        }

        .preview-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(17.5rem, 100%), 1fr));
            gap: clamp(1rem, 3vw, 1.5rem); /* 16px - 24px responsive */
            padding: clamp(1rem, 3vw, 1.5rem) 0;
        }

        .preview-item {
            background: white;
            border-radius: 12px;
            border: 2px solid #e2e8f0;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .preview-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .preview-item.selected {
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .preview-item-header {
            padding: 12px 15px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-item-name {
            font-weight: 600;
            color: #374151;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .preview-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .preview-image-container {
            position: relative;
            height: 200px;
            background: #f9fafb;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .preview-image {
            max-width: 100%;
            max-height: 100%;
            border-radius: 4px;
        }

        .preview-crop-overlay {
            position: absolute;
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
            pointer-events: none;
        }

        .preview-item-info {
            padding: 12px 15px;
            font-size: 0.85rem;
            color: #6b7280;
        }

        .preview-stats {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        /* Enhanced Preview Gallery Styles */
        .preview-item {
            background: var(--white);
            border: 2px solid var(--light-yellow);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .preview-item:hover {
            border-color: var(--primary-blue);
            box-shadow: 0 8px 16px rgba(59, 130, 246, 0.2);
            transform: translateY(-2px);
        }

        .preview-image-container {
            position: relative;
            width: 100%;
            height: 200px;
            overflow: hidden;
            background: var(--light-yellow);
        }

        .preview-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }

        .preview-item:hover .preview-image {
            transform: scale(1.05);
        }

        .preview-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
            color: var(--white);
            padding: 15px;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .preview-item:hover .preview-overlay {
            transform: translateY(0);
        }

        .preview-name {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .preview-size {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        .preview-controls {
            padding: 12px;
            display: flex;
            gap: 8px;
            background: #f8f9fa;
        }

        .preview-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-family: 'Lexend', sans-serif;
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preview-btn.edit {
            background: var(--primary-blue);
            color: var(--white);
        }

        .preview-btn.edit:hover {
            background: var(--dark-blue);
            transform: translateY(-1px);
        }

        .preview-btn.remove {
            background: #ef4444;
            color: var(--white);
        }

        .preview-btn.remove:hover {
            background: #dc2626;
            transform: translateY(-1px);
        }

        /* Multi-image crop editor for manual mode */
        .crop-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            max-height: 70vh;
            overflow-y: auto;
            padding: 20px;
        }

        .crop-image-card {
            background: var(--white);
            border: 2px solid var(--light-yellow);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .crop-image-card.selected {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
        }

        .crop-card-header {
            padding: 12px 16px;
            background: var(--light-yellow);
            border-bottom: 1px solid var(--primary-yellow);
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-dark);
        }

        .crop-card-canvas-container {
            position: relative;
            height: 250px;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .crop-card-canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 4px;
        }

        .crop-card-controls {
            padding: 12px 16px;
            display: flex;
            gap: 8px;
            background: #f8f9fa;
        }

        .crop-card-btn {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid var(--primary-blue);
            background: var(--white);
            color: var(--primary-blue);
            border-radius: 4px;
            font-family: 'Lexend', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .crop-card-btn:hover {
            background: var(--primary-blue);
            color: var(--white);
        }

        .crop-card-btn.primary {
            background: var(--primary-blue);
            color: var(--white);
        }

        .crop-card-btn.primary:hover {
            background: var(--dark-blue);
        }

        /* Multi-Crop Editor Styles */
        .multi-crop-editor-content {
            max-width: 95vw;
            max-height: 95vh;
            width: 95vw;
            height: 95vh;
        }

        .multi-crop-editor-body {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            height: calc(100% - 120px);
        }

        .global-crop-controls {
            background: var(--light-yellow);
            padding: 16px 20px;
            border-radius: 12px;
            border: 2px solid var(--primary-yellow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .global-info {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .target-size-display,
        .aspect-ratio-display {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .global-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .global-btn {
            padding: 8px 16px;
            border: 2px solid var(--primary-blue);
            background: var(--white);
            color: var(--primary-blue);
            border-radius: 8px;
            font-family: 'Lexend', sans-serif;
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .global-btn:hover {
            background: var(--primary-blue);
            color: var(--white);
            transform: translateY(-1px);
        }

        .global-btn.toggle.active {
            background: var(--primary-blue);
            color: var(--white);
        }

        .multi-crop-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(23.75rem, 100%), 1fr));
            gap: clamp(1rem, 3vw, 2rem); /* 16px - 32px responsive */
            flex: 1;
            overflow-y: auto;
            padding: clamp(0.5rem, 2vw, 1.5rem);
            justify-content: center;
            max-width: 100%;
            container-type: inline-size;
        }

        .multi-crop-card {
            background: var(--white);
            border: 0.1875rem solid var(--light-yellow); /* 3px */
            border-radius: 0.75rem; /* 12px */
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
            min-height: clamp(25rem, 30vh, 35rem); /* 400px - 560px responsive */
            width: 100%;
            aspect-ratio: 4/5; /* Consistent card proportions */
            display: flex;
            flex-direction: column;
        }

        .multi-crop-card.selected {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
        }

        .multi-crop-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .multi-crop-header {
            padding: 12px 16px;
            background: var(--light-yellow);
            border-bottom: 2px solid var(--primary-yellow);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .multi-crop-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-dark);
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .multi-crop-selector {
            position: relative;
        }

        .multi-crop-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary-blue);
            border-radius: 4px;
            background: var(--white);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .multi-crop-checkbox.checked {
            background: var(--primary-blue);
            color: var(--white);
        }

        .multi-crop-canvas-container {
            position: relative;
            flex: 1; /* Take remaining space in card */
            min-height: clamp(15rem, 25vh, 25rem); /* 240px - 400px responsive */
            width: 100%;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
            border: 0.125rem solid #e0e0e0; /* 2px */
            margin: 0;
            aspect-ratio: 4/3;
        }

        .multi-crop-canvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            display: block;
            border: 2px solid #007bff;
            background: white;
            object-fit: contain;
        }

        .multi-crop-overlay {
            position: absolute;
            pointer-events: none;
            /* Will be positioned dynamically to match canvas */
        }

        .multi-crop-selection {
            position: absolute;
            border: 2px solid var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
            cursor: move;
            pointer-events: all;
            transition: box-shadow 0.2s ease;
        }

        .multi-crop-selection:hover {
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .multi-crop-selection.dragging {
            cursor: grabbing;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }

        /* DISABLED ALL MULTI-CROP RESIZE HANDLES */
        .multi-crop-handle {
            display: none !important; /* COMPLETELY HIDE ALL RESIZE HANDLES */
            pointer-events: none !important;
        }

        .multi-crop-handle.corner,
        .multi-crop-handle.corner.nw,
        .multi-crop-handle.corner.ne,
        .multi-crop-handle.corner.sw,
        .multi-crop-handle.corner.se {
            display: none !important; /* FORCE HIDE CORNER HANDLES */
            pointer-events: none !important;
        }

        .multi-crop-move-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: rgba(59, 130, 246, 0.9);
            color: var(--white);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .multi-crop-move-handle:hover {
            background: var(--primary-blue);
            transform: translate(-50%, -50%) scale(1.1);
        }

        .multi-crop-move-handle:active {
            cursor: grabbing;
        }

        .multi-crop-controls {
            padding: 12px 16px;
            background: #f8f9fa;
            display: flex;
            gap: 8px;
        }

        .multi-crop-btn {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid var(--primary-blue);
            background: var(--white);
            color: var(--primary-blue);
            border-radius: 6px;
            font-family: 'Lexend', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .multi-crop-btn:hover {
            background: var(--primary-blue);
            color: var(--white);
        }

        .multi-crop-info {
            padding: 8px 16px;
            background: var(--light-yellow);
            font-size: 0.8rem;
            color: var(--text-dark);
            text-align: center;
        }

        /* Modern Responsive Design - Zoom-Independent Layout
           
           Key Features:
           - Uses rem units instead of px for zoom independence
           - clamp() functions for fluid responsive sizing  
           - min() function in minmax() for overflow protection
           - Container queries where supported
           - Consistent aspect ratios across all zoom levels
           
           Grid Systems:
           - file-list: Auto-fit grid with 12rem minimum cards
           - multi-crop-container: Auto-fit grid with 23.75rem minimum cards
           - template-grid: Auto-fit grid with 7.5rem minimum cards
           - stats: Auto-fit grid with 9.375rem minimum cards
           
           Responsive Breakpoints:
           - 75rem (1200px): Large desktop
           - 60rem (960px): Medium desktop  
           - 48rem (768px): Tablet
           - 30rem (480px): Mobile
        */
        
        /* Container Queries for Multi-Crop Component */
        @container (max-width: 60rem) {
            .multi-crop-container {
                grid-template-columns: repeat(auto-fit, minmax(min(20rem, 100%), 1fr));
                gap: clamp(0.75rem, 2vw, 1.5rem);
            }
        }

        @container (max-width: 40rem) {
            .multi-crop-container {
                grid-template-columns: 1fr;
                gap: clamp(1rem, 3vw, 2rem);
            }
        }

        /* Viewport-based responsive breakpoints using rem units */
        @media (max-width: 75rem) {
            .file-list {
                grid-template-columns: repeat(auto-fit, minmax(min(10rem, 100%), 1fr));
            }
        }

        @media (max-width: 60rem) {
            .file-list {
                grid-template-columns: repeat(auto-fit, minmax(min(8rem, 100%), 1fr));
            }
            
            .multi-crop-container {
                padding: clamp(0.5rem, 1.5vw, 1rem);
            }
            
            .template-grid {
                grid-template-columns: repeat(auto-fit, minmax(min(6rem, 100%), 1fr));
            }
        }

        @media (max-width: 48rem) {
            .file-list {
                grid-template-columns: repeat(auto-fit, minmax(min(7rem, 100%), 1fr));
                gap: clamp(0.5rem, 1.5vw, 1rem);
            }
            
            .stats {
                grid-template-columns: repeat(auto-fit, minmax(min(8rem, 100%), 1fr));
            }
        }

        @media (max-width: 30rem) {
            .file-list {
                grid-template-columns: repeat(auto-fit, minmax(min(6rem, 100%), 1fr));
            }
            
            .multi-crop-container {
                grid-template-columns: 1fr;
            }
            
            .stats {
                grid-template-columns: 1fr;
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .controls-row {
                flex-direction: column;
                gap: 15px;
            }

            .control-group {
                justify-content: space-between;
                margin-bottom: 10px;
            }

            .control-group label {
                min-width: 60px;
            }

            .control-group select,
            .control-group input[type="text"] {
                min-width: 200px;
            }

            .actions-group {
                justify-content: center;
            }

            .action-btn {
                min-width: 100px;
                font-size: 0.9rem;
            }

            .file-actions {
                grid-column: 1 / -1;
                display: flex;
                gap: 8px;
                justify-content: center;
                margin-top: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: clamp(0.75rem, 2vw, 1.25rem);
            }

            .multi-crop-container {
                grid-template-columns: 1fr;
            }
        }


        /* Template Crop Editor Styles */
        .template-crop-content {
            width: 90vw;
            height: 85vh;
            max-width: 1200px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10001;
            pointer-events: auto;
        }
        
        .template-crop-content * {
            pointer-events: auto;
        }
        
        .template-crop-content button {
            pointer-events: auto !important;
            cursor: pointer !important;
        }
        
        .template-crop-body {
            padding: 15px;
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
            min-height: 500px;
        }
        
        .template-crop-main {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0;
        }
        
        .template-image-container {
            flex: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            border-radius: 8px;
            position: relative;
            overflow: visible;
            min-height: 500px;
            min-width: 600px;
            padding: 20px;
        }
        
        .template-crop-container {
            position: relative;
            max-width: 100%;
            max-height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .template-crop-canvas {
            display: block;
            min-width: 400px;
            min-height: 300px;
            max-width: 80vw;
            max-height: 60vh;
            width: auto;
            height: auto;
            border: 2px solid #007bff;
            background: white;
            margin: auto;
            border-radius: 4px;
        }
        
        .template-crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .template-crop-selection {
            position: absolute;
            border: 3px solid var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
            cursor: move;
            pointer-events: all;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .template-crop-selection:hover {
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }

        .template-crop-selection.dragging {
            cursor: grabbing;
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.5);
        }

        /* Crop handles for resize */
        .crop-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--primary-blue);
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            cursor: pointer;
        }

        .crop-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .crop-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .crop-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
        .crop-handle.n { top: -5px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .crop-handle.s { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .crop-handle.w { top: 50%; left: -5px; transform: translateY(-50%); cursor: w-resize; }
        .crop-handle.e { top: 50%; right: -5px; transform: translateY(-50%); cursor: e-resize; }

        .crop-handle:hover {
            background: #0056b3;
            box-shadow: 0 3px 6px rgba(0,0,0,0.4);
        }

        /* Crop overlay areas (darken non-selected areas) */
        .crop-overlay {
            position: absolute;
            background: rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }

        .crop-overlay.top {
            top: 0;
            left: 0;
            right: 0;
            height: 0; /* Will be set dynamically */
        }

        .crop-overlay.bottom {
            bottom: 0;
            left: 0;
            right: 0;
            height: 0; /* Will be set dynamically */  
        }

        .crop-overlay.left {
            top: 0;
            bottom: 0;
            left: 0;
            width: 0; /* Will be set dynamically */
        }

        .crop-overlay.right {
            top: 0;
            bottom: 0;
            right: 0;
            width: 0; /* Will be set dynamically */
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);
        }
        
        .template-move-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(59, 130, 246, 0.95);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: move;
            user-select: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            border: 2px solid white;
        }
        
        .template-move-handle:hover {
            background: rgba(59, 130, 246, 1);
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
        }
        
        .template-selection-info {
            position: absolute;
            top: -30px;
            left: 0;
            background: var(--primary-blue);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
        }
        
        .template-controls {
            width: 320px;
            padding: 20px;
            background: white;
            border-left: 1px solid #e0e0e0;
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .template-control-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .template-control-section:last-child {
            border-bottom: none;
        }
        
        .template-control-section h4 {
            margin: 0 0 15px 0;
            color: var(--text-dark);
            font-size: 1rem;
            font-weight: bold;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-btn:hover {
            background: var(--dark-blue);
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        #templateZoomSlider {
            flex: 1;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            outline: none;
            cursor: pointer;
            margin: 0 8px;
        }
        
        #templateZoomSlider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary-blue);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }
        
        #templateZoomSlider::-webkit-slider-thumb:hover {
            background: var(--dark-blue);
            transform: scale(1.1);
        }
        
        #templateZoomValue {
            font-size: 1rem;
            font-weight: bold;
            color: var(--primary-blue);
            min-width: 50px;
            text-align: center;
        }
        
        .position-controls, .display-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .position-btn, .toggle-btn {
            padding: 8px 12px;
            background: var(--light-yellow);
            border: 1px solid var(--primary-yellow);
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .position-btn:hover, .toggle-btn:hover {
            background: var(--primary-yellow);
            transform: translateY(-1px);
        }
        
        .toggle-btn.active {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
        }
        
        .template-info-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        /* Multi-crop controls CSS */
        .multi-crop-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .multi-crop-btn {
            padding: 4px 8px;
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .multi-crop-btn:hover {
            background: var(--dark-blue);
            transform: translateY(-1px);
        }
        
        /* Multi-crop zoom CSS removed - no longer needed */
        
        /* Template crop resize handles */
        .template-resize-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: var(--primary-blue);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            opacity: 1;
            transition: all 0.2s ease;
            z-index: 1001;
            cursor: pointer;
        }
        
        .template-resize-handle:hover {
            background: var(--dark-blue);
            transform: scale(1.3);
            opacity: 1;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .template-resize-handle.nw {
            top: -8px;
            left: -8px;
            cursor: nw-resize;
        }
        
        .template-resize-handle.ne {
            top: -8px;
            right: -8px;
            cursor: ne-resize;
        }
        
        .template-resize-handle.sw {
            bottom: -8px;
            left: -8px;
            cursor: sw-resize;
        }
        
        .template-resize-handle.se {
            bottom: -8px;
            right: -8px;
            cursor: se-resize;
        }
        
        .resize-info {
            padding: 10px;
            background: #f0f8ff;
        }

        /* Template Polaroid Styles */
        .template-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Border Template Styles */
        .border-template-preview-container {
            flex-shrink: 0;
        }

        .border-template-frame {
            width: 200px;
            height: 300px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .border-template-image-area {
            width: 100%;
            height: 100%;
            background: #f3f4f6;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        /* Enhanced Template Crop Page Styles - cropPage adapted for Polaroid templates */
        .template-crop-page-content {
            width: 95vw;
            height: 90vh;
            max-width: 1400px;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10001;
            pointer-events: auto;
        }

        .template-crop-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 12px 12px 0 0;
        }

        .template-header-left h2 {
            margin: 0 0 5px 0;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .template-progress-info {
            display: flex;
            gap: 15px;
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .template-size-info {
            background: rgba(255,255,255,0.2);
            padding: 3px 8px;
            border-radius: 12px;
            font-weight: 500;
        }

        .template-crop-page-body {
            flex: 1;
            display: flex;
            min-height: 0;
            background: #f8f9fa;
        }

        .template-crop-sidebar {
            width: 320px;
            background: white;
            border-right: 1px solid #e9ecef;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .template-section {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }

        .template-section h3 {
            margin: 0 0 15px 0;
            font-size: 1.1rem;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .template-section h4 {
            margin: 0 0 10px 0;
            font-size: 1rem;
            color: #6c757d;
        }

        .template-size-details {
            margin-bottom: 20px;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .detail-label {
            color: #6c757d;
            font-weight: 500;
        }

        .detail-value {
            color: #495057;
            font-weight: 600;
        }

        .detail-value.highlight {
            color: #007bff;
            font-weight: 700;
        }

        .template-border-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
        }

        .border-details {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .border-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
        }

        .border-label {
            color: #6c757d;
        }

        .border-value {
            color: #495057;
            font-weight: 600;
        }

        .template-settings-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-item label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .modern-select {
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
            color: #495057;
            transition: border-color 0.2s ease;
        }

        .modern-select:focus {
            border-color: #007bff;
            outline: none;
        }

        .setting-help {
            font-size: 0.8rem;
            color: #6c757d;
            font-style: italic;
        }

        .template-position-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .control-btn {
            flex: 1;
            padding: 8px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .control-btn:hover {
            background: #0056b3;
        }

        .template-display-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .toggle-btn {
            padding: 6px 10px;
            background: #f8f9fa;
            color: #6c757d;
            border: 2px solid #e9ecef;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .toggle-btn:hover,
        .toggle-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .template-process-modes {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mode-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .mode-card:hover {
            border-color: #007bff;
        }

        .mode-card.active {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .mode-card input[type="radio"] {
            display: none;
        }

        .mode-icon {
            font-size: 1.2rem;
            width: 30px;
            text-align: center;
        }

        .mode-info {
            flex: 1;
        }

        .mode-name {
            font-weight: 600;
            color: #495057;
            margin-bottom: 2px;
        }

        .mode-desc {
            font-size: 0.8rem;
            color: #6c757d;
        }

        .template-crop-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .template-crop-workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
        }

        .template-workspace-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 12px 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .current-image-info h4 {
            margin: 0 0 4px 0;
            color: #495057;
            font-size: 1.1rem;
        }

        .image-dimensions {
            font-size: 0.9rem;
            color: #6c757d;
        }

        .workspace-controls {
            display: flex;
            gap: 8px;
        }

        .workspace-btn {
            padding: 6px 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .workspace-btn:hover {
            background: #495057;
        }

        .template-image-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            position: relative;
            overflow: visible;
            min-height: 400px;
            padding: 20px;
        }

        .template-workspace-footer {
            margin-top: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            padding: 15px;
        }

        .crop-preview-mini h5 {
            margin: 0 0 10px 0;
            font-size: 0.95rem;
            color: #495057;
        }

        .mini-preview-container {
            display: flex;
            justify-content: center;
        }

        .template-mini-preview {
            max-width: 200px;
            max-height: 150px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
        }

        .template-crop-footer {
            background: white;
            border-top: 1px solid #e9ecef;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .template-nav-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .nav-btn {
            padding: 8px 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .nav-btn:hover:not(:disabled) {
            background: #495057;
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-status {
            font-weight: 600;
            color: #495057;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .template-action-controls {
            display: flex;
            gap: 10px;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn.cancel {
            background: #dc3545;
            color: white;
        }

        .modal-btn.cancel:hover {
            background: #c82333;
        }

        .modal-btn.secondary {
            background: #6c757d;
            color: white;
        }

        .modal-btn.secondary:hover {
            background: #545b62;
        }

        .modal-btn.primary {
            background: #007bff;
            color: white;
        }

        .modal-btn.primary:hover {
            background: #0056b3;
        }

        .selection-status {
            margin-left: 10px;
            font-size: 0.8rem;
            padding: 2px 6px;
            border-radius: 10px;
            background: #d4edda;
            color: #155724;
        }
        
        /* Polaroid Template Compact Layout Styles */
        .polaroid-compact-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .polaroid-top-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 16px 20px;
            color: white;
        }

        .polaroid-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-info h3 {
            margin: 0 0 4px 0;
            font-size: 1.3rem;
        }

        .template-quick-specs {
            font-size: 0.9rem;
            opacity: 0.9;
            font-family: monospace;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .compact-btn {
            padding: 8px 16px;
            border: 2px solid transparent;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .compact-btn.secondary {
            background: #f1f5f9;
            color: #374151;
            border-color: #d1d5db;
        }

        .compact-btn.secondary:hover {
            background: #e2e8f0;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .compact-btn.primary {
            background: #28a745;
            color: white;
        }

        .compact-btn.primary:hover {
            background: #218838;
        }

        .compact-btn.primary:active,
        .compact-btn.primary.active {
            background: #1e7e34 !important;
            transform: translateY(1px);
        }

        .compact-btn.secondary:active,
        .compact-btn.secondary.active {
            background: #d1d5db !important;
            border-color: #6b7280 !important;
            transform: translateY(1px);
        }

        .polaroid-main-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            min-height: 500px;
        }

        .polaroid-preview-section {
            background: white;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #f0f0f0;
        }

        .preview-title {
            font-weight: 600;
            color: #495057;
        }

        .preview-controls {
            display: flex;
            gap: 4px;
        }

        .mini-btn {
            width: 28px;
            height: 28px;
            border: 2px solid #d1d5db;
            background: #f1f5f9;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .mini-btn:hover {
            background: #e2e8f0;
            border-color: #007bff;
            transform: translateY(-1px);
        }

        .mini-btn:active,
        .mini-btn.active {
            background: #d1d5db !important;
            border-color: #6b7280 !important;
            transform: translateY(0px);
        }

        .polaroid-preview-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 12px;
        }

        .compact-upload-zone {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .compact-upload-zone:hover {
            border-color: #007bff;
            background: #f0f9ff;
        }

        .upload-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: #6c757d;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .upload-icon {
            font-size: 1.2rem;
        }

        .polaroid-controls-section {
            background: white;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }

        .settings-tabs {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .tab-header {
            display: flex;
            background: #f8f9fa;
            border-radius: 12px 12px 0 0;
            overflow: hidden;
        }

        .tab-btn {
            flex: 1;
            padding: 12px 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
        }

        .tab-btn:hover {
            background: rgba(0,123,255,0.1);
            color: #007bff;
        }

        .tab-btn.active {
            background: #f8fafc !important;
            color: #007bff !important;
            border-bottom-color: #007bff !important;
            border: 2px solid #007bff !important;
            border-bottom: 3px solid #007bff !important;
        }

        .tab-content {
            flex: 1;
            padding: 16px;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .compact-settings {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .setting-row label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #495057;
            min-width: 80px;
        }

        .compact-input {
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.9rem;
            width: 80px;
            text-align: center;
        }

        .compact-select {
            padding: 6px 10px;
            border: 2px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.9rem;
            background: #f8fafc;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .compact-select:hover {
            border-color: #9ca3af;
            background: #f1f5f9;
        }

        .compact-select:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.1);
        }

        .compact-color {
            width: 40px;
            height: 30px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            cursor: pointer;
        }

        .compact-checkbox {
            transform: scale(1.1);
            margin-right: 6px;
        }

        .size-inputs {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .size-inputs span {
            color: #6c757d;
            font-weight: bold;
        }

        .compact-border-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .border-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .border-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .border-item label {
            font-size: 0.85rem;
            font-weight: 500;
            color: #6c757d;
        }

        .border-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .compact-slider {
            flex: 1;
            height: 6px;
        }

        .compact-number {
            width: 50px;
            padding: 4px 6px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.8rem;
            text-align: center;
        }

        .current-specs-compact {
            margin-top: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .specs-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
        }

        .polaroid-bottom-section {
            background: white;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #e9ecef;
        }

        .download-settings-compact h4 {
            margin: 0 0 12px 0;
            color: #495057;
            font-size: 1rem;
        }

        .compact-download-options {
            margin-bottom: 16px;
        }

        .download-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .download-row label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: #6c757d;
            cursor: pointer;
        }

        .compact-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            padding-top: 12px;
            border-top: 1px solid #f0f0f0;
        }

        .nav-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-btn-compact {
            width: 32px;
            height: 32px;
            border: 2px solid #d1d5db;
            background: #f1f5f9;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .nav-btn-compact:hover:not(:disabled) {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .nav-btn-compact:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-info-compact {
            font-family: monospace;
            font-size: 0.9rem;
            color: #6c757d;
            min-width: 40px;
            text-align: center;
        }

        .export-section {
            display: flex;
            gap: 8px;
        }

        .export-btn-compact {
            padding: 8px 12px;
            border: 2px solid transparent;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .export-btn-compact.primary {
            background: #28a745;
            color: white;
        }

        .export-btn-compact.primary:hover {
            background: #218838;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.2);
        }

        .export-btn-compact.secondary {
            background: #6c757d;
            color: white;
        }

        .export-btn-compact.secondary:hover {
            background: #545b62;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(108, 117, 125, 0.2);
        }

        .export-btn-compact.tertiary {
            background: #007bff;
            color: white;
        }

        .export-btn-compact.tertiary:hover {
            background: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .polaroid-main-section {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .polaroid-header {
                flex-direction: column;
                gap: 12px;
                text-align: center;
            }

            .tab-header {
                flex-wrap: wrap;
            }

            .tab-btn {
                min-width: 50%;
            }

            .compact-actions {
                flex-direction: column;
                gap: 12px;
            }

            .export-section {
                width: 100%;
                justify-content: center;
            }
        }

        /* Strip Template Styles */
        .strip-template-preview-container {
            flex-shrink: 0;
        }

        .strip-template-frame {
            width: 150px;
            height: 450px;
            background: #4a90e2;
            border: 3px solid #ffffff;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .strip-template-frame::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #4a90e2, #357abd, #2980b9);
            border-radius: 15px;
            z-index: -1;
        }

        .strip-frame {
            flex: 1;
            background: #f8fafc;
            border: 3px solid #ffffff;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            font-size: 0.8rem;
            color: #6b7280;
            min-height: 85px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .strip-frame:nth-child(1) { background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); }
        .strip-frame:nth-child(2) { background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%); }
        .strip-frame:nth-child(3) { background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%); }
        .strip-frame:nth-child(4) { background: linear-gradient(135deg, #fff3e0 0%, #ffcc02 100%); }
        
        .strip-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .strip-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .placeholder-landscape {
            width: 80%;
            height: 60%;
            background: linear-gradient(135deg, #87ceeb 0%, #98fb98 40%, #87ceeb 100%);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .placeholder-landscape::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 10%;
            width: 30%;
            height: 25%;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .placeholder-landscape::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40%;
            background: linear-gradient(180deg, transparent 0%, #7fb069 100%);
            border-radius: 0 0 4px 4px;
        }
        
        .strip-placeholder .placeholder-text {
            font-size: 0.75rem;
            color: #64748b;
            font-weight: 600;
            text-align: center;
        }
        
        /* Slider Input Styles */
        .slider-input {
            width: 80px;
            margin-right: 8px;
        }
        
        .setting-row {
            display: flex;
            gap: 20px;
            margin-bottom: 12px;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
        }
        
        .setting-item label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-dark);
        }

        .template-config-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .template-specs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .spec-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }

        .spec-label {
            font-weight: 500;
            color: #6b7280;
        }

        .spec-value {
            font-weight: 600;
            color: #1f2937;
        }

        .template-upload-zone {
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fafafa;
        }

        .template-upload-zone:hover {
            border-color: var(--primary-blue);
            background: #f0f8ff;
        }

        .template-upload-zone .upload-icon {
            font-size: 48px;
            color: #9ca3af;
            margin-bottom: 12px;
        }

        .template-upload-zone .upload-text {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .template-upload-zone .upload-subtext {
            font-size: 14px;
            color: #6b7280;
        }

        .template-preview-area {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            background: #e5e7eb;
            padding: 15px;
            border-radius: 8px;
        }
        
        /* Templates Section Styles */
        .templates-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .template-sub-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 32px;
            background: rgba(248, 250, 252, 0.8);
            padding: 8px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .sub-tab-button {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-light);
            font-weight: 500;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .sub-tab-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .sub-tab-button:hover {
            background: #f8fafc !important;
            color: var(--primary-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }
        
        .sub-tab-button:hover::before {
            left: 100%;
        }
        
        .sub-tab-button.active {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%) !important;
            color: white !important;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3);
            transform: translateY(-1px);
        }
        
        .sub-tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 3px;
            background: white;
            border-radius: 2px;
        }
        
        .sub-tab-icon {
            font-size: 1.1rem;
        }
        
        .sub-tab-text {
            font-weight: 600;
        }
        
        .template-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .template-content.active {
            display: block;
        }
        
        .template-content-header {
            text-align: center;
            margin-bottom: 24px;
            padding: 16px 0;
        }
        
        .template-content-header h3 {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .template-content-header p {
            font-size: 1rem;
            color: var(--text-light);
            font-weight: 500;
            opacity: 0.9;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @media (max-width: 768px) {
            .template-preview-area {
                flex-direction: column;
                gap: 20px;
            }
            
            .border-template-frame,
            .strip-template-frame {
                margin: 0 auto;
                transform: scale(0.8);
            }
            
            .strip-template-frame {
                width: 130px;
                height: 380px;
            }
            
            .template-sub-tabs {
                flex-direction: column;
                gap: 4px;
            }
            
            .sub-tab-button {
                justify-content: center;
            }
            
            .templates-container {
                padding: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .template-sub-tabs {
                padding: 6px;
            }
            
            .sub-tab-button {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
            
            .strip-template-frame {
                width: 110px;
                height: 320px;
                padding: 10px;
            }
            
            .strip-frame {
                min-height: 65px;
                border-width: 2px;
            }
            
            .placeholder-landscape {
                height: 50%;
            }
        }

        .polaroid-preview-container {
            flex-shrink: 0;
        }

        .polaroid-frame {
            width: 180px;
            height: 270px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .polaroid-image-area {
            width: calc(100% - 10px);
            height: 220px;
            background: #f3f4f6;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            margin: 5px 5px 0 5px;
        }

        .polaroid-caption-area {
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 12px;
            margin-top: 0px;
        }

        .placeholder-text {
            color: #9ca3af;
            font-size: 14px;
        }

        .crop-controls {
            flex: 1;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .control-btn {
            padding: 8px 16px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            background: #f1f5f9;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            border-color: var(--primary-blue);
            background: #e2e8f0;
            transform: translateY(-1px);
        }

        .crop-info {
            font-size: 14px;
            color: #6b7280;
            padding: 10px;
            background: #fffbeb;
            border-radius: 6px;
            border: 1px solid #fbbf24;
        }

        .template-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .current-specs {
            background: #f8f9ff;
            border: 1px solid #e0e7ff;
            border-radius: 8px;
            padding: 12px;
        }
        
        .spec-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .spec-item:last-of-type {
            margin-bottom: 12px;
        }
        
        .spec-label {
            color: #6b7280;
            font-weight: 500;
        }
        
        .spec-value {
            color: #1f2937;
            font-weight: 600;
            font-family: monospace;
        }
        
        .spec-value.highlight {
            color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .spec-note {
            font-size: 12px;
            color: #059669;
            background: rgba(5, 150, 105, 0.05);
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #10b981;
        }

        .navigation-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            justify-content: center;
        }

        .nav-btn {
            padding: 10px 20px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            background: #f1f5f9;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .nav-btn:hover:not(:disabled) {
            border-color: var(--primary-blue);
            background: #e2e8f0;
            transform: translateY(-1px);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-info {
            font-weight: 600;
            color: #374151;
            min-width: 60px;
            text-align: center;
        }

        .export-controls {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .export-btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .export-btn.primary {
            background: var(--primary-blue);
            color: white;
        }

        .export-btn.primary:hover {
            background: var(--dark-blue);
        }

        .export-btn.secondary {
            background: #f1f5f9;
            color: #374151;
            border: 2px solid #d1d5db;
        }

        .export-btn.secondary:hover {
            background: #e2e8f0;
            transform: translateY(-1px);
            border-color: #9ca3af;
        }

        .export-btn.individual {
            background: #fef3c7;
            color: #92400e;
            border: 2px solid #f59e0b;
        }

        .export-btn.individual:hover {
            background: #fde68a;
            transform: translateY(-1px);
            border-color: #d97706;
        }

        .export-info {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
        }

        .info-label {
            font-weight: 500;
            color: #6b7280;
        }

        .info-value {
            font-weight: 600;
            color: #1f2937;
            font-size: 14px;
        }

        .template-gallery {
            margin-top: 30px;
            padding: 20px;
            background: #fafafa;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
        }

        .gallery-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .gallery-stats {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-value {
            font-weight: 700;
            font-size: 18px;
            color: var(--primary-blue);
        }

        .stat-label {
            color: #6b7280;
            font-size: 14px;
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px;
        }

        .template-item {
            background: white;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .template-item:hover {
            border-color: var(--primary-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .template-item.active {
            border-color: var(--primary-blue);
            background: #f0f8ff;
        }

        .template-item-preview {
            width: 100%;
            aspect-ratio: 2/3;
            background: #d1d5db;
            border-radius: 4px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .template-item-name {
            font-size: 12px;
            text-align: center;
            color: #6b7280;
            font-weight: 500;
        }

        /* Template Configuration Styles */
        .polaroid-basic-settings,
        .border-settings,
        .advanced-settings,
        .caption-settings,
        .current-specs,
        .reset-controls {
            margin-bottom: 20px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .subsection-label {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
            margin-bottom: 12px;
            display: block;
        }

        .setting-row {
            display: flex;
            gap: 16px;
            margin-bottom: 12px;
        }

        .setting-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .setting-item label {
            font-size: 13px;
            font-weight: 500;
            color: #6b7280;
        }

        .template-select,
        .template-input,
        .size-input,
        .caption-text-input {
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            background: #f8fafc;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        .template-select:hover,
        .template-input:hover,
        .size-input:hover {
            border-color: #9ca3af;
            background: #f1f5f9;
        }

        .template-select:focus,
        .template-input:focus,
        .size-input:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .caption-text-input:hover {
            border-color: #9ca3af;
            background: #f1f5f9;
        }

        .caption-text-input:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .size-inputs {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .size-input {
            width: 70px;
        }

        .border-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .border-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .border-input-group label {
            font-size: 13px;
            font-weight: 500;
            color: #6b7280;
        }

        .border-slider {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .border-slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-blue);
            border-radius: 50%;
            cursor: pointer;
        }

        .border-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--primary-blue);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .border-number {
            width: 60px;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }

        .color-input {
            width: 50px;
            height: 40px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            cursor: pointer;
        }

        .checkbox-input {
            width: 18px;
            height: 18px;
            accent-color: var(--primary-blue);
        }

        .advanced-controls,
        .caption-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .specs-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            font-size: 13px;
        }

        .spec-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .spec-key {
            font-weight: 500;
            color: #6b7280;
        }

        .spec-value {
            font-weight: 600;
            color: #1f2937;
        }

        .reset-btn {
            padding: 10px 20px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            background: #f1f5f9;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .reset-btn:hover {
            border-color: var(--primary-blue);
            color: var(--primary-blue);
            background: #e2e8f0;
            transform: translateY(-1px);
        }

        .caption-text-input {
            width: 100%;
        }

        @media (max-width: 768px) {
            .setting-row {
                flex-direction: column;
                gap: 12px;
            }
            
            .border-controls {
                grid-template-columns: 1fr;
                gap: 12px;
            }
        }
            border-radius: 6px;
            border: 1px solid #e0e8f0;
        }
        
        .info-text {
            font-size: 12px;
            color: #5a6c7d;
            margin-bottom: 4px;
        }
        
        .info-text:last-child {
            margin-bottom: 0;
        }
        
        /* Multi-crop resize handles */
        .multi-crop-resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--primary-blue);
            border: 1px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            opacity: 0.8;
            transition: all 0.2s ease;
            z-index: 1002;
        }
        
        .multi-crop-resize-handle:hover {
            background: var(--dark-blue);
            transform: scale(1.3);
            opacity: 1;
        }
        
        .multi-crop-resize-handle.nw {
            top: -5px;
            left: -5px;
            cursor: nw-resize;
        }
        
        .multi-crop-resize-handle.ne {
            top: -5px;
            right: -5px;
            cursor: ne-resize;
        }
        
        .multi-crop-resize-handle.sw {
            bottom: -5px;
            left: -5px;
            cursor: sw-resize;
        }
        
        .multi-crop-resize-handle.se {
            bottom: -5px;
            right: -5px;
            cursor: se-resize;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }
        
        .info-row:last-child {
            margin-bottom: 0;
        }
        
        .info-label {
            color: var(--text-light);
            font-weight: 500;
        }
        
        .template-nav-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .nav-btn {
            padding: 8px 16px;
            background: var(--light-gray);
            border: 1px solid #ccc;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .nav-btn:hover:not(:disabled) {
            background: var(--primary-blue);
            color: white;
        }
        
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #templateImageName {
            font-weight: 600;
            color: var(--text-dark);
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .template-action-controls {
            display: flex;
            gap: 10px;
        }

        /* Old fixed-column media queries removed - using new responsive system above */

        @media (max-width: 480px) {
            .controls-row {
                text-align: center;
            }

            .control-group {
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }

            .control-group label {
                min-width: auto;
            }

            .actions-group {
                flex-direction: column;
                align-items: center;
            }

            .action-btn {
                width: 100%;
                max-width: 200px;
            }

            .stats {
                grid-template-columns: 1fr;
            }

            .file-list {
                grid-template-columns: repeat(auto-fit, minmax(min(6rem, 45%), 1fr));
                gap: clamp(0.5rem, 1.5vw, 0.75rem);
            }

            .file-preview {
                min-height: 100px;
            }
        }
        /* Print Section Styles */
        .print-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
        }

        .print-config-panel {
            background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 32px;
            margin-bottom: 24px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
        }
        
        .print-config-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #3b82f6, #06b6d4, #10b981);
            border-radius: 16px 16px 0 0;
        }

        .config-column {
            display: flex;
            flex-direction: column;
            gap: 28px;
        }

        .config-column-left {
            /* Core settings: Paper, Photo Size, Print Mode */
        }

        .config-column-right {
            /* Advanced settings: Margins, Cutting Guides, Fit Mode */
        }

        .config-group {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            padding: 24px;
            border: 1px solid rgba(226, 232, 240, 0.5);
            transition: all 0.3s ease;
            margin-bottom: 0;
        }
        
        .config-group:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: #cbd5e1;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .config-label {
            display: flex;
            align-items: center;
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--text-dark);
            margin-bottom: 18px;
            gap: 10px;
        }

        /* Download Settings */
        .download-settings {
            margin-top: var(--spacing-sm);
        }

        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
        }

        .config-row label {
            font-weight: 500;
            color: var(--text-dark);
            min-width: 100px;
        }

        .config-row input[type="text"] {
            flex: 1;
            margin-left: var(--spacing-sm);
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid #ddd;
            border-radius: var(--radius-sm);
            font-family: inherit;
        }

        .config-row input[type="checkbox"] {
            margin-right: var(--spacing-xs);
        }

        .subfolder-settings {
            margin-left: var(--spacing-md);
            margin-top: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            border-left: 3px solid var(--primary-blue);
        }

        .config-btn {
            width: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            margin-top: var(--spacing-sm);
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .config-btn:hover {
            background: var(--dark-blue);
        }

        /* Paper Size Styles */
        .paper-size-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .preset-sizes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 16px;
        }

        .size-preset {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .size-preset::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .size-preset:hover {
            border-color: var(--primary-blue);
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            transform: translateY(-4px);
            box-shadow: 0 12px 30px rgba(59, 130, 246, 0.2);
        }
        
        .size-preset:hover::before {
            left: 100%;
        }

        .size-preset.active {
            border-color: var(--primary-blue);
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            color: var(--primary-blue);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.25);
            transform: translateY(-2px);
        }
        
        .size-preset.active::after {
            content: '✓';
            position: absolute;
            top: 8px;
            right: 8px;
            color: var(--primary-blue);
            font-weight: bold;
            font-size: 1rem;
        }

        .size-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-dark);
            margin-bottom: 4px;
        }

        .size-dim {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .custom-paper-input, .custom-photo-input {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            padding: 16px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-md);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .input-group label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-dark);
        }

        .input-group input {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            transition: border-color 0.2s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .orientation-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .orientation-options {
            display: flex;
            gap: 8px;
        }

        .orientation-btn {
            flex: 1;
            padding: 10px 16px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .orientation-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .orientation-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        /* Photo Size Styles */
        .photo-size-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .preset-photo-sizes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .photo-preset {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px 12px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .photo-preset:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .photo-preset.active {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }

        .photo-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-dark);
            margin-bottom: 4px;
        }

        .photo-desc {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        /* Margin Configuration */
        .margin-config {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .margin-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
        }

        .gutter-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        /* Quality Configuration */
        .quality-config {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .dpi-selection {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .dpi-options {
            display: flex;
            gap: 8px;
        }

        .dpi-btn {
            flex: 1;
            padding: 10px 16px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .dpi-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .dpi-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        .fit-mode-selection {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .fit-options {
            display: flex;
            gap: 12px;
        }

        .fit-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 14px 12px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .fit-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .fit-btn.active {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }

        .fit-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-dark);
            margin-bottom: 4px;
        }

        .fit-desc {
            font-size: 0.8rem;
            color: var(--text-light);
            text-align: center;
        }

        /* Layout Information */
        .layout-info {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
            border-radius: var(--radius-lg);
            padding: 20px;
            margin-bottom: 24px;
        }

        .layout-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary-blue);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-light);
            font-weight: 500;
        }

        /* Upload Section */
        .print-upload-section {
            margin-bottom: 32px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 16px;
            padding: 28px;
            border: 2px dashed #e2e8f0;
            transition: all 0.3s ease;
        }
        
        .print-upload-section:hover {
            border-color: var(--primary-blue);
            background: rgba(248, 250, 252, 0.8);
        }

        .upload-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .btn-secondary {
            padding: 14px 28px;
            border: 2px solid var(--primary-blue);
            border-radius: 12px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            color: var(--primary-blue);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            align-self: flex-start;
            position: relative;
            overflow: hidden;
        }
        
        .btn-secondary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }
        
        .btn-secondary:hover::before {
            left: 100%;
        }

        /* Selected Images */
        .selected-images {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-lg);
            padding: 20px;
            margin-bottom: 24px;
        }

        .images-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .images-header h3 {
            margin: 0;
            color: var(--text-dark);
        }

        .btn-clear {
            padding: 8px 16px;
            border: 1px solid #ef4444;
            border-radius: var(--radius-sm);
            background: white;
            color: #ef4444;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-clear:hover {
            background: #ef4444;
            color: white;
        }

        .images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
        }
        
        /* Override for compact version - use smaller thumbnails */
        .selected-images-compact .images-grid {
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Preview Canvas */
        .print-preview {
            background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 28px;
            margin-bottom: 32px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            position: relative;
            overflow: hidden;
        }
        
        .print-preview::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #06b6d4, #3b82f6, #8b5cf6);
            border-radius: 16px 16px 0 0;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .preview-header h3 {
            margin: 0;
            color: var(--text-dark);
        }

        .preview-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .btn-preview {
            padding: 8px 16px;
            border: 1px solid var(--primary-blue);
            border-radius: var(--radius-sm);
            background: white;
            color: var(--primary-blue);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-preview:hover:not(:disabled) {
            background: var(--primary-blue);
            color: white;
        }

        .btn-preview:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .page-indicator {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-dark);
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-md);
            padding: 20px;
            min-height: 400px;
        }

        .print-canvas {
            max-width: 100%;
            max-height: 600px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Export Section */
        .export-section {
            background: linear-gradient(135deg, #f0fdf4 0%, #f8fafc 100%);
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 28px;
            box-shadow: 0 4px 20px rgba(16, 185, 129, 0.1);
            position: relative;
        }
        
        .export-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #10b981, #059669);
            border-radius: 16px 16px 0 0;
        }

        .export-header h3 {
            margin: 0 0 16px 0;
            color: var(--text-dark);
        }

        .export-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .export-format {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .format-option {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 16px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .format-option:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .format-option input[type="radio"] {
            margin-top: 2px;
        }

        .format-option label {
            flex: 1;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .format-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-dark);
        }

        .format-desc {
            font-size: 0.85rem;
            color: var(--text-light);
        }

        .export-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn-primary {
            padding: 16px 32px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .btn-primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-4px);
            box-shadow: 0 12px 35px rgba(59, 130, 246, 0.4);
        }
        
        .btn-primary:hover:not(:disabled)::before {
            left: 100%;
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Cutting Guides Styles */
        .cutting-guides-config {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .cutting-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .cutting-option {
            display: flex;
            align-items: center;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-dark);
        }

        .checkbox-label input[type="checkbox"] {
            display: none;
        }

        .checkbox-custom {
            width: 18px;
            height: 18px;
            border: 2px solid #e2e8f0;
            border-radius: 3px;
            background: white;
            position: relative;
            transition: all 0.2s ease;
        }

        .checkbox-label input[type="checkbox"]:checked + .checkbox-custom {
            background: var(--primary-blue);
            border-color: var(--primary-blue);
        }

        .checkbox-label input[type="checkbox"]:checked + .checkbox-custom::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .option-text {
            flex: 1;
        }

        .cutting-style-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .style-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .style-group label {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-dark);
        }

        .color-options {
            display: flex;
            gap: 6px;
        }

        .color-btn {
            width: 28px;
            height: 28px;
            border: 2px solid #e2e8f0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .thickness-options, .line-style-options {
            display: flex;
            gap: 4px;
        }

        .thickness-btn, .line-style-btn {
            padding: 6px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .thickness-btn:hover, .line-style-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .thickness-btn.active, .line-style-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        /* Enhanced Preview Styles */
        .preview-header {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 16px;
        }

        .preview-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .preview-stat {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-dark);
        }

        .stat-icon {
            font-size: 0.9rem;
        }

        .preview-tools {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .view-controls, .guide-toggles {
            display: flex;
            gap: 8px;
        }

        .view-btn, .toggle-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .view-btn:hover, .toggle-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .view-btn.active, .toggle-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        .btn-icon {
            font-size: 0.9rem;
        }

        .btn-text {
            font-weight: 500;
        }

        .canvas-viewport {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
            overflow: auto;
            max-height: 80vh;
        }

        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: white;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin: 0 auto;
            width: fit-content;
        }

        .canvas-ruler-h, .canvas-ruler-v {
            position: absolute;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            font-size: 10px;
            color: #6b7280;
            z-index: 10;
        }

        .canvas-ruler-h {
            top: -25px;
            left: 0;
            right: 0;
            height: 24px;
        }

        .canvas-ruler-v {
            left: -25px;
            top: 0;
            bottom: 0;
            width: 24px;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 5;
        }

        .print-canvas {
            display: block;
            border: 1px solid #e2e8f0;
            background: white;
        }

        /* Dual Canvas Layout for Duplex Mode */
        .dual-canvas-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
            padding: 20px 0;
        }

        .canvas-side {
            flex: 1;
            max-width: 45%;
            text-align: center;
        }

        .side-header {
            margin-bottom: 10px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .front-side .side-header {
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            border-color: #86efac;
            color: #166534;
        }

        .back-side .side-header {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-color: #facc15;
            color: #92400e;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        .duplex-canvas {
            display: block;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 4px;
            max-width: 100%;
            max-height: 500px;
        }

        .front-side .duplex-canvas {
            border-color: #86efac;
        }

        .back-side .duplex-canvas {
            border-color: #facc15;
        }

        /* Responsive behavior for dual canvas */
        @media (max-width: 1200px) {
            .dual-canvas-container {
                flex-direction: column;
                align-items: center;
                gap: 30px;
            }
            
            .canvas-side {
                max-width: 80%;
            }
        }

        /* Gallery Grid for Duplex Mode */
        .gallery-section-duplex {
            margin: 20px 0;
            padding: 15px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }

        .gallery-grid-duplex {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 10px;
        }

        .gallery-item-duplex {
            position: relative;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            overflow: hidden;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .gallery-item-duplex:hover {
            border-color: #3b82f6;
            transform: scale(1.02);
        }

        .gallery-item-duplex.selection-mode {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .gallery-item-duplex img {
            width: 100%;
            height: 80px;
            object-fit: cover;
        }

        .gallery-item-duplex .image-name {
            padding: 4px 6px;
            font-size: 0.7rem;
            background: rgba(0,0,0,0.7);
            color: white;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .preview-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .wysiwyg-indicator, .quality-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .wysiwyg-icon {
            font-size: 1rem;
        }

        .wysiwyg-text {
            font-weight: 600;
            color: #059669;
        }

        .quality-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
        }

        .quality-text {
            color: var(--text-dark);
            font-weight: 500;
        }

        /* Print Mode Styles */
        .print-mode-selection {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .print-mode-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .mode-option {
            position: relative;
        }

        .mode-option input[type="radio"] {
            display: none;
        }

        .mode-label {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mode-label:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .mode-option input[type="radio"]:checked + .mode-label {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }

        .mode-icon {
            font-size: 1.5rem;
            width: 32px;
            text-align: center;
        }

        .mode-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .mode-name {
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-dark);
        }

        .mode-desc {
            font-size: 0.85rem;
            color: var(--text-light);
        }

        .duplex-options {
            padding: 16px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin-top: 8px;
        }

        .duplex-config {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .config-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-item label {
            font-weight: 500;
            font-size: 0.9rem;
            color: var(--text-dark);
        }

        .flip-direction {
            display: flex;
            gap: 8px;
        }

        .flip-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 12px 8px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .flip-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .flip-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        .flip-icon {
            font-size: 1.2rem;
        }

        .flip-text {
            font-size: 0.8rem;
            font-weight: 500;
        }

        .duplex-preview-mini {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
        }

        .offset-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .offset-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
        }

        .offset-input-group label {
            font-size: 0.8rem;
            font-weight: 500;
            color: #374151;
            min-width: 80px;
        }

        .offset-input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: center;
        }

        .offset-input:focus {
            border-color: var(--primary-blue);
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .offset-unit {
            font-size: 0.8rem;
            color: #6b7280;
            font-weight: 500;
        }

        .offset-help {
            margin-top: 8px;
            padding: 8px 12px;
            background: #fef3cd;
            border: 1px solid #fde047;
            border-radius: 6px;
        }

        .offset-help small {
            color: #92400e;
            font-size: 0.75rem;
        }

        .preview-instruction {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        .instruction-icon {
            font-size: 1.1rem;
            margin-top: 2px;
        }

        .instruction-text {
            flex: 1;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .instruction-text strong {
            color: var(--text-dark);
        }

        /* Responsive Design for Print Section */
        @media (max-width: 768px) {
            .preset-sizes {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            }

            .preset-photo-sizes {
                grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            }

            .margin-inputs {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }

            .gutter-inputs {
                grid-template-columns: 1fr;
            }

            .print-config-panel {
                grid-template-columns: 1fr;
                gap: 24px;
                padding: 24px 20px;
            }

            .config-column {
                gap: 24px;
            }
            
            .config-group {
                padding: 20px 16px;
            }
            
            .section-header h2 {
                font-size: 1.8rem;
            }
            
            .upload-zone {
                padding: 36px 20px;
            }

            .custom-paper-input, .custom-photo-input {
                grid-template-columns: 1fr;
            }

            .fit-options {
                flex-direction: column;
            }

            .layout-stats {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }

            .export-actions {
                flex-direction: column;
            }

            .btn-primary, .btn-secondary {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .print-config-panel {
                padding: 20px 16px;
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .config-column {
                gap: 20px;
            }
            
            .config-group {
                padding: 18px 14px;
            }
            
            .section-header h2 {
                font-size: 1.6rem;
            }
            
            .section-header h2::before {
                font-size: 1.4rem;
            }
            
            .upload-zone {
                padding: 32px 16px;
            }
            
            .print-preview {
                padding: 20px 16px;
            }
            
            .export-section {
                padding: 20px 16px;
            }
            
            .btn-primary, .btn-secondary {
                padding: 14px 24px;
                font-size: 0.9rem;
            }

            .dpi-options {
                flex-direction: column;
            }

            .orientation-options {
                flex-direction: column;
            }

            .preset-sizes {
                grid-template-columns: 1fr;
            }

            .preset-photo-sizes {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1>MEU Layout</h1>
                <p class="header-subtitle">Đơn giản • Nhanh chóng • Chất lượng cao</p>
            </div>
        </div>

        <div class="main-content">
            <!-- Function Tabs -->
            <div class="function-tabs">
                <button class="tab-button active animate-slideUp" id="convertTab">
                    <span class="tab-icon">🔄</span>
                    <span class="tab-text">Convert Files</span>
                </button>
                <button class="tab-button animate-slideUp animate-delay-75" id="cropTab">
                    <span class="tab-icon">✂️</span>
                    <span class="tab-text">Template Crop</span>
                </button>
                <button class="tab-button animate-slideUp animate-delay-150" id="templatesTab">
                    <span class="tab-icon">◈</span>
                    <span class="tab-text">Templates</span>
                </button>
                <button class="tab-button animate-slideUp animate-delay-200" id="galleryTab">
                    <span class="tab-icon">🖼️</span>
                    <span class="tab-text">Kho Ảnh</span>
                </button>
                <button class="tab-button animate-slideUp animate-delay-300" id="printTab">
                    <span class="tab-icon">🖨️</span>
                    <span class="tab-text">File in</span>
                </button>
            </div>

            <!-- Convert Section -->
            <div class="function-section active" id="convertSection">
                <!-- Header -->
                <div class="section-header">
                    <h2>Chuyển đổi định dạng ảnh</h2>
                    <p>Chuyển đổi ảnh giữa các định dạng khác nhau một cách nhanh chóng và chất lượng cao</p>
                </div>

                <!-- Convert Content -->
                <div class="convert-content">
                    <!-- Upload Zone for Convert -->
                    <div class="upload-zone convert-upload" onclick="document.getElementById('convertFileInput').click()">
                        <div class="upload-icon">🔄</div>
                        <div class="upload-text">Chọn ảnh để chuyển đổi format</div>
                        <div class="upload-subtext">Hỗ trợ: PNG, JPG, WEBP, BMP, HEIC → JPG/PNG/WEBP</div>
                        <div class="upload-hint">Kéo thả hoặc nhấn để chọn file</div>
                    </div>
                    <input type="file" id="convertFileInput" class="file-input" multiple>

                    <!-- Legacy file input for backward compatibility -->
                    <input type="file" id="fileInput" class="file-input" multiple style="display: none;">

                    <!-- Stats -->
                    <div class="stats">
                        <div class="stat-card">
                            <div class="stat-number" id="totalFiles">0</div>
                            <div class="stat-label">Tổng file</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="convertedFiles">0</div>
                            <div class="stat-label">Đã chuyển đổi</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="totalSize">0 MB</div>
                            <div class="stat-label">Tổng dung lượng</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="successRate">0%</div>
                            <div class="stat-label">Tỷ lệ thành công</div>
                        </div>
                    </div>

                    <!-- Controls -->
                    <div class="controls">
                        <div class="controls-row">
                            <div class="control-group">
                                <label for="outputFormat">Định dạng:</label>
                                <select id="outputFormat">
                                    <option value="auto">Tự động (Khuyến nghị)</option>
                                    <option value="jpeg" selected>JPG</option>
                                    <option value="png">PNG</option>
                                    <option value="webp">WebP</option>
                                    <option value="bmp">BMP</option>
                                </select>
                            </div>

                            <div class="control-group">
                                <label for="quality">Chất lượng:</label>
                                <div class="quality-container">
                                    <input type="range" id="quality" class="quality-slider" min="10" max="100" value="100">
                                    <span class="quality-value" id="qualityValue">100% (Tuyệt đối file gốc)</span>
                                    <button class="quick-btn" id="maxQualityBtn">Max</button>
                                </div>
                            </div>
                        </div>

                        <div class="controls-row">
                            <div class="control-group">
                                <label for="namingOption">Đặt tên:</label>
                                <select id="namingOption">
                                    <option value="keep" selected>Giữ nguyên</option>
                                    <option value="add_converted">Thêm "_converted"</option>
                                    <option value="add_timestamp">Thêm thời gian</option>
                                    <option value="custom">Tùy chỉnh</option>
                                </select>
                                <input type="text" id="customPrefix" placeholder="Nhập tiền tố..." style="display: none;">
                            </div>

                            <button class="convert-btn" id="convertAllBtn" disabled>Bắt đầu chuyển đổi</button>
                        </div>
                    </div>

                    <!-- Actions -->
                    <div class="actions" id="bulkActions" style="display: none;">
                        <div class="actions-container">
                            <div class="actions-group primary-actions">
                                <button class="action-btn download" id="downloadAllBtn">📥 Tải từng file gốc</button>
                                <button class="action-btn download" id="downloadZipBtn">📦 Tải ZIP file gốc</button>
                            </div>
                            
                            <div class="actions-group tools-actions">
                                <button class="action-btn tool" id="createPdfBtn">Tạo PDF</button>
                                <button class="action-btn tool" id="cropImagesBtn">Cắt ảnh</button>
                            </div>
                            
                            <div class="actions-group utility-actions">
                                <button class="action-btn utility" id="retryFailedBtn">Thử lại lỗi</button>
                                <button class="action-btn utility" id="showCropResultsBtn">📊 Xem kết quả cắt ảnh</button>
                                <button class="action-btn utility clear" id="clearAllBtn">Xóa tất cả</button>
                            </div>
                        </div>
                    </div>

                    <!-- File List -->
                    <div class="file-list" id="fileList"></div>

                    <!-- Progress -->
                    <div class="progress-bar" id="progressContainer" style="display: none;">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
            </div>

            <!-- Template Crop Section - Enhanced UI -->
            <div class="function-section" id="cropSection">
                <div class="crop-container-enhanced">
                    <!-- Modern Header with Progress -->
                    <div class="section-header-modern">
                        <div class="header-content">
                            <div class="header-icon">✂️</div>
                            <div class="header-text">
                                <h2>Cắt Ảnh Chuyên Nghiệp</h2>
                                <p>Tạo ảnh chuẩn với kích thước hoàn hảo cho mọi nhu cầu</p>
                            </div>
                        </div>
                        <div class="progress-steps" id="cropProgressSteps">
                            <div class="step active">
                                <div class="step-number">1</div>
                                <span>Chọn kích thước</span>
                            </div>
                            <div class="step">
                                <div class="step-number">2</div>
                                <span>Tải ảnh</span>
                            </div>
                            <div class="step">
                                <div class="step-number">3</div>
                                <span>Hoàn thành</span>
                            </div>
                        </div>
                    </div>

                    <!-- Modern Size Selection with Preview -->
                    <div class="size-selection-modern">
                        <div class="selection-header">
                            <h3>🎯 Chọn kích thước mong muốn</h3>
                            <div class="selection-hint">Chọn một trong các kích thước phổ biến hoặc tùy chỉnh</div>
                        </div>
                        
                        <div class="size-grid">
                            <div class="size-card active" data-size="5.5x8.5">
                                <div class="size-preview">
                                    <div class="ratio-box" style="aspect-ratio: 5.5/8.5;"></div>
                                </div>
                                <div class="size-info">
                                    <div class="size-title">Căn cước công dân</div>
                                    <div class="size-dimensions">5.5 × 8.5 cm</div>
                                    <div class="size-pixels">650 × 1000px @ 300 DPI</div>
                                    <div class="size-usage">CCCD, Thẻ căn cước</div>
                                </div>
                                <div class="size-badge">Phổ biến nhất</div>
                            </div>
                            
                            <div class="size-card" data-size="3x4">
                                <div class="size-preview">
                                    <div class="ratio-box" style="aspect-ratio: 3/4;"></div>
                                </div>
                                <div class="size-info">
                                    <div class="size-title">Ảnh thẻ chuẩn</div>
                                    <div class="size-dimensions">3 × 4 cm</div>
                                    <div class="size-pixels">354 × 472px @ 300 DPI</div>
                                    <div class="size-usage">Thẻ sinh viên, hồ sơ</div>
                                </div>
                            </div>
                            
                            <div class="size-card" data-size="4x6">
                                <div class="size-preview">
                                    <div class="ratio-box" style="aspect-ratio: 4/6;"></div>
                                </div>
                                <div class="size-info">
                                    <div class="size-title">Ảnh hộ chiếu</div>
                                    <div class="size-dimensions">4 × 6 cm</div>
                                    <div class="size-pixels">472 × 708px @ 300 DPI</div>
                                    <div class="size-usage">Hộ chiếu, visa</div>
                                </div>
                            </div>
                            
                            <div class="size-card custom-card" data-size="custom">
                                <div class="size-preview">
                                    <div class="ratio-box custom-ratio">
                                        <div class="custom-icon">⚙️</div>
                                    </div>
                                </div>
                                <div class="size-info">
                                    <div class="size-title">Tùy chỉnh</div>
                                    <div class="size-dimensions">Kích thước riêng</div>
                                    <div class="size-pixels">Tự định nghĩa</div>
                                    <div class="size-usage">Mọi nhu cầu khác</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced Custom Size Input -->
                        <div class="custom-dimensions-modern" id="customSizeInput" style="display: none;">
                            <div class="custom-header">
                                <h4>🎨 Kích thước tùy chỉnh</h4>
                                <p>Nhập kích thước chính xác theo nhu cầu của bạn</p>
                            </div>
                            <div class="dimension-inputs-grid">
                                <div class="input-group">
                                    <label for="customWidth">
                                        <span class="label-icon">📏</span>
                                        Chiều rộng
                                    </label>
                                    <div class="input-with-unit">
                                        <input type="number" id="customWidth" value="5.5" min="1" max="50" step="0.1" placeholder="5.5">
                                        <span class="unit">cm</span>
                                    </div>
                                </div>
                                <div class="input-group">
                                    <label for="customHeight">
                                        <span class="label-icon">📐</span>
                                        Chiều cao
                                    </label>
                                    <div class="input-with-unit">
                                        <input type="number" id="customHeight" value="8.5" min="1" max="50" step="0.1" placeholder="8.5">
                                        <span class="unit">cm</span>
                                    </div>
                                </div>
                                <div class="input-group">
                                    <label>
                                        <span class="label-icon">🎯</span>
                                        Độ phân giải
                                    </label>
                                    <select class="dpi-select" id="customDPI">
                                        <option value="300" selected>300 DPI (In ấn)</option>
                                        <option value="150">150 DPI (Web)</option>
                                        <option value="72">72 DPI (Màn hình)</option>
                                    </select>
                                </div>
                            </div>
                            <div class="dimension-preview" id="dimensionPreview">
                                <div class="preview-info">
                                    <span class="preview-size">Kích thước: <strong id="previewDimensions">5.5 × 8.5 cm</strong></span>
                                    <span class="preview-pixels">Pixels: <strong id="previewPixels">650 × 1000px</strong></span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Enhanced Upload Area with Better Visual Feedback -->
                    <div class="upload-area-modern" id="cropUploadArea">
                        <div class="upload-zone" onclick="document.getElementById('cropFileInput').click()">
                            <div class="upload-visual">
                                <div class="upload-icon">📤</div>
                                <div class="upload-animation"></div>
                            </div>
                            <div class="upload-content">
                                <h3 class="upload-title">Tải lên ảnh của bạn</h3>
                                <p class="upload-subtitle">Kéo thả file vào đây hoặc nhấp để chọn</p>
                                <div class="upload-formats">
                                    <span class="format-badge">JPG</span>
                                    <span class="format-badge">PNG</span>
                                    <span class="format-badge">WEBP</span>
                                    <span class="format-badge">BMP</span>
                                </div>
                                <div class="upload-limit">Tối đa 20MB mỗi file</div>
                            </div>
                        </div>
                        <input type="file" id="cropFileInput" class="file-input" multiple accept="image/*">
                    </div>

                    <!-- Modern Progress & Processing -->
                    <div class="processing-area" id="cropProcessingArea" style="display: none;">
                        <div class="processing-header">
                            <h3>🔄 Đang xử lý ảnh...</h3>
                            <div class="processing-count">
                                <span id="processedCount">0</span> / <span id="totalCount">0</span> ảnh
                            </div>
                        </div>
                        <div class="processing-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" id="cropProgressFill"></div>
                            </div>
                            <div class="progress-text" id="cropProgressText">Khởi tạo...</div>
                        </div>
                        <div class="processing-preview" id="cropProcessingPreview">
                            <!-- Dynamic preview thumbnails will be inserted here -->
                        </div>
                    </div>

                    <!-- Enhanced Results & Actions -->
                    <div class="crop-results" id="cropResults" style="display: none;">
                        <div class="results-header">
                            <div class="results-summary">
                                <h3>✅ Hoàn thành cắt ảnh!</h3>
                                <p>Đã xử lý <span id="successCount">0</span> ảnh thành công</p>
                            </div>
                            <div class="results-stats">
                                <div class="stat-item">
                                    <div class="stat-number" id="totalSize">0 MB</div>
                                    <div class="stat-label">Tổng dung lượng</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-number" id="avgTime">0s</div>
                                    <div class="stat-label">Thời gian trung bình</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="action-grid">
                            <button class="action-card primary" id="downloadCroppedAllBtn">
                                <div class="action-icon">📁</div>
                                <div class="action-content">
                                    <div class="action-title">Tải từng file</div>
                                    <div class="action-subtitle">Tải xuống riêng lẻ</div>
                                </div>
                            </button>
                            
                            <button class="action-card secondary" id="downloadCroppedZipBtn">
                                <div class="action-icon">📦</div>
                                <div class="action-content">
                                    <div class="action-title">Tải file ZIP</div>
                                    <div class="action-subtitle">Nén tất cả thành 1 file</div>
                                </div>
                            </button>
                            
                            <button class="action-card tertiary" id="cropResultsBtn">
                                <div class="action-icon">👁️</div>
                                <div class="action-content">
                                    <div class="action-title">Xem chi tiết</div>
                                    <div class="action-subtitle">Preview kết quả</div>
                                </div>
                            </button>
                            
                            <button class="action-card quaternary" id="cropNewBatchBtn">
                                <div class="action-icon">🔄</div>
                                <div class="action-content">
                                    <div class="action-title">Cắt batch mới</div>
                                    <div class="action-subtitle">Bắt đầu lại</div>
                                </div>
                            </button>
                        </div>
                        
                        <div class="results-gallery" id="cropResultsGallery">
                            <!-- Cropped images preview will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Gallery Section -->
            <div class="function-section" id="gallerySection">
                <div class="gallery-container">
                    <!-- Header -->
                    <div class="section-header">
                        <h2>Kho Ảnh</h2>
                        <p>Upload, quản lý và phân loại ảnh</p>
                    </div>

                    <!-- Gallery Controls -->
                    <div class="gallery-controls">
                        <div class="control-group">
                            <div class="gallery-status">
                                <span class="gallery-count" id="galleryCount">0 ảnh</span>
                                <span class="gallery-info">JPG, PNG, GIF, WebP</span>
                            </div>
                        </div>
                        
                        <div class="control-group search-section">
                            <div class="search-box">
                                <input type="text" id="gallerySearchInput" placeholder="Tìm kiếm ảnh..." class="search-input">
                                <span class="search-icon">🔍</span>
                            </div>
                            <select id="galleryFilterSelect" class="filter-select">
                                <option value="all">Tất cả</option>
                                <option value="uploaded">Ảnh tải lên</option>
                                <option value="cropped">Ảnh đã cắt</option>
                            </select>
                        </div>
                        
                        <div class="control-group upload-section">
                            <button class="control-btn upload-btn" id="uploadBtn">
                                <span class="btn-icon">📤</span>
                                <span class="btn-text">Tải ảnh lên</span>
                                <span class="btn-desc">Chọn nhiều file</span>
                            </button>
                            <input type="file" id="galleryFileInput" class="file-input" multiple accept="image/*,image/jpeg,image/jpg,image/png,image/gif,image/webp">
                        </div>
                        
                        <div class="control-group management">
                            <button class="control-btn classify" id="classifyBtn" disabled>
                                <span class="btn-icon">🔄</span>
                                <span class="btn-text">Phân loại</span>
                            </button>
                            <button class="control-btn auto-classify" id="autoClassifyBtn" disabled>
                                <span class="btn-icon">🤖</span>
                                <span class="btn-text">Tự động phân loại</span>
                                <span class="btn-desc">Theo tên file</span>
                            </button>
                            <button class="control-btn clear" id="clearGalleryBtn" disabled>
                                <span class="btn-icon">🗑️</span>
                                <span class="btn-text">Xóa tất cả</span>
                            </button>
                        </div>

                    </div>

                    <!-- Upload Progress -->
                    <div class="upload-progress" id="uploadProgress" style="display: none;">
                        <div class="progress-header">
                            <span class="progress-text">Đang tải lên...</span>
                            <span class="progress-count" id="progressCount">0/0</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="progress-details" id="progressDetails">Chuẩn bị...</div>
                    </div>

                    <!-- Main Gallery Grid -->
                    <div class="gallery-grid" id="galleryGrid">
                        <div class="empty-gallery">
                            <div class="empty-icon">Không có ảnh</div>
                            <div class="empty-text">Các ảnh đã crop sẽ xuất hiện ở đây</div>
                            <div class="empty-hint">Sử dụng chức năng Template Crop để bắt đầu</div>
                        </div>
                    </div>

                    <!-- Classification Mode -->
                    <div class="classification-mode" id="classificationMode" style="display: none;">
                        <!-- Source Grid -->
                        <div class="section-title">🎯 Tất cả ảnh đã crop 
                            <span class="instruction-hint" id="sourceGridHint">Click ảnh để chọn cho duplex</span>
                        </div>
                        <div class="source-grid" id="sourceGrid" style="border: 2px dashed #3b82f6; padding: 10px; border-radius: 8px;"></div>
                        
                        <!-- Quick Selection Controls -->
                        <div class="quick-selection-section">
                            <div class="section-title">
                                <span>⚡ Chọn nhanh</span>
                                <div class="selection-status" id="selectionStatus" style="display: none;">
                                    <span class="selection-text">Chế độ chọn: </span>
                                    <span class="selection-type" id="selectionType">Không hoạt động</span>
                                    <span class="selection-counter" id="selectionCounter">(0 ảnh đã chọn)</span>
                                </div>
                            </div>
                            
                            <div class="quick-select-controls">
                                <button class="quick-select-btn front-type" id="quickSelectFrontBtn">
                                    <span class="btn-icon">🆔</span>
                                    <span class="btn-text">📂 Kho: Chọn Trước</span>
                                </button>
                                <button class="quick-select-btn back-type" id="quickSelectBackBtn">
                                    <span class="btn-icon">📃</span>
                                    <span class="btn-text">📂 Kho: Chọn Sau</span>
                                </button>
                                <button class="quick-select-btn" id="selectAllFrontBtn">
                                    <span class="btn-icon">✅</span>
                                    <span class="btn-text">📂 Kho: Tất Cả → Trước</span>
                                </button>
                                <button class="quick-select-btn" id="selectAllBackBtn">
                                    <span class="btn-icon">❌</span>
                                    <span class="btn-text">📂 Kho: Tất Cả → Sau</span>
                                </button>
                                <button class="quick-select-btn apply-btn" id="applySelectionBtn" style="display: none;">
                                    <span class="btn-icon">✅</span>
                                    <span class="btn-text">📂 Kho: Áp dụng</span>
                                </button>
                                <button class="quick-select-btn cancel-btn" id="cancelSelectionBtn" style="display: none;">
                                    <span class="btn-icon">🚫</span>
                                    <span class="btn-text">📂 Kho: Hủy</span>
                                </button>
                            </div>
                        </div>

                        <!-- Classification Areas -->
                        <div class="classification-areas">
                            <div class="classification-panel">
                                <div class="panel-header">
                                    <h3>Mặt trước</h3>
                                    <div class="panel-controls">
                                        <input type="text" id="frontPrefix" placeholder="Tiền tố..." value="">
                                        <span class="rename-pattern">1a, 2a, 3a...</span>
                                    </div>
                                </div>
                                <div class="drop-zone" id="frontDropZone" data-type="front">
                                    <div class="drop-hint">Kéo ảnh vào đây</div>
                                </div>
                            </div>

                            <div class="classification-panel">
                                <div class="panel-header">
                                    <h3>Mặt sau</h3>
                                    <div class="panel-controls">
                                        <input type="text" id="backPrefix" placeholder="Tiền tố..." value="">
                                        <span class="rename-pattern">1b, 2b, 3b...</span>
                                    </div>
                                </div>
                                <div class="drop-zone" id="backDropZone" data-type="back">
                                    <div class="drop-hint">Kéo ảnh vào đây</div>
                                </div>
                            </div>
                        </div>

                        <!-- Classification Controls -->
                        <div class="classification-controls">
                            <button class="control-btn" id="previewDownloadBtn" disabled>Xem trước</button>
                            <button class="control-btn secondary" id="exitClassifyBtn">Thoát phân loại</button>
                        </div>
                    </div>

                    <!-- Download Options -->
                    <div class="download-options" id="downloadOptions" style="display: none;">
                        <div class="section-header download-header">
                            <h3>Tải xuống ảnh đã phân loại</h3>
                            <p>Chọn phương thức tải xuống cho ảnh mặt trước/sau</p>
                        </div>
                        
                        <div class="download-methods-grid">
                            <!-- Individual Download Method -->
                            <div class="download-method-card">
                                <div class="method-header">
                                    <span class="method-icon">📄</span>
                                    <div class="method-info">
                                        <h4>Từng file</h4>
                                        <p>300 DPI, JPG, Chất lượng max</p>
                                    </div>
                                </div>
                                <div class="method-buttons">
                                    <button class="method-btn individual-btn" id="downloadFrontIndividualBtn" disabled>
                                        <span class="btn-label">Mặt trước</span>
                                        <span class="btn-count" id="frontCount">0 file</span>
                                    </button>
                                    <button class="method-btn individual-btn" id="downloadBackIndividualBtn" disabled>
                                        <span class="btn-label">Mặt sau</span>
                                        <span class="btn-count" id="backCount">0 file</span>
                                    </button>
                                    <button class="method-btn individual-btn all" id="downloadAllIndividualBtn" disabled>
                                        <span class="btn-label">Tất cả</span>
                                        <span class="btn-count" id="allCount">0 file</span>
                                    </button>
                                </div>
                            </div>
                            
                            <!-- ZIP Download Method -->
                            <div class="download-method-card">
                                <div class="method-header">
                                    <span class="method-icon">📦</span>
                                    <div class="method-info">
                                        <h4>ZIP File</h4>
                                        <p>Nén tất cả</p>
                                    </div>
                                </div>
                                <div class="method-buttons">
                                    <button class="method-btn zip-btn" id="downloadZipFrontBtn" disabled>
                                        <span class="btn-label">ZIP mặt trước</span>
                                        <span class="btn-count" id="frontZipCount">0 file</span>
                                    </button>
                                    <button class="method-btn zip-btn" id="downloadZipBackBtn" disabled>
                                        <span class="btn-label">ZIP mặt sau</span>
                                        <span class="btn-count" id="backZipCount">0 file</span>
                                    </button>
                                    <button class="method-btn zip-btn all" id="downloadZipAllBtn" disabled>
                                        <span class="btn-label">ZIP tất cả</span>
                                        <span class="btn-count" id="allZipCount">0 file</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Templates Section -->
            <div class="function-section" id="templatesSection">
                <div class="templates-container">
                    <!-- Header -->
                    <div class="section-header">
                        <h2>◈ Templates</h2>
                        <p>Các mẫu thiết kế cho ảnh</p>
                    </div>
                    
                    <!-- Sub-tabs for Templates -->
                    <div class="template-sub-tabs">
                        <button class="sub-tab-button active" id="polaroidSubTab">
                            <span class="sub-tab-icon">◈</span>
                            <span class="sub-tab-text">Polaroid</span>
                        </button>
                        <button class="sub-tab-button" id="borderSubTab">
                            <span class="sub-tab-icon">🖼️</span>
                            <span class="sub-tab-text">Viền Thường</span>
                        </button>
                        <button class="sub-tab-button" id="stripSubTab">
                            <span class="sub-tab-icon">📸</span>
                            <span class="sub-tab-text">Strip Layout</span>
                        </button>
                    </div>
                    
                    <!-- Polaroid Template Content - Optimized Compact Design -->
                    <div class="template-content active" id="polaroidTemplateContent">
                        <div class="polaroid-compact-container">
                            <!-- Top Section: Header + Quick Actions -->
                            <div class="polaroid-top-section">
                                <div class="polaroid-header">
                                    <div class="header-info">
                                        <h3>◈ Polaroid Template</h3>
                                        <div class="template-quick-specs" id="quickSpecs">5.5×8.5cm • 300 DPI • 1:1.55</div>
                                    </div>
                                    <div class="header-actions">
                                        <button class="compact-btn secondary" id="resetTemplateDefaults">↺ Reset</button>
                                        <button class="compact-btn primary" id="templateCropEdit">✂️ Crop ảnh</button>
                                    </div>
                                </div>
                            </div>

                            <!-- Main Section: Preview + Controls Side by Side -->
                            <div class="polaroid-main-section">
                                <!-- Left: Preview -->
                                <div class="polaroid-preview-section">
                                    <div class="preview-header">
                                        <span class="preview-title">👁️ Preview</span>
                                        <div class="preview-controls">
                                            <button class="mini-btn" id="templateCropReset" title="Reset crop">⟲</button>
                                            <button class="mini-btn" id="templateCropCenter" title="Center crop">⊚</button>
                                            <button class="mini-btn" id="templateCropFit" title="Fit crop">◈</button>
                                        </div>
                                    </div>
                                    <div class="polaroid-preview-container">
                                        <div class="polaroid-frame">
                                            <div class="polaroid-image-area" id="polaroidImageArea">
                                                <div class="placeholder-text">Chờ ảnh...</div>
                                            </div>
                                            <div class="polaroid-caption-area">
                                                <div class="caption-placeholder">Viền Polaroid</div>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- Upload Zone under preview -->
                                    <div class="compact-upload-zone" onclick="document.getElementById('templateFileInput').click()">
                                        <div class="upload-content">
                                            <span class="upload-icon">⬆️</span>
                                            <span class="upload-text">Chọn ảnh</span>
                                        </div>
                                        <input type="file" id="templateFileInput" accept="image/*" multiple style="display: none;">
                                    </div>
                                </div>

                                <!-- Right: Controls -->
                                <div class="polaroid-controls-section">
                                    <!-- Compact Settings Tabs -->
                                    <div class="settings-tabs">
                                        <div class="tab-header">
                                            <button class="tab-btn active" data-tab="basic">📐 Cơ bản</button>
                                            <button class="tab-btn" data-tab="borders">🖼️ Viền</button>
                                            <button class="tab-btn" data-tab="caption">✏️ Caption</button>
                                            <button class="tab-btn" data-tab="advanced">⚙️ Nâng cao</button>
                                        </div>
                                        
                                        <!-- Basic Settings Tab -->
                                        <div class="tab-content active" data-tab="basic">
                                            <div class="compact-settings">
                                                <div class="setting-row">
                                                    <label>Kích thước (cm)</label>
                                                    <div class="size-inputs">
                                                        <input type="number" id="templateWidth" min="3" max="20" step="0.1" value="5.5" class="compact-input">
                                                        <span>×</span>
                                                        <input type="number" id="templateHeight" min="3" max="30" step="0.1" value="8.5" class="compact-input">
                                                    </div>
                                                </div>
                                                <div class="setting-row">
                                                    <label>DPI</label>
                                                    <select id="templateDPI" class="compact-select">
                                                        <option value="150">150 DPI</option>
                                                        <option value="200">200 DPI</option>
                                                        <option value="300" selected>300 DPI</option>
                                                    </select>
                                                </div>
                                                <div class="setting-row">
                                                    <label>Fit Mode</label>
                                                    <select id="templateFitMode" class="compact-select">
                                                        <option value="contain">Contain (giữ viền)</option>
                                                        <option value="cover" selected>Cover (đổ kín)</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Borders Tab -->
                                        <div class="tab-content" data-tab="borders">
                                            <div class="compact-border-controls">
                                                <div class="border-grid">
                                                    <div class="border-item">
                                                        <label>Trên</label>
                                                        <div class="border-control">
                                                            <input type="range" id="borderTop" min="0" max="100" value="50" class="compact-slider">
                                                            <input type="number" id="borderTopValue" min="0" max="100" value="50" class="compact-number">
                                                        </div>
                                                    </div>
                                                    <div class="border-item">
                                                        <label>Trái</label>
                                                        <div class="border-control">
                                                            <input type="range" id="borderLeft" min="0" max="100" value="45" class="compact-slider">
                                                            <input type="number" id="borderLeftValue" min="0" max="100" value="45" class="compact-number">
                                                        </div>
                                                    </div>
                                                    <div class="border-item">
                                                        <label>Phải</label>
                                                        <div class="border-control">
                                                            <input type="range" id="borderRight" min="0" max="100" value="45" class="compact-slider">
                                                            <input type="number" id="borderRightValue" min="0" max="100" value="45" class="compact-number">
                                                        </div>
                                                    </div>
                                                    <div class="border-item">
                                                        <label>Caption</label>
                                                        <div class="border-control">
                                                            <input type="range" id="borderBottom" min="50" max="300" value="175" class="compact-slider">
                                                            <input type="number" id="borderBottomValue" min="50" max="300" value="175" class="compact-number">
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Caption Tab -->
                                        <div class="tab-content" data-tab="caption">
                                            <div class="compact-settings">
                                                <div class="setting-row">
                                                    <label>Văn bản</label>
                                                    <input type="text" id="captionText" placeholder="Tùy chọn..." class="compact-input">
                                                </div>
                                                <div class="setting-row">
                                                    <label>Font</label>
                                                    <select id="captionFont" class="compact-select">
                                                        <option value="Arial">Arial</option>
                                                        <option value="Georgia">Georgia</option>
                                                        <option value="Times">Times</option>
                                                        <option value="Courier">Courier</option>
                                                    </select>
                                                </div>
                                                <div class="setting-row">
                                                    <label>Size</label>
                                                    <input type="number" id="captionFontSize" min="8" max="48" value="16" class="compact-input">
                                                </div>
                                                <div class="setting-row">
                                                    <label>Màu</label>
                                                    <input type="color" id="captionColor" value="#000000" class="compact-color">
                                                </div>
                                                <div class="setting-row">
                                                    <label>Căn chỉnh</label>
                                                    <select id="captionAlign" class="compact-select">
                                                        <option value="center" selected>Center</option>
                                                        <option value="left">Left</option>
                                                        <option value="right">Right</option>
                                                    </select>
                                                </div>
                                                <div class="setting-row">
                                                    <label>Margin</label>
                                                    <input type="number" id="captionMarginTop" min="0" max="50" value="10" class="compact-input">
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Advanced Tab -->
                                        <div class="tab-content" data-tab="advanced">
                                            <div class="compact-settings">
                                                <div class="setting-row">
                                                    <label>Safe Area (px)</label>
                                                    <input type="number" id="templateSafeArea" min="0" max="50" value="0" class="compact-input">
                                                </div>
                                                <div class="setting-row">
                                                    <label>Màu nền</label>
                                                    <input type="color" id="templateBgColor" value="#FFFFFF" class="compact-color">
                                                </div>
                                                <div class="setting-row">
                                                    <label>Overlay Frame</label>
                                                    <input type="checkbox" id="templateOverlay" class="compact-checkbox">
                                                </div>
                                                <!-- Current Specs Display -->
                                                <div class="current-specs-compact">
                                                    <div class="specs-title">📊 Thông số:</div>
                                                    <div class="specs-display" id="currentSpecsDisplay">
                                                        <!-- Will be populated by JavaScript -->
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Compact Bottom Section: Download Settings -->
                        <div class="polaroid-bottom-section">
                            <div class="download-settings-compact">
                                <h4>📁 Tải về</h4>
                                <div class="compact-download-options">
                                    <div class="download-row">
                                        <label>
                                            <input type="checkbox" id="useSubfolders" class="compact-checkbox"> 
                                            Tạo thư mục con
                                        </label>
                                        <input type="text" id="folderPrefix" placeholder="Tiền tố..." maxlength="20" class="compact-input">
                                    </div>
                                </div>
                                
                                <!-- Navigation & Export Controls -->
                                <div class="compact-actions">
                                    <div class="nav-section">
                                        <button class="nav-btn-compact" id="templatePrevBtn" disabled>◀</button>
                                        <span class="nav-info-compact" id="templateNavInfo">0/0</span>
                                        <button class="nav-btn-compact" id="templateNextBtn" disabled">▶</button>
                                    </div>
                                    
                                    <div class="export-section">
                                        <button class="export-btn-compact primary" id="exportCurrentPolaroid">💾 Tải về trang hiện tại</button>
                                        <button class="export-btn-compact secondary" id="exportAllIndividual">📄 Tải về hàng loạt</button>
                                        <button class="export-btn-compact tertiary" id="exportAllPolaroids">📦 Tải về ZIP</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Template Gallery -->
                    <div class="template-gallery" id="templateGallery">
                        <div class="gallery-header">
                            <h3>◈ Danh sách Polaroid</h3>
                            <div class="gallery-stats">
                                <span class="stat-value" id="templateImageCount">0</span>
                                <span class="stat-label">ảnh đã tải</span>
                            </div>
                        </div>
                        <div class="template-grid" id="templateGrid">
                            <!-- Polaroid previews will be generated here -->
                        </div>
                    </div>
                </div>
            </div>

                    </div>
                    
                    <!-- Border Template Content -->
                    <div class="template-content" id="borderTemplateContent">
                <div class="template-container">
                    <!-- Header -->
                    <div class="template-content-header">
                        <h3>🖼️ Viền Thường</h3>
                        <p>Ảnh với viền mỏng đơn giản hoặc tràn viền hoàn toàn</p>
                    </div>

                    <!-- Template Configuration -->
                    <div class="template-config-panel">
                        <!-- Border Template Configuration -->
                        <div class="config-group">
                            <label class="config-label" data-icon="🖼️">Cấu hình Viền Thường</label>
                            
                            <!-- Size & DPI Settings -->
                            <div class="polaroid-basic-settings">
                                <div class="setting-row">
                                    <div class="setting-item">
                                        <label>DPI</label>
                                        <select id="borderTemplateDPI" class="template-select">
                                            <option value="150">150 DPI</option>
                                            <option value="200">200 DPI</option>
                                            <option value="300" selected>300 DPI</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <label>Kích thước (cm)</label>
                                        <div class="size-inputs">
                                            <input type="number" id="borderTemplateWidth" min="3" max="20" step="0.1" value="10" class="size-input">
                                            <span>×</span>
                                            <input type="number" id="borderTemplateHeight" min="3" max="30" step="0.1" value="15" class="size-input">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Border Settings -->
                            <div class="border-settings">
                                <label class="subsection-label">▦ Viền (mm)</label>
                                <div class="border-controls">
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Kích hoạt viền</label>
                                            <input type="checkbox" id="borderTemplateEnabled" checked class="checkbox-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>Độ dày viền</label>
                                            <input type="range" id="borderThickness" min="0" max="20" value="5" class="slider-input">
                                            <input type="number" id="borderThicknessValue" min="0" max="20" value="5" class="template-input">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Màu viền</label>
                                            <input type="color" id="borderTemplateColor" value="#FFFFFF" class="color-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>Góc bo tròn (px)</label>
                                            <input type="range" id="borderCornerRadius" min="0" max="50" value="0" class="slider-input">
                                            <input type="number" id="borderCornerRadiusValue" min="0" max="50" value="0" class="template-input">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Advanced Settings -->
                            <div class="advanced-settings">
                                <label class="subsection-label">⚙ Tùy chọn nâng cao</label>
                                <div class="advanced-controls">
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Fit Mode</label>
                                            <select id="borderTemplateFitMode" class="template-select">
                                                <option value="contain">Contain (giữ viền)</option>
                                                <option value="cover" selected>Cover (đổ kín, crop)</option>
                                            </select>
                                        </div>
                                        <div class="setting-item">
                                            <label>Safe Area (px)</label>
                                            <input type="number" id="borderTemplateSafeArea" min="0" max="50" value="0" class="template-input">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Màu nền</label>
                                            <input type="color" id="borderTemplateBgColor" value="#FFFFFF" class="color-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>Drop Shadow</label>
                                            <input type="checkbox" id="borderTemplateDropShadow" class="checkbox-input">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Real-time Specs Display -->
                            <div class="current-specs">
                                <label class="subsection-label">◯ Thông số hiện tại</label>
                                <div class="specs-display" id="borderTemplateSpecsDisplay">
                                    <!-- Will be populated by JavaScript -->
                                </div>
                            </div>

                            <!-- Reset Controls -->
                            <div class="reset-controls">
                                <button class="reset-btn" id="resetBorderTemplateDefaults">↺ Khôi phục mặc định</button>
                            </div>
                        </div>

                        <!-- Upload Area -->
                        <div class="config-group">
                            <label class="config-label" data-icon="⬆">Ảnh upload</label>
                            <div class="template-upload-zone" onclick="document.getElementById('borderTemplateFileInput').click()">
                                <div class="upload-icon">🖼️</div>
                                <div class="upload-text">Chọn ảnh để tạo viền thường</div>
                                <div class="upload-subtext">Hỗ trợ nhiều ảnh cùng lúc - Auto crop center</div>
                                <input type="file" id="borderTemplateFileInput" accept="image/*" multiple style="display: none;">
                            </div>
                        </div>

                        <!-- Template Preview & Controls -->
                        <div class="config-group">
                            <label class="config-label" data-icon="◇">Preview & Điều chỉnh</label>
                            <div class="template-preview-area">
                                <div class="border-template-preview-container">
                                    <div class="border-template-frame">
                                        <div class="border-template-image-area" id="borderTemplateImageArea">
                                            <div class="placeholder-text">Chờ ảnh...</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Crop Controls -->
                                <div class="crop-controls" id="borderTemplateCropControls" style="display: none;">
                                    <div class="control-group">
                                        <button class="control-btn" id="borderTemplateCropReset">⟲ Reset</button>
                                        <button class="control-btn" id="borderTemplateCropCenter">⊚ Center</button>
                                        <button class="control-btn" id="borderTemplateCropFit">◈ Fit</button>
                                        <button class="control-btn primary" id="borderTemplateCropEdit">✂️ Chỉnh crop</button>
                                    </div>
                                    <div class="crop-info" id="borderTemplateCropInfo">
                                        <span>Kéo để điều chỉnh vùng crop</span>
                                    </div>
                                </div>
                                
                                <!-- Navigation Controls -->
                                <div class="navigation-controls" id="borderTemplateNavControls" style="display: none;">
                                    <button class="nav-btn" id="borderTemplatePrevBtn" disabled>◀ Trước</button>
                                    <span class="nav-info" id="borderTemplateNavInfo">0 / 0</span>
                                    <button class="nav-btn" id="borderTemplateNextBtn" disabled>Sau ▶</button>
                                </div>
                                
                                <div class="export-controls">
                                    <button class="export-btn primary" id="exportCurrentBorderTemplate">🖼️ Xuất ảnh hiện tại</button>
                                    <button class="export-btn secondary" id="exportAllBorderTemplates">◇ Xuất tất cả ZIP</button>
                                    <button class="export-btn individual" id="exportAllBorderIndividual">📁 Xuất từng file riêng</button>
                                </div>
                                
                                <div class="export-info">
                                    <div class="info-item">
                                        <span class="info-label">Tên file:</span>
                                        <span class="info-value">Border_001.jpg, Border_002.jpg...</span>
                                    </div>
                                    <div class="info-item">
                                        <span class="info-label">Định dạng:</span>
                                        <span class="info-value">JPG - 300 DPI</span>
                                    </div>
                                    <div class="info-item">
                                        <span class="info-label">Xuất riêng:</span>
                                        <span class="info-value">Mỗi ảnh thành 1 file riêng biệt</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Template Gallery -->
                    <div class="template-gallery" id="borderTemplateGallery">
                        <div class="gallery-header">
                            <h3>🖼️ Danh sách ảnh viền thường</h3>
                            <div class="gallery-stats">
                                <span class="stat-value" id="borderTemplateImageCount">0</span>
                                <span class="stat-label">ảnh đã tải</span>
                            </div>
                        </div>
                        <div class="template-grid" id="borderTemplateGrid">
                            <!-- Border template previews will be generated here -->
                        </div>
                    </div>
                </div>
            </div>

                    </div>
                    
                    <!-- Strip Template Content -->
                    <div class="template-content" id="stripTemplateContent">
                <div class="template-container">
                    <!-- Header -->
                    <div class="template-content-header">
                        <h3>📸 Strip Layout</h3>
                        <p>Dải ảnh dọc 4 khung phong cách retro cổ điển</p>
                    </div>

                    <!-- Template Configuration -->
                    <div class="template-config-panel">
                        <!-- Strip Configuration -->
                        <div class="config-group">
                            <label class="config-label" data-icon="📸">Cấu hình Strip Layout</label>
                            
                            <!-- Size & DPI Settings -->
                            <div class="polaroid-basic-settings">
                                <div class="setting-row">
                                    <div class="setting-item">
                                        <label>DPI</label>
                                        <select id="stripTemplateDPI" class="template-select">
                                            <option value="150">150 DPI</option>
                                            <option value="200">200 DPI</option>
                                            <option value="300" selected>300 DPI</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <label>Kích thước Strip (cm)</label>
                                        <div class="size-inputs">
                                            <input type="number" id="stripTemplateWidth" min="3" max="10" step="0.1" value="5" class="size-input">
                                            <span>×</span>
                                            <input type="number" id="stripTemplateHeight" min="10" max="25" step="0.1" value="15" class="size-input">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Frame Layout Settings -->
                            <div class="border-settings">
                                <label class="subsection-label">🖼️ Cấu hình khung ảnh</label>
                                <div class="border-controls">
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Số khung ảnh</label>
                                            <select id="stripFrameCount" class="template-select">
                                                <option value="3">3 khung</option>
                                                <option value="4" selected>4 khung</option>
                                                <option value="5">5 khung</option>
                                            </select>
                                        </div>
                                        <div class="setting-item">
                                            <label>Tỷ lệ khung</label>
                                            <select id="stripFrameRatio" class="template-select">
                                                <option value="3:2">3:2 (Landscape)</option>
                                                <option value="4:3" selected>4:3 (Landscape)</option>
                                                <option value="16:9">16:9 (Wide)</option>
                                                <option value="1:1">1:1 (Vuông)</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Border & Spacing Settings -->
                            <div class="advanced-settings">
                                <label class="subsection-label">⚙ Viền & Khoảng cách</label>
                                <div class="advanced-controls">
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Viền ngoài (mm)</label>
                                            <input type="range" id="stripOuterBorder" min="0" max="15" value="5" class="slider-input">
                                            <input type="number" id="stripOuterBorderValue" min="0" max="15" value="5" class="template-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>Khoảng cách giữa khung (mm)</label>
                                            <input type="range" id="stripFrameSpacing" min="0" max="10" value="2" class="slider-input">
                                            <input type="number" id="stripFrameSpacingValue" min="0" max="10" value="2" class="template-input">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Viền từng ảnh (mm)</label>
                                            <input type="range" id="stripFrameBorder" min="0" max="8" value="1" class="slider-input">
                                            <input type="number" id="stripFrameBorderValue" min="0" max="8" value="1" class="template-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>Màu viền Strip</label>
                                            <input type="color" id="stripBorderColor" value="#FFFFFF" class="color-input">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Màu viền khung</label>
                                            <input type="color" id="stripFrameColor" value="#FFFFFF" class="color-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>Màu nền</label>
                                            <input type="color" id="stripTemplateBgColor" value="#000000" class="color-input">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Real-time Specs Display -->
                            <div class="current-specs">
                                <label class="subsection-label">◯ Thông số hiện tại</label>
                                <div class="specs-display" id="stripTemplateSpecsDisplay">
                                    <!-- Will be populated by JavaScript -->
                                </div>
                            </div>

                            <!-- Reset Controls -->
                            <div class="reset-controls">
                                <button class="reset-btn" id="resetStripTemplateDefaults">↺ Khôi phục mặc định</button>
                            </div>
                        </div>

                        <!-- Upload Area -->
                        <div class="config-group">
                            <label class="config-label" data-icon="⬆">Upload ảnh cho Strip</label>
                            <div class="template-upload-zone" onclick="document.getElementById('stripTemplateFileInput').click()">
                                <div class="upload-icon">📸</div>
                                <div class="upload-text">Chọn 4 ảnh để tạo Strip Layout</div>
                                <div class="upload-subtext">Hỗ trợ nhiều ảnh - Tỷ lệ landscape khuyến nghị</div>
                                <input type="file" id="stripTemplateFileInput" accept="image/*" multiple style="display: none;">
                            </div>
                        </div>

                        <!-- Template Preview & Controls -->
                        <div class="config-group">
                            <label class="config-label" data-icon="◇">Preview Strip Layout</label>
                            <div class="template-preview-area">
                                <div class="strip-template-preview-container">
                                    <div class="strip-template-frame" id="stripTemplateFrame">
                                        <!-- 4 frame areas will be generated here -->
                                        <div class="strip-frame" id="stripFrame1">
                                            <div class="strip-placeholder">
                                                <div class="placeholder-landscape"></div>
                                                <div class="placeholder-text">Ảnh 1</div>
                                            </div>
                                        </div>
                                        <div class="strip-frame" id="stripFrame2">
                                            <div class="strip-placeholder">
                                                <div class="placeholder-landscape"></div>
                                                <div class="placeholder-text">Ảnh 2</div>
                                            </div>
                                        </div>
                                        <div class="strip-frame" id="stripFrame3">
                                            <div class="strip-placeholder">
                                                <div class="placeholder-landscape"></div>
                                                <div class="placeholder-text">Ảnh 3</div>
                                            </div>
                                        </div>
                                        <div class="strip-frame" id="stripFrame4">
                                            <div class="strip-placeholder">
                                                <div class="placeholder-landscape"></div>
                                                <div class="placeholder-text">Ảnh 4</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Crop Controls -->
                                <div class="crop-controls" id="stripTemplateCropControls" style="display: none;">
                                    <div class="control-group">
                                        <button class="control-btn" id="stripTemplateCropReset">⟲ Reset Tất cả</button>
                                        <button class="control-btn" id="stripTemplateCropCenter">⊚ Center Tất cả</button>
                                        <button class="control-btn primary" id="stripTemplateCropEdit">✂️ Chỉnh từng ảnh</button>
                                    </div>
                                    <div class="crop-info" id="stripTemplateCropInfo">
                                        <span>Sử dụng navigation để xem từng ảnh trong strip</span>
                                    </div>
                                </div>
                                
                                <!-- Navigation Controls -->
                                <div class="navigation-controls" id="stripTemplateNavControls" style="display: none;">
                                    <button class="nav-btn" id="stripTemplatePrevBtn" disabled>◀ Ảnh trước</button>
                                    <span class="nav-info" id="stripTemplateNavInfo">0 / 0</span>
                                    <button class="nav-btn" id="stripTemplateNextBtn" disabled>Ảnh sau ▶</button>
                                </div>
                                
                                <div class="export-controls">
                                    <button class="export-btn primary" id="exportCurrentStripTemplate">📸 Xuất Strip hiện tại</button>
                                    <button class="export-btn secondary" id="exportAllStripTemplates">◇ Xuất tất cả ZIP</button>
                                    <button class="export-btn individual" id="exportAllStripIndividual">📁 Xuất từng strip riêng</button>
                                </div>
                                
                                <div class="export-info">
                                    <div class="info-item">
                                        <span class="info-label">Tên file:</span>
                                        <span class="info-value">PhotoStrip_001.jpg, PhotoStrip_002.jpg...</span>
                                    </div>
                                    <div class="info-item">
                                        <span class="info-label">Định dạng:</span>
                                        <span class="info-value">JPG - 300 DPI - 5×15cm</span>
                                    </div>
                                    <div class="info-item">
                                        <span class="info-label">Xuất:</span>
                                        <span class="info-value">Mỗi strip chứa 4 ảnh thành 1 file</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Template Gallery -->
                    <div class="template-gallery" id="stripTemplateGallery">
                        <div class="gallery-header">
                            <h3>📸 Danh sách Strip Layout</h3>
                            <div class="gallery-stats">
                                <span class="stat-value" id="stripTemplateImageCount">0</span>
                                <span class="stat-label">strip đã tạo</span>
                            </div>
                        </div>
                        <div class="template-grid" id="stripTemplateGrid">
                            <!-- Strip template previews will be generated here -->
                        </div>
                    </div>
                    </div>
                </div>
            </div>

            <!-- Print Section -->
            <div class="function-section" id="printSection">
                <div class="print-container">
                    <!-- Header -->
                    <div class="section-header">
                        <h2>File in</h2>
                        <p>Dàn ảnh tối ưu cho in ấn với độ chính xác cao</p>
                    </div>

                    <!-- Quick Setup Presets -->
                    <div class="quick-presets">
                        <h3>⚡ Cài đặt nhanh</h3>
                        <div class="preset-options">
                            <button class="preset-card active" data-preset="standard-5.5x8.5">
                                <div class="preset-icon">📸</div>
                                <div class="preset-content">
                                    <div class="preset-name">5.5×8.5 cm</div>
                                    <div class="preset-desc">A4 dọc, ảnh 5.5×8.5cm, lề 10mm</div>
                                </div>
                            </button>
                            <button class="preset-card" data-preset="standard-6x9">
                                <div class="preset-icon">🆔</div>
                                <div class="preset-content">
                                    <div class="preset-name">6×9 cm</div>
                                    <div class="preset-desc">A4 dọc, ảnh 6×9cm, lề 15mm</div>
                                </div>
                            </button>
                            <button class="preset-card" data-preset="standard-7x10">
                                <div class="preset-icon">📷</div>
                                <div class="preset-content">
                                    <div class="preset-name">7×10 cm</div>
                                    <div class="preset-desc">A4 dọc, ảnh 7×10cm, lề 10mm</div>
                                </div>
                            </button>
                            <button class="preset-card" data-preset="custom">
                                <div class="preset-icon">⚙️</div>
                                <div class="preset-content">
                                    <div class="preset-name">Tùy chỉnh</div>
                                    <div class="preset-desc">Cài đặt chi tiết</div>
                                </div>
                            </button>
                        </div>
                    </div>

                    <!-- Compact Configuration Panel -->
                    <div class="print-config-compact" id="printConfigCompact">
                        <!-- Essential Settings Card -->
                        <div class="config-card essential-card">
                            <div class="card-header">
                                <h4>🎯 Cài đặt cơ bản</h4>
                                <button class="card-toggle" data-target="essential-settings">▲</button>
                            </div>
                            <div class="card-content" id="essential-settings">
                                <div class="settings-row">
                                    <div class="setting-group">
                                        <label>📄 Khổ giấy</label>
                                        <select id="paperSizeSelect" class="compact-select">
                                            <option value="a4">A4 (210×297mm)</option>
                                            <option value="a3">A3 (297×420mm)</option>
                                            <option value="letter">Letter (216×279mm)</option>
                                            <option value="custom">Tùy chỉnh</option>
                                        </select>
                                    </div>
                                    <div class="setting-group">
                                        <label>↻ Hướng</label>
                                        <div class="orientation-buttons">
                                            <button class="orient-btn active" data-orientation="portrait" title="Dọc">▯</button>
                                            <button class="orient-btn" data-orientation="landscape" title="Ngang">▭</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="settings-row">
                                    <div class="setting-group">
                                        <label>🖼️ Kích thước ảnh</label>
                                        <select id="photoSizeSelect" class="compact-select">
                                            <option value="4x6">4×6 cm</option>
                                            <option value="5x7">5×7 cm</option>
                                            <option value="5.5x8.5">5.5×8.5 cm (Tiêu chuẩn)</option>
                                            <option value="6x9">6×9 cm (Hộ chiếu)</option>
                                            <option value="polaroid">54×67 mm (Mini Polaroid)</option>
                                            <option value="custom">Tùy chỉnh</option>
                                        </select>
                                    </div>
                                    <div class="setting-group">
                                        <label>📑 Chế độ in</label>
                                        <select id="printModeSelect" class="compact-select">
                                            <option value="single">In 1 mặt</option>
                                            <option value="duplex">In 2 mặt thủ công</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <!-- Custom Size Inputs (Hidden by default) -->
                                <div class="custom-inputs" id="customInputsSection" style="display: none;">
                                    <div class="custom-paper" id="customPaperInputs" style="display: none;">
                                        <h5>📄 Kích thước giấy tùy chỉnh</h5>
                                        <div class="input-row">
                                            <input type="number" id="paperWidth" min="50" max="1000" value="210" placeholder="Rộng (mm)">
                                            <input type="number" id="paperHeight" min="50" max="1500" value="297" placeholder="Cao (mm)">
                                        </div>
                                    </div>
                                    <div class="custom-photo" id="customPhotoInputs" style="display: none;">
                                        <h5>🖼️ Kích thước ảnh tùy chỉnh</h5>
                                        <div class="input-row">
                                            <input type="number" id="photoWidth" min="1" max="50" step="0.1" value="5.5" placeholder="Rộng (cm)">
                                            <input type="number" id="photoHeight" min="1" max="50" step="0.1" value="8.5" placeholder="Cao (cm)">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Layout Settings Card -->
                        <div class="config-card layout-card">
                            <div class="card-header">
                                <h4>📐 Layout & Spacing</h4>
                                <button class="card-toggle" data-target="layout-settings">▼</button>
                            </div>
                            <div class="card-content collapsed" id="layout-settings">
                                <div class="settings-row">
                                    <div class="setting-group">
                                        <label>📏 Lề (mm)</label>
                                        <div class="margin-inputs-compact">
                                            <input type="number" id="marginAll" min="0" max="50" value="10" placeholder="Tất cả">
                                            <button class="margin-expand" id="marginExpandBtn" title="Tùy chỉnh từng cạnh">⚙</button>
                                        </div>
                                        <div class="margin-detailed" id="marginDetailed" style="display: none;">
                                            <div class="margin-grid">
                                                <input type="number" id="marginTop" min="0" max="50" value="10" placeholder="Trên">
                                                <input type="number" id="marginRight" min="0" max="50" value="10" placeholder="Phải">
                                                <input type="number" id="marginBottom" min="0" max="50" value="10" placeholder="Dưới">
                                                <input type="number" id="marginLeft" min="0" max="50" value="10" placeholder="Trái">
                                            </div>
                                        </div>
                                    </div>
                                    <div class="setting-group">
                                        <label>📐 Khoảng cách (mm)</label>
                                        <div class="gutter-inputs-compact">
                                            <input type="number" id="gutterX" min="0" max="20" value="5" placeholder="Ngang">
                                            <input type="number" id="gutterY" min="0" max="20" value="5" placeholder="Dọc">
                                        </div>
                                    </div>
                                </div>
                                <div class="settings-row">
                                    <div class="setting-group">
                                        <label>⚡ Fit ảnh</label>
                                        <div class="fit-buttons">
                                            <button class="fit-btn active" data-fit="fill" title="Lấp đầy, crop nếu cần">✂ Fill</button>
                                            <button class="fit-btn" data-fit="contain" title="Không crop, thêm viền">▢ Fit</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Advanced Settings Card -->
                        <div class="config-card advanced-card">
                            <div class="card-header">
                                <h4>✂️ Đường cắt & Nâng cao</h4>
                                <button class="card-toggle" data-target="advanced-settings">▼</button>
                            </div>
                            <div class="card-content collapsed" id="advanced-settings">
                                <div class="settings-row">
                                    <div class="setting-group full-width">
                                        <label>✂️ Đường cắt</label>
                                        <div class="cutting-presets">
                                            <button class="cutting-preset active" data-cutting="standard">
                                                <span class="preset-icon">📏</span>
                                                <div class="preset-info">
                                                    <div class="preset-name">Tiêu chuẩn</div>
                                                    <div class="preset-desc">Đường cắt ngoài + giữa ảnh</div>
                                                </div>
                                            </button>
                                            <button class="cutting-preset" data-cutting="minimal">
                                                <span class="preset-icon">✨</span>
                                                <div class="preset-info">
                                                    <div class="preset-name">Tối giản</div>
                                                    <div class="preset-desc">Chỉ đường cắt cần thiết</div>
                                                </div>
                                            </button>
                                            <button class="cutting-preset" data-cutting="detailed">
                                                <span class="preset-icon">🎯</span>
                                                <div class="preset-info">
                                                    <div class="preset-name">Chi tiết</div>
                                                    <div class="preset-desc">Đầy đủ đánh dấu + lưới</div>
                                                </div>
                                            </button>
                                            <button class="cutting-preset" data-cutting="custom">
                                                <span class="preset-icon">⚙</span>
                                                <div class="preset-info">
                                                    <div class="preset-name">Tùy chỉnh</div>
                                                    <div class="preset-desc">Thiết lập riêng</div>
                                                </div>
                                            </button>
                                        </div>
                                        
                                        <!-- Custom Cutting Options -->
                                        <div class="cutting-custom-options" id="cuttingCustomOptions" style="display: none;">
                                            <div class="cutting-checkboxes">
                                                <label class="cutting-check">
                                                    <input type="checkbox" id="outerCuttingLines" checked>
                                                    <span class="check-icon">■</span>
                                                    <span class="check-text">Đường cắt ngoài</span>
                                                </label>
                                                <label class="cutting-check">
                                                    <input type="checkbox" id="betweenImages" checked>
                                                    <span class="check-icon">┆</span>
                                                    <span class="check-text">Đường cắt giữa ảnh</span>
                                                </label>
                                                <label class="cutting-check">
                                                    <input type="checkbox" id="cornerMarks">
                                                    <span class="check-icon">┼</span>
                                                    <span class="check-text">Đánh dấu góc</span>
                                                </label>
                                                <label class="cutting-check">
                                                    <input type="checkbox" id="gridHelperLines">
                                                    <span class="check-icon">▒</span>
                                                    <span class="check-text">Lưới hỗ trợ</span>
                                                </label>
                                            </div>
                                            <div class="cutting-style-compact">
                                                <div class="style-row">
                                                    <label>Màu:</label>
                                                    <div class="color-dots">
                                                        <button class="color-dot active" data-color="#000000" style="background: #000000;" title="Đen"></button>
                                                        <button class="color-dot" data-color="#3B82F6" style="background: #3B82F6;" title="Xanh"></button>
                                                        <button class="color-dot" data-color="#EF4444" style="background: #EF4444;" title="Đỏ"></button>
                                                    </div>
                                                </div>
                                                <div class="style-row">
                                                    <label>Độ dày:</label>
                                                    <select id="lineThickness" class="mini-select">
                                                        <option value="0.1">0.1px</option>
                                                        <option value="0.25" selected>0.25px</option>
                                                        <option value="0.5">0.5px</option>
                                                        <option value="1.0">1.0px</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Duplex Configuration -->
                                <div class="duplex-config-compact" id="duplexConfigCompact" style="display: none;">
                                    <div class="duplex-flip-options">
                                        <label>📖 Hướng lật giấy:</label>
                                        <div class="flip-buttons">
                                            <button class="flip-btn active" data-flip="long-edge">
                                                <span class="flip-icon">📖</span>
                                                <span class="flip-text">Cạnh dài</span>
                                            </button>
                                            <button class="flip-btn" data-flip="short-edge">
                                                <span class="flip-icon">🗂️</span>
                                                <span class="flip-text">Cạnh ngắn</span>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="duplex-instruction-mini">
                                        <span class="instruction-icon">💡</span>
                                        <span id="duplexInstructions">1. In trang lẻ → 2. Lật theo cạnh dài → 3. In trang chẵn</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Real-time Layout Preview -->
                    <div class="layout-preview-compact">
                        <div class="preview-summary">
                            <div class="summary-stats">
                                <div class="stat-compact">
                                    <span class="stat-icon">🖼️</span>
                                    <span class="stat-value" id="maxPhotosCount">0</span>
                                    <span class="stat-label">ảnh/trang</span>
                                </div>
                                <div class="stat-compact">
                                    <span class="stat-icon">📐</span>
                                    <span class="stat-value" id="gridLayout">0×0</span>
                                    <span class="stat-label">lưới</span>
                                </div>
                                <div class="stat-compact">
                                    <span class="stat-icon">📄</span>
                                    <span class="stat-value" id="totalPages">0</span>
                                    <span class="stat-label">trang</span>
                                </div>
                                <div class="stat-compact">
                                    <span class="stat-icon">📈</span>
                                    <span class="stat-value" id="efficiencyRate">0%</span>
                                    <span class="stat-label">hiệu suất</span>
                                </div>
                            </div>
                            <div class="layout-suggestion" id="layoutSuggestion">
                                <span class="suggestion-icon">💡</span>
                                <span class="suggestion-text">Chờ cấu hình...</span>
                            </div>
                        </div>
                    </div>

                    <!-- Streamlined Image Upload/Selection -->
                    <div class="print-upload-compact">
                        <div class="upload-actions">
                            <button class="upload-btn primary" onclick="document.getElementById('printFileInput').click()">
                                <span class="btn-icon">📷</span>
                                <span class="btn-text">Chọn ảnh để in</span>
                                <span class="btn-hint">JPG, PNG - Chất lượng cao</span>
                            </button>
                            <button class="upload-btn secondary" id="useGalleryImagesBtn">
                                <span class="btn-icon">🖼️</span>
                                <span class="btn-text">Dùng ảnh từ kho</span>
                                <span class="btn-hint" id="galleryImageCount">0 ảnh trong kho</span>
                            </button>
                        </div>
                        <input type="file" id="printFileInput" class="file-input" multiple accept="image/*">
                    </div>

                    <!-- Compact Selected Images -->
                    <div class="selected-images-compact" id="selectedImagesContainer" style="display: none;">
                        <div class="images-header-compact">
                            <h4>🖼️ Ảnh đã chọn (<span id="selectedCount">0</span>)</h4>
                            <div class="header-actions">
                                <button class="action-btn" id="clearSelectedBtn" title="Xóa tất cả">🗑️</button>
                                <button class="action-btn" id="toggleImagesView" title="Thu gọn/Mở rộng">▼</button>
                            </div>
                        </div>
                        <div class="images-grid-compact" id="selectedImagesGrid"></div>
                    </div>

                    <!-- Compact Duplex Classification -->
                    <div class="duplex-classification-compact" id="duplexClassificationSection" style="display: none;">
                        <div class="duplex-header-compact">
                            <h4>📑 Phân loại ảnh cho in 2 mặt</h4>
                            <div class="duplex-quick-stats">
                                <span class="quick-stat front">📄 <span id="frontImageCount">0</span> trước</span>
                                <span class="quick-stat back">📃 <span id="backImageCount">0</span> sau</span>
                                <span class="quick-stat pages">📄 <span id="maxDuplexPages">0</span> trang</span>
                            </div>
                        </div>
                        
                        <div class="duplex-actions-compact">
                            <button class="classify-action-btn front" id="classifyFrontBtn">
                                <span class="action-icon">📄</span>
                                <span class="action-text">Chọn làm mặt trước</span>
                            </button>
                            <button class="classify-action-btn back" id="classifyBackBtn">
                                <span class="action-icon">📃</span>
                                <span class="action-text">Chọn làm mặt sau</span>
                            </button>
                            <button class="classify-action-btn exit" id="exitClassifyBtn">
                                <span class="action-icon">❌</span>
                                <span class="action-text">Thoát phân loại</span>
                            </button>
                        </div>
                        
                        <!-- Simplified Classification Grid -->
                        <div class="classification-grid-compact">
                            <div class="classification-side front-side">
                                <div class="side-header">
                                    <span class="side-icon">📄</span>
                                    <span class="side-title">Mặt trước (<span id="frontCount">0</span>)</span>
                                    <button class="clear-side-btn" id="clearFrontBtn">🗑️</button>
                                </div>
                                <div class="classification-thumbnails" id="frontImagesList"></div>
                            </div>
                            
                            <div class="classification-side back-side">
                                <div class="side-header">
                                    <span class="side-icon">📃</span>
                                    <span class="side-title">Mặt sau (<span id="backCount">0</span>)</span>
                                    <button class="clear-side-btn" id="clearBackBtn">🗑️</button>
                                </div>
                                <div class="classification-thumbnails" id="backImagesList"></div>
                            </div>
                        </div>
                        
                        <!-- Gallery for Selection -->
                        <div class="gallery-selection-compact" id="galleryGridDuplex">
                            <!-- Gallery images will be populated here -->
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="print-actions">
                        <button class="action-btn primary" id="generatePreviewBtn" disabled>
                            <span class="btn-icon">🔍</span>
                            <span class="btn-text">Xem trước</span>
                        </button>
                        <button class="action-btn secondary" id="generatePrintBtnNew" disabled>
                            <span class="btn-icon">🖨️</span>
                            <span class="btn-text">Tạo file in</span>
                        </button>
                        <button class="action-btn utility" id="resetConfigBtn">
                            <span class="btn-icon">♾️</span>
                            <span class="btn-text">Reset</span>
                        </button>
                    </div>

                    <!-- Compact Print Preview -->
                    <div class="print-preview-compact" id="printPreviewContainer" style="display: none;">
                        <div class="preview-header-compact">
                            <div class="preview-title">
                                <h4>🖼️ Bản xem trước</h4>
                                <div class="preview-stats-inline">
                                    <span id="previewDimensions">210×297mm</span> • 
                                    <span id="previewDPI">300 DPI</span> • 
                                    <span id="previewImageCount">0 ảnh</span>
                                </div>
                            </div>
                            
                            <div class="preview-controls-compact">
                                <div class="page-nav">
                                    <button class="nav-btn" id="prevPageBtn" disabled>◀</button>
                                    <span class="page-indicator" id="pageIndicator">1/1</span>
                                    <button class="nav-btn" id="nextPageBtn" disabled>▶</button>
                                </div>
                                
                                <div class="duplex-toggle" id="duplexPreviewControls" style="display: none;">
                                    <button class="duplex-btn active" id="frontSideBtn" data-side="front">📄 Trước</button>
                                    <button class="duplex-btn" id="backSideBtn" data-side="back">📃 Sau</button>
                                </div>
                                
                                <div class="view-tools">
                                    <button class="tool-btn active" id="fitToWidthBtn" title="Vừa rộng">↔️</button>
                                    <button class="tool-btn" id="actualSizeBtn" title="Kích thước thực">🔍</button>
                                    <button class="tool-btn active" id="toggleGuides" title="Hiện/Ẩn đường cắt">✂️</button>
                                    <button class="tool-btn" id="toggleRuler" title="Hiện thước">📏</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="canvas-viewport">
                            <!-- Single Canvas for Single Mode -->
                            <div class="canvas-container single-mode" id="canvasContainer">
                                <div class="canvas-ruler-h" id="rulerHorizontal" style="display: none;"></div>
                                <div class="canvas-ruler-v" id="rulerVertical" style="display: none;"></div>
                                <canvas id="printCanvas" class="print-canvas"></canvas>
                                <div class="canvas-overlay" id="canvasOverlay"></div>
                            </div>
                            
                            <!-- Dual Canvas for Duplex Mode -->
                            <div class="dual-canvas-container duplex-mode" id="duplexCanvasContainer" style="display: none;">
                                <div class="canvas-side front-side">
                                    <div class="side-header">
                                        <h4>📄 Mặt trước</h4>
                                    </div>
                                    <div class="canvas-wrapper">
                                        <canvas id="frontCanvas" class="duplex-canvas"></canvas>
                                        <div class="canvas-overlay" id="frontCanvasOverlay"></div>
                                    </div>
                                </div>
                                
                                <div class="canvas-side back-side">
                                    <div class="side-header">
                                        <h4>📃 Mặt sau</h4>
                                    </div>
                                    <div class="canvas-wrapper">
                                        <canvas id="backCanvas" class="duplex-canvas"></canvas>
                                        <div class="canvas-overlay" id="backCanvasOverlay"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="preview-footer-compact">
                            <div class="quality-badge">
                                <span class="badge-icon">✅</span>
                                <span class="badge-text">Chất lượng in chuẩn chuyên nghiệp - 300 DPI</span>
                            </div>
                        </div>
                    </div>

                    <!-- Compact Export Options -->
                    <div class="export-section-compact" id="exportSection" style="display: none;">
                        <div class="export-options-compact">
                            <div class="export-format-tabs">
                                <button class="format-tab active" data-format="jpg-zip">
                                    <span class="tab-icon">📦</span>
                                    <span class="tab-text">JPG (ZIP)</span>
                                </button>
                                <button class="format-tab" data-format="jpg-individual">
                                    <span class="tab-icon">🖼️</span>
                                    <span class="tab-text">JPG riêng</span>
                                </button>
                                <button class="format-tab" data-format="pdf">
                                    <span class="tab-icon">📄</span>
                                    <span class="tab-text">PDF</span>
                                </button>
                            </div>
                            <button class="export-btn primary" id="generatePrintBtn" disabled>
                                <span class="btn-icon">🚀</span>
                                <span class="btn-text">Tạo và tải file in</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Add CSS for new compact interface -->
            <style>
            /* Quick Presets */
            .quick-presets {
                margin: 20px 0;
                padding: 20px;
                background: #f8fafc;
                border-radius: 12px;
                border: 2px dashed #e2e8f0;
            }
            
            .quick-presets h3 {
                margin: 0 0 16px 0;
                font-size: 1.1em;
                color: #1e293b;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .preset-options {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 12px;
            }
            
            .preset-card {
                display: flex;
                align-items: center;
                padding: 12px;
                background: white;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                gap: 12px;
            }
            
            .preset-card:hover {
                border-color: #3b82f6;
                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.1);
            }
            
            .preset-card.active {
                border-color: #3b82f6;
                background: #eff6ff;
            }
            
            .preset-icon {
                font-size: 1.5em;
                width: 32px;
                text-align: center;
            }
            
            .preset-content {
                flex: 1;
            }
            
            .preset-name {
                font-weight: 600;
                color: #1e293b;
                display: block;
            }
            
            .preset-desc {
                font-size: 0.85em;
                color: #64748b;
                margin-top: 2px;
            }
            
            /* Compact Configuration */
            .print-config-compact {
                display: flex;
                flex-direction: column;
                gap: 16px;
                margin: 20px 0;
            }
            
            .config-card {
                background: white;
                border: 1px solid #e2e8f0;
                border-radius: 8px;
                overflow: hidden;
            }
            
            .card-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 16px;
                background: #f8fafc;
                border-bottom: 1px solid #e2e8f0;
                cursor: pointer;
                user-select: none;
            }
            
            .card-header h4 {
                margin: 0;
                font-size: 1em;
                color: #1e293b;
            }
            
            .card-toggle {
                background: none;
                border: none;
                font-size: 1.2em;
                color: #64748b;
                cursor: pointer;
                transition: transform 0.2s ease;
            }
            
            .card-toggle.expanded {
                transform: rotate(180deg);
            }
            
            .card-content {
                padding: 16px;
                transition: all 0.3s ease;
            }
            
            .card-content.collapsed {
                display: none;
            }
            
            .settings-row {
                display: flex;
                gap: 16px;
                margin-bottom: 16px;
                flex-wrap: wrap;
            }
            
            .setting-group {
                flex: 1;
                min-width: 200px;
            }
            
            .setting-group.full-width {
                flex: 1 1 100%;
            }
            
            .setting-group label {
                display: block;
                margin-bottom: 6px;
                font-weight: 500;
                color: #374151;
                font-size: 0.9em;
            }
            
            .compact-select, .mini-select {
                width: 100%;
                padding: 8px 12px;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                background: white;
                font-size: 0.9em;
            }
            
            .mini-select {
                width: auto;
                min-width: 80px;
            }
            
            .orientation-buttons, .fit-buttons {
                display: flex;
                gap: 4px;
            }
            
            .orient-btn, .fit-btn {
                flex: 1;
                padding: 8px 12px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 0.85em;
            }
            
            .orient-btn.active, .fit-btn.active {
                background: #3b82f6;
                color: white;
                border-color: #3b82f6;
            }
            
            /* Layout Preview Compact */
            .layout-preview-compact {
                margin: 16px 0;
                padding: 16px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border-radius: 8px;
                color: white;
            }
            
            .summary-stats {
                display: flex;
                gap: 20px;
                margin-bottom: 12px;
                flex-wrap: wrap;
            }
            
            .stat-compact {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 0.9em;
            }
            
            .stat-compact .stat-icon {
                font-size: 1.1em;
            }
            
            .stat-compact .stat-value {
                font-weight: 600;
            }
            
            .stat-compact .stat-label {
                opacity: 0.8;
            }
            
            .layout-suggestion {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 0.85em;
                opacity: 0.9;
            }
            
            /* Upload Compact */
            .print-upload-compact {
                margin: 20px 0;
            }
            
            .upload-actions {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
            }
            
            .upload-btn {
                flex: 1;
                min-width: 200px;
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 20px;
                border: 2px dashed #d1d5db;
                border-radius: 8px;
                background: white;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .upload-btn:hover {
                border-color: #3b82f6;
                background: #eff6ff;
            }
            
            .upload-btn.primary {
                border-color: #3b82f6;
                background: #eff6ff;
            }
            
            .upload-btn .btn-icon {
                font-size: 2em;
                margin-bottom: 8px;
            }
            
            .upload-btn .btn-text {
                font-weight: 600;
                color: #1e293b;
            }
            
            .upload-btn .btn-hint {
                font-size: 0.8em;
                color: #64748b;
                margin-top: 4px;
            }
            
            /* Print Actions */
            .print-actions {
                display: flex;
                gap: 12px;
                margin: 20px 0;
                flex-wrap: wrap;
            }
            
            .action-btn {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px 20px;
                border: 2px solid #d1d5db;
                border-radius: 6px;
                background: #f8fafc;
                cursor: pointer;
                transition: all 0.2s ease;
                font-weight: 500;
            }
            
            .action-btn.primary {
                background: #3b82f6;
                color: white;
                border-color: #3b82f6;
            }
            
            .action-btn.secondary {
                background: #10b981;
                color: white;
                border-color: #10b981;
            }
            
            .action-btn:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            }
            
            .action-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none;
            }
            
            /* Preview Compact */
            .print-preview-compact {
                margin: 20px 0;
                border: 1px solid #e2e8f0;
                border-radius: 8px;
                overflow: hidden;
            }
            
            .preview-header-compact {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 16px;
                background: #f8fafc;
                border-bottom: 1px solid #e2e8f0;
                flex-wrap: wrap;
                gap: 12px;
            }
            
            .preview-title h4 {
                margin: 0 0 4px 0;
            }
            
            .preview-stats-inline {
                font-size: 0.8em;
                color: #64748b;
            }
            
            .preview-controls-compact {
                display: flex;
                align-items: center;
                gap: 16px;
                flex-wrap: wrap;
            }
            
            .page-nav {
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .nav-btn {
                width: 32px;
                height: 32px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .nav-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }
            
            .duplex-toggle {
                display: flex;
                gap: 4px;
            }
            
            .duplex-btn {
                padding: 6px 12px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.8em;
            }
            
            .duplex-btn.active {
                background: #3b82f6;
                color: white;
                border-color: #3b82f6;
            }
            
            .view-tools {
                display: flex;
                gap: 4px;
            }
            
            .tool-btn {
                width: 32px;
                height: 32px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.9em;
            }
            
            .tool-btn.active {
                background: #3b82f6;
                color: white;
                border-color: #3b82f6;
            }
            
            /* Export Compact */
            .export-section-compact {
                margin: 20px 0;
                padding: 16px;
                background: #f8fafc;
                border-radius: 8px;
                border: 1px solid #e2e8f0;
            }
            
            .export-options-compact {
                display: flex;
                flex-direction: column;
                gap: 16px;
                align-items: center;
            }
            
            .export-format-tabs {
                display: flex;
                gap: 8px;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                overflow: hidden;
            }
            
            .format-tab {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
                padding: 12px 16px;
                background: white;
                border: none;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 0.85em;
            }
            
            .format-tab.active {
                background: #3b82f6;
                color: white;
            }
            
            .export-btn {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 16px 32px;
                background: #10b981;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                font-size: 1.1em;
                transition: all 0.2s ease;
            }
            
            .export-btn:hover {
                background: #059669;
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
            }
            
            .export-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none;
            }
            
            /* Images Compact */
            .selected-images-compact {
                margin: 16px 0;
                border: 1px solid #e2e8f0;
                border-radius: 8px;
                overflow: hidden;
                background: white;
            }
            
            .selected-images-compact .images-header-compact {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                background: #f8fafc;
                border-bottom: 1px solid #e2e8f0;
            }
            
            .selected-images-compact .header-actions {
                display: flex;
                gap: 8px;
            }
            
            .selected-images-compact .action-btn {
                width: 32px;
                height: 32px;
                border: 2px solid #d1d5db;
                background: #f1f5f9;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1em;
                transition: all 0.2s ease;
            }
            
            .selected-images-compact .action-btn:hover {
                background: #e2e8f0;
                border-color: #3b82f6;
                transform: translateY(-1px);
            }
            
            /* Optimized Images Grid */
            .images-grid-compact {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 8px;
                padding: 16px;
                max-height: 300px;
                overflow-y: auto;
            }
            
            .images-grid-compact .image-item {
                position: relative;
                aspect-ratio: 1;
                border-radius: 6px;
                overflow: hidden;
                border: 1px solid #e5e7eb;
                cursor: pointer;
                transition: all 0.2s ease;
                background: #f9fafb;
            }
            
            .images-grid-compact .image-item:hover {
                border-color: #3b82f6;
                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
                transform: translateY(-1px);
            }
            
            .images-grid-compact .image-item img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                display: block;
            }
            
            .images-grid-compact .image-item .remove-btn {
                position: absolute;
                top: 4px;
                right: 4px;
                width: 20px;
                height: 20px;
                background: rgba(239, 68, 68, 0.9);
                color: white;
                border: none;
                border-radius: 50%;
                font-size: 12px;
                line-height: 1;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 0;
                transition: opacity 0.2s ease;
            }
            
            .images-grid-compact .image-item:hover .remove-btn {
                opacity: 1;
            }
            
            .images-grid-compact .image-item .remove-btn:hover {
                background: #dc2626;
            }
            
            .images-grid-compact .image-item .image-info {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
                color: white;
                font-size: 10px;
                padding: 4px;
                opacity: 0;
                transition: opacity 0.2s ease;
            }
            
            .images-grid-compact .image-item:hover .image-info {
                opacity: 1;
            }
            
            /* Duplex Compact */
            .duplex-classification-compact .duplex-header-compact {
                padding: 16px;
                background: #f8fafc;
                border-bottom: 1px solid #e2e8f0;
            }
            
            .duplex-classification-compact .duplex-quick-stats {
                display: flex;
                gap: 16px;
                margin-top: 8px;
                font-size: 0.9em;
            }
            
            .duplex-classification-compact .duplex-actions-compact {
                display: flex;
                gap: 12px;
                padding: 16px;
                flex-wrap: wrap;
            }
            
            .duplex-classification-compact .classify-action-btn {
                flex: 1;
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px 16px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                min-width: 150px;
            }
            
            .duplex-classification-compact .classify-action-btn.front {
                border-color: #3b82f6;
                background: #eff6ff;
            }
            
            .duplex-classification-compact .classify-action-btn.back {
                border-color: #10b981;
                background: #ecfdf5;
            }
            
            .duplex-classification-compact .classification-grid-compact {
                display: flex;
                gap: 16px;
                padding: 16px;
            }
            
            .duplex-classification-compact .classification-side {
                flex: 1;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                overflow: hidden;
            }
            
            .duplex-classification-compact .side-header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px;
                background: #f8fafc;
                border-bottom: 1px solid #e2e8f0;
                font-size: 0.9em;
                font-weight: 600;
            }
            
            /* Responsive */
            @media (max-width: 768px) {
                .preset-options {
                    grid-template-columns: 1fr;
                }
                
                .settings-row {
                    flex-direction: column;
                    gap: 12px;
                }
                
                .upload-actions {
                    flex-direction: column;
                }
                
                .upload-btn {
                    min-width: 100%;
                }
                
                .print-actions {
                    flex-direction: column;
                }
                
                .preview-header-compact {
                    flex-direction: column;
                    align-items: flex-start;
                }
                
                .preview-controls-compact {
                    width: 100%;
                    justify-content: space-between;
                }
                
                .export-format-tabs {
                    flex-direction: column;
                }
                
                .duplex-actions-compact {
                    flex-direction: column;
                }
                
                .classification-grid-compact {
                    flex-direction: column;
                }
                
                /* Responsive Images Grid */
                .images-grid-compact {
                    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                    gap: 6px;
                    padding: 12px;
                    max-height: 250px;
                }
                
                .images-grid-compact .image-item .remove-btn {
                    width: 18px;
                    height: 18px;
                    font-size: 10px;
                }
                
                .selected-images-compact .images-header-compact {
                    padding: 8px 12px;
                    flex-wrap: wrap;
                    gap: 8px;
                }
                
                .selected-images-compact .header-actions {
                    gap: 6px;
                }
                
                .selected-images-compact .action-btn {
                    width: 28px;
                    height: 28px;
                    font-size: 0.9em;
                }
            }
            
        /* ===========================================
           MODERN CROP PAGE REDESIGN - CLEAN & INTUITIVE
           =========================================== */
           
        /* Layout Updates */
        .crop-body {
            display: flex;
            flex-direction: row;
            gap: 30px;
            height: calc(100vh - 80px);
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .crop-main-content {
            flex: 1;
            background: var(--white);
            border-radius: 20px;
            border: 2px solid #e5e7eb;
            padding: 30px;
            overflow-y: auto;
        }
        
        .crop-sidebar-modern {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* Size Selection - Modern Design */
        .size-selection-modern {
            max-width: 100%;
        }
        
        .size-header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .size-header h2 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-dark);
            margin: 0 0 8px 0;
        }
        
        .size-header p {
            font-size: 1.1rem;
            color: var(--text-light);
            margin: 0;
        }
        
        .size-categories {
            display: flex;
            flex-direction: column;
            gap: 35px;
        }
        
        .category-section h3 {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--text-dark);
            margin: 0 0 20px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Large Size Cards - Main Options */
        .size-cards-large {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 10px;
        }
        
        .size-card-large {
            background: var(--white);
            border: 2px solid #e5e7eb;
            border-radius: 16px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            gap: 16px;
            align-items: center;
        }
        
        .size-card-large:hover {
            border-color: var(--primary-blue);
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.15);
            transform: translateY(-2px);
        }
        
        .size-card-large.active {
            border-color: var(--primary-blue);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.05), rgba(59, 130, 246, 0.02));
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.2);
        }
        
        .size-preview-large {
            width: 60px;
            height: 60px;
            background: #f8fafc;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid #e2e8f0;
            flex-shrink: 0;
        }
        
        .ratio-visual {
            background: linear-gradient(135deg, var(--primary-blue), var(--dark-blue));
            border-radius: 4px;
            max-width: 40px;
            max-height: 40px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .size-info-large {
            flex: 1;
        }
        
        .size-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-dark);
            margin: 0 0 4px 0;
        }
        
        .size-dimensions {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--primary-blue);
            margin: 0 0 4px 0;
        }
        
        .size-pixels {
            font-size: 0.85rem;
            color: var(--text-light);
            margin: 0 0 6px 0;
        }
        
        .size-usage {
            font-size: 0.8rem;
            color: var(--text-light);
            line-height: 1.4;
            opacity: 0.8;
        }
        
        /* Compact Size Cards - More Options */
        .more-sizes-toggle {
            border: none;
            margin: 10px 0 0 0;
        }
        
        .more-sizes-toggle summary {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 15px 20px;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            transition: all 0.2s ease;
            list-style: none;
        }
        
        .more-sizes-toggle summary::-webkit-details-marker {
            display: none;
        }
        
        .more-sizes-toggle summary:hover {
            background: #f1f5f9;
            border-color: var(--primary-blue);
        }
        
        .more-sizes-toggle[open] summary {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
        }
        
        .more-sizes-toggle[open] .toggle-icon {
            transform: rotate(180deg);
        }
        
        .toggle-icon {
            transition: transform 0.2s ease;
            font-size: 0.8rem;
        }
        
        .size-cards-compact {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 20px;
            padding: 20px;
            background: #f8fafc;
            border-radius: 12px;
        }
        
        .size-card-compact {
            background: var(--white);
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .size-card-compact:hover {
            border-color: var(--primary-blue);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .size-card-compact.active {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }
        
        .size-preview-compact {
            width: 32px;
            height: 32px;
            background: #f1f5f9;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 8px auto;
            border: 1px solid #e2e8f0;
        }
        
        .size-info-compact .size-name {
            font-size: 0.85rem;
            font-weight: 600;
            margin: 0 0 2px 0;
        }
        
        .size-info-compact .size-dimensions {
            font-size: 0.75rem;
            color: var(--text-light);
            margin: 0;
        }
        
        .custom-visual {
            background: linear-gradient(135deg, #64748b, #475569) !important;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Selection Summary */
        .selection-summary {
            margin-top: 30px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(16, 185, 129, 0.08));
            border: 2px solid rgba(59, 130, 246, 0.2);
            border-radius: 16px;
            padding: 20px;
        }
        
        .summary-content {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .summary-icon {
            font-size: 2rem;
            flex-shrink: 0;
        }
        
        .summary-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-dark);
            margin: 0 0 4px 0;
        }
        
        .summary-details {
            font-size: 0.9rem;
            color: var(--text-light);
            margin: 0;
        }
        
        /* Sidebar Modern Design */
        .quick-actions-modern {
            background: var(--white);
            border: 2px solid var(--primary-yellow);
            border-radius: 16px;
            padding: 20px;
        }
        
        .action-btn-modern {
            width: 100%;
            background: linear-gradient(135deg, var(--primary-blue), var(--dark-blue));
            color: white;
            border: none;
            border-radius: 12px;
            padding: 18px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .action-btn-modern:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }
        
        .btn-icon {
            font-size: 1.4rem;
            flex-shrink: 0;
        }
        
        .btn-content {
            flex: 1;
            text-align: left;
        }
        
        .btn-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin: 0 0 2px 0;
        }
        
        .btn-subtitle {
            font-size: 0.85rem;
            opacity: 0.9;
            margin: 0;
        }
        
        /* Advanced Settings */
        .advanced-settings-modern {
            background: var(--white);
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            overflow: hidden;
        }
        
        .settings-toggle summary {
            padding: 16px 20px;
            background: #f8fafc;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
            color: var(--text-dark);
            transition: all 0.2s ease;
            list-style: none;
        }
        
        .settings-toggle summary::-webkit-details-marker {
            display: none;
        }
        
        .settings-toggle summary:hover {
            background: #f1f5f9;
        }
        
        .settings-toggle[open] summary {
            background: var(--primary-blue);
            color: white;
        }
        
        .settings-toggle[open] .toggle-icon {
            transform: rotate(180deg);
        }
        
        .settings-content {
            padding: 20px;
            background: var(--white);
        }
        
        .setting-section {
            margin-bottom: 20px;
        }
        
        .setting-section:last-child {
            margin-bottom: 0;
        }
        
        .setting-section h4 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-dark);
            margin: 0 0 12px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .custom-inputs-modern .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .input-field label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-dark);
            margin: 0 0 4px 0;
        }
        
        .setting-field {
            margin-bottom: 12px;
        }
        
        .setting-field:last-child {
            margin-bottom: 0;
        }
        
        .setting-field label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-dark);
            margin: 0 0 6px 0;
        }
        
        .modern-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: white;
            font-size: 0.85rem;
            color: var(--text-dark);
            cursor: pointer;
        }
        
        .modern-select:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }
        
        /* Process Mode */
        .process-mode-modern {
            background: var(--white);
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            padding: 20px;
        }
        
        .process-mode-modern h4 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-dark);
            margin: 0 0 16px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .mode-tabs {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .mode-tab {
            display: block;
            cursor: pointer;
        }
        
        .mode-tab input[type="radio"] {
            display: none;
        }
        
        .tab-content {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            transition: all 0.2s ease;
            background: white;
        }
        
        .mode-tab:hover .tab-content {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }
        
        .mode-tab input:checked + .tab-content,
        .mode-tab.active .tab-content {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
            color: var(--primary-blue);
            font-weight: 600;
        }
        
        .tab-icon {
            font-size: 1.1rem;
        }
        
        .tab-text {
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        /* Responsive Design */
        @media (max-width: 1024px) {
            .crop-body {
                flex-direction: column;
                height: auto;
                min-height: calc(100vh - 80px);
            }
            
            .crop-sidebar-modern {
                width: 100%;
                flex-direction: row;
                gap: 15px;
                overflow-x: auto;
                padding-bottom: 10px;
            }
            
            .crop-sidebar-modern > * {
                flex-shrink: 0;
                min-width: 250px;
            }
            
            .size-cards-large {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .crop-main-content {
                padding: 20px;
            }
            
            .size-header h2 {
                font-size: 1.6rem;
            }
            
            .size-card-large {
                flex-direction: column;
                text-align: center;
                gap: 12px;
                padding: 16px;
            }
            
            .size-cards-compact {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
            
            .crop-sidebar-modern {
                flex-direction: column;
            }
        }
            </style>

        </div>
    </div>

    <!-- Crop Page -->
    <div class="crop-page" id="cropPage" style="display: none;">
        <div class="crop-header">
            <div class="crop-nav">
                <button class="nav-btn back" id="backToMain">
                    <span class="nav-icon">←</span>
                    <span class="nav-text">Quay lại</span>
                </button>
                <h1>Cắt ảnh theo kích thước</h1>
                <div class="crop-progress">
                    <span id="cropProgressText">Bước 1/3: Chọn kích thước</span>
                </div>
            </div>
        </div>

        <div class="crop-body">
            <!-- Main Content Area -->
            <div class="crop-main-content">
                <!-- Size Selection - Redesigned Clean Layout -->
                <div class="size-selection-modern">
                    <div class="size-header">
                        <h2>🎯 Chọn kích thước cắt</h2>
                        <p>Chọn kích thước phù hợp cho ảnh của bạn</p>
                    </div>
                    
                    <!-- Popular Sizes - Large Cards -->
                    <div class="size-categories">
                        <div class="category-section">
                            <h3>📋 Kích thước phổ biến</h3>
                            <div class="size-cards-large">
                                <div class="size-card-large active" data-size="5.5x8.5">
                                    <div class="size-preview-large">
                                        <div class="ratio-visual" style="aspect-ratio: 5.5/8.5;"></div>
                                    </div>
                                    <div class="size-info-large">
                                        <div class="size-name">Căn cước công dân</div>
                                        <div class="size-dimensions">5.5 × 8.5 cm</div>
                                        <div class="size-pixels">650 × 1000px</div>
                                        <div class="size-usage">CCCD, thẻ căn cước, chứng minh</div>
                                    </div>
                                </div>
                                
                                <div class="size-card-large" data-size="5.4x9">
                                    <div class="size-preview-large">
                                        <div class="ratio-visual" style="aspect-ratio: 5.4/9;"></div>
                                    </div>
                                    <div class="size-info-large">
                                        <div class="size-name">Thẻ tạm trú</div>
                                        <div class="size-dimensions">5.4 × 9 cm</div>
                                        <div class="size-pixels">638 × 1063px</div>
                                        <div class="size-usage">Thẻ tạm trú, thẻ định cư</div>
                                    </div>
                                </div>
                                
                                <div class="size-card-large" data-size="6x9">
                                    <div class="size-preview-large">
                                        <div class="ratio-visual" style="aspect-ratio: 6/9;"></div>
                                    </div>
                                    <div class="size-info-large">
                                        <div class="size-name">Ảnh hộ chiếu</div>
                                        <div class="size-dimensions">6 × 9 cm</div>
                                        <div class="size-pixels">709 × 1063px</div>
                                        <div class="size-usage">Hộ chiếu, visa, thẻ học sinh</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- More Sizes - Compact Grid -->
                        <div class="category-section">
                            <details class="more-sizes-toggle">
                                <summary>
                                    <h3>📸 Kích thước khác</h3>
                                    <span class="toggle-icon">▼</span>
                                </summary>
                                <div class="size-cards-compact">
                                    <div class="size-card-compact" data-size="10x15">
                                        <div class="size-preview-compact">
                                            <div class="ratio-visual" style="aspect-ratio: 10/15;"></div>
                                        </div>
                                        <div class="size-info-compact">
                                            <div class="size-name">Ảnh 4×6</div>
                                            <div class="size-dimensions">10×15 cm</div>
                                        </div>
                                    </div>
                                    
                                    <div class="size-card-compact" data-size="13x18">
                                        <div class="size-preview-compact">
                                            <div class="ratio-visual" style="aspect-ratio: 13/18;"></div>
                                        </div>
                                        <div class="size-info-compact">
                                            <div class="size-name">Ảnh 5×7</div>
                                            <div class="size-dimensions">13×18 cm</div>
                                        </div>
                                    </div>
                                    
                                    <div class="size-card-compact" data-size="20x25">
                                        <div class="size-preview-compact">
                                            <div class="ratio-visual" style="aspect-ratio: 20/25;"></div>
                                        </div>
                                        <div class="size-info-compact">
                                            <div class="size-name">Ảnh 8×10</div>
                                            <div class="size-dimensions">20×25 cm</div>
                                        </div>
                                    </div>
                                    
                                    <div class="size-card-compact custom-card" data-size="custom">
                                        <div class="size-preview-compact">
                                            <div class="ratio-visual custom-visual">
                                                <span>?</span>
                                            </div>
                                        </div>
                                        <div class="size-info-compact">
                                            <div class="size-name">Tùy chỉnh</div>
                                            <div class="size-dimensions">Kích thước khác</div>
                                        </div>
                                    </div>
                                </div>
                            </details>
                        </div>
                    </div>
                    
                    <!-- Current Selection Summary -->
                    <div class="selection-summary" id="selectionSummary">
                        <div class="summary-content">
                            <div class="summary-icon">🎯</div>
                            <div class="summary-info">
                                <div class="summary-title">Đã chọn: <span id="currentSizePage">5.5×8.5 cm</span></div>
                                <div class="summary-details">
                                    <span id="currentPixelsPage">650×1000px</span> • 
                                    <span id="currentRatioPage">11:17</span> • 
                                    <span>300 DPI</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Sidebar - Simplified -->
            <div class="crop-sidebar-modern">
                <!-- Quick Actions -->
                <div class="quick-actions-modern">
                    <button class="action-btn-modern primary" id="startCroppingPage">
                        <div class="btn-icon">🚀</div>
                        <div class="btn-content">
                            <div class="btn-title">Bắt đầu cắt</div>
                            <div class="btn-subtitle">Tiến hành cắt ảnh</div>
                        </div>
                    </button>
                </div>
                
                <!-- Advanced Settings - Collapsible -->
                <div class="advanced-settings-modern">
                    <details class="settings-toggle">
                        <summary>
                            <span class="settings-icon">⚙️</span>
                            <span class="settings-title">Cài đặt nâng cao</span>
                            <span class="toggle-icon">▼</span>
                        </summary>
                        
                        <div class="settings-content">
                            <!-- Custom Size Section -->
                            <div class="setting-section" id="customSizeSectionPage" style="display: none;">
                                <h4>📏 Kích thước tùy chỉnh</h4>
                                <div class="custom-inputs-modern">
                                    <div class="input-row">
                                        <div class="input-field">
                                            <label>Rộng</label>
                                            <div class="input-with-unit">
                                                <input type="number" id="cropWidthPage" value="6" min="0.5" max="50" step="0.1">
                                                <span class="unit">cm</span>
                                            </div>
                                        </div>
                                        <div class="input-field">
                                            <label>Cao</label>
                                            <div class="input-with-unit">
                                                <input type="number" id="cropHeightPage" value="9" min="0.5" max="50" step="0.1">
                                                <span class="unit">cm</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Crop Settings -->
                            <div class="setting-section">
                                <h4>🎯 Cài đặt cắt</h4>
                                <div class="setting-field">
                                    <label>Chế độ</label>
                                    <select id="cropModePage" class="modern-select">
                                        <option value="auto">Tự động - Trung tâm</option>
                                        <option value="smart">Thông minh - AI</option>
                                        <option value="manual" selected>Thủ công</option>
                                    </select>
                                </div>
                                <div class="setting-field">
                                    <label>Xử lý viền</label>
                                    <select id="cropBackgroundPage" class="modern-select">
                                        <option value="fill" selected>Đầy khung</option>
                                        <option value="fit">Vừa khít</option>
                                        <option value="stretch">Kéo giãn</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Quality Settings -->
                            <div class="setting-section">
                                <h4>📊 Chất lượng</h4>
                                <div class="setting-field">
                                    <label>DPI</label>
                                    <select id="cropDPIPage" class="modern-select">
                                        <option value="300" selected>300 DPI - In ấn</option>
                                        <option value="150">150 DPI - Web</option>
                                        <option value="72">72 DPI - Thấp</option>
                                    </select>
                                </div>
                                <div class="setting-field">
                                    <label>Đặt tên</label>
                                    <select id="cropNamingPage" class="modern-select">
                                        <option value="append">Thêm kích thước</option>
                                        <option value="replace">Thay thế tên</option>
                                        <option value="keep" selected>Giữ nguyên</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </details>
                </div>
                
                <!-- Process Mode - Simplified -->
                <div class="process-mode-modern">
                    <h4>⚡ Chế độ xử lý</h4>
                    <div class="mode-tabs">
                        <label class="mode-tab">
                            <input type="radio" name="cropProcessModePage" value="preview">
                            <span class="tab-content">
                                <span class="tab-icon">👁️</span>
                                <span class="tab-text">Xem trước</span>
                            </span>
                        </label>
                        <label class="mode-tab">
                            <input type="radio" name="cropProcessModePage" value="batch">
                            <span class="tab-content">
                                <span class="tab-icon">📋</span>
                                <span class="tab-text">Hàng loạt</span>
                            </span>
                        </label>
                        <label class="mode-tab active">
                            <input type="radio" name="cropProcessModePage" value="individual" checked>
                            <span class="tab-content">
                                <span class="tab-icon">🎯</span>
                                <span class="tab-text">Từng ảnh</span>
                            </span>
                        </label>
                    </div>
                </div>
                
                <div class="crop-actions">
                        <span class="btn-icon">✂️</span>
                        <span class="btn-text">Bắt đầu cắt ảnh</span>
                    </button>
                </div>
            </div>

            <div class="crop-main">
                <div class="crop-preview-area">
                    <div class="preview-header">
                        <h3>Danh sách ảnh sẽ cắt</h3>
                        <div class="preview-stats">
                            <span id="cropFileCount">0 ảnh được chọn</span>
                        </div>
                    </div>
                    <div class="crop-file-grid" id="cropFileGrid">
                        <!-- Crop preview items will be generated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- PDF Configuration Modal -->
    <div class="modal" id="pdfModal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Tạo file PDF bản in</h2>
                <span class="close" id="closePdfModal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="pdf-config">
                    <div class="config-section">
                        <label>📐 Kích thước giấy:</label>
                        <select id="pdfPageSize">
                            <option value="a4">A4 (210×297mm)</option>
                            <option value="a3">A3 (297×420mm)</option>
                            <option value="letter">Letter (216×279mm)</option>
                            <option value="legal">Legal (216×356mm)</option>
                        </select>
                    </div>

                    <div class="config-section">
                        <label>📱 Hướng giấy:</label>
                        <select id="pdfOrientation">
                            <option value="portrait">Dọc (Portrait)</option>
                            <option value="landscape">Ngang (Landscape)</option>
                        </select>
                    </div>

                    <div class="config-section">
                        <label>🖼️ Layout ảnh:</label>
                        <select id="pdfLayout">
                            <option value="grid">Lưới (Grid)</option>
                            <option value="list">Danh sách (List)</option>
                            <option value="single">Từng ảnh một trang</option>
                        </select>
                    </div>

                    <div class="config-section">
                        <label>📏 Số ảnh mỗi trang:</label>
                        <input type="number" id="imagesPerPage" value="4" min="1" max="20">
                    </div>

                    <div class="config-section">
                        <label>📝 Tiêu đề PDF:</label>
                        <input type="text" id="pdfTitle" value="Bộ sưu tập ảnh đã chuyển đổi" placeholder="Nhập tiêu đề...">
                    </div>

                    <div class="config-section">
                        <label>✏️ Mô tả:</label>
                        <textarea id="pdfDescription" placeholder="Thêm mô tả cho PDF..." rows="3">Các ảnh đã được chuyển đổi với chất lượng cao bằng Image Converter Tool.</textarea>
                    </div>

                    <div class="config-section">
                        <label>🏷️ Hiển thị tên file:</label>
                        <input type="checkbox" id="showFilenames" checked>
                        <span>Hiển thị tên file dưới mỗi ảnh</span>
                    </div>

                    <div class="config-section">
                        <label>📊 Hiển thị thông tin:</label>
                        <input type="checkbox" id="showImageInfo" checked>
                        <span>Hiển thị kích thước và format</span>
                    </div>

                    <div class="config-section">
                        <label>📅 Thêm ngày tháng:</label>
                        <input type="checkbox" id="addTimestamp" checked>
                        <span>Thêm timestamp vào PDF</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn cancel" id="cancelPdf">❌ Hủy</button>
                <button class="modal-btn primary" id="generatePdf">📄 Tạo PDF</button>
            </div>
        </div>
    </div>

    <!-- Crop Configuration Modal -->
    <div class="modal" id="cropModal" style="display: none;">
        <div class="modal-content crop-modal-content">
            <div class="modal-header">
                <h2>🔪 Cắt ảnh theo kích thước</h2>
                <span class="close" id="closeCropModal">&times;</span>
            </div>
            <div class="modal-body crop-modal-body">
                <div class="crop-config">
                    <!-- Template Section -->
                    <div class="crop-section template-section">
                        <h3>📐 Kích thước</h3>
                        <div class="template-grid">
                            <div class="template-card" data-size="6x9">
                                <div class="template-preview">
                                    <div class="ratio-box ratio-6x9"></div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">Ảnh hộ chiếu</div>
                                    <div class="template-size">6×9 cm</div>
                                </div>
                            </div>
                            <div class="template-card" data-size="5.5x8.5">
                                <div class="template-preview">
                                    <div class="ratio-box ratio-55x85"></div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">Thẻ visit</div>
                                    <div class="template-size">5.5×8.5 cm</div>
                                </div>
                            </div>
                            <div class="template-card active" data-size="10x15">
                                <div class="template-preview">
                                    <div class="ratio-box ratio-10x15"></div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">Ảnh 4×6</div>
                                    <div class="template-size">10×15 cm</div>
                                </div>
                            </div>
                            <div class="template-card" data-size="13x18">
                                <div class="template-preview">
                                    <div class="ratio-box ratio-13x18"></div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">Ảnh 5×7</div>
                                    <div class="template-size">13×18 cm</div>
                                </div>
                            </div>
                            <div class="template-card" data-size="20x25">
                                <div class="template-preview">
                                    <div class="ratio-box ratio-20x25"></div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">Ảnh 8×10</div>
                                    <div class="template-size">20×25 cm</div>
                                </div>
                            </div>
                            <div class="template-card custom" data-size="custom">
                                <div class="template-preview">
                                    <div class="ratio-box custom-box">
                                        <span>?</span>
                                    </div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">Tùy chỉnh</div>
                                    <div class="template-size">Custom</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="size-details" id="sizeDetails">
                            <div class="detail-item">
                                <span class="detail-label">Kích thước:</span>
                                <span class="detail-value" id="currentSize">10×15 cm</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Pixel (300 DPI):</span>
                                <span class="detail-value" id="currentPixels">1181×1772px</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Tỷ lệ:</span>
                                <span class="detail-value" id="currentRatio">2:3</span>
                            </div>
                        </div>
                    </div>

                    <!-- Custom Size Section -->
                    <div class="crop-section custom-section" id="customSizeSection" style="display: none;">
                        <h3>📏 Kích thước tùy chỉnh</h3>
                        <div class="custom-inputs">
                            <div class="input-group">
                                <label>Chiều rộng</label>
                                <div class="input-with-unit">
                                    <input type="number" id="cropWidth" value="10" min="0.5" max="50" step="0.1">
                                    <span class="unit">cm</span>
                                </div>
                            </div>
                            <div class="input-group">
                                <label>Chiều cao</label>
                                <div class="input-with-unit">
                                    <input type="number" id="cropHeight" value="15" min="0.5" max="50" step="0.1">
                                    <span class="unit">cm</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Settings Section -->
                    <div class="crop-section settings-section">
                        <h3>⚙️ Cài đặt</h3>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <label>🎯 Chế độ cắt</label>
                                <select id="cropMode" class="modern-select">
                                    <option value="auto">Tự động - Cắt trung tâm</option>
                                    <option value="smart">Thông minh - Phát hiện đối tượng</option>
                                    <option value="manual">Thủ công - Điều chỉnh từng ảnh</option>
                                </select>
                            </div>

                            <div class="setting-item">
                                <label>📊 Chất lượng DPI</label>
                                <select id="cropDPI" class="modern-select">
                                    <option value="300">300 DPI - In chất lượng cao</option>
                                    <option value="150">150 DPI - Web/Màn hình</option>
                                    <option value="72">72 DPI - Web thông thường</option>
                                </select>
                            </div>

                            <div class="setting-item">
                                <label>🎨 Xử lý viền</label>
                                <select id="cropBackground" class="modern-select">
                                    <option value="fill">Đầy khung - Cắt ảnh vừa khung</option>
                                    <option value="fit">Vừa khít - Thêm viền trắng</option>
                                    <option value="stretch">Kéo giãn - Biến dạng ảnh</option>
                                </select>
                                <div class="setting-help" id="edgeModeHelp">
                                    <span id="edgeModeDetails">Chọn cách xử lý khi ảnh không vừa tỷ lệ khung cắt</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Process Mode Section -->
                    <div class="crop-section process-section">
                        <h3>⚡ Chế độ xử lý</h3>
                        <div class="process-modes">
                            <label class="mode-card">
                                <input type="radio" name="cropProcessMode" value="preview">
                                <div class="mode-icon">👁️</div>
                                <div class="mode-info">
                                    <div class="mode-name">Xem trước</div>
                                    <div class="mode-desc">Kiểm tra trước khi cắt</div>
                                </div>
                            </label>
                            <label class="mode-card">
                                <input type="radio" name="cropProcessMode" value="batch">
                                <div class="mode-icon">📋</div>
                                <div class="mode-info">
                                    <div class="mode-name">Hàng loạt</div>
                                    <div class="mode-desc">Cắt tất cả cùng lúc</div>
                                </div>
                            </label>
                            <label class="mode-card active">
                                <input type="radio" name="cropProcessMode" value="individual" checked>
                                <div class="mode-icon">🎯</div>
                                <div class="mode-info">
                                    <div class="mode-name">Từng ảnh</div>
                                    <div class="mode-desc">Điều chỉnh riêng biệt</div>
                                </div>
                            </label>
                        </div>
                        
                        <div class="naming-section">
                            <label>🏷️ Đặt tên file</label>
                            <select id="cropNaming" class="modern-select">
                                <option value="append">Thêm kích thước vào tên</option>
                                <option value="replace">Thay thế: "cropped_[kích thước]"</option>
                                <option value="keep">Giữ nguyên tên gốc</option>
                            </select>
                        </div>
                    </div>

                    <div class="preview-info">
                        <h3>Thông tin chi tiết:</h3>
                        <div class="info-grid">
                            <div class="info-item">
                                <strong>Kích thước:</strong> <span id="cropSizeInfo">6×9 cm</span>
                            </div>
                            <div class="info-item">
                                <strong>Pixels (300 DPI):</strong> <span id="cropPixelInfo">708×1063 px</span>
                            </div>
                            <div class="info-item">
                                <strong>Tỷ lệ:</strong> <span id="cropRatioInfo">2:3</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn cancel" id="cancelCrop">❌ Hủy</button>
                <button class="modal-btn secondary" id="downloadCropConfigZip">📦 Tải ZIP</button>
                <button class="modal-btn primary" id="startCropping">✂️ Bắt đầu cắt</button>
            </div>
        </div>
    </div>

    <!-- Crop Preview Gallery Modal -->
    <div class="modal" id="cropPreviewModal" style="display: none;">
        <div class="modal-content crop-preview-content">
            <div class="modal-header">
                <h2>Xem trước cắt ảnh - <span id="previewModeTitle">Chế độ mẫu</span></h2>
                <div class="preview-stats">
                    <span id="previewCount">0/0</span>
                </div>
                <span class="close" id="closePreviewModal">&times;</span>
            </div>
            <div class="modal-body preview-gallery-body">
                <div class="preview-controls-top">
                    <div class="template-info">
                        <span>📐 Kích thước: <span id="previewTemplateSize">6×9 cm</span></span>
                        <span>📏 Pixel: <span id="previewPixelSize">709×1063px</span></span>
                        <span>🎯 Chế độ: <span id="previewCropMode">Smart</span></span>
                    </div>
                    <div class="batch-controls">
                        <button class="preview-btn" id="acceptAllPreviews">✅ Chấp nhận tất cả</button>
                        <button class="preview-btn secondary" id="selectAllPreviews">☑️ Chọn tất cả</button>
                        <button class="preview-btn secondary" id="clearAllPreviews">❌ Bỏ chọn tất cả</button>
                    </div>
                </div>
                
                <div class="preview-gallery" id="previewGallery">
                    <!-- Preview items will be generated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn cancel" id="cancelPreview">❌ Hủy</button>
                <button class="modal-btn secondary" id="downloadCropPreviewZip">📦 Tải ZIP</button>
                <button class="modal-btn" id="cropSelectedPreviews">✂️ Cắt đã chọn (<span id="selectedCount">0</span>)</button>
                <button class="modal-btn primary" id="cropAllPreviews">🚀 Cắt tất cả</button>
            </div>
        </div>
    </div>

    <!-- Multi-Image Crop Editor Modal -->
    <div class="modal" id="cropEditorModal" style="display: none;">
        <div class="modal-content multi-crop-editor-content">
            <div class="modal-header">
                <h2>Chỉnh sửa cắt ảnh hàng loạt</h2>
                <div class="crop-progress">
                    <span id="multiCropProgress">5 ảnh</span>
                </div>
                <span class="close" id="closeCropEditor">&times;</span>
            </div>
            <div class="modal-body multi-crop-editor-body">
                <!-- Global Controls -->
                <div class="global-crop-controls">
                    <div class="global-info">
                        <div class="target-size-display">
                            <span class="info-label">Kích thước mục tiêu:</span>
                            <span id="globalTargetSize">6×9 cm</span>
                        </div>
                        <div class="aspect-ratio-display">
                            <span class="info-label">Tỷ lệ:</span>
                            <span id="globalAspectRatio">2:3</span>
                        </div>
                    </div>
                    <div class="global-actions">
                        <button class="global-btn" id="resetAllCrops">Đặt lại tất cả</button>
                        <button class="global-btn" id="centerAllCrops">Căn giữa tất cả</button>
                        <button class="global-btn" id="fitAllCrops">Tối đa tất cả</button>
                        <button class="global-btn toggle" id="globalAspectLock">Khóa tỷ lệ</button>
                        <button class="global-btn toggle" id="globalSizeLock">Khóa kích thước</button>
                    </div>
                </div>

                <!-- Multi-Image Grid -->
                <div class="multi-crop-container" id="multiCropContainer">
                    <!-- Dynamic crop cards will be inserted here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn cancel" id="cancelMultiCrop">Hủy</button>
                <button class="modal-btn" id="selectAllCrops">Chọn tất cả</button>
                <button class="modal-btn primary" id="acceptAllCrops">Cắt tất cả ảnh đã chọn</button>
            </div>
        </div>
    </div>

    <!-- Template Crop Editor Modal (Fixed Aspect Ratio) -->
    <!-- Polaroid Template Crop Modal - Enhanced cropPage-style Interface -->
    <div class="modal" id="templateCropModal" style="display: none;">
        <div class="modal-content template-crop-page-content">
            <div class="modal-header template-crop-header">
                <div class="template-header-left">
                    <h2>✂️ Cắt ảnh Polaroid Template</h2>
                    <div class="template-progress-info">
                        <span id="templateCropProgress">1/5 ảnh</span>
                        <span class="template-size-info" id="templateSizeDisplay">5.5×8.5 cm</span>
                    </div>
                </div>
                <span class="close" id="closeTemplateCrop">&times;</span>
            </div>
            
            <div class="modal-body template-crop-page-body">
                <div class="template-crop-sidebar">
                    <!-- Template Configuration Section -->
                    <div class="template-section template-config-section">
                        <h3>📐 Cấu hình Template</h3>
                        <div class="template-size-details">
                            <div class="detail-item">
                                <span class="detail-label">Kích thước:</span>
                                <span class="detail-value" id="templateCurrentSizeDetail">5.5×8.5 cm</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Pixel (300 DPI):</span>
                                <span class="detail-value" id="templateCurrentPixels">650×1000px</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Tỷ lệ ảnh chuẩn:</span>
                                <span class="detail-value highlight" id="templateAspectRatio">1:1.55</span>
                            </div>
                        </div>
                        
                        <div class="template-border-info">
                            <h4>🖼️ Viền Polaroid</h4>
                            <div class="border-details">
                                <div class="border-item">
                                    <span class="border-label">Trên/Trái/Phải:</span>
                                    <span class="border-value" id="templateBorderTLR">50-45-45px</span>
                                </div>
                                <div class="border-item">
                                    <span class="border-label">Caption (dưới):</span>
                                    <span class="border-value" id="templateBorderBottom">175px</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Crop Settings Section -->
                    <div class="template-section template-settings-section">
                        <h3>⚙️ Cài đặt Crop</h3>
                        <div class="template-settings-grid">
                            <div class="setting-item">
                                <label>🎯 Chế độ cắt</label>
                                <select id="templateCropMode" class="modern-select">
                                    <option value="manual" selected>Thủ công - Điều chỉnh từng ảnh</option>
                                    <option value="auto">Tự động - Cắt trung tâm</option>
                                    <option value="smart">Thông minh - Phát hiện đối tượng</option>
                                </select>
                            </div>

                            <div class="setting-item">
                                <label>📊 Chất lượng DPI</label>
                                <select id="templateCropDPI" class="modern-select">
                                    <option value="300" selected>300 DPI - In chất lượng cao</option>
                                    <option value="150">150 DPI - Web/Màn hình</option>
                                    <option value="72">72 DPI - Web thông thường</option>
                                </select>
                            </div>

                            <div class="setting-item">
                                <label>🎨 Xử lý viền</label>
                                <select id="templateCropBackground" class="modern-select">
                                    <option value="fill" selected>Đầy khung - Cắt ảnh vừa khung</option>
                                    <option value="fit">Vừa khít - Thêm viền trắng</option>
                                    <option value="stretch">Kéo giãn - Biến dạng ảnh</option>
                                </select>
                                <div class="setting-help">
                                    <span>Xử lý khi ảnh không vừa tỷ lệ 1:1.55</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Crop Controls Section -->
                    <div class="template-section template-controls-section">
                        <h3>🎛️ Điều khiển</h3>
                        <div class="template-position-controls">
                            <button class="control-btn" id="templateCenter">📍 Căn giữa</button>
                            <button class="control-btn" id="templateReset">🔄 Đặt lại</button>
                        </div>
                        
                        <div class="template-display-controls">
                            <button class="toggle-btn" id="templateGrid">📏 Lưới</button>
                            <button class="toggle-btn" id="templateGuides">📐 Hướng dẫn</button>
                            <button class="toggle-btn" id="templateBorderPreview">🖼️ Preview viền</button>
                        </div>
                    </div>

                    <!-- Process Mode Section -->
                    <div class="template-section template-process-section">
                        <h3>⚡ Chế độ xử lý</h3>
                        <div class="template-process-modes">
                            <label class="mode-card active">
                                <input type="radio" name="templateProcessMode" value="individual" checked>
                                <div class="mode-icon">🎯</div>
                                <div class="mode-info">
                                    <div class="mode-name">Từng ảnh</div>
                                    <div class="mode-desc">Điều chỉnh riêng biệt</div>
                                </div>
                            </label>
                            <label class="mode-card">
                                <input type="radio" name="templateProcessMode" value="batch">
                                <div class="mode-icon">📋</div>
                                <div class="mode-info">
                                    <div class="mode-name">Hàng loạt</div>
                                    <div class="mode-desc">Cắt tất cả cùng lúc</div>
                                </div>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="template-crop-main">
                    <div class="template-crop-workspace">
                        <div class="template-workspace-header">
                            <div class="current-image-info">
                                <h4 id="templateImageName">image1.jpg</h4>
                                <span class="image-dimensions" id="templateImageDimensions">1920×1280px</span>
                            </div>
                            <div class="workspace-controls">
                                <button class="workspace-btn" id="templateFitToScreen">🔍 Fit màn hình</button>
                                <button class="workspace-btn" id="templateActualSize">📏 Kích thước thực</button>
                            </div>
                        </div>
                        
                        <div class="template-image-container">
                            <div id="templateCropContainer" class="template-crop-container">
                                <canvas id="templateCropCanvas" class="template-crop-canvas"></canvas>
                                <div id="templateCropOverlay" class="template-crop-overlay">
                                    <div id="templateCropSelection" class="template-crop-selection">
                                        <!-- Move handle -->
                                        <div class="template-move-handle">✥</div>
                                        
                                        <!-- Resize handles with aspect ratio lock -->
                                        <div class="template-resize-handle nw" data-direction="nw"></div>
                                        <div class="template-resize-handle ne" data-direction="ne"></div>
                                        <div class="template-resize-handle sw" data-direction="sw"></div>
                                        <div class="template-resize-handle se" data-direction="se"></div>
                                        
                                        <div class="template-selection-info">
                                            <span id="templateSelectionSize">650×1000px</span>
                                            <span class="selection-status" id="templateSelectionStatus">✅ Tỷ lệ chuẩn</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="template-workspace-footer">
                            <div class="crop-preview-mini">
                                <h5>👁️ Preview kết quả</h5>
                                <div class="mini-preview-container">
                                    <canvas id="templateMiniPreview" class="template-mini-preview"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="modal-footer template-crop-footer">
                <div class="template-nav-controls">
                    <button class="nav-btn" id="prevTemplateImage" disabled>◀ Trước</button>
                    <span class="nav-status" id="templateNavStatus">1 / 5</span>
                    <button class="nav-btn" id="nextTemplateImage">Sau ▶</button>
                </div>
                <div class="template-action-controls">
                    <button class="modal-btn cancel" id="cancelTemplateCrop">❌ Hủy</button>
                    <button class="modal-btn secondary" id="skipTemplateImage">⏭️ Bỏ qua</button>
                    <button class="modal-btn secondary" id="downloadCropZip">📦 Tải tất cả</button>
                    <button class="modal-btn primary" id="cropTemplateImage">✂️ Cắt ảnh này</button>
                </div>
            </div>
        </div>
    </div>


    <!-- Preview Before Download Modal -->
    <div class="modal" id="previewModal" style="display: none;" onclick="converter.handleModalClick(event)">
        <div class="modal-content preview-modal-content" onclick="event.stopPropagation()">
            <div class="modal-header preview-modal-header">
                <h2>
                    <span>👁️</span>
                    <span id="previewModalTitle">Preview File</span>
                </h2>
                <button class="close" onclick="converter.hidePreviewModal()">&times;</button>
            </div>
            <div class="modal-body preview-modal-body">
                <div id="previewLoadingContainer" class="preview-loading">
                    <div class="preview-loading-spinner"></div>
                    <p>Đang tải preview...</p>
                </div>
                
                <div id="previewContentContainer" class="preview-container" style="display: none;">
                    <div class="preview-image-container">
                        <img id="previewImage" class="preview-image" alt="Preview">
                        <div class="preview-image-info">
                            <div id="previewImageDimensions">Đang tải kích thước...</div>
                        </div>
                    </div>
                    
                    <div class="preview-details">
                        <h3>📋 Thông tin chi tiết</h3>
                        <div class="detail-grid">
                            <div class="detail-item">
                                <span class="detail-label">Tên file</span>
                                <span class="detail-value" id="previewFileName">...</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Định dạng</span>
                                <span class="detail-value" id="previewFormat">...</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Kích thước file</span>
                                <span class="detail-value" id="previewFileSize">...</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Chất lượng</span>
                                <span class="detail-value" id="previewQuality">...</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Kích thước ảnh</span>
                                <span class="detail-value" id="previewDimensions">...</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">DPI/Độ phân giải</span>
                                <span class="detail-value" id="previewDPI">300 DPI</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer preview-modal-footer">
                <button class="preview-btn cancel" onclick="converter.hidePreviewModal()">
                    <span>❌</span>
                    <span>Cancel</span>
                </button>
                <button class="preview-btn download" id="previewDownloadBtn" onclick="converter.confirmDownload()">
                    <span>💾</span>
                    <span>Download</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        class BatchImageConverter {
            constructor() {
                this.files = [];
                this.convertedFiles = [];
                this.currentConversion = 0;
                this.totalConversions = 0;
                this.currentCropSize = { width: 5.5, height: 8.5 };
                this.cropProcessedFiles = [];
                this.isDownloading = false;
                this.isDownloadingCropped = false;
                
                // Resource management for memory leaks prevention
                this.objectURLs = new Set(); // Track all created object URLs
                this.canvasElements = new Set(); // Track all canvas elements
                this.eventListeners = new Map(); // Track all event listeners for cleanup
                this.intervals = new Set(); // Track all intervals
                this.timeouts = new Set(); // Track all timeouts
                this.abortControllers = new Map(); // Track abort controllers for async operations
                
                // Gallery management
                this.galleryImages = this.loadGalleryFromStorage();
                this.classificationMode = false;
                this.frontImages = [];
                this.backImages = [];
                this.selectedImageForAction = null;
                
                // Quick selection mode
                this.selectionMode = false;
                this.selectionType = null; // 'front', 'back', or null
                this.selectedImages = [];
                
                // Performance optimization
                this.galleryCache = new Map();
                this.thumbnailCache = new Map();
                this.lazyLoadObserver = null;
                this.batchSize = 20;
                this.currentBatchIndex = 0;
                
                // Download folder preferences
                this.downloadSettings = {
                    folderPrefix: '',
                    useSubfolders: false,
                    subfolderNames: {
                        front: 'Mat_truoc',
                        back: 'Mat_sau', 
                        cropped: 'Da_cat',
                        original: 'Goc',
                        gallery: 'Kho_anh'
                    }
                };

                // Load download settings from localStorage
                this.loadDownloadSettings();
                
                this.initializeEventListeners();
                this.initKeyboardShortcuts();
                this.updateStats();
                this.updateGalleryDisplay();
                
                // Initialize template preview after DOM is ready
                setTimeout(() => this.updateTemplatePreview(), 100);
                
                // Setup auto cleanup for memory management
                this.setupAutoCleanup();
                
                // Initialize performance monitoring
                this.initPerformanceMonitoring();
            }

            // ============= CENTRALIZED ERROR HANDLING & RESOURCE MANAGEMENT =============
            
            // Centralized error handler with context
            handleError(error, context = 'Unknown', showToast = true) {
                const errorMessage = `Error in ${context}: ${error?.message || error}`;
                console.error(errorMessage, error);
                
                if (showToast) {
                    const userMessage = this.getUserFriendlyErrorMessage(error, context);
                    this.showToast(`❌ ${userMessage}`, 'error');
                }
                
                // Log to external service if needed (can be extended)
                this.logError(error, context);
                
                return false; // Return false to indicate error handled
            }
            
            // Convert technical errors to user-friendly messages
            getUserFriendlyErrorMessage(error, context) {
                const message = error?.message?.toLowerCase() || '';
                
                if (context.includes('convert') || context.includes('file')) {
                    if (message.includes('memory') || message.includes('size')) {
                        return 'File quá lớn, vui lòng thử file nhỏ hơn';
                    }
                    if (message.includes('format') || message.includes('type')) {
                        return 'Định dạng file không hỗ trợ';
                    }
                    if (message.includes('load') || message.includes('url')) {
                        return 'Không thể tải file, vui lòng thử lại';
                    }
                    return 'Lỗi xử lý file, vui lòng thử lại';
                }
                
                if (context.includes('crop')) {
                    return 'Lỗi cắt ảnh, vui lòng kiểm tra kích thước';
                }
                
                if (context.includes('download')) {
                    return 'Lỗi tải xuống, vui lòng thử lại';
                }
                
                return 'Có lỗi xảy ra, vui lòng thử lại';
            }
            
            // Log error to external service (placeholder)
            logError(error, context) {
                // Can be extended to send to analytics service
                if (window.gtag) {
                    gtag('event', 'exception', {
                        description: `${context}: ${error?.message}`,
                        fatal: false
                    });
                }
            }
            
            // Safe object URL creation with tracking
            safeCreateObjectURL(blob) {
                try {
                    if (!blob) {
                        throw new Error('Blob is null or undefined');
                    }
                    
                    const url = URL.createObjectURL(blob);
                    this.objectURLs.add(url);
                    
                    // Auto-cleanup after 10 minutes to prevent memory leaks
                    const timeoutId = setTimeout(() => {
                        this.safeRevokeObjectURL(url);
                    }, 10 * 60 * 1000);
                    this.timeouts.add(timeoutId);
                    
                    return url;
                } catch (error) {
                    this.handleError(error, 'safeCreateObjectURL');
                    return null;
                }
            }
            
            // Safe object URL cleanup
            safeRevokeObjectURL(url) {
                try {
                    if (url && this.objectURLs.has(url)) {
                        URL.revokeObjectURL(url);
                        this.objectURLs.delete(url);
                    }
                } catch (error) {
                    console.warn('Error revoking object URL:', error);
                }
            }
            
            // Safe canvas creation with tracking
            safeCreateCanvas(width, height) {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    this.canvasElements.add(canvas);
                    
                    // Add cleanup method to canvas
                    canvas._cleanup = () => {
                        const ctx = canvas.getContext('2d');
                        if (ctx) {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                        canvas.width = 1;
                        canvas.height = 1;
                        this.canvasElements.delete(canvas);
                    };
                    
                    return canvas;
                } catch (error) {
                    this.handleError(error, 'safeCreateCanvas');
                    return null;
                }
            }
            
            // Safe event listener addition with tracking
            safeAddEventListener(element, event, handler, options = {}) {
                try {
                    if (!element) {
                        console.warn(`⚠️ Element bị null/undefined cho sự kiện '${event}'`);
                        return;
                    }
                    
                    if (typeof handler !== 'function') {
                        console.warn(`⚠️ Handler không phải là function cho sự kiện '${event}' trên element:`, element);
                        return;
                    }
                    
                    element.addEventListener(event, handler, options);
                    
                    // Track for cleanup - use element tag name or ID for better tracking
                    const elementId = element.id || element.tagName || 'unknown';
                    const key = `${elementId}-${event}`;
                    if (!this.eventListeners.has(key)) {
                        this.eventListeners.set(key, []);
                    }
                    this.eventListeners.get(key).push({ element, event, handler, options });
                    
                } catch (error) {
                    console.error(`❌ Lỗi khi thêm event listener cho '${event}':`, error);
                    // Don't use this.handleError here to avoid recursion
                }
            }
            
            // Safe interval creation with tracking  
            safeSetInterval(callback, delay) {
                try {
                    const intervalId = setInterval(() => {
                        try {
                            callback();
                        } catch (error) {
                            this.handleError(error, 'interval callback');
                        }
                    }, delay);
                    
                    this.intervals.add(intervalId);
                    return intervalId;
                } catch (error) {
                    this.handleError(error, 'safeSetInterval');
                    return null;
                }
            }
            
            // Safe timeout creation with tracking
            safeSetTimeout(callback, delay) {
                try {
                    const timeoutId = setTimeout(() => {
                        try {
                            callback();
                        } catch (error) {
                            this.handleError(error, 'timeout callback');
                        }
                        this.timeouts.delete(timeoutId);
                    }, delay);
                    
                    this.timeouts.add(timeoutId);
                    return timeoutId;
                } catch (error) {
                    this.handleError(error, 'safeSetTimeout');
                    return null;
                }
            }
            
            // Create abort controller for async operations
            createAbortController(operationId) {
                const controller = new AbortController();
                this.abortControllers.set(operationId, controller);
                return controller;
            }
            
            // Cleanup all resources
            cleanup() {
                try {
                    // Cleanup object URLs
                    for (const url of this.objectURLs) {
                        URL.revokeObjectURL(url);
                    }
                    this.objectURLs.clear();
                    
                    // Cleanup canvas elements
                    for (const canvas of this.canvasElements) {
                        if (canvas._cleanup) {
                            canvas._cleanup();
                        }
                    }
                    this.canvasElements.clear();
                    
                    // Cleanup event listeners
                    for (const [key, listeners] of this.eventListeners) {
                        for (const { element, event, handler, options } of listeners) {
                            element.removeEventListener(event, handler, options);
                        }
                    }
                    this.eventListeners.clear();
                    
                    // Cleanup intervals
                    for (const intervalId of this.intervals) {
                        clearInterval(intervalId);
                    }
                    this.intervals.clear();
                    
                    // Cleanup timeouts
                    for (const timeoutId of this.timeouts) {
                        clearTimeout(timeoutId);
                    }
                    this.timeouts.clear();
                    
                    // Abort ongoing operations
                    for (const [operationId, controller] of this.abortControllers) {
                        controller.abort();
                    }
                    this.abortControllers.clear();
                    
                } catch (error) {
                    console.error('Error during cleanup:', error);
                }
            }
            
            // Auto cleanup on page unload
            setupAutoCleanup() {
                window.addEventListener('beforeunload', () => {
                    this.cleanup();
                });
                
                // Cleanup every 5 minutes to prevent accumulation
                this.safeSetInterval(() => {
                    this.performMaintenanceCleanup();
                }, 5 * 60 * 1000);
            }
            
            // Periodic maintenance cleanup
            performMaintenanceCleanup() {
                try {
                    // Cleanup expired cache entries
                    const now = Date.now();
                    for (const [key, entry] of this.galleryCache) {
                        if (entry.timestamp && (now - entry.timestamp) > 30 * 60 * 1000) { // 30 minutes
                            this.galleryCache.delete(key);
                        }
                    }
                    
                    // Cleanup orphaned object URLs
                    const urlsToCleanup = [];
                    for (const url of this.objectURLs) {
                        // If URL is not being used anywhere, mark for cleanup
                        if (!document.querySelector(`[src="${url}"]`) && 
                            !document.querySelector(`[href="${url}"]`)) {
                            urlsToCleanup.push(url);
                        }
                    }
                    
                    for (const url of urlsToCleanup) {
                        this.safeRevokeObjectURL(url);
                    }
                    
                } catch (error) {
                    console.warn('Error during maintenance cleanup:', error);
                }
            }
            
            // Performance monitoring to ensure memory leak fixes don't impact performance
            initPerformanceMonitoring() {
                this.performanceStats = {
                    startTime: Date.now(),
                    memoryUsage: 0,
                    operationTimes: new Map(),
                    resourceCounts: {
                        objectURLs: 0,
                        canvases: 0,
                        eventListeners: 0
                    }
                };
                
                // Monitor memory usage periodically
                this.safeSetInterval(() => {
                    this.updatePerformanceStats();
                }, 30000); // Every 30 seconds
                
                // Log performance stats when user leaves
                window.addEventListener('beforeunload', () => {
                    this.logFinalPerformanceStats();
                });
            }
            
            // Update performance statistics
            updatePerformanceStats() {
                try {
                    const stats = this.performanceStats;
                    
                    // Update resource counts
                    stats.resourceCounts.objectURLs = this.objectURLs.size;
                    stats.resourceCounts.canvases = this.canvasElements.size;
                    stats.resourceCounts.eventListeners = this.eventListeners.size;
                    
                    // Check memory usage if available
                    if (performance.memory) {
                        stats.memoryUsage = performance.memory.usedJSHeapSize;
                    }
                    
                    // Log warning if resource counts are too high
                    if (stats.resourceCounts.objectURLs > 50) {
                        console.warn('High object URL count:', stats.resourceCounts.objectURLs);
                    }
                    if (stats.resourceCounts.canvases > 10) {
                        console.warn('High canvas count:', stats.resourceCounts.canvases);
                    }
                    
                } catch (error) {
                    console.warn('Error updating performance stats:', error);
                }
            }
            
            // Log final performance statistics
            logFinalPerformanceStats() {
                try {
                    const stats = this.performanceStats;
                    const totalTime = (Date.now() - stats.startTime) / 1000;
                    
                    console.log('=== PERFORMANCE STATS ===');
                    console.log(`Session duration: ${totalTime.toFixed(1)}s`);
                    console.log(`Final resource counts:`, stats.resourceCounts);
                    
                    if (performance.memory) {
                        console.log(`Memory usage: ${(stats.memoryUsage / 1024 / 1024).toFixed(1)} MB`);
                    }
                    
                    // Log operation times if any were tracked
                    if (stats.operationTimes.size > 0) {
                        console.log('Operation times:');
                        for (const [operation, times] of stats.operationTimes) {
                            const avg = times.reduce((a, b) => a + b, 0) / times.length;
                            console.log(`  ${operation}: ${avg.toFixed(1)}ms avg (${times.length} ops)`);
                        }
                    }
                    
                } catch (error) {
                    console.warn('Error logging performance stats:', error);
                }
            }
            
            // Track operation time for performance monitoring
            trackOperationTime(operation, startTime) {
                try {
                    const duration = Date.now() - startTime;
                    
                    if (!this.performanceStats.operationTimes.has(operation)) {
                        this.performanceStats.operationTimes.set(operation, []);
                    }
                    
                    const times = this.performanceStats.operationTimes.get(operation);
                    times.push(duration);
                    
                    // Keep only last 100 measurements
                    if (times.length > 100) {
                        times.shift();
                    }
                    
                } catch (error) {
                    console.warn('Error tracking operation time:', error);
                }
            }

            // Load download settings from localStorage
            loadDownloadSettings() {
                try {
                    const saved = localStorage.getItem('downloadSettings');
                    if (saved) {
                        this.downloadSettings = { ...this.downloadSettings, ...JSON.parse(saved) };
                        this.updateDownloadSettingsUI();
                    }
                } catch (error) {
                    console.error('Error loading download settings:', error);
                }
            }

            // Update UI with loaded settings
            updateDownloadSettingsUI() {
                document.getElementById('folderPrefix').value = this.downloadSettings.folderPrefix || '';
                document.getElementById('useSubfolders').checked = this.downloadSettings.useSubfolders || false;
                document.getElementById('frontFolderName').value = this.downloadSettings.subfolderNames.front || 'Mat_truoc';
                document.getElementById('backFolderName').value = this.downloadSettings.subfolderNames.back || 'Mat_sau';
                document.getElementById('croppedFolderName').value = this.downloadSettings.subfolderNames.cropped || 'Da_cat';
                document.getElementById('galleryFolderName').value = this.downloadSettings.subfolderNames.gallery || 'Kho_anh';
                
                // Show/hide subfolder settings
                const subfolderSettings = document.getElementById('subfolderSettings');
                if (subfolderSettings) {
                    subfolderSettings.style.display = this.downloadSettings.useSubfolders ? 'block' : 'none';
                }
            }

            // Save download settings to localStorage
            saveDownloadSettings() {
                this.downloadSettings.folderPrefix = document.getElementById('folderPrefix').value.trim();
                this.downloadSettings.useSubfolders = document.getElementById('useSubfolders').checked;
                this.downloadSettings.subfolderNames.front = document.getElementById('frontFolderName').value.trim() || 'Mat_truoc';
                this.downloadSettings.subfolderNames.back = document.getElementById('backFolderName').value.trim() || 'Mat_sau';
                this.downloadSettings.subfolderNames.cropped = document.getElementById('croppedFolderName').value.trim() || 'Da_cat';
                this.downloadSettings.subfolderNames.gallery = document.getElementById('galleryFolderName').value.trim() || 'Kho_anh';
                
                try {
                    localStorage.setItem('downloadSettings', JSON.stringify(this.downloadSettings));
                    this.showToast('✅ Đã lưu cài đặt thư mục tải về!', 'success');
                } catch (error) {
                    console.error('Error saving download settings:', error);
                    this.showToast('❌ Lỗi khi lưu cài đặt!', 'error');
                }
            }

            // Apply folder settings to filename
            applyDownloadFolderSettings(fileName, type) {
                let finalName = fileName;
                
                // Add folder prefix if enabled
                if (this.downloadSettings.folderPrefix) {
                    const prefix = this.downloadSettings.folderPrefix.replace(/[<>:"/\|?*]/g, '_');
                    finalName = `${prefix}${finalName}`;
                }
                
                // Add subfolder path if enabled
                if (this.downloadSettings.useSubfolders && this.downloadSettings.subfolderNames[type]) {
                    const subfolderName = this.downloadSettings.subfolderNames[type].replace(/[<>:"/\|?*]/g, '_');
                    finalName = `${subfolderName}/${finalName}`;
                }
                
                return finalName;
            }

            // Initialize keyboard shortcuts
            initKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Escape key to close preview modal or exit selection mode
                    if (e.key === 'Escape') {
                        const previewModal = document.getElementById('previewModal');
                        if (previewModal && previewModal.style.display === 'flex') {
                            this.hidePreviewModal();
                        } else if (this.selectionMode) {
                            this.exitSelectionMode();
                        }
                    }
                    
                    // Enter key to download in preview modal
                    if (e.key === 'Enter') {
                        const previewModal = document.getElementById('previewModal');
                        if (previewModal && previewModal.style.display === 'flex' && this.currentPreviewFileId) {
                            this.confirmDownload();
                        }
                    }
                    
                    // Quick selection shortcuts (only in Gallery tab)
                    const currentTab = document.querySelector('.function-section.active');
                    if (currentTab && currentTab.id === 'gallery') {
                        // Ctrl+F: Quick select front
                        if (e.ctrlKey && e.key === 'f') {
                            e.preventDefault();
                            if (!this.selectionMode || this.selectionType !== 'front') {
                                this.startQuickSelection('front');
                            }
                        }
                        
                        // Ctrl+B: Quick select back
                        if (e.ctrlKey && e.key === 'b') {
                            e.preventDefault();
                            if (!this.selectionMode || this.selectionType !== 'back') {
                                this.startQuickSelection('back');
                            }
                        }
                        
                        // Ctrl+A: Select all current images
                        if (e.ctrlKey && e.key === 'a' && this.selectionMode) {
                            e.preventDefault();
                            this.galleryImages.forEach(image => {
                                if (!this.selectedImages.includes(image.id)) {
                                    this.selectedImages.push(image.id);
                                }
                            });
                            this.updateGallerySelectionMode();
                            this.updateSelectionCounter();
                        }
                    }
                });
            }


            initializeEventListeners() {
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        try {
                            console.log('🔥 Đã kích hoạt sự kiện thay đổi file input');
                            this.handleFileSelect(e.target.files);
                        } catch (error) {
                            console.error('❌ Lỗi trong xử lý sự kiện thay đổi file input:', error);
                            this.showToast('Lỗi khi xử lý file đã chọn!', 'error');
                        }
                    });
                    fileInput.removeAttribute('accept');
                } else {
                    console.error('❌ Không tìm thấy element file input!');
                }

                const uploadZone = document.querySelector('.upload-zone');
                if (uploadZone) {
                    uploadZone.addEventListener('dragover', this.handleDragOver.bind(this));
                    uploadZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
                    uploadZone.addEventListener('drop', (e) => {
                        try {
                            console.log('Drop event triggered');
                            this.handleDrop(e);
                        } catch (error) {
                            console.error('Error in drop handler:', error);
                            this.showToast('Lỗi khi thả file!', 'error');
                        }
                    });
                } else {
                    console.error('❌ Không tìm thấy element vùng upload!');
                }

                // Quality slider with warnings
                const qualitySlider = document.getElementById('quality');
                if (qualitySlider) {
                    this.safeAddEventListener(qualitySlider, 'input', (e) => {
                        const value = parseInt(e.target.value);
                        const qualityValue = document.getElementById('qualityValue');
                        if (qualityValue) {
                            if (value === 100) {
                                qualityValue.textContent = '100% (Tuyệt đối file gốc)';
                            } else {
                                qualityValue.textContent = value + '%';
                            }
                        }
                        
                        // Show quality warnings
                        if (value < 70) {
                            this.showToast('⚠️ Chất lượng thấp có thể làm giảm độ chi tiết ảnh', 'error');
                        } else if (value < 85) {
                            this.showToast('💡 Khuyến nghị: Chất lượng ≥85% cho kết quả tốt nhất', 'success');
                        }
                    });
                }

                // Max quality button
                const maxQualityBtn = document.getElementById('maxQualityBtn');
                if (maxQualityBtn) {
                    this.safeAddEventListener(maxQualityBtn, 'click', () => {
                        const quality = document.getElementById('quality');
                        const qualityValue = document.getElementById('qualityValue');
                        if (quality) quality.value = 100;
                        if (qualityValue) qualityValue.textContent = '100% (Tuyệt đối file gốc)';
                    });
                }

                // Naming options
                const namingSelect = document.getElementById('namingOption');
                const customPrefix = document.getElementById('customPrefix');
                
                if (namingSelect && customPrefix) {
                    this.safeAddEventListener(namingSelect, 'change', (e) => {
                        if (e.target.value === 'custom') {
                            customPrefix.style.display = 'inline-block';
                        } else {
                            customPrefix.style.display = 'none';
                        }
                    });
                }

                // Buttons with null checks and safe event listeners
                const convertAllBtn = document.getElementById('convertAllBtn');
                if (convertAllBtn) this.safeAddEventListener(convertAllBtn, 'click', () => this.convertAllFiles());
                
                const downloadAllBtn = document.getElementById('downloadAllBtn');
                if (downloadAllBtn) this.safeAddEventListener(downloadAllBtn, 'click', () => this.downloadAllFiles());
                
                const downloadZipBtn = document.getElementById('downloadZipBtn');
                if (downloadZipBtn) this.safeAddEventListener(downloadZipBtn, 'click', () => this.downloadAsZip());
                
                const createPdfBtn = document.getElementById('createPdfBtn');
                if (createPdfBtn) this.safeAddEventListener(createPdfBtn, 'click', () => this.showPdfModal());
                
                const cropImagesBtn = document.getElementById('cropImagesBtn');
                if (cropImagesBtn) this.safeAddEventListener(cropImagesBtn, 'click', () => this.showCropModal());
                
                const clearAllBtn = document.getElementById('clearAllBtn');
                if (clearAllBtn) this.safeAddEventListener(clearAllBtn, 'click', () => this.clearAllFiles());
                
                const showCropResultsBtn = document.getElementById('showCropResultsBtn');
                if (showCropResultsBtn) this.safeAddEventListener(showCropResultsBtn, 'click', () => {
                    console.log('🎯 Hiển thị kết quả cắt ảnh được yêu cầu');
                    if (window.showCropResultsSection) {
                        window.showCropResultsSection();
                        // Switch to Template Crop tab to see results
                        const cropTab = document.getElementById('cropTab');
                        if (cropTab) {
                            cropTab.click();
                        }
                        this.showToast('✅ Đã hiển thị kết quả cắt ảnh!', 'success');
                    }
                });
                
                const retryFailedBtn = document.getElementById('retryFailedBtn');
                if (retryFailedBtn) this.safeAddEventListener(retryFailedBtn, 'click', () => this.retryFailedFiles());
                
                // DPI change listener - update file list when DPI changes
                const customDPI = document.getElementById('customDPI');
                if (customDPI) this.safeAddEventListener(customDPI, 'change', () => {
                    console.log('📐 DPI changed, updating file list display');
                    this.renderFileList(); // Re-render to show updated cm calculations
                });

                // PDF Modal events
                const closePdfModal = document.getElementById('closePdfModal');
                if (closePdfModal) this.safeAddEventListener(closePdfModal, 'click', () => this.hidePdfModal());
                
                const cancelPdf = document.getElementById('cancelPdf');
                if (cancelPdf) this.safeAddEventListener(cancelPdf, 'click', () => this.hidePdfModal());
                
                const generatePdf = document.getElementById('generatePdf');
                if (generatePdf) this.safeAddEventListener(generatePdf, 'click', () => this.generatePDF());
                
                // Close modal when clicking outside
                const pdfModal = document.getElementById('pdfModal');
                if (pdfModal) {
                    this.safeAddEventListener(pdfModal, 'click', (e) => {
                        if (e.target.id === 'pdfModal') this.hidePdfModal();
                    });
                }

                // Crop Modal events
                const closeCropModal = document.getElementById('closeCropModal');
                if (closeCropModal) this.safeAddEventListener(closeCropModal, 'click', () => this.hideCropModal());
                
                const cancelCrop = document.getElementById('cancelCrop');
                if (cancelCrop) this.safeAddEventListener(cancelCrop, 'click', () => this.hideCropModal());
                
                const startCropping = document.getElementById('startCropping');
                if (startCropping) this.safeAddEventListener(startCropping, 'click', () => this.startCropping());
                
                const cropModal = document.getElementById('cropModal');
                if (cropModal) {
                    this.safeAddEventListener(cropModal, 'click', (e) => {
                        if (e.target.id === 'cropModal') this.hideCropModal();
                    });
                }

                // Template card click handlers
                this.initializeCropTemplateHandlers();
                
                const cropWidth = document.getElementById('cropWidth');
                if (cropWidth) {
                    this.safeAddEventListener(cropWidth, 'input', () => {
                        this.updateSizeDetails();
                        this.updateCropInfo();
                    });
                }
                
                const cropHeight = document.getElementById('cropHeight');
                if (cropHeight) {
                    this.safeAddEventListener(cropHeight, 'input', () => {
                        this.updateSizeDetails();
                        this.updateCropInfo();
                    });
                }
                
                const cropDPI = document.getElementById('cropDPI');
                if (cropDPI) {
                    this.safeAddEventListener(cropDPI, 'change', () => {
                        this.updateSizeDetails();
                        this.updateCropInfo();
                    });
                }

                // Crop Editor events (with null checks)
                const closeCropEditor = document.getElementById('closeCropEditor');
                if (closeCropEditor) {
                    this.safeAddEventListener(closeCropEditor, 'click', () => this.hideCropEditor());
                }
                
                const acceptCropImage = document.getElementById('acceptCropImage');
                if (acceptCropImage) {
                    this.safeAddEventListener(acceptCropImage, 'click', () => this.acceptCurrentCrop());
                }
                
                const skipCropImage = document.getElementById('skipCropImage');
                if (skipCropImage) {
                    this.safeAddEventListener(skipCropImage, 'click', () => this.skipCurrentCrop());
                }
                
                const prevCropImage = document.getElementById('prevCropImage');
                if (prevCropImage) {
                    prevCropImage.addEventListener('click', () => this.previousCropImage());
                }
                
                const nextCropImage = document.getElementById('nextCropImage');
                if (nextCropImage) {
                    nextCropImage.addEventListener('click', () => this.nextCropImage());
                }
                
                const cropReset = document.getElementById('cropReset');
                if (cropReset) {
                    cropReset.addEventListener('click', () => this.resetCropSelection());
                }
                
                const cropCenter = document.getElementById('cropCenter');
                if (cropCenter) {
                    cropCenter.addEventListener('click', () => this.centerCropSelection());
                }
                
                const cropFit = document.getElementById('cropFit');
                if (cropFit) {
                    cropFit.addEventListener('click', () => this.fitCropSelection());
                }

                // Crop Preview Modal events (with null checks)
                const closePreviewModal = document.getElementById('closePreviewModal');
                if (closePreviewModal) {
                    closePreviewModal.addEventListener('click', () => this.hideCropPreviewModal());
                }
                
                const cancelPreview = document.getElementById('cancelPreview');
                if (cancelPreview) {
                    cancelPreview.addEventListener('click', () => this.hideCropPreviewModal());
                }
                
                const cropAllPreviews = document.getElementById('cropAllPreviews');
                if (cropAllPreviews) {
                    cropAllPreviews.addEventListener('click', () => this.cropAllFromPreviews());
                }
                
                const cropSelectedPreviews = document.getElementById('cropSelectedPreviews');
                if (cropSelectedPreviews) {
                    cropSelectedPreviews.addEventListener('click', () => this.cropSelectedFromPreviews());
                }
                
                const selectAllPreviews = document.getElementById('selectAllPreviews');
                if (selectAllPreviews) {
                    selectAllPreviews.addEventListener('click', () => this.selectAllPreviews());
                }
                
                const clearAllPreviews = document.getElementById('clearAllPreviews');
                if (clearAllPreviews) {
                    clearAllPreviews.addEventListener('click', () => this.clearAllPreviews());
                }

                // Cutting guides toggle functionality
                const cuttingGuidesToggle = document.getElementById('cuttingGuidesToggle');
                const cuttingGuidesConfig = document.getElementById('cuttingGuidesConfig');
                if (cuttingGuidesToggle && cuttingGuidesConfig) {
                    cuttingGuidesToggle.addEventListener('click', () => {
                        const isVisible = cuttingGuidesConfig.style.display !== 'none';
                        cuttingGuidesConfig.style.display = isVisible ? 'none' : 'block';
                        const arrow = cuttingGuidesToggle.querySelector('.toggle-arrow');
                        if (arrow) {
                            arrow.style.transform = isVisible ? 'rotate(-90deg)' : 'rotate(0deg)';
                        }
                    });
                }
                
                const acceptAllPreviews = document.getElementById('acceptAllPreviews');
                if (acceptAllPreviews) {
                    acceptAllPreviews.addEventListener('click', () => this.acceptAllPreviews());
                }

                const cropPreviewModal = document.getElementById('cropPreviewModal');
                if (cropPreviewModal) {
                    cropPreviewModal.addEventListener('click', (e) => {
                        if (e.target.id === 'cropPreviewModal') this.hideCropPreviewModal();
                    });
                }

                // Tab switching functionality
                const convertTab = document.getElementById('convertTab');
                const cropTab = document.getElementById('cropTab');
                const templatesTab = document.getElementById('templatesTab');
                const galleryTab = document.getElementById('galleryTab');
                if (convertTab) {
                    convertTab.addEventListener('click', () => this.switchToTab('convert'));
                }
                if (cropTab) {
                    cropTab.addEventListener('click', () => this.switchToTab('crop'));
                }
                if (templatesTab) {
                    templatesTab.addEventListener('click', () => this.switchToTab('templates'));
                }
                if (galleryTab) {
                    galleryTab.addEventListener('click', () => this.switchToTab('gallery'));
                }
                
                // Template sub-tabs
                const polaroidSubTab = document.getElementById('polaroidSubTab');
                const borderSubTab = document.getElementById('borderSubTab');
                const stripSubTab = document.getElementById('stripSubTab');
                
                if (polaroidSubTab) {
                    polaroidSubTab.addEventListener('click', () => this.switchTemplateSubTab('polaroid'));
                }
                if (borderSubTab) {
                    borderSubTab.addEventListener('click', () => this.switchTemplateSubTab('border'));
                }
                if (stripSubTab) {
                    stripSubTab.addEventListener('click', () => this.switchTemplateSubTab('strip'));
                }
                
                const printTab = document.getElementById('printTab');
                if (printTab) {
                    printTab.addEventListener('click', () => this.switchToTab('print'));
                }

                // Gallery event listeners
                this.initializeGalleryEventListeners();

                // Independent crop file input handler
                const cropFileInput = document.getElementById('cropFileInput');
                if (cropFileInput) {
                    cropFileInput.addEventListener('change', (e) => {
                        try {
                            console.log('Crop file input change event triggered');
                            this.handleCropFileSelect(e.target.files);
                        } catch (error) {
                            console.error('Error in crop file input change handler:', error);
                            this.showToast('Lỗi khi xử lý file crop!', 'error');
                        }
                    });
                }

                // Convert file input handler
                const convertFileInput = document.getElementById('convertFileInput');
                if (convertFileInput) {
                    convertFileInput.addEventListener('change', (e) => {
                        try {
                            console.log('Convert file input change event triggered');
                            this.handleFileSelect(e.target.files);
                        } catch (error) {
                            console.error('Error in convert file input change handler:', error);
                            this.showToast('Lỗi khi xử lý file convert!', 'error');
                        }
                    });
                    convertFileInput.removeAttribute('accept');
                }

                // Crop size selection handlers
                const sizeButtons = document.querySelectorAll('.size-option');
                sizeButtons.forEach(btn => {
                    btn.addEventListener('click', () => this.selectCropSize(btn.dataset.size));
                });

                // Crop ZIP download handlers
                const downloadCropZip = document.getElementById('downloadCropZip');
                if (downloadCropZip) {
                    downloadCropZip.addEventListener('click', () => this.downloadCropAsZip());
                }

                const downloadCropPreviewZip = document.getElementById('downloadCropPreviewZip');
                if (downloadCropPreviewZip) {
                    downloadCropPreviewZip.addEventListener('click', () => this.downloadCropAsZip());
                }

                const downloadCropConfigZip = document.getElementById('downloadCropConfigZip');
                if (downloadCropConfigZip) {
                    downloadCropConfigZip.addEventListener('click', () => this.downloadCropAsZip());
                }

                // Crop section action handlers
                const downloadCroppedAllBtn = document.getElementById('downloadCroppedAllBtn');
                if (downloadCroppedAllBtn) {
                    downloadCroppedAllBtn.addEventListener('click', () => this.downloadAllCroppedFiles());
                }

                const downloadCroppedZipBtn = document.getElementById('downloadCroppedZipBtn');
                if (downloadCroppedZipBtn) {
                    downloadCroppedZipBtn.addEventListener('click', () => this.downloadCropAsZip());
                }

                const cropResultsBtn = document.getElementById('cropResultsBtn');
                if (cropResultsBtn) {
                    cropResultsBtn.addEventListener('click', () => this.showCropResults());
                }

                const cropNewBatchBtn = document.getElementById('cropNewBatchBtn');
                if (cropNewBatchBtn) {
                    cropNewBatchBtn.addEventListener('click', () => this.startNewCropBatch());
                }
            }

            // Tab switching functionality
            switchToTab(tabName) {
                // Remove active class from all tabs and sections
                document.querySelectorAll('.tab-button').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.function-section').forEach(section => {
                    section.classList.remove('active');
                    section.style.display = 'none';
                });

                // Add active class to selected tab and section
                if (tabName === 'convert') {
                    document.getElementById('convertTab').classList.add('active');
                    const convertSection = document.getElementById('convertSection');
                    convertSection.classList.add('active');
                    convertSection.style.display = 'block';
                } else if (tabName === 'crop') {
                    document.getElementById('cropTab').classList.add('active');
                    const cropSection = document.getElementById('cropSection');
                    cropSection.classList.add('active');
                    cropSection.style.display = 'block';
                } else if (tabName === 'templates') {
                    document.getElementById('templatesTab').classList.add('active');
                    const templatesSection = document.getElementById('templatesSection');
                    templatesSection.classList.add('active');
                    templatesSection.style.display = 'block';
                    // Initialize current active template
                    this.initializeActiveTemplate();
                } else if (tabName === 'gallery') {
                    document.getElementById('galleryTab').classList.add('active');
                    const gallerySection = document.getElementById('gallerySection');
                    gallerySection.classList.add('active');
                    gallerySection.style.display = 'block';
                    this.updateGalleryDisplay();
                } else if (tabName === 'print') {
                    document.getElementById('printTab').classList.add('active');
                    const printSection = document.getElementById('printSection');
                    printSection.classList.add('active');
                    printSection.style.display = 'block';
                    this.initializePrintSection();
                }
            }

            // Crop size selection
            selectCropSize(sizeValue) {
                // Remove active class from all size buttons
                document.querySelectorAll('.size-option').forEach(btn => btn.classList.remove('active'));
                
                // Add active class to selected button
                const selectedBtn = document.querySelector(`[data-size="${sizeValue}"]`);
                if (selectedBtn) {
                    selectedBtn.classList.add('active');
                }

                // Show/hide custom input
                const customSizeInput = document.getElementById('customSizeInput');
                if (sizeValue === 'custom') {
                    customSizeInput.style.display = 'block';
                } else {
                    customSizeInput.style.display = 'none';
                    
                    // Set predefined values
                    if (sizeValue === '5.5x8.5') {
                        this.currentCropSize = { width: 5.5, height: 8.5 };
                    } else if (sizeValue === '3x4') {
                        this.currentCropSize = { width: 3, height: 4 };
                    } else if (sizeValue === '4x6') {
                        this.currentCropSize = { width: 4, height: 6 };
                    }
                }
            }

            // Handle crop file selection (independent workflow) - Updated 2025-08-19
            async handleCropFileSelect(files) {
                console.log('Processing crop files:', files.length);
                
                if (!files || files.length === 0) {
                    console.log('No files selected for cropping');
                    return;
                }

                // Get current crop size
                let cropSize = this.currentCropSize || { width: 5.5, height: 8.5 };
                
                // Check if custom size is selected
                const customSizeInput = document.getElementById('customSizeInput');
                if (customSizeInput && customSizeInput.style.display !== 'none') {
                    const customWidth = parseFloat(document.getElementById('customWidth').value);
                    const customHeight = parseFloat(document.getElementById('customHeight').value);
                    if (customWidth > 0 && customHeight > 0) {
                        cropSize = { width: customWidth, height: customHeight };
                    }
                }

                // Automatically detect image orientation and adapt crop ratio
                if (files.length > 0) {
                    const firstFile = files[0];
                    const imageOrientation = await this.detectImageOrientation(firstFile);
                    cropSize = this.adaptCropSizeToOrientation(cropSize, imageOrientation);
                    console.log('Adapted crop size for orientation:', imageOrientation, cropSize);
                }

                console.log('Using crop size:', cropSize);

                // Validate files
                const validFiles = [];
                for (let file of files) {
                    const isValid = await this.validateImageFile(file);
                    if (isValid) {
                        validFiles.push(file);
                    } else {
                        console.log('Invalid image file:', file.name);
                        this.showToast(`File không hợp lệ: ${file.name}`, 'error');
                    }
                }

                if (validFiles.length === 0) {
                    this.showToast('Không có file ảnh hợp lệ nào được chọn!', 'error');
                    return;
                }

                // Set crop mode and size
                this.currentCropMode = 'template';
                this.currentCropSize = cropSize;
                
                // Update crop modal with size info
                document.getElementById('cropWidth').value = cropSize.width;
                document.getElementById('cropHeight').value = cropSize.height;
                
                // Create simplified file data objects for cropping
                this.files = [];
                for (let index = 0; index < validFiles.length; index++) {
                    const file = validFiles[index];
                    
                    const fileData = {
                        id: `file_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`,
                        file: file,
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        hash: `hash_${Date.now()}_${index}`, // Simplified hash
                        lastModified: file.lastModified,
                        quality: { score: 80, issues: [] }, // Default quality
                        status: 'pending'
                    };
                    
                    this.files.push(fileData);
                }

                if (this.files.length > 0) {
                    // Update stats
                    this.updateStats();
                    
                    // Show crop actions
                    this.showCropActions();
                    
                    // Show crop modal directly
                    this.showCropModal();
                    this.showToast(`Đã load ${this.files.length} ảnh để crop`, 'success');
                } else {
                    this.showToast('Không thể xử lý file ảnh nào!', 'error');
                }
            }

            // Show crop actions bar
            showCropActions() {
                const cropActions = document.getElementById('cropActions');
                if (cropActions) {
                    cropActions.style.display = 'block';
                }
            }

            // Hide crop actions bar
            hideCropActions() {
                const cropActions = document.getElementById('cropActions');
                if (cropActions) {
                    cropActions.style.display = 'none';
                }
            }

            // Download all cropped files individually
            async downloadAllCroppedFiles() {
                console.log('🎯 downloadAllCroppedFiles called');
                console.log('📊 cropProcessedFiles:', this.cropProcessedFiles);
                console.log('📊 cropData.croppedImages:', this.cropData?.croppedImages);
                
                // Auto-sync first to ensure data is available
                this.syncCropProcessedFiles();
                
                // Also check alternative source from cropData
                const sourceFiles = this.cropProcessedFiles && this.cropProcessedFiles.length > 0 
                    ? this.cropProcessedFiles 
                    : this.cropData?.croppedImages || [];
                
                if (sourceFiles.length === 0) {
                    this.showToast('Chưa có ảnh nào được cắt! Hãy cắt ảnh trước khi tải về.', 'error');
                    return;
                }

                // Prevent multiple downloads
                if (this.isDownloadingCropped) {
                    this.showToast('⏳ Đang tải ảnh đã cắt... Vui lòng chờ!', 'warning');
                    return;
                }

                this.isDownloadingCropped = true;
                this.showToast(`Đang tải về ${sourceFiles.length} ảnh đã cắt từng file...`, 'success');

                // Fast batch download for cropped files
                const downloadedNames = new Set(); // Prevent duplicate names
                let downloadedCount = 0;
                const totalCount = sourceFiles.length;
                
                // Process in batches of 4 files to avoid browser limits
                const batchSize = 4;
                
                for (let i = 0; i < sourceFiles.length; i += batchSize) {
                    const batch = sourceFiles.slice(i, i + batchSize);
                    
                    // Process current batch in parallel
                    const batchPromises = batch.map((processedFile, indexInBatch) => {
                        return new Promise((resolve) => {
                            setTimeout(() => {
                                const fileBlob = processedFile.blob || processedFile.croppedBlob;
                                const fileName = processedFile.name || processedFile.croppedName;
                                
                                if (processedFile && fileBlob && !downloadedNames.has(fileName)) {
                                    downloadedNames.add(fileName);
                                    
                                    const url = this.safeCreateObjectURL(fileBlob);
                                    if (url) {
                                        const a = document.createElement('a');
                                        a.href = url;
                                        a.download = fileName;
                                        a.setAttribute('rel', 'noopener noreferrer');
                                        document.body.appendChild(a);
                                        a.click();
                                        document.body.removeChild(a);
                                        
                                        // Safe cleanup with delay
                                        this.safeSetTimeout(() => this.safeRevokeObjectURL(url), 1000);
                                        
                                        downloadedCount++;
                                        console.log(`📥 Downloaded cropped file ${downloadedCount}/${totalCount}: ${fileName}`);
                                    }
                                }
                                resolve();
                            }, indexInBatch * 50); // 50ms delay within batch
                        });
                    });
                    
                    // Wait for current batch to complete before starting next batch
                    await Promise.all(batchPromises);
                    
                    // Small delay between batches
                    if (i + batchSize < sourceFiles.length) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }

                this.isDownloadingCropped = false;
                this.showToast('✅ Đã tải về tất cả ảnh đã cắt từng file riêng lẻ!', 'success');
            }

            // Sync cropData to cropProcessedFiles automatically
            syncCropProcessedFiles() {
                console.log('🔄 Syncing cropProcessedFiles...');
                
                // If cropProcessedFiles is empty but we have cropData.croppedImages, sync them
                if ((!this.cropProcessedFiles || this.cropProcessedFiles.length === 0) 
                    && this.cropData?.croppedImages?.length > 0) {
                    
                    console.log('📋 Auto-syncing from cropData.croppedImages:', this.cropData.croppedImages.length);
                    this.cropProcessedFiles = [];
                    
                    for (const croppedImage of this.cropData.croppedImages) {
                        this.cropProcessedFiles.push({
                            blob: croppedImage.croppedBlob,
                            name: croppedImage.croppedName,
                            size: croppedImage.croppedBlob.size
                        });
                    }
                    
                    console.log('✅ Synced to cropProcessedFiles:', this.cropProcessedFiles.length);
                }
            }

            // Show crop results summary
            showCropResults() {
                // Auto-sync first
                this.syncCropProcessedFiles();
                
                if (!this.cropProcessedFiles || this.cropProcessedFiles.length === 0) {
                    this.showToast('Chưa có ảnh nào được cắt!', 'error');
                    return;
                }

                const totalSize = this.cropProcessedFiles.reduce((sum, file) => sum + (file.blob?.size || 0), 0);
                const averageSize = (totalSize / this.cropProcessedFiles.length / 1024).toFixed(1);
                
                this.showToast(`📊 Kết quả cắt: ${this.cropProcessedFiles.length} ảnh, trung bình ${averageSize}KB/ảnh`, 'success');
            }

            // Start new crop batch
            startNewCropBatch() {
                this.files = [];
                this.cropProcessedFiles = [];
                this.hideCropActions();
                this.updateStats();
                this.showToast('🔄 Đã reset để cắt batch mới. Hãy chọn ảnh mới!', 'success');
            }

            // Download cropped images as ZIP
            async downloadCropAsZip() {
                // Check if there are cropped files to download
                if (!this.cropProcessedFiles || this.cropProcessedFiles.length === 0) {
                    this.showToast('Chưa có ảnh nào được cắt! Hãy cắt ảnh trước khi tải về.', 'error');
                    return;
                }

                this.showToast('Đang tạo file ZIP chứa ảnh đã cắt...', 'success');

                try {
                    // Disable ZIP buttons during processing
                    const zipBtn = document.getElementById('downloadCropZip');
                    const previewZipBtn = document.getElementById('downloadCropPreviewZip');
                    const configZipBtn = document.getElementById('downloadCropConfigZip');
                    const croppedZipBtn = document.getElementById('downloadCroppedZipBtn');
                    
                    if (zipBtn) {
                        zipBtn.disabled = true;
                        zipBtn.textContent = '📦 Đang tạo ZIP...';
                    }
                    if (previewZipBtn) {
                        previewZipBtn.disabled = true;
                        previewZipBtn.textContent = '📦 Đang tạo ZIP...';
                    }
                    if (configZipBtn) {
                        configZipBtn.disabled = true;
                        configZipBtn.textContent = '📦 Đang tạo ZIP...';
                    }
                    if (croppedZipBtn) {
                        croppedZipBtn.disabled = true;
                        croppedZipBtn.textContent = '📦 Đang tạo ZIP...';
                    }

                    // Prepare files for safe ZIP generation
                    const files = [];
                    for (let index = 0; index < this.cropProcessedFiles.length; index++) {
                        const processedFile = this.cropProcessedFiles[index];
                        if (processedFile && processedFile.blob) {
                            files.push({
                                filename: processedFile.name,
                                data: processedFile.blob
                            });
                        }
                    }

                    const zipName = `cropped_images_${new Date().getFullYear()}-${(new Date().getMonth() + 1).toString().padStart(2, '0')}-${new Date().getDate().toString().padStart(2, '0')}.zip`;
                    
                    // Generate safe ZIP
                    const zipBlob = await this.createSafeZip(
                        files,
                        zipName,
                        'Safe cropped images archive - Created by MEU Layout'
                    );

                    // Download safely
                    this.downloadSafeZip(zipBlob, zipName);

                    this.showToast(`✅ Đã tải về ${this.cropProcessedFiles.length} ảnh đã cắt dưới dạng ZIP!`, 'success');

                } catch (error) {
                    console.error('Error creating crop ZIP:', error);
                    this.showToast('❌ Lỗi khi tạo file ZIP!', 'error');
                } finally {
                    // Re-enable ZIP buttons
                    const zipBtn = document.getElementById('downloadCropZip');
                    const previewZipBtn = document.getElementById('downloadCropPreviewZip');
                    const configZipBtn = document.getElementById('downloadCropConfigZip');
                    const croppedZipBtn = document.getElementById('downloadCroppedZipBtn');
                    
                    if (zipBtn) {
                        zipBtn.disabled = false;
                        zipBtn.textContent = '📦 Tải ZIP';
                    }
                    if (previewZipBtn) {
                        previewZipBtn.disabled = false;
                        previewZipBtn.textContent = '📦 Tải ZIP';
                    }
                    if (configZipBtn) {
                        configZipBtn.disabled = false;
                        configZipBtn.textContent = '📦 Tải ZIP';
                    }
                    if (croppedZipBtn) {
                        croppedZipBtn.disabled = false;
                        croppedZipBtn.textContent = '📦 Tải về ZIP';
                    }
                }
            }

            // Advanced image file validation
            // Detect image orientation (landscape/portrait) from first image
            async detectImageOrientation(file) {
                return new Promise((resolve) => {
                    const img = new Image();
                    const url = this.safeCreateObjectURL(file);
                    
                    if (!url) {
                        this.handleError(new Error('Failed to create URL for orientation detection'), 'detectImageOrientation');
                        resolve('portrait');
                        return;
                    }
                    
                    img.onload = () => {
                        try {
                            const orientation = img.width > img.height ? 'landscape' : 'portrait';
                            console.log(`Image orientation detected: ${orientation} (${img.width}×${img.height})`);
                            this.safeRevokeObjectURL(url);
                            resolve(orientation);
                        } catch (error) {
                            this.handleError(error, 'detectImageOrientation-onload');
                            this.safeRevokeObjectURL(url);
                            resolve('portrait');
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.warn('Failed to detect orientation, defaulting to portrait');
                        this.handleError(error, 'detectImageOrientation-onerror', false);
                        this.safeRevokeObjectURL(url);
                        resolve('portrait');
                    };
                    
                    img.src = url;
                });
            }

            // Adapt crop size based on image orientation
            adaptCropSizeToOrientation(originalCropSize, imageOrientation) {
                const { width, height } = originalCropSize;
                
                // Calculate original crop ratio
                const cropRatio = width / height;
                const isOriginalLandscape = cropRatio > 1;
                const isImageLandscape = imageOrientation === 'landscape';
                
                // If orientations match, keep original
                if (isOriginalLandscape === isImageLandscape) {
                    return originalCropSize;
                }
                
                // If orientations don't match, swap dimensions
                if (isImageLandscape && !isOriginalLandscape) {
                    // Image is landscape but crop is portrait -> make crop landscape
                    return { width: height, height: width };
                } else if (!isImageLandscape && isOriginalLandscape) {
                    // Image is portrait but crop is landscape -> make crop portrait  
                    return { width: height, height: width };
                }
                
                return originalCropSize;
            }

            // Detect image orientation from file data (for multi-crop)
            async detectImageOrientationFromFileData(fileData) {
                return new Promise((resolve) => {
                    const img = new Image();
                    const url = this.safeCreateObjectURL(fileData.convertedBlob);
                    
                    if (!url) {
                        this.handleError(new Error('Failed to create URL for file data orientation detection'), 'detectImageOrientationFromFileData');
                        resolve('portrait');
                        return;
                    }
                    
                    img.onload = () => {
                        try {
                            const orientation = img.width > img.height ? 'landscape' : 'portrait';
                            console.log(`File ${fileData.name}: ${orientation} (${img.width}×${img.height})`);
                            this.safeRevokeObjectURL(url);
                            resolve(orientation);
                        } catch (error) {
                            this.handleError(error, 'detectImageOrientationFromFileData-onload');
                            this.safeRevokeObjectURL(url);
                            resolve('portrait');
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.warn(`Failed to detect orientation for ${fileData.name}, defaulting to portrait`);
                        this.handleError(error, 'detectImageOrientationFromFileData-onerror', false);
                        this.safeRevokeObjectURL(url);
                        resolve('portrait');
                    };
                    
                    img.src = url;
                });
            }

            async validateImageFile(file) {
                console.log('Validating file:', file.name, 'MIME type:', file.type);
                
                // First check MIME type (for files with correct extensions)
                if (file.type && file.type.startsWith('image/')) {
                    console.log('File passed MIME type validation:', file.type);
                    return true;
                }
                
                // Also accept files with common image extensions even without MIME type
                const fileName = file.name.toLowerCase();
                const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.tif', '.heic', '.heif'];
                if (imageExtensions.some(ext => fileName.endsWith(ext))) {
                    console.log('File passed extension validation:', fileName);
                    return true;
                }
                
                // For files without proper MIME type, check file signatures
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const arr = new Uint8Array(e.target.result);
                        const isImage = this.checkImageSignature(arr);
                        console.log('File signature validation result:', isImage, 'for', file.name);
                        resolve(isImage);
                    };
                    reader.onerror = (error) => {
                        console.error('Error reading file for validation:', error);
                        resolve(false);
                    };
                    // Read first 20 bytes to check file signature
                    reader.readAsArrayBuffer(file.slice(0, 20));
                });
            }

            // Check file signature (magic numbers) to identify image files
            checkImageSignature(uint8Array) {
                const signatures = {
                    // JPEG signatures - more comprehensive
                    jpeg1: [0xFF, 0xD8, 0xFF, 0xE0],  // JFIF
                    jpeg2: [0xFF, 0xD8, 0xFF, 0xE1],  // EXIF
                    jpeg3: [0xFF, 0xD8, 0xFF, 0xE2],  // Canon
                    jpeg4: [0xFF, 0xD8, 0xFF, 0xE3],  // Samsung
                    jpeg5: [0xFF, 0xD8, 0xFF, 0xE8],  // SPIFF
                    jpeg6: [0xFF, 0xD8, 0xFF, 0xDB],  // Quantization tables
                    jpeg7: [0xFF, 0xD8, 0xFF, 0xC0],  // Start of Frame
                    jpeg8: [0xFF, 0xD8, 0xFF, 0xC2],  // Progressive JPEG
                    jpeg9: [0xFF, 0xD8, 0xFF, 0xC4],  // Huffman tables
                    jpeg10: [0xFF, 0xD8, 0xFF, 0xED], // Photoshop JPEG
                    jpeg11: [0xFF, 0xD8, 0xFF, 0xEE], // Adobe JPEG
                    jpeg_simple: [0xFF, 0xD8],        // Basic JPEG (2 bytes)
                    
                    // PNG signature
                    png: [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A],
                    
                    // GIF signatures
                    gif87a: [0x47, 0x49, 0x46, 0x38, 0x37, 0x61],
                    gif89a: [0x47, 0x49, 0x46, 0x38, 0x39, 0x61],
                    
                    // BMP signature
                    bmp: [0x42, 0x4D],
                    
                    // TIFF signatures
                    tiff1: [0x49, 0x49, 0x2A, 0x00],  // Little endian
                    tiff2: [0x4D, 0x4D, 0x00, 0x2A],  // Big endian
                    
                    // WebP signature (check first 4 bytes for RIFF)
                    webp: [0x52, 0x49, 0x46, 0x46],
                    
                    // ICO signature
                    ico: [0x00, 0x00, 0x01, 0x00],
                    cur: [0x00, 0x00, 0x02, 0x00],    // Cursor files
                    
                    // PSD signature
                    psd: [0x38, 0x42, 0x50, 0x53],
                    
                    // HEIC signatures
                    heic1: [0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63], // ftyp heic
                    heic2: [0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63], // ftyp heic (variant)
                    heic3: [0x00, 0x00, 0x00, 0x1C, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63], // ftyp heic (variant)
                    heif: [0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x66],  // ftyp heif
                    
                    // Additional formats for better detection
                    
                    // AVIF
                    avif: [0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66],
                    
                    // SVG (XML-based, check for '<svg' or '<?xml')
                    svg1: [0x3C, 0x73, 0x76, 0x67],   // <svg
                    svg2: [0x3C, 0x3F, 0x78, 0x6D, 0x6C] // <?xml
                };

                // Check each signature
                for (const [format, signature] of Object.entries(signatures)) {
                    if (this.matchesSignature(uint8Array, signature)) {
                        return true;
                    }
                }
                
                // Special check for WebP (need to check WEBP string at offset 8)
                if (uint8Array.length >= 12) {
                    const webpCheck = Array.from(uint8Array.slice(8, 12));
                    if (webpCheck[0] === 0x57 && webpCheck[1] === 0x45 && 
                        webpCheck[2] === 0x42 && webpCheck[3] === 0x50) {
                        return true;
                    }
                }
                
                return false;
            }

            // Helper function to match file signature
            matchesSignature(uint8Array, signature) {
                if (uint8Array.length < signature.length) return false;
                
                for (let i = 0; i < signature.length; i++) {
                    if (uint8Array[i] !== signature[i]) {
                        return false;
                    }
                }
                return true;
            }

            // Generate file hash for duplicate detection
            async generateFileHash(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const buffer = e.target.result;
                        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                        resolve(hashHex);
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            // Advanced image quality analysis
            async analyzeImageQuality(file) {
                return new Promise(async (resolve) => {
                    try {
                        let img;
                        
                        // Handle HEIC files differently - be more specific
                        const fileName = file.name.toLowerCase();
                        const isHEIC = (fileName.endsWith('.heic') || fileName.endsWith('.heif')) && 
                                       (!file.type || !file.type.startsWith('image/') || 
                                        file.type === 'image/heic' || file.type === 'image/heif');
                        
                        console.log('Quality analysis - File:', fileName, 'Type:', file.type, 'isHEIC:', isHEIC);
                        
                        if (isHEIC && typeof heic2any !== 'undefined') {
                            // Convert HEIC to blob first for analysis
                            const convertedBlob = await heic2any({
                                blob: file,
                                toType: 'image/jpeg',
                                quality: 0.95
                            });
                            const url = URL.createObjectURL(convertedBlob);
                            
                            img = new Image();
                            img.onload = () => {
                                URL.revokeObjectURL(url);
                                this.performQualityAnalysis(img, file, resolve);
                            };
                            img.onerror = () => {
                                URL.revokeObjectURL(url);
                                this.returnDefaultAnalysis(file, resolve);
                            };
                            img.src = url;
                        } else {
                            // Regular image files
                            img = new Image();
                            img.onload = () => {
                                this.performQualityAnalysis(img, file, resolve);
                            };
                            img.onerror = () => {
                                this.returnDefaultAnalysis(file, resolve);
                            };
                            img.src = URL.createObjectURL(file);
                        }
                    } catch (error) {
                        console.error('Quality analysis error:', error);
                        this.returnDefaultAnalysis(file, resolve);
                    }
                });
            }
            
            performQualityAnalysis(img, file, resolve) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                        
                // Get image data for analysis
                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                const data = imageData.data;
                
                const analysis = {
                    width: img.width,
                    height: img.height,
                    totalPixels: img.width * img.height,
                    fileSize: file.size,
                    format: this.detectOriginalFormat(file),
                    hasTransparency: this.detectTransparency(data),
                    colorComplexity: this.calculateColorComplexity(data),
                    compressionArtifacts: this.detectCompressionArtifacts(data, img.width, img.height),
                    recommendedFormat: null,
                    qualityScore: 0
                };
                
                // Calculate quality metrics
                analysis.qualityScore = this.calculateQualityScore(analysis);
                analysis.recommendedFormat = this.recommendOptimalFormat(analysis);
                
                resolve(analysis);
            }
            
            returnDefaultAnalysis(file, resolve) {
                resolve({
                    width: 0, height: 0, totalPixels: 0,
                    fileSize: file.size, format: this.detectOriginalFormat(file),
                    hasTransparency: false, colorComplexity: 8,
                    compressionArtifacts: 0, qualityScore: 85,
                    recommendedFormat: 'jpeg'
                });
            }

            // Detect original image format from file signature
            detectOriginalFormat(file) {
                // Check file extension first for HEIC/HEIF
                const fileName = file.name.toLowerCase();
                if (fileName.endsWith('.heic')) return 'heic';
                if (fileName.endsWith('.heif')) return 'heif';
                
                // Then check MIME type
                if (file.type) {
                    const format = file.type.split('/')[1];
                    if (format === 'heic' || format === 'heif') return format;
                    return format || 'unknown';
                }
                
                // Fallback to extension detection
                if (fileName.endsWith('.jpg') || fileName.endsWith('.jpeg')) return 'jpeg';
                if (fileName.endsWith('.png')) return 'png';
                if (fileName.endsWith('.webp')) return 'webp';
                if (fileName.endsWith('.bmp')) return 'bmp';
                if (fileName.endsWith('.gif')) return 'gif';
                
                return 'unknown';
            }

            // Detect transparency in image
            detectTransparency(data) {
                for (let i = 3; i < data.length; i += 4) {
                    if (data[i] < 255) {
                        return true; // Found transparent/semi-transparent pixel
                    }
                }
                return false;
            }

            // Calculate color complexity (entropy-like measure)
            calculateColorComplexity(data) {
                const colorFreq = new Map();
                const totalPixels = data.length / 4;
                
                // Sample every 4th pixel for performance
                for (let i = 0; i < data.length; i += 16) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const color = (r << 16) | (g << 8) | b;
                    
                    colorFreq.set(color, (colorFreq.get(color) || 0) + 1);
                }
                
                // Calculate entropy-like score
                let entropy = 0;
                const sampleSize = Math.floor(totalPixels / 4);
                
                for (const freq of colorFreq.values()) {
                    const probability = freq / sampleSize;
                    if (probability > 0) {
                        entropy -= probability * Math.log2(probability);
                    }
                }
                
                return Math.min(entropy, 15); // Normalize to 0-15 range
            }

            // Detect compression artifacts (basic JPEG blockiness detection)
            detectCompressionArtifacts(data, width, height) {
                let blockiness = 0;
                const blockSize = 8; // JPEG uses 8x8 blocks
                
                // Sample some 8x8 blocks
                for (let y = 0; y < height - blockSize; y += blockSize * 2) {
                    for (let x = 0; x < width - blockSize; x += blockSize * 2) {
                        // Check horizontal discontinuity at block boundary
                        const leftIdx = (y * width + x + blockSize - 1) * 4;
                        const rightIdx = (y * width + x + blockSize) * 4;
                        
                        if (leftIdx >= 0 && rightIdx < data.length - 3) {
                            const leftBrightness = (data[leftIdx] + data[leftIdx + 1] + data[leftIdx + 2]) / 3;
                            const rightBrightness = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;
                            blockiness += Math.abs(leftBrightness - rightBrightness);
                        }
                    }
                }
                
                return Math.min(blockiness / 1000, 100); // Normalize
            }

            // Calculate overall quality score - NO SIZE BIAS
            calculateQualityScore(analysis) {
                let score = 100;
                
                // Penalize compression artifacts
                score -= analysis.compressionArtifacts * 0.5;
                
                // NO resolution rewards - all sizes are equally valid
                
                // Penalize low file size relative to dimensions (over-compression)
                const bytesPerPixel = analysis.fileSize / analysis.totalPixels;
                if (bytesPerPixel < 0.5) score -= 15; // Heavily compressed
                else if (bytesPerPixel < 1) score -= 10;
                else if (bytesPerPixel < 2) score -= 5;
                
                // Reward color complexity (more detail)
                score += analysis.colorComplexity;
                
                return Math.max(0, Math.min(100, Math.round(score)));
            }

            // Recommend optimal format based on analysis - NO SIZE CONSIDERATIONS
            recommendOptimalFormat(analysis) {
                // PNG for transparency or low color complexity (graphics/logos)
                if (analysis.hasTransparency) return 'png';
                if (analysis.colorComplexity < 8) return 'png';
                
                // WebP for modern browsers - ALL SIZES supported
                if (this.supportsWebP() && analysis.colorComplexity > 8) return 'webp';
                
                // JPEG for photos with high color complexity
                if (analysis.colorComplexity > 10) return 'jpeg';
                
                // Default to JPEG
                return 'jpeg';
            }

            // Check WebP support
            supportsWebP() {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 1;
                return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
            }

            // Fixed drag over handler
            handleDragOver(e) {
                e.preventDefault();
                e.currentTarget.classList.add('dragover');
            }

            handleDragLeave(e) {
                e.currentTarget.classList.remove('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('dragover');
                this.handleFileSelect(e.dataTransfer.files);
            }

            async handleFileSelect(fileList) {
                try {
                    console.log('🔥 Gọi handleFileSelect với', fileList?.length || 0, 'file(s)');
                    const files = Array.from(fileList);
                    const validFiles = [];
                    const invalidFiles = [];
                    const duplicateFiles = [];
                    
                    // Show upload progress overlay
                    if (files.length > 0) {
                        this.showUploadProgress(files.length);
                    }
                    
                    // Process each file with single progress tracking
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        
                        console.log('🔄 Đang xử lý file:', file.name, 'Định dạng:', file.type, 'Kích thước:', file.size);
                        
                        this.updateSingleUploadProgress(file.name, 'Đang validate...', i, 20);
                        const isValid = await this.validateImageFile(file);
                        console.log('✅ Kết quả xác thực file cho', file.name, ':', isValid);
                        
                        if (isValid) {
                            this.updateSingleUploadProgress(file.name, 'Đang tạo hash...', i, 50);
                            // Generate unique file hash for duplicate detection
                            const fileHash = await this.generateFileHash(file);
                            
                            this.updateSingleUploadProgress(file.name, 'Kiểm tra trùng lặp...', i, 70);
                            // Check for duplicates
                            const existingFile = this.files.find(f => f.hash === fileHash);
                            if (existingFile) {
                                duplicateFiles.push(file.name);
                                this.updateSingleUploadProgress(file.name, '⚠️ File trùng lặp', i, 100);
                                continue;
                            }
                            
                            validFiles.push({file, hash: fileHash});
                            this.updateSingleUploadProgress(file.name, '✅ Hợp lệ', i, 100);
                        } else {
                            invalidFiles.push(file.name);
                            this.updateSingleUploadProgress(file.name, '❌ Không hợp lệ', i, 100);
                        }
                    }
                    
                    if (validFiles.length === 0) {
                        let message = 'Không tìm thấy file ảnh hợp lệ!';
                        if (duplicateFiles.length > 0) {
                            message += ` (${duplicateFiles.length} file trùng lặp)`;
                        }
                        this.showToast(message, 'error');
                        this.hideUploadProgress();
                        return;
                    }

                    // Analyze each valid file and create file data with quality info
                    for (let index = 0; index < validFiles.length; index++) {
                        const fileInfo = validFiles[index];
                        const file = fileInfo.file;
                        
                        // Calculate actual file index in total files (not just valid files)
                        const totalFileIndex = files.findIndex(f => f.name === file.name);
                        
                        this.updateSingleUploadProgress(file.name, 'Phân tích chất lượng...', totalFileIndex, 80);
                        
                        // Analyze image quality
                        const qualityAnalysis = await this.analyzeImageQuality(file);
                        
                        this.updateSingleUploadProgress(file.name, '✅ Hoàn thành', totalFileIndex, 100);
                        
                        const fileData = {
                            id: `file_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`, // Unique ID
                            file: file,
                            name: file.name,
                            size: file.size,
                            status: 'pending',
                            convertedBlob: null,
                            convertedName: null,
                            isImageFile: true,
                            hash: fileInfo.hash,
                            originalIndex: this.files.length + index, // Track order
                            qualityAnalysis: qualityAnalysis // Store quality analysis
                        };
                        this.files.push(fileData);
                    }

                    this.renderFileList();
                    this.updateStats();
                    this.updateControls();
                    
                    // Complete upload progress
                    this.completeUploadProgress();
                    
                    let message = `Đã thêm ${validFiles.length} file ảnh!`;
                    if (invalidFiles.length > 0) {
                        message += ` (Bỏ qua ${invalidFiles.length} file không phải ảnh)`;
                    }
                    this.showToast(message);
                    
                } catch (error) {
                    this.handleError(error, 'handleFileSelect');
                    this.completeUploadProgress(); // Ensure progress overlay is hidden
                } finally {
                    // Always update UI state
                    this.updateStats();
                    this.updateControls();
                }
            }

            getFileIcon(fileData) {
                if (fileData.status === 'success') return '✅';
                if (fileData.status === 'error') return '❌';
                if (fileData.status === 'processing') return '⏳';
                return '🖼️';
            }

            renderFileList() {
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';

                this.files.forEach(fileData => {
                    const fileItem = this.createFileItem(fileData);
                    fileList.appendChild(fileItem);
                });
            }

            createFileItem(fileData) {
                const item = document.createElement('div');
                item.className = 'file-item';
                
                const statusClass = {
                    pending: 'pending',
                    processing: 'converting', 
                    success: 'success',
                    error: 'error'
                }[fileData.status];

                // Create image preview
                const previewContent = this.createImagePreview(fileData);
                
                // Generate dimensions info with cm calculation
                let dimensionsInfo = '';
                if (fileData.qualityAnalysis) {
                    const analysis = fileData.qualityAnalysis;
                    const pixels = `${analysis.width}×${analysis.height}px`;
                    
                    // Calculate physical dimensions in cm (get DPI from current setting)
                    const dpiSelect = document.getElementById('customDPI');
                    const dpi = dpiSelect ? parseInt(dpiSelect.value) || 300 : 300;
                    const widthCm = (analysis.width / dpi * 2.54).toFixed(1);
                    const heightCm = (analysis.height / dpi * 2.54).toFixed(1);
                    const physicalSize = `${widthCm}×${heightCm}cm`;
                    
                    dimensionsInfo = `${pixels} • ${physicalSize} @ ${dpi} DPI`;
                }

                // Show conversion info for successful conversions
                let conversionInfo = '';
                if (fileData.status === 'success' && fileData.actualFormat) {
                    const qualityPercent = Math.round((fileData.usedQuality || 1) * 100);
                    conversionInfo = `➜ ${fileData.actualFormat.toUpperCase()} (${qualityPercent}%)`;
                }

                item.innerHTML = `
                    <div class="file-preview">
                        ${previewContent}
                    </div>
                    <div class="file-content">
                        <div class="file-header">
                            <div class="file-info">
                                <div class="file-name" title="${fileData.name}">${fileData.name}</div>
                            </div>
                        </div>
                        <div class="file-meta">
                            <div class="file-size">${this.formatFileSize(fileData.size)}</div>
                            <div class="file-status ${statusClass}">
                                ${this.getStatusText(fileData.status)}
                            </div>
                        </div>
                        ${dimensionsInfo ? `<div class="file-dimensions">${dimensionsInfo}</div>` : ''}
                        ${conversionInfo ? `<div class="conversion-info">${conversionInfo}</div>` : ''}
                        
                        <!-- Progress bar for conversion -->
                        <div class="file-progress ${fileData.status === 'processing' ? 'show' : ''}" id="progress-${fileData.id}">
                            <div class="progress-bar">
                                <div class="progress-fill" id="progress-fill-${fileData.id}"></div>
                            </div>
                            <div class="progress-text" id="progress-text-${fileData.id}">Đang xử lý...</div>
                            <div class="progress-time" id="progress-time-${fileData.id}"></div>
                        </div>
                        
                        <div class="file-actions">
                            <button class="file-action-btn download" ${fileData.status !== 'success' ? 'disabled' : ''} 
                                    onclick="converter.showPreview('${fileData.id}')">
                                👁️ Preview
                            </button>
                            <button class="file-action-btn delete" onclick="converter.removeFile('${fileData.id}')">
                                Xóa
                            </button>
                        </div>
                    </div>
                `;

                return item;
            }

            createImagePreview(fileData) {
                // Check if it's an image file (including HEIC/HEIF)
                const fileName = fileData.file.name.toLowerCase();
                const isImageFile = fileData.file.type.startsWith('image/') || 
                                   fileName.endsWith('.heic') || 
                                   fileName.endsWith('.heif');
                
                if (fileData.file && isImageFile) {
                    // Cleanup existing previewUrl if exists to prevent memory leak
                    if (fileData.previewUrl) {
                        URL.revokeObjectURL(fileData.previewUrl);
                    }
                    
                    // For HEIC/HEIF files, show a placeholder while processing
                    const isHEIC = (fileName.endsWith('.heic') || fileName.endsWith('.heif')) && 
                                   (!fileData.file.type || !fileData.file.type.startsWith('image/') || 
                                    fileData.file.type === 'image/heic' || fileData.file.type === 'image/heif');
                    if (isHEIC) {
                        // Store file reference for potential processing later
                        return `<div class="file-icon heic-placeholder">🖼️<br><small>HEIC</small></div>`;
                    } else {
                        // Regular image files (not HEIC)
                        const previewUrl = this.safeCreateObjectURL(fileData.file);
                        if (previewUrl) {
                            fileData.previewUrl = previewUrl;
                            return `<img src="${previewUrl}" alt="${fileData.name}" loading="lazy">`;
                        } else {
                            // Fallback for files that can't create blob URL
                            return `<div class="file-icon">🖼️<br><small>IMG</small></div>`;
                        }
                    }
                } else {
                    // Fallback icon for non-images
                    return `<div class="file-icon">${this.getFileIcon(fileData)}</div>`;
                }
            }

            // Get quality badge based on score
            getQualityBadge(score) {
                if (score >= 80) return '🟢 Cao';
                if (score >= 60) return '🟡 Trung bình';
                if (score >= 40) return '🟠 Thấp';
                return '🔴 Rất thấp';
            }

            getStatusText(status) {
                const statusTexts = {
                    pending: 'Chờ xử lý',
                    processing: 'Đang xử lý...',
                    success: 'Hoàn thành',
                    error: 'Lỗi'
                };
                return statusTexts[status] || 'Unknown';
            }

            async convertAllFiles() {
                const pendingFiles = this.files.filter(f => f.status === 'pending');
                if (pendingFiles.length === 0) {
                    this.showToast('Không có file nào cần chuyển đổi!', 'error');
                    return;
                }

                this.totalConversions = pendingFiles.length;
                this.currentConversion = 0;
                
                document.getElementById('progressContainer').style.display = 'block';
                document.getElementById('convertAllBtn').disabled = true;

                // Process files with controlled concurrency to avoid overload
                const BATCH_SIZE = 3; // Process 3 files at a time to prevent memory issues
                let successCount = 0;
                let errorCount = 0;

                for (let i = 0; i < pendingFiles.length; i += BATCH_SIZE) {
                    const batch = pendingFiles.slice(i, i + BATCH_SIZE);
                    
                    // Process batch concurrently
                    const batchPromises = batch.map(async (fileData) => {
                        try {
                            await this.convertFile(fileData);
                            if (fileData.status === 'success') {
                                successCount++;
                            } else {
                                errorCount++;
                            }
                        } catch (error) {
                            console.error('Error converting file:', fileData.name, error);
                            fileData.status = 'error';
                            errorCount++;
                        }
                        this.currentConversion++;
                        this.updateProgress();
                    });
                    
                    await Promise.all(batchPromises);
                    
                    // Small delay between batches to prevent UI blocking
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                document.getElementById('progressContainer').style.display = 'none';
                document.getElementById('convertAllBtn').disabled = false;
                
                this.updateStats();
                this.updateControls();
                
                let message = `Hoàn thành: ${successCount} thành công`;
                if (errorCount > 0) {
                    message += `, ${errorCount} lỗi`;
                }
                this.showToast(message);
            }

            async convertFile(fileData) {
                const startTime = Date.now();
                fileData.status = 'processing';
                this.renderFileList();
                
                let canvas = null; // Declare canvas for cleanup
                
                // Show progress bar
                this.showProgress(fileData.id, 'Đang khởi tạo...');

                try {
                    // Check if file is HEIC/HEIF format - be more specific  
                    const fileName = fileData.file.name.toLowerCase();
                    const isHEIC = (fileName.endsWith('.heic') || fileName.endsWith('.heif')) && 
                                   (!fileData.file.type || !fileData.file.type.startsWith('image/') || 
                                    fileData.file.type === 'image/heic' || fileData.file.type === 'image/heif');
                    
                    let img;
                    
                    if (isHEIC) {
                        // Handle HEIC/HEIF files using conversion
                        this.updateProgress(fileData.id, 10, 'Đang chuyển đổi HEIC...');
                        img = await this.convertHEICToImage(fileData.file);
                        this.updateProgress(fileData.id, 30, 'HEIC đã chuyển đổi');
                    } else {
                        // Handle regular image files
                        this.updateProgress(fileData.id, 10, 'Đang tải ảnh...');
                        const fileUrl = this.safeCreateObjectURL(fileData.file);
                        if (!fileUrl) {
                            throw new Error('Cannot create blob URL for this file type');
                        }
                        img = new Image();
                        
                        // Load image with error handling
                        await new Promise((resolve, reject) => {
                            img.onload = () => {
                                this.safeRevokeObjectURL(fileUrl);
                                resolve();
                            };
                            img.onerror = (error) => {
                                this.safeRevokeObjectURL(fileUrl);
                                this.handleError(error, 'convertFile-image-load', false);
                                reject(new Error('Cannot load image file'));
                            };
                            
                            // Set crossOrigin before src for security
                            img.crossOrigin = 'anonymous';
                            img.src = fileUrl;
                        });
                    }
                    
                    this.updateProgress(fileData.id, 40, 'Đang phân tích format...');
                    
                    // Determine optimal format and settings
                    const selectedFormat = document.getElementById('outputFormat').value;
                    let actualFormat = selectedFormat;
                    
                    if (selectedFormat === 'auto') {
                        // Use AI-analyzed recommendation, default to JPEG for HEIC
                        actualFormat = isHEIC ? 'jpeg' : (fileData.qualityAnalysis?.recommendedFormat || 'jpeg');
                    }

                    const canvas = this.safeCreateCanvas(img.width, img.height);
                    if (!canvas) {
                        throw new Error('Failed to create canvas for image conversion');
                    }
                    const ctx = canvas.getContext('2d', {
                        alpha: fileData.qualityAnalysis?.hasTransparency !== false,
                        colorSpace: 'srgb', // Ensure consistent color space
                        willReadFrequently: false
                    });
                    
                    // Configure canvas for high quality rendering
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // Set color profile optimizations
                    if (actualFormat === 'jpeg') {
                        // For JPEG, ensure no alpha channel confusion
                        ctx.globalCompositeOperation = 'source-over';
                    }

                    this.updateProgress(fileData.id, 60, 'Đang tạo canvas...');
                    
                    // Set canvas dimensions - ALWAYS keep original size
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Draw image with original dimensions - NO SCALING
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    
                    this.updateProgress(fileData.id, 80, 'Đang chuyển đổi format...');

                    let quality = parseInt(document.getElementById('quality').value) / 100;
                    
                    // Smart quality adjustment based on analysis
                    if (fileData.qualityAnalysis) {
                        quality = this.calculateOptimalQuality(fileData.qualityAnalysis, actualFormat, quality);
                    }
                    
                    // Ensure maximum quality for lossless formats
                    if (actualFormat === 'png' || actualFormat === 'bmp') {
                        quality = 1.0; // PNG and BMP are lossless
                    }
                    
                    const mimeType = {
                        'jpeg': 'image/jpeg',
                        'png': 'image/png', 
                        'webp': 'image/webp',
                        'bmp': 'image/bmp'
                    }[actualFormat];

                    // Convert to blob with optimized settings and 300 DPI metadata
                    const blob = await new Promise((resolve, reject) => {
                        try {
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    // For JPEG, enhance to maximum quality and add DPI metadata
                                    if (actualFormat === 'jpeg') {
                                        this.addDPIMetadata(blob, 300).then(resolve).catch(() => resolve(blob));
                                    } else {
                                        resolve(blob);
                                    }
                                } else {
                                    reject(new Error('Failed to convert image - canvas.toBlob returned null'));
                                }
                            }, mimeType, actualFormat === 'jpeg' ? 1.0 : quality); // Always max quality for JPEG
                        } catch (error) {
                            reject(new Error(`Canvas conversion failed: ${error.message}`));
                        }
                    });

                    this.updateProgress(fileData.id, 95, 'Hoàn tất chuyển đổi...');
                    
                    // Generate new filename based on naming option
                    const newFileName = this.generateFileName(fileData.name, actualFormat);

                    fileData.convertedBlob = blob;
                    fileData.convertedName = newFileName;
                    fileData.actualFormat = actualFormat; // Store the format used
                    fileData.usedQuality = quality; // Store the quality used
                    fileData.status = 'success';
                    
                    // Calculate processing time
                    const processingTime = (Date.now() - startTime) / 1000;
                    const timeInfo = `Hoàn thành trong ${processingTime.toFixed(1)}s`;
                    
                    // Complete progress with success
                    this.updateProgress(fileData.id, 100, '✅ Hoàn thành', timeInfo);
                    setTimeout(() => this.hideProgress(fileData.id), 2000);

                } catch (error) {
                    this.handleError(error, `convertFile-${fileData.name}`);
                    fileData.status = 'error';
                    fileData.errorMessage = error.message;
                    
                    // Show user-friendly error in progress  
                    const userError = this.getUserFriendlyErrorMessage(error, 'convert');
                    this.updateProgress(fileData.id, 100, '❌ Lỗi chuyển đổi', userError);
                    this.safeSetTimeout(() => this.hideProgress(fileData.id), 3000);
                } finally {
                    // Always cleanup canvas if it was created
                    if (canvas && canvas._cleanup) {
                        canvas._cleanup();
                    }
                }

                this.renderFileList();
            }


            // Calculate optimal quality based on image analysis - NO SIZE BIAS
            calculateOptimalQuality(analysis, format, userQuality) {
                let optimalQuality = userQuality;
                
                // For JPEG with high compression artifacts, use higher quality
                if (format === 'jpeg' && analysis.compressionArtifacts > 30) {
                    optimalQuality = Math.max(optimalQuality, 0.9);
                }
                
                // NO size-based quality adjustments - treat all sizes equally
                
                // For low-quality originals, don't go below certain threshold
                if (analysis.qualityScore < 60) {
                    optimalQuality = Math.max(optimalQuality, 0.85);
                }
                
                return optimalQuality;
            }

            // Generate filename based on naming options
            generateFileName(originalName, format) {
                const namingOption = document.getElementById('namingOption').value;
                const customPrefix = document.getElementById('customPrefix').value;
                
                // Define known image extensions
                const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff', 'tif', 'svg', 'ico'];
                
                // Get current extension (if any)
                const lastDotIndex = originalName.lastIndexOf('.');
                let baseName = originalName;
                let originalExt = '';
                
                if (lastDotIndex > 0) {
                    originalExt = originalName.substring(lastDotIndex + 1).toLowerCase();
                    
                    // Only remove extension if it's a known image extension
                    if (imageExtensions.includes(originalExt)) {
                        baseName = originalName.substring(0, lastDotIndex);
                        console.log(`Removed image extension .${originalExt} from ${originalName}`);
                    } else {
                        // Keep the "extension" as part of filename if it's not an image extension
                        baseName = originalName;
                        console.log(`Keeping non-image extension .${originalExt} in filename: ${originalName}`);
                    }
                } else {
                    // No extension found
                    baseName = originalName;
                }
                
                // Handle empty or very short names (like files from Google Drive)
                if (!baseName || baseName.trim() === '') {
                    baseName = 'converted_image';
                }
                
                const extension = {
                    'jpeg': 'jpg',
                    'png': 'png',
                    'webp': 'webp',
                    'bmp': 'bmp'
                }[format];

                let newName = baseName;
                
                switch(namingOption) {
                    case 'keep':
                        // Keep original name, just add new extension
                        break;
                    case 'add_converted':
                        newName = `${baseName}_converted`;
                        break;
                    case 'add_timestamp':
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                        newName = `${baseName}_${timestamp}`;
                        break;
                    case 'custom':
                        if (customPrefix && customPrefix.trim() !== '') {
                            newName = `${customPrefix.trim()}_${baseName}`;
                        }
                        break;
                }
                
                const finalName = `${newName}.${extension}`;
                console.log(`Generated filename: ${originalName} → ${finalName}`);
                return finalName;
            }

            downloadFile(fileId) {
                const fileData = this.files.find(f => f.id == fileId);
                if (!fileData || !fileData.convertedBlob) return;

                // Create safe download with proper MIME type
                const safeBlob = new Blob([fileData.convertedBlob], { 
                    type: fileData.convertedBlob.type || 'image/jpeg' 
                });
                
                const url = URL.createObjectURL(safeBlob);
                const a = document.createElement('a');
                a.href = url;
                
                // Apply download folder settings
                const fileName = this.applyDownloadFolderSettings(fileData.convertedName, 'original');
                a.download = fileName;
                
                // Add attributes to prevent browser warnings
                a.setAttribute('rel', 'noopener noreferrer');
                a.setAttribute('target', '_self');
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up URL after short delay to ensure download starts
                setTimeout(() => URL.revokeObjectURL(url), 1000);

                this.showToast(`Đã tải xuống: ${fileData.convertedName}`);
            }

            // Show preview modal before download
            showPreview(fileId) {
                const fileData = this.files.find(f => f.id == fileId);
                if (!fileData || !fileData.convertedBlob || fileData.status !== 'success') {
                    this.showToast('File không sẵn sàng để xem trước!', 'error');
                    return;
                }

                this.currentPreviewFileId = fileId;
                
                // Show modal with loading state
                document.getElementById('previewModal').style.display = 'flex';
                document.getElementById('previewLoadingContainer').style.display = 'flex';
                document.getElementById('previewContentContainer').style.display = 'none';
                
                // Set title
                document.getElementById('previewModalTitle').textContent = `Preview - ${fileData.convertedName}`;
                
                // Load preview content
                this.loadPreviewContent(fileData);
            }

            // Load preview content
            async loadPreviewContent(fileData) {
                try {
                    // Create URL for preview
                    const previewUrl = URL.createObjectURL(fileData.convertedBlob);
                    
                    // Load image
                    const img = document.getElementById('previewImage');
                    img.onload = () => {
                        // Hide loading and show content
                        document.getElementById('previewLoadingContainer').style.display = 'none';
                        document.getElementById('previewContentContainer').style.display = 'flex';
                        
                        // Update image dimensions in overlay and details
                        const dimensions = `${img.naturalWidth} × ${img.naturalHeight}px`;
                        document.getElementById('previewImageDimensions').textContent = dimensions;
                        document.getElementById('previewDimensions').textContent = dimensions;
                        
                        // Clean up URL
                        URL.revokeObjectURL(previewUrl);
                    };
                    
                    img.onerror = () => {
                        this.showToast('Không thể tải preview image!', 'error');
                        this.hidePreviewModal();
                        URL.revokeObjectURL(previewUrl);
                    };
                    
                    img.src = previewUrl;
                    
                    // Update file details
                    this.updatePreviewDetails(fileData);
                    
                } catch (error) {
                    console.error('Load preview error:', error);
                    this.showToast('Lỗi khi tải preview!', 'error');
                    this.hidePreviewModal();
                }
            }

            // Update preview details
            updatePreviewDetails(fileData) {
                document.getElementById('previewFileName').textContent = fileData.convertedName;
                document.getElementById('previewFormat').textContent = this.getFileFormat(fileData.convertedName).toUpperCase();
                document.getElementById('previewFileSize').textContent = this.formatFileSize(fileData.convertedBlob.size);
                
                // Get quality info
                const qualityInfo = fileData.qualityAnalysis ? `${Math.round(fileData.qualityAnalysis.score)}%` : 'Chất lượng cao';
                document.getElementById('previewQuality').textContent = qualityInfo;
                
                // Get dimensions (will be updated when image loads)
                document.getElementById('previewDimensions').textContent = fileData.dimensions || 'Đang tải...';
                
                // DPI info
                const format = this.getFileFormat(fileData.convertedName);
                const dpiText = (format === 'jpg' || format === 'jpeg') ? '300 DPI' : 'Vector/Lossless';
                document.getElementById('previewDPI').textContent = dpiText;
            }

            // Get file format from name
            getFileFormat(fileName) {
                const extension = fileName.split('.').pop().toLowerCase();
                return extension || 'unknown';
            }

            // Handle modal click (click outside to close)
            handleModalClick(event) {
                if (event.target.id === 'previewModal') {
                    this.hidePreviewModal();
                }
            }

            // Hide preview modal
            hidePreviewModal() {
                document.getElementById('previewModal').style.display = 'none';
                this.currentPreviewFileId = null;
                
                // Reset image src to prevent memory leaks
                const img = document.getElementById('previewImage');
                if (img.src) {
                    img.src = '';
                }
            }

            // Confirm download from preview
            confirmDownload() {
                if (this.currentPreviewFileId) {
                    this.hidePreviewModal();
                    // Use original download function
                    this.downloadFile(this.currentPreviewFileId);
                    this.showToast('🎉 Bắt đầu tải xuống!', 'success');
                }
            }

            downloadAllFiles() {
                const successFiles = this.files.filter(f => f.status === 'success');
                if (successFiles.length === 0) {
                    this.showToast('Không có file nào để tải xuống!', 'error');
                    return;
                }

                // Prevent multiple downloads - check if already downloading
                if (this.isDownloading) {
                    this.showToast('⏳ Đang tải xuống... Vui lòng chờ!', 'warning');
                    return;
                }

                const downloadBtn = document.getElementById('downloadAllBtn');
                if (downloadBtn && downloadBtn.disabled) {
                    this.showToast('⏳ Đang tải xuống... Vui lòng chờ!', 'warning');
                    return;
                }

                // Set download flag
                this.isDownloading = true;
                if (downloadBtn) {
                    downloadBtn.disabled = true;
                    downloadBtn.textContent = `📥 Đang tải ${successFiles.length} files...`;
                }

                // Warn if user has cropped images but downloading originals
                if (this.cropProcessedFiles && this.cropProcessedFiles.length > 0) {
                    const confirmDownload = confirm(
                        `⚠️ CẢNH BÁO: Bạn đã cắt ${this.cropProcessedFiles.length} ảnh!\n\n` +
                        `Bạn đang tải về FILE GỐC (chưa cắt).\n` +
                        `Để tải ảnh đã cắt, hãy dùng nút "✂️ Tải từng file đã cắt".\n\n` +
                        `Vẫn muốn tải file gốc?`
                    );
                    
                    if (!confirmDownload) {
                        // Re-enable button and reset flag if cancelled
                        this.isDownloading = false;
                        if (downloadBtn) {
                            downloadBtn.disabled = false;
                            downloadBtn.textContent = '📥 Tải từng file gốc';
                        }
                        this.showToast('❌ Đã hủy tải file gốc. Hãy dùng nút "✂️ Tải từng file đã cắt" để tải ảnh đã cắt!', 'warning');
                        return;
                    }
                }

                // Fast parallel download with reduced delays
                this.performFastDownload(successFiles, downloadBtn);

                this.showToast(`📥 Đang tải xuống ${successFiles.length} file GỐC... (💡 Tip: Dùng nút "✂️ Tải từng file đã cắt" để tải ảnh đã cắt!)`);
            }

            // Fast parallel download method - much faster for many files
            performFastDownload(successFiles, downloadBtn) {
                const totalCount = successFiles.length;
                const downloadedIds = new Set();
                let downloadedCount = 0;
                
                // Batch size for parallel downloads (browser can handle ~6 parallel requests)
                const batchSize = Math.min(6, totalCount);
                const batches = [];
                
                // Split files into batches
                for (let i = 0; i < totalCount; i += batchSize) {
                    batches.push(successFiles.slice(i, i + batchSize));
                }
                
                console.log(`🚀 Starting fast download: ${totalCount} files in ${batches.length} batches`);
                
                // Process batches sequentially, but files within batch in parallel
                const processBatch = (batchIndex) => {
                    if (batchIndex >= batches.length) {
                        // All batches completed
                        setTimeout(() => {
                            this.isDownloading = false;
                            if (downloadBtn) {
                                downloadBtn.disabled = false;
                                downloadBtn.textContent = '📥 Tải từng file gốc';
                            }
                            this.showToast(`✅ Đã tải xong ${totalCount} file gốc!`, 'success');
                        }, 200);
                        return;
                    }
                    
                    const currentBatch = batches[batchIndex];
                    
                    // Process all files in current batch in parallel
                    currentBatch.forEach((fileData, indexInBatch) => {
                        setTimeout(() => {
                            if (!downloadedIds.has(fileData.id)) {
                                downloadedIds.add(fileData.id);
                                this.downloadFile(fileData.id);
                                downloadedCount++;
                                
                                // Update progress
                                if (downloadBtn) {
                                    downloadBtn.textContent = `📥 Đang tải ${downloadedCount}/${totalCount}...`;
                                }
                                
                                // Check if this batch is complete
                                if (downloadedCount === (batchIndex + 1) * batchSize || 
                                    downloadedCount === totalCount) {
                                    // Wait a bit then process next batch
                                    setTimeout(() => processBatch(batchIndex + 1), 150);
                                }
                            }
                        }, indexInBatch * 20); // Very small delay within batch (20ms)
                    });
                };
                
                // Start processing
                processBatch(0);
            }

            async downloadAsZip() {
                try {
                    const successFiles = this.files.filter(f => f.status === 'success');
                    if (successFiles.length === 0) {
                        this.showToast('Không có file nào để tạo ZIP!', 'error');
                        return;
                    }

                    // Warn if user has cropped images but downloading originals
                    if (this.cropProcessedFiles && this.cropProcessedFiles.length > 0) {
                        const confirmDownload = confirm(
                            `⚠️ CẢNH BÁO: Bạn đã cắt ${this.cropProcessedFiles.length} ảnh!\n\n` +
                            `Bạn đang tải về ZIP FILE GỐC (chưa cắt).\n` +
                            `Để tải ZIP ảnh đã cắt, hãy dùng nút "📦 Tải ZIP đã cắt".\n\n` +
                            `Vẫn muốn tạo ZIP file gốc?`
                        );
                        
                        if (!confirmDownload) {
                            this.showToast('❌ Đã hủy tải ZIP gốc. Hãy dùng nút "📦 Tải ZIP đã cắt" để tải ZIP ảnh đã cắt!', 'warning');
                            return;
                        }
                    }

                    this.showToast('Đang tạo ZIP file GỐC chất lượng cao...', 'success');
                    
                    // Disable button during process
                    const zipBtn = document.getElementById('downloadZipBtn');
                    zipBtn.disabled = true;
                    zipBtn.textContent = '📦 Đang tạo ZIP...';

                    // Prepare files for safe ZIP generation
                    const files = [];
                    
                    // Create high-quality versions and prepare for ZIP
                    for (let i = 0; i < successFiles.length; i++) {
                        const fileData = successFiles[i];
                        
                        // Get high-quality version
                        let finalBlob;
                        if (this.needsHighQualityReconversion(fileData)) {
                            // Reconvert at maximum quality
                            finalBlob = await this.createHighQualityVersion(fileData);
                        } else {
                            // Use existing blob if already high quality
                            finalBlob = fileData.convertedBlob;
                        }

                        files.push({
                            filename: fileData.convertedName,
                            data: finalBlob
                        });
                        
                        // Update progress
                        zipBtn.textContent = `📦 Đang tạo ZIP... (${i + 1}/${successFiles.length})`;
                    }

                    // Generate safe ZIP
                    zipBtn.textContent = '📦 Đang nén file...';
                    
                    const timestamp = new Date().toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '-');
                    const zipName = `converted_images_300dpi_${timestamp}.zip`;
                    
                    const zipBlob = await this.createSafeZip(
                        files,
                        zipName,
                        'Safe high-quality converted images archive - Created by MEU Layout'
                    );

                    // Download safely
                    this.downloadSafeZip(zipBlob, zipName);

                    this.showToast(`✅ Đã tải ZIP: ${zipName} (${successFiles.length} ảnh chất lượng cao)`);

                } catch (error) {
                    this.handleError(error, 'downloadAsZip');
                } finally {
                    // Re-enable button
                    const zipBtn = document.getElementById('downloadZipBtn');
                    if (zipBtn) {
                        zipBtn.disabled = false;
                        zipBtn.textContent = '📦 Tải về ZIP (Chất lượng cao)';
                    }
                }
            }

            // Check if file needs high-quality reconversion
            needsHighQualityReconversion(fileData) {
                const currentQuality = parseInt(document.getElementById('quality').value);
                return currentQuality < 100; // Reconvert if not at maximum quality
            }

            // Create high-quality version of the image
            async createHighQualityVersion(fileData) {
                try {
                    const fileUrl = this.safeCreateObjectURL(fileData.file);
                    if (!fileUrl) {
                        throw new Error('Cannot create blob URL for this file type');
                    }
                    const canvas = this.safeCreateCanvas(1, 1); // Will be resized later
                    const ctx = canvas.getContext('2d');
                    const img = new Image();

                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            this.safeRevokeObjectURL(fileUrl);
                            resolve();
                        };
                        img.onerror = (error) => {
                            this.safeRevokeObjectURL(fileUrl);
                            this.handleError(error, 'createHighQualityVersion-image-load', false);
                            reject(error);
                        };
                        img.crossOrigin = 'anonymous';
                        img.src = fileUrl;
                    });

                    // Always preserve original dimensions
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0, img.width, img.height);

                    // Get format from filename
                    const format = this.getFormatFromFileName(fileData.convertedName);
                    const mimeType = {
                        'jpg': 'image/jpeg',
                        'jpeg': 'image/jpeg',
                        'png': 'image/png',
                        'webp': 'image/webp',
                        'bmp': 'image/bmp'
                    }[format.toLowerCase()] || 'image/jpeg';

                    // Always use maximum quality (1.0)
                    const quality = 1.0;

                    const blob = await new Promise((resolve, reject) => {
                        canvas.toBlob(async (blob) => {
                            if (blob) {
                                // Add DPI metadata for JPEG
                                if (format.toLowerCase() === 'jpg' || format.toLowerCase() === 'jpeg') {
                                    try {
                                        const enhancedBlob = await this.addDPIMetadata(blob, 300);
                                        resolve(enhancedBlob);
                                    } catch (error) {
                                        resolve(blob); // Fallback to original
                                    }
                                } else {
                                    resolve(blob);
                                }
                            } else {
                                reject(new Error('Failed to create high-quality version'));
                            }
                        }, mimeType, 1.0); // Always maximum quality
                    });

                    return blob;

                } catch (error) {
                    this.handleError(error, 'createHighQualityVersion');
                    // Return original if reconversion fails
                    return fileData.convertedBlob;
                } finally {
                    // Always cleanup canvas
                    if (canvas && canvas._cleanup) {
                        canvas._cleanup();
                    }
                }
            }

            // Get format from filename
            getFormatFromFileName(fileName) {
                const extension = fileName.split('.').pop();
                return extension || 'jpg';
            }

            // Add safe 300 DPI metadata with EXIF resolution to JPEG blob
            async addDPIMetadata(blob, dpi = 300) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const arrayBuffer = e.target.result;
                            const uint8Array = new Uint8Array(arrayBuffer);
                            
                            // Create enhanced JFIF header with proper DPI
                            const jfifHeader = this.createEnhancedJFIFHeader(dpi);
                            
                            // Create comprehensive EXIF metadata with resolution
                            const exifHeader = this.createResolutionEXIFHeader(dpi);
                            
                            // Find the end of SOI (Start of Image) marker
                            let insertIndex = 2; // After FF D8
                            
                            // Remove any existing JFIF/EXIF headers
                            while (insertIndex < uint8Array.length - 1 && 
                                   uint8Array[insertIndex] === 0xFF && 
                                   (uint8Array[insertIndex + 1] === 0xE0 || 
                                    uint8Array[insertIndex + 1] === 0xE1)) {
                                const length = (uint8Array[insertIndex + 2] << 8) | uint8Array[insertIndex + 3];
                                insertIndex += 2 + length;
                            }
                            
                            // Create new array with enhanced headers
                            const totalHeaderLength = jfifHeader.length + exifHeader.length;
                            const newArray = new Uint8Array(uint8Array.length - insertIndex + 2 + totalHeaderLength);
                            let offset = 0;
                            
                            // Add SOI marker
                            newArray[offset++] = 0xFF;
                            newArray[offset++] = 0xD8;
                            
                            // Add enhanced JFIF header
                            newArray.set(jfifHeader, offset);
                            offset += jfifHeader.length;
                            
                            // Add resolution EXIF header
                            newArray.set(exifHeader, offset);
                            offset += exifHeader.length;
                            
                            // Add rest of original image (skip old headers)
                            newArray.set(uint8Array.slice(insertIndex), offset);
                            
                            const newBlob = new Blob([newArray], { 
                                type: 'image/jpeg',
                                lastModified: Date.now()
                            });
                            console.log(`✅ Enhanced DPI metadata: ${dpi} DPI added to JPEG`);
                            console.log(`📏 Physical size should be: ${(newArray.length > 50000 ? 'Large file' : 'Small file')} - Check with image viewer that supports DPI`);
                            resolve(newBlob);
                        } catch (error) {
                            console.warn('Failed to add enhanced DPI metadata:', error);
                            resolve(blob); // Return original if failed
                        }
                    };
                    reader.readAsArrayBuffer(blob);
                });
            }

            // Create enhanced JFIF header with proper DPI encoding
            createEnhancedJFIFHeader(dpi) {
                const header = new Uint8Array(18);
                let offset = 0;
                
                // JFIF marker
                header[offset++] = 0xFF; // Marker prefix
                header[offset++] = 0xE0; // JFIF marker
                
                // Length (16 bytes after this field)
                header[offset++] = 0x00;
                header[offset++] = 0x10;
                
                // JFIF identifier
                header[offset++] = 0x4A; // 'J'
                header[offset++] = 0x46; // 'F'
                header[offset++] = 0x49; // 'I'
                header[offset++] = 0x46; // 'F'
                header[offset++] = 0x00; // null terminator
                
                // Version (1.02 for better compatibility)
                header[offset++] = 0x01; // Major
                header[offset++] = 0x02; // Minor
                
                // Density units (1 = pixels per inch, 2 = pixels per cm)
                header[offset++] = 0x01; // Keep as PPI
                
                // X density (DPI) - Big endian format
                header[offset++] = (dpi >> 8) & 0xFF;
                header[offset++] = dpi & 0xFF;
                
                // Y density (DPI) - Big endian format
                header[offset++] = (dpi >> 8) & 0xFF;
                header[offset++] = dpi & 0xFF;
                
                // Thumbnail dimensions (0x0 = no thumbnail)
                header[offset++] = 0x00; // X thumbnail
                header[offset++] = 0x00; // Y thumbnail
                
                return header;
            }

            // Create comprehensive EXIF header with resolution information
            createResolutionEXIFHeader(dpi = 300) {
                // Enhanced EXIF header with proper resolution tags
                const header = new Uint8Array(98);
                let offset = 0;
                
                // EXIF marker
                header[offset++] = 0xFF; // Marker prefix
                header[offset++] = 0xE1; // EXIF marker
                
                // Length (96 bytes after this field)
                header[offset++] = 0x00;
                header[offset++] = 0x60;
                
                // EXIF identifier
                header[offset++] = 0x45; // 'E'
                header[offset++] = 0x78; // 'x'
                header[offset++] = 0x69; // 'i'
                header[offset++] = 0x66; // 'f'
                header[offset++] = 0x00; // null terminator
                header[offset++] = 0x00; // padding
                
                // TIFF header (little-endian)
                header[offset++] = 0x49; // 'I'
                header[offset++] = 0x49; // 'I' (little-endian)
                header[offset++] = 0x2A; // TIFF magic number
                header[offset++] = 0x00;
                header[offset++] = 0x08; // IFD offset
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // IFD (Image File Directory) - 3 entries
                header[offset++] = 0x03; // Number of entries
                header[offset++] = 0x00;
                
                // Entry 1: Software tag (safe identifier)
                header[offset++] = 0x31; // Tag 0x0131 (Software)
                header[offset++] = 0x01;
                header[offset++] = 0x02; // ASCII type
                header[offset++] = 0x00;
                header[offset++] = 0x1A; // 26 characters
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x32; // Offset to string
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // Entry 2: DateTime tag
                header[offset++] = 0x32; // Tag 0x0132 (DateTime)
                header[offset++] = 0x01;
                header[offset++] = 0x02; // ASCII type
                header[offset++] = 0x00;
                header[offset++] = 0x14; // 20 characters
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x4C; // Offset to datetime
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // Entry 3: Image description (digital signature)
                header[offset++] = 0x0E; // Tag 0x010E (ImageDescription)
                header[offset++] = 0x01;
                header[offset++] = 0x02; // ASCII type
                header[offset++] = 0x00;
                header[offset++] = 0x06; // 6 characters
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x70; // Offset to string
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // Next IFD offset (0 = no more IFDs)
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // XResolution rational value (DPI/1)
                header[offset++] = dpi & 0xFF;        // DPI numerator low
                header[offset++] = (dpi >> 8) & 0xFF; // DPI numerator high
                header[offset++] = (dpi >> 16) & 0xFF;// DPI numerator
                header[offset++] = (dpi >> 24) & 0xFF;// DPI numerator
                header[offset++] = 0x01; // Denominator = 1
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // YResolution rational value (same as X)
                header[offset++] = dpi & 0xFF;        // DPI numerator low
                header[offset++] = (dpi >> 8) & 0xFF; // DPI numerator high
                header[offset++] = (dpi >> 16) & 0xFF;// DPI numerator
                header[offset++] = (dpi >> 24) & 0xFF;// DPI numerator
                header[offset++] = 0x01; // Denominator = 1
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // Software string: "ImgConv\0\0\0"
                const software = "ImgConv\0\0\0";
                for (let i = 0; i < Math.min(software.length, 10); i++) {
                    header[offset++] = software.charCodeAt(i);
                }
                
                // Image description: "HiRes\0"
                const description = "HiRes\0";
                for (let i = 0; i < Math.min(description.length, 6); i++) {
                    header[offset++] = description.charCodeAt(i);
                }
                
                console.log(`EXIF Resolution metadata: ${dpi} DPI encoded in EXIF`);
                return header;
            }

            removeFile(fileId) {
                // Find file to cleanup blob URLs before removing
                const fileToRemove = this.files.find(f => f.id === fileId);
                if (fileToRemove && fileToRemove.previewUrl) {
                    URL.revokeObjectURL(fileToRemove.previewUrl);
                }
                
                this.files = this.files.filter(f => f.id != fileId);
                this.renderFileList();
                this.updateStats();
                this.updateControls();
                this.showToast('Đã xóa file!');
            }

            clearAllFiles() {
                if (confirm('Bạn có chắc muốn xóa tất cả file?')) {
                    // Cleanup all blob URLs before clearing files
                    this.files.forEach(file => {
                        if (file.previewUrl) {
                            URL.revokeObjectURL(file.previewUrl);
                        }
                    });
                    
                    this.files = [];
                    this.renderFileList();
                    this.updateStats();
                    this.updateControls();
                    this.showToast('Đã xóa tất cả file!');
                }
            }

            retryFailedFiles() {
                const failedFiles = this.files.filter(f => f.status === 'error');
                failedFiles.forEach(f => f.status = 'pending');
                this.renderFileList();
                this.showToast(`Đã đặt lại ${failedFiles.length} file lỗi!`);
            }

            updateProgress() {
                const progress = (this.currentConversion / this.totalConversions) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
            }

            updateStats() {
                const totalFiles = this.files.length;
                const convertedFiles = this.files.filter(f => f.status === 'success').length;
                const totalSize = this.files.reduce((sum, f) => sum + f.size, 0);
                const successRate = totalFiles > 0 ? Math.round((convertedFiles / totalFiles) * 100) : 0;

                document.getElementById('totalFiles').textContent = totalFiles;
                document.getElementById('convertedFiles').textContent = convertedFiles;
                document.getElementById('totalSize').textContent = this.formatFileSize(totalSize);
                document.getElementById('successRate').textContent = successRate + '%';
            }

            updateControls() {
                const hasPendingFiles = this.files.some(f => f.status === 'pending');
                const hasSuccessFiles = this.files.some(f => f.status === 'success');
                const hasFiles = this.files.length > 0;

                document.getElementById('convertAllBtn').disabled = !hasPendingFiles;
                document.getElementById('bulkActions').style.display = hasFiles ? 'flex' : 'none';
                document.getElementById('downloadAllBtn').disabled = !hasSuccessFiles;
                document.getElementById('downloadZipBtn').disabled = !hasSuccessFiles;
                document.getElementById('createPdfBtn').disabled = !hasSuccessFiles;
                document.getElementById('cropImagesBtn').disabled = !hasSuccessFiles;
            }

            // Show crop configuration modal
            showCropModal() {
                this.showCropPage();
            }

            showCropPage() {
                const successFiles = this.files.filter(f => f.status === 'success');
                if (successFiles.length === 0) {
                    this.showToast('Không có ảnh nào để cắt!', 'error');
                    return;
                }
                
                // Hide main container and show crop page
                document.querySelector('.container').style.display = 'none';
                document.getElementById('cropPage').style.display = 'block';
                
                // Initialize template selection if not already done
                if (!this.currentCropTemplate) {
                    this.currentCropTemplate = '5.5x8.5';
                }
                
                this.initializeCropPageHandlers();
                this.populateCropFileGrid();
                this.updateSizeDetailsPage();
            }

            hideCropPage() {
                document.querySelector('.container').style.display = 'block';
                document.getElementById('cropPage').style.display = 'none';
            }

            // Hide crop modal (legacy)
            hideCropModal() {
                document.getElementById('cropModal').style.display = 'none';
            }

            initializeCropPageHandlers() {
                // Back button
                document.getElementById('backToMain').addEventListener('click', () => {
                    this.hideCropPage();
                });

                // Size cards in page - both large and compact
                const sizeCards = document.querySelectorAll('#cropPage .size-card-large, #cropPage .size-card-compact');
                sizeCards.forEach(card => {
                    card.addEventListener('click', () => {
                        // Remove active from all cards
                        sizeCards.forEach(c => c.classList.remove('active'));
                        card.classList.add('active');
                        
                        const templateSize = card.getAttribute('data-size');
                        this.selectCropTemplatePage(templateSize);
                    });
                });

                // Custom inputs
                document.getElementById('cropWidthPage').addEventListener('input', () => {
                    this.updateSizeDetailsPage();
                });
                document.getElementById('cropHeightPage').addEventListener('input', () => {
                    this.updateSizeDetailsPage();
                });
                document.getElementById('cropDPIPage').addEventListener('change', () => {
                    this.updateSizeDetailsPage();
                });

                // Start cropping button
                document.getElementById('startCroppingPage').addEventListener('click', () => {
                    this.startCroppingFromPage();
                });
            }

            selectCropTemplatePage(template) {
                const customSection = document.getElementById('customSizeSectionPage');
                
                if (template === 'custom') {
                    customSection.style.display = 'block';
                    // Enable custom inputs for custom template
                    const widthInput = document.getElementById('cropWidthPage');
                    const heightInput = document.getElementById('cropHeightPage');
                    if (widthInput) widthInput.disabled = false;
                    if (heightInput) heightInput.disabled = false;
                } else {
                    customSection.style.display = 'none';
                    const [width, height] = template.split('x').map(s => parseFloat(s));
                    document.getElementById('cropWidthPage').value = width;
                    document.getElementById('cropHeightPage').value = height;
                    
                    // LOCK SIZE INPUTS - CANNOT CHANGE PREDEFINED TEMPLATES
                    const widthInput = document.getElementById('cropWidthPage');
                    const heightInput = document.getElementById('cropHeightPage');
                    if (widthInput) widthInput.disabled = true;
                    if (heightInput) heightInput.disabled = true;
                }
                
                this.currentCropTemplate = template;
                this.updateSizeDetailsPage();
            }

            updateSizeDetailsPage() {
                const template = this.currentCropTemplate || '5.5x8.5';
                let width, height;
                
                if (template === 'custom') {
                    width = parseFloat(document.getElementById('cropWidthPage').value);
                    height = parseFloat(document.getElementById('cropHeightPage').value);
                } else {
                    [width, height] = template.split('x').map(s => parseFloat(s));
                }
                
                // CÔNG THỨC CHÍNH XÁC: Cố định DPI = 300
                const DPI = 300;
                const pixelWidth = Math.round((width / 2.54) * DPI); // (cm ÷ 2.54) × 300
                const pixelHeight = Math.round((height / 2.54) * DPI); // (cm ÷ 2.54) × 300
                const ratio = this.getSimpleRatio(width, height);
                
                document.getElementById('currentSizePage').textContent = `${width}×${height} cm`;
                document.getElementById('currentPixelsPage').textContent = `${pixelWidth}×${pixelHeight}px`;
                document.getElementById('currentRatioPage').textContent = ratio;
            }

            populateCropFileGrid() {
                const grid = document.getElementById('cropFileGrid');
                const successFiles = this.files.filter(f => f.status === 'success');
                
                grid.innerHTML = '';
                
                successFiles.forEach((fileData, index) => {
                    const item = this.createCropFileItem(fileData, index);
                    grid.appendChild(item);
                });

                // Update file count
                document.getElementById('cropFileCount').textContent = `${successFiles.length} ảnh được chọn`;
            }

            createCropFileItem(fileData, index) {
                const item = document.createElement('div');
                item.className = 'crop-file-item selected';
                item.setAttribute('data-file-id', fileData.id);

                const previewUrl = fileData.convertedBlob ? 
                    URL.createObjectURL(fileData.convertedBlob) : 
                    this.safeCreateObjectURL(fileData.file);

                const imageContent = previewUrl ? 
                    `<img src="${previewUrl}" alt="${fileData.name}" loading="lazy">` :
                    `<div class="file-icon">🖼️</div>`;

                item.innerHTML = `
                    <div class="crop-file-preview">
                        ${imageContent}
                    </div>
                    <div class="crop-file-info">
                        <div class="crop-file-name" title="${fileData.name}">${fileData.name}</div>
                        <div class="crop-file-size">${this.formatFileSize(fileData.size)}</div>
                    </div>
                `;

                item.addEventListener('click', () => {
                    item.classList.toggle('selected');
                    this.updateCropFileCount();
                });

                return item;
            }

            updateCropFileCount() {
                const selectedItems = document.querySelectorAll('.crop-file-item.selected');
                document.getElementById('cropFileCount').textContent = `${selectedItems.length} ảnh được chọn`;
            }

            startCroppingFromPage() {
                const selectedItems = document.querySelectorAll('.crop-file-item.selected');
                if (selectedItems.length === 0) {
                    this.showToast('Vui lòng chọn ít nhất một ảnh để cắt!', 'error');
                    return;
                }

                // Get settings from page
                const width = parseFloat(document.getElementById('cropWidthPage').value);
                const height = parseFloat(document.getElementById('cropHeightPage').value);
                const dpi = parseInt(document.getElementById('cropDPIPage').value) || 300;
                const mode = document.getElementById('cropModePage').value;
                const background = document.getElementById('cropBackgroundPage').value;
                const naming = document.getElementById('cropNamingPage').value;
                const processMode = document.querySelector('input[name="cropProcessModePage"]:checked').value;

                // Update the original controls for compatibility
                document.getElementById('cropWidth').value = width;
                document.getElementById('cropHeight').value = height;
                document.getElementById('cropDPI').value = dpi;
                document.getElementById('cropMode').value = mode;
                document.getElementById('cropBackground').value = background;
                document.getElementById('cropNaming').value = naming;
                document.querySelector(`input[name="cropProcessMode"][value="${processMode}"]`).checked = true;

                // Hide crop page and start cropping
                this.hideCropPage();
                this.startCropping();
            }

            // Update crop template
            initializeCropTemplateHandlers() {
                const templateCards = document.querySelectorAll('.template-card');
                templateCards.forEach(card => {
                    card.addEventListener('click', () => {
                        // Remove active class from all cards
                        templateCards.forEach(c => c.classList.remove('active'));
                        // Add active class to clicked card
                        card.classList.add('active');
                        
                        // Get the template size
                        const templateSize = card.getAttribute('data-size');
                        this.selectCropTemplate(templateSize);
                    });
                });
            }

            selectCropTemplate(template) {
                const customSection = document.getElementById('customSizeSection');
                
                if (template === 'custom') {
                    customSection.style.display = 'block';
                    // Enable custom inputs for custom template
                    const widthInput = document.getElementById('cropWidth');
                    const heightInput = document.getElementById('cropHeight');
                    if (widthInput) widthInput.disabled = false;
                    if (heightInput) heightInput.disabled = false;
                } else {
                    customSection.style.display = 'none';
                    const [width, height] = template.split('x').map(s => parseFloat(s));
                    document.getElementById('cropWidth').value = width;
                    document.getElementById('cropHeight').value = height;
                    
                    // LOCK SIZE INPUTS - CANNOT CHANGE PREDEFINED TEMPLATES
                    const widthInput = document.getElementById('cropWidth');
                    const heightInput = document.getElementById('cropHeight');
                    if (widthInput) widthInput.disabled = true;
                    if (heightInput) heightInput.disabled = true;
                }
                
                this.currentCropTemplate = template;
                this.updateSizeDetails();
                this.updateCropInfo();
            }

            updateSizeDetails() {
                const template = this.currentCropTemplate || '10x15';
                let width, height;
                
                if (template === 'custom') {
                    width = parseFloat(document.getElementById('cropWidth').value);
                    height = parseFloat(document.getElementById('cropHeight').value);
                } else {
                    [width, height] = template.split('x').map(s => parseFloat(s));
                }
                
                // CÔNG THỨC CHÍNH XÁC: Cố định DPI = 300
                const DPI = 300;
                const pixelWidth = Math.round((width / 2.54) * DPI); // (cm ÷ 2.54) × 300
                const pixelHeight = Math.round((height / 2.54) * DPI); // (cm ÷ 2.54) × 300
                const ratio = this.getSimpleRatio(width, height);
                
                document.getElementById('currentSize').textContent = `${width}×${height} cm`;
                document.getElementById('currentPixels').textContent = `${pixelWidth}×${pixelHeight}px`;
                document.getElementById('currentRatio').textContent = ratio;
            }

            getSimpleRatio(width, height) {
                const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
                const divisor = gcd(width * 10, height * 10);
                const w = (width * 10) / divisor;
                const h = (height * 10) / divisor;
                return `${w}:${h}`;
            }

            updateCropTemplate() {
                // Legacy function for compatibility
                this.updateSizeDetails();
            }

            // Update template preview (legacy function for compatibility)
            updateTemplatePreview() {
                // This function is now handled by updateSizeDetails()
                this.updateSizeDetails();
            }

            // Update crop information display
            updateCropInfo() {
                const width = parseFloat(document.getElementById('cropWidth').value);
                const height = parseFloat(document.getElementById('cropHeight').value);
                const dpi = parseInt(document.getElementById('cropDPI').value);
                
                if (!width || !height || width <= 0 || height <= 0) return;
                
                // Calculate pixels at specified DPI
                const pixelWidth = Math.round((width * dpi) / 2.54); // cm to inches to pixels
                const pixelHeight = Math.round((height * dpi) / 2.54);
                
                // Calculate aspect ratio
                const gcd = this.getGCD(Math.round(width * 10), Math.round(height * 10));
                const ratioW = Math.round(width * 10) / gcd;
                const ratioH = Math.round(height * 10) / gcd;
                
                // Update display
                document.getElementById('cropSizeInfo').textContent = `${width}×${height} cm`;
                document.getElementById('cropPixelInfo').textContent = `${pixelWidth}×${pixelHeight} px`;
                document.getElementById('cropRatioInfo').textContent = `${ratioW}:${ratioH}`;
            }

            // Get Greatest Common Divisor
            getGCD(a, b) {
                return b === 0 ? a : this.getGCD(b, a % b);
            }

            // Start cropping process
            async startCropping() {
                const successFiles = this.files.filter(f => f.status === 'success');
                const cropMode = document.getElementById('cropMode').value;
                const cropProcessMode = document.querySelector('input[name="cropProcessMode"]:checked')?.value || 'individual';
                
                this.hideCropModal();
                
                // Check if this is template mode (size crop)
                if (cropMode === 'size') {
                    return await this.startTemplateCropping(successFiles, cropProcessMode);
                }
                
                // Handle different crop modes
                switch (cropProcessMode) {
                    case 'batch':
                        return await this.startBatchCropping(successFiles, cropMode);
                    case 'preview':
                        return await this.startPreviewMode(successFiles, cropMode);
                    case 'individual':
                    default:
                        return await this.startIndividualCropping(successFiles, cropMode);
                }
            }

            // Template cropping with fixed aspect ratio
            async startTemplateCropping(successFiles, processMode) {
                // Get template size configuration
                const width = parseFloat(document.getElementById('cropWidth').value);
                const height = parseFloat(document.getElementById('cropHeight').value);
                const dpi = parseInt(document.getElementById('cropDPI').value) || 300;
                const unit = document.getElementById('cropUnit').value;
                
                // CÔNG THỨC CHÍNH XÁC: Cố định DPI = 300
                const DPI = 300;
                let targetWidth, targetHeight;
                if (unit === 'cm') {
                    targetWidth = Math.round((width / 2.54) * DPI); // (cm ÷ 2.54) × 300
                    targetHeight = Math.round((height / 2.54) * DPI); // (cm ÷ 2.54) × 300
                } else {
                    targetWidth = Math.round(width * DPI);
                    targetHeight = Math.round(height * DPI);
                }
                
                // Initialize template crop data
                this.templateCropData = {
                    files: successFiles,
                    currentIndex: 0,
                    croppedImages: [],
                    config: {
                        width: width,
                        height: height,
                        dpi: dpi,
                        unit: unit,
                        targetWidth: targetWidth,
                        targetHeight: targetHeight,
                        aspectRatio: width / height,
                        naming: document.getElementById('cropNaming').value
                    },
                    processMode: processMode
                };
                
                // Start template cropping based on process mode
                switch (processMode) {
                    case 'batch':
                        return await this.startBatchTemplateCropping();
                    case 'preview':
                        return await this.startPreviewTemplateCropping();
                    case 'individual':
                    default:
                        return await this.startIndividualTemplateCropping();
                }
            }
            
            // Individual template cropping
            async startIndividualTemplateCropping() {
                this.showTemplateCropEditor();
                await this.loadImageForTemplateCropping(0);
            }

            // Individual cropping (original method)
            async startIndividualCropping(successFiles, cropMode) {
                // Initialize crop data
                this.cropData = {
                    files: successFiles,
                    currentIndex: 0,
                    croppedImages: [],
                    config: {
                        width: parseFloat(document.getElementById('cropWidth').value),
                        height: parseFloat(document.getElementById('cropHeight').value),
                        dpi: parseInt(document.getElementById('cropDPI').value),
                        mode: cropMode,
                        background: document.getElementById('cropBackground').value,
                        naming: document.getElementById('cropNaming').value
                    }
                };
                
                try {
                    if (cropMode === 'manual') {
                        await this.startManualCropping();
                    } else {
                        await this.processAutoCropping();
                    }
                } catch (error) {
                    console.error('Cropping error:', error);
                    this.showToast('Lỗi khi cắt ảnh!', 'error');
                }
            }

            // Process auto cropping (center or smart)
            async processAutoCropping() {
                this.showToast('🎨 Tạo preview cho tất cả ảnh...', 'success');
                
                // Initialize preview data
                this.cropData.previewData = [];
                this.cropData.selectedFiles = new Set();
                
                // Generate previews for all files
                for (let i = 0; i < this.cropData.files.length; i++) {
                    const fileData = this.cropData.files[i];
                    try {
                        const previewData = await this.generateCropPreview(fileData);
                        this.cropData.previewData.push(previewData);
                        
                        this.showToast(`🎨 Tạo preview ${i + 1}/${this.cropData.files.length}`, 'success');
                    } catch (error) {
                        console.error('Error generating preview:', fileData.name, error);
                    }
                }
                
                // Show preview gallery before download
                this.showPreviewGallery();
            }

            // Batch cropping - applies same template to all images automatically
            async startBatchCropping(successFiles, cropMode) {
                this.showToast('🎨 Tạo preview cho tất cả ảnh...', 'success');
                
                // Initialize crop data
                this.cropData = {
                    files: successFiles,
                    croppedImages: [],
                    previewData: [],
                    selectedFiles: new Set(),
                    config: {
                        width: parseFloat(document.getElementById('cropWidth').value),
                        height: parseFloat(document.getElementById('cropHeight').value),
                        dpi: parseInt(document.getElementById('cropDPI').value),
                        mode: cropMode,
                        background: document.getElementById('cropBackground').value,
                        naming: document.getElementById('cropNaming').value
                    }
                };

                try {
                    // Generate previews for all files first
                    for (let i = 0; i < successFiles.length; i++) {
                        const fileData = successFiles[i];
                        try {
                            const previewData = await this.generateCropPreview(fileData);
                            this.cropData.previewData.push(previewData);
                            
                            this.showToast(`🎨 Tạo preview ${i + 1}/${successFiles.length}`, 'success');
                        } catch (error) {
                            console.error('Error generating preview:', fileData.name, error);
                        }
                    }
                    
                    // Show preview gallery before download
                    this.showPreviewGallery();
                } catch (error) {
                    console.error('Batch cropping error:', error);
                    this.showToast('❌ Lỗi khi cắt hàng loạt!', 'error');
                }
            }

            // Preview mode - shows preview gallery before cropping
            async startPreviewMode(successFiles, cropMode) {
                this.showToast('👁️ Tạo preview cho tất cả ảnh...', 'success');
                
                // Initialize crop data
                this.cropData = {
                    files: successFiles,
                    croppedImages: [],
                    previewData: [],
                    selectedFiles: new Set(),
                    config: {
                        width: parseFloat(document.getElementById('cropWidth').value),
                        height: parseFloat(document.getElementById('cropHeight').value),
                        dpi: parseInt(document.getElementById('cropDPI').value),
                        mode: cropMode,
                        background: document.getElementById('cropBackground').value,
                        naming: document.getElementById('cropNaming').value
                    }
                };

                try {
                    // Generate previews for all files
                    for (let i = 0; i < successFiles.length; i++) {
                        const fileData = successFiles[i];
                        const previewData = await this.generateCropPreview(fileData);
                        this.cropData.previewData.push(previewData);
                        
                        this.showToast(`🎨 Tạo preview ${i + 1}/${successFiles.length}`, 'success');
                    }

                    // Show preview gallery
                    this.showPreviewGallery();
                } catch (error) {
                    console.error('Preview generation error:', error);
                    this.showToast('❌ Lỗi khi tạo preview!', 'error');
                }
            }

            // Start multi-image manual cropping process
            async startManualCropping() {
                if (this.cropData.files.length === 0) return;
                
                // Initialize multi-crop data
                this.multiCropData = {
                    files: this.cropData.files,
                    selectedFiles: new Set(),
                    cropSelections: new Map(), // Store crop area for each file
                    globalSettings: {
                        aspectLocked: true, // Start with aspect lock enabled
                        sizeLocked: false
                    }
                };
                
                // Show multi-crop editor
                await this.showMultiCropEditor();
            }

            // Load image for manual cropping
            async loadImageForCropping(index) {
                if (index < 0 || index >= this.cropData.files.length) return;
                
                this.cropData.currentIndex = index;
                const fileData = this.cropData.files[index];
                
                // Update UI
                document.getElementById('currentImageName').textContent = fileData.name;
                document.getElementById('cropProgress').textContent = `${index + 1}/${this.cropData.files.length}`;
                
                // Load image onto canvas
                const canvas = document.getElementById('cropCanvas');
                const ctx = canvas.getContext('2d');
                
                const img = new Image();
                const imageUrl = URL.createObjectURL(fileData.convertedBlob); // Safe: convertedBlob is always valid
                
                img.onload = () => {
                    // Set canvas size
                    const maxWidth = 800;
                    const maxHeight = 600;
                    let { width, height } = this.calculateDisplaySize(img.width, img.height, maxWidth, maxHeight);
                    
                    canvas.width = width;
                    canvas.height = height;
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    
                    // Draw image
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Sync overlay size with canvas
                    this.syncOverlayWithCanvas();
                    
                    // Initialize crop selection
                    this.initializeCropSelection(width, height);
                    
                    URL.revokeObjectURL(imageUrl);
                };
                
                img.src = imageUrl;
                
                // Update navigation buttons
                document.getElementById('prevCropImage').disabled = index === 0;
                document.getElementById('nextCropImage').disabled = index === this.cropData.files.length - 1;
            }

            // Sync overlay size with canvas
            syncOverlayWithCanvas() {
                const canvas = document.getElementById('cropCanvas');
                const overlay = document.getElementById('cropOverlay');
                
                if (!canvas || !overlay) return;
                
                // Set overlay dimensions to match canvas exactly
                overlay.style.width = canvas.style.width || canvas.width + 'px';
                overlay.style.height = canvas.style.height || canvas.height + 'px';
                
            }

            // Calculate display size maintaining aspect ratio
            calculateDisplaySize(imgWidth, imgHeight, maxWidth, maxHeight) {
                const aspectRatio = imgWidth / imgHeight;
                
                let width = Math.min(imgWidth, maxWidth);
                let height = width / aspectRatio;
                
                if (height > maxHeight) {
                    height = maxHeight;
                    width = height * aspectRatio;
                }
                
                return { width: Math.round(width), height: Math.round(height) };
            }

            // Initialize crop selection overlay
            initializeCropSelection(canvasWidth, canvasHeight) {
                const targetRatio = this.cropData.config.width / this.cropData.config.height;
                const canvasRatio = canvasWidth / canvasHeight;
                
                let selectionWidth, selectionHeight;
                
                // Luôn sử dụng kích thước tối đa có thể (95% để có margin nhỏ)
                if (targetRatio > canvasRatio) {
                    // Target rộng hơn canvas - fit theo chiều rộng
                    selectionWidth = canvasWidth * 0.95;
                    selectionHeight = selectionWidth / targetRatio;
                    
                    // Nếu chiều cao vượt quá canvas, fit theo chiều cao
                    if (selectionHeight > canvasHeight * 0.95) {
                        selectionHeight = canvasHeight * 0.95;
                        selectionWidth = selectionHeight * targetRatio;
                    }
                } else {
                    // Target cao hơn canvas - fit theo chiều cao
                    selectionHeight = canvasHeight * 0.95;
                    selectionWidth = selectionHeight * targetRatio;
                    
                    // Nếu chiều rộng vượt quá canvas, fit theo chiều rộng
                    if (selectionWidth > canvasWidth * 0.95) {
                        selectionWidth = canvasWidth * 0.95;
                        selectionHeight = selectionWidth / targetRatio;
                    }
                }
                
                const x = (canvasWidth - selectionWidth) / 2;
                const y = (canvasHeight - selectionHeight) / 2;
                
                this.updateCropSelection(x, y, selectionWidth, selectionHeight);
                this.initializeCropHandlers();
            }

            // Update crop selection display
            updateCropSelection(x, y, width, height) {
                const selection = document.getElementById('cropSelection');
                const canvas = document.getElementById('cropCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                selection.style.left = x + 'px';
                selection.style.top = y + 'px';
                selection.style.width = width + 'px';
                selection.style.height = height + 'px';
                
                // Update size display
                const scaleX = this.cropData.files[this.cropData.currentIndex].qualityAnalysis.width / canvas.width;
                const scaleY = this.cropData.files[this.cropData.currentIndex].qualityAnalysis.height / canvas.height;
                const actualWidth = Math.round(width * scaleX);
                const actualHeight = Math.round(height * scaleY);
                
                document.getElementById('selectionSize').textContent = `${actualWidth}×${actualHeight}px`;
            }

            // Initialize crop selection handlers
            initializeCropHandlers() {
                const selection = document.getElementById('cropSelection');
                const canvas = document.getElementById('cropCanvas');
                
                // Setup aspect lock button
                const aspectLockBtn = document.getElementById('toggleAspectLock');
                if (aspectLockBtn) {
                    aspectLockBtn.classList.add('active'); // Start active
                }
                
                let isDragging = false;
                let isResizing = false;
                let resizeDirection = '';
                let startX = 0, startY = 0, startLeft = 0, startTop = 0, startWidth = 0, startHeight = 0;
                let aspectLocked = true; // Can be toggled
                let sizeLocked = false;
                let targetAspectRatio = this.cropData?.config ? this.cropData.config.width / this.cropData.config.height : 1;
                let snapToGrid = true;
                let snapThreshold = 10;
                let lockedWidth = 0;
                let lockedHeight = 0;
                
                // Helper function for snapping
                const snapToValue = (value, snapPoints, threshold = snapThreshold) => {
                    for (let snap of snapPoints) {
                        if (Math.abs(value - snap) <= threshold) {
                            return snap;
                        }
                    }
                    return value;
                };

                // DISABLED - NO RESIZE HANDLES ALLOWED
                // const handles = selection.querySelectorAll('.crop-handle');
                // handles.forEach(handle => {
                //     handle.addEventListener('mousedown', (e) => {
                //         e.preventDefault();
                //         
                //         // Prevent resizing if size is locked or aspect ratio is locked
                //         if (sizeLocked) {
                //             this.showToast('⚠️ Kích thước đã bị khóa! Bấm nút 📐 để mở khóa', 'warning');
                //             return;
                //         }
                //         
                //         if (aspectLocked) {
                //             this.showToast('⚠️ Tỷ lệ đã bị khóa! Chỉ có thể di chuyển, không thể thay đổi kích thước', 'warning');
                //             return;
                //         }
                //         
                //         isResizing = true;
                //         resizeDirection = handle.getAttribute('data-direction');
                //         startX = e.clientX; startY = e.clientY;
                //         
                //         const rect = selection.getBoundingClientRect();
                //         const canvasRect = canvas.getBoundingClientRect();
                //         startLeft = rect.left - canvasRect.left;
                //         startTop = rect.top - canvasRect.top;
                //         startWidth = rect.width; startHeight = rect.height;
                //         
                //         // Add visual feedback
                //         selection.classList.add('resizing');
                //         document.body.style.cursor = handle.style.cursor;
                //         
                //         document.addEventListener('mousemove', onMouseMove);
                //         document.addEventListener('mouseup', onMouseUp);
                //     });
                // }); // DISABLED RESIZE HANDLES

                // Add move handle listener
                const moveHandle = selection.querySelector('.crop-move-handle');
                if (moveHandle) {
                    moveHandle.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        isDragging = true;
                        startX = e.clientX; startY = e.clientY;
                        
                        const rect = selection.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();
                        startLeft = rect.left - canvasRect.left;
                        startTop = rect.top - canvasRect.top;
                        
                        // Add visual feedback
                        selection.classList.add('dragging');
                        document.body.style.cursor = 'grabbing';
                        
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    });
                }

                // Smooth animation frame for better performance
                let animationId = null;
                
                const onMouseMove = (e) => {
                    if (animationId) cancelAnimationFrame(animationId);
                    
                    animationId = requestAnimationFrame(() => {
                        if (isDragging) {
                            const deltaX = e.clientX - startX;
                            const deltaY = e.clientY - startY;
                            let newLeft = startLeft + deltaX;
                            let newTop = startTop + deltaY;
                            
                            // Snap to grid if enabled
                            if (snapToGrid) {
                                const gridSize = canvas.width / 3; // 3x3 grid
                                const snapPointsX = [0, gridSize, gridSize * 2, canvas.width - selection.offsetWidth];
                                const snapPointsY = [0, canvas.height / 3, (canvas.height / 3) * 2, canvas.height - selection.offsetHeight];
                                
                                newLeft = snapToValue(newLeft, snapPointsX);
                                newTop = snapToValue(newTop, snapPointsY);
                            }
                            
                            // Constrain within canvas
                            newLeft = Math.max(0, Math.min(canvas.width - selection.offsetWidth, newLeft));
                            newTop = Math.max(0, Math.min(canvas.height - selection.offsetHeight, newTop));
                            
                            selection.style.left = newLeft + 'px';
                            selection.style.top = newTop + 'px';
                            this.updateCropDisplayInfo();
                        } else if (isResizing && !sizeLocked) {
                            const deltaX = e.clientX - startX;
                            const deltaY = e.clientY - startY;
                            let newWidth = startWidth, newHeight = startHeight, newLeft = startLeft, newTop = startTop;
                            
                            switch (resizeDirection) {
                                case 'se': newWidth = startWidth + deltaX; newHeight = startHeight + deltaY; break;
                                case 'nw': newWidth = startWidth - deltaX; newHeight = startHeight - deltaY; 
                                          newLeft = startLeft + deltaX; newTop = startTop + deltaY; break;
                                case 'ne': newWidth = startWidth + deltaX; newHeight = startHeight - deltaY; 
                                          newTop = startTop + deltaY; break;
                                case 'sw': newWidth = startWidth - deltaX; newHeight = startHeight + deltaY; 
                                          newLeft = startLeft + deltaX; break;
                            }
                            
                            // Maintain aspect ratio if locked
                            if (aspectLocked && ['nw', 'ne', 'sw', 'se'].includes(resizeDirection)) {
                                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                    newHeight = newWidth / targetAspectRatio;
                                } else {
                                    newWidth = newHeight * targetAspectRatio;
                                }
                            }
                            
                            // Apply constraints
                            newWidth = Math.max(50, Math.min(newWidth, canvas.width - newLeft));
                            newHeight = Math.max(50, Math.min(newHeight, canvas.height - newTop));
                            newLeft = Math.max(0, Math.min(canvas.width - newWidth, newLeft));
                            newTop = Math.max(0, Math.min(canvas.height - newHeight, newTop));
                            
                            selection.style.left = newLeft + 'px'; selection.style.top = newTop + 'px';
                            selection.style.width = newWidth + 'px'; selection.style.height = newHeight + 'px';
                            this.updateCropDisplayInfo();
                        }
                    });
                };

                const onMouseUp = () => {
                    // Remove visual feedback
                    selection.classList.remove('dragging', 'resizing');
                    document.body.style.cursor = '';
                    
                    isDragging = false; isResizing = false; resizeDirection = '';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };

                // Toggle controls (reuse aspectLockBtn from above)
                const gridBtn = document.getElementById('toggleGrid');
                const sizeLockBtn = document.getElementById('toggleSizeLock');
                const grid = document.getElementById('cropGrid');
                
                // Aspect lock toggle
                aspectLockBtn?.addEventListener('click', () => {
                    aspectLocked = !aspectLocked;
                    aspectLockBtn.classList.toggle('active', aspectLocked);
                    
                    if (aspectLocked) {
                        this.showToast('🔒 Khóa tỷ lệ: BẬT - Giữ nguyên tỷ lệ khi kéo', 'success');
                    } else {
                        this.showToast('🔓 Khóa tỷ lệ: TẮT - Có thể kéo tự do', 'info');
                    }
                });
                
                gridBtn?.addEventListener('click', () => {
                    grid?.classList.toggle('visible');
                    gridBtn.classList.toggle('active', grid?.classList.contains('visible'));
                });
                
                sizeLockBtn?.addEventListener('click', () => {
                    sizeLocked = !sizeLocked;
                    if (sizeLocked) {
                        // Store current ACTUAL dimensions when locking (not display dimensions)
                        const rect = selection.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();
                        
                        // Calculate scale factors to convert display pixels to actual pixels
                        const scaleX = canvas.width / canvasRect.width;
                        const scaleY = canvas.height / canvasRect.height;
                        
                        // Store actual pixel dimensions (zoom-independent)
                        lockedWidth = Math.round(rect.width * scaleX);
                        lockedHeight = Math.round(rect.height * scaleY);
                        
                        // Also store in global scope for zoom handling
                        window.cropSizeLockData = {
                            sizeLocked: true,
                            lockedWidth: lockedWidth,
                            lockedHeight: lockedHeight
                        };
                        
                        console.log(`Locked actual size: ${lockedWidth}x${lockedHeight}px (display: ${rect.width}x${rect.height}px)`);
                        this.showToast('🔒 Đã khóa kích thước khung cắt', 'info');
                    } else {
                        // Clear global lock data when unlocking
                        if (window.cropSizeLockData) {
                            window.cropSizeLockData.sizeLocked = false;
                        }
                        this.showToast('🔓 Đã mở khóa kích thước khung cắt', 'info');
                    }
                    sizeLockBtn.classList.toggle('active', sizeLocked);
                    
                    // NO RESIZE HANDLES - NO CURSOR UPDATE NEEDED
                    // const handles = selection.querySelectorAll('.crop-handle');
                    // handles.forEach(handle => {
                    //     if (aspectLocked || sizeLocked) {
                    //         handle.style.cursor = 'not-allowed';
                    //     } else {
                    //         handle.style.cursor = handle.getAttribute('data-cursor') || 'nw-resize';
                    //     }
                    // });
                });
                
                // Setup ResizeObserver for single crop mode zoom handling
                if (window.ResizeObserver && !canvas._singleCropResizeObserver) {
                    const resizeObserver = new ResizeObserver(() => {
                        setTimeout(() => {
                            this.syncOverlayWithCanvas();
                            // Apply size lock after zoom if it's active
                            this.applySizeLockAfterZoom(null); // null for single crop mode
                        }, 50);
                    });
                    resizeObserver.observe(canvas);
                    canvas._singleCropResizeObserver = resizeObserver;
                }
                
                // Show helpful tip about max sizing
                setTimeout(() => {
                    this.showToast('💡 Khung cắt đã tối ưu kích thước tối đa có thể!', 'success');
                }, 500);
                
                // Initialize display
                this.updateCropDisplayInfo();
                
                // Add edge mode explanation functionality
                const cropBackground = document.getElementById('cropBackground');
                const edgeModeDetails = document.getElementById('edgeModeDetails');
                
                const updateEdgeModeExplanation = () => {
                    const mode = cropBackground.value;
                    let explanation = '';
                    
                    switch(mode) {
                        case 'stretch':
                            explanation = '<strong>🔄 Kéo giãn (Stretch):</strong><br>' +
                                        '• Kéo giãn ảnh để vừa khung cắt<br>' +
                                        '• <span style="color: #f59e0b;">⚠️ Có thể làm biến dạng ảnh</span><br>' +
                                        '• Phù hợp: Logo, hình đơn giản<br>' +
                                        '• <strong>Ví dụ:</strong> Ảnh 4:3 → 16:9 sẽ bị giãn ngang';
                            break;
                        case 'fit':
                            explanation = '<strong>⬜ Vừa khít + viền trắng:</strong><br>' +
                                        '• Giữ nguyên tỷ lệ ảnh gốc<br>' +
                                        '• <span style="color: #10b981;">✅ Thêm viền trắng để đầy khung</span><br>' +
                                        '• Phù hợp: Ảnh chân dung, tài liệu<br>' +
                                        '• <strong>Ví dụ:</strong> Ảnh vuông trong khung chữ nhật có viền trắng 2 bên';
                            break;
                        case 'fill':
                            explanation = '<strong>📏 Đầy khung (Cover):</strong><br>' +
                                        '• Phóng to ảnh để đầy khung<br>' +
                                        '• <span style="color: #f59e0b;">⚠️ Cắt bớt ảnh nếu tỷ lệ khác nhau</span><br>' +
                                        '• Phù hợp: Ảnh phong cảnh, background<br>' +
                                        '• <strong>Ví dụ:</strong> Ảnh vuông trong khung chữ nhật sẽ bị cắt trên/dưới';
                            break;
                    }
                    
                    edgeModeDetails.innerHTML = explanation;
                };
                
                cropBackground?.addEventListener('change', updateEdgeModeExplanation);
                
                // Show initial explanation
                updateEdgeModeExplanation();
            }

            // Update crop display info
            updateCropDisplayInfo() {
                const selection = document.getElementById('cropSelection');
                const canvas = document.getElementById('cropCanvas');
                
                if (!selection || !canvas) return;
                
                const rect = selection.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calculate actual pixel dimensions
                const scaleX = canvas.width / canvasRect.width;
                const scaleY = canvas.height / canvasRect.height;
                const actualWidth = Math.round(rect.width * scaleX);
                const actualHeight = Math.round(rect.height * scaleY);
                
                // Update selection size
                const selectionSizeEl = document.getElementById('selectionSize');
                if (selectionSizeEl) {
                    selectionSizeEl.textContent = `${actualWidth}×${actualHeight}px`;
                }
                
                // Update ratio status
                const ratioStatusEl = document.getElementById('cropRatioStatus');
                if (ratioStatusEl && this.cropData?.config) {
                    const currentRatio = actualWidth / actualHeight;
                    const targetRatio = this.cropData.config.width / this.cropData.config.height;
                    const ratioDiff = Math.abs(currentRatio - targetRatio) / targetRatio;
                    
                    if (ratioDiff < 0.05) {
                        ratioStatusEl.textContent = '✅ Đúng tỷ lệ';
                        ratioStatusEl.style.color = '#10b981';
                    } else {
                        ratioStatusEl.textContent = '⚠️ Sai tỷ lệ';
                        ratioStatusEl.style.color = '#f59e0b';
                    }
                }
                
                // Update mini preview
                this.updateMiniPreview();
            }

            // Update mini preview
            updateMiniPreview() {
                const previewCanvas = document.getElementById('previewCanvas');
                const mainCanvas = document.getElementById('cropCanvas');
                const selection = document.getElementById('cropSelection');
                
                if (!previewCanvas || !mainCanvas || !selection) return;
                
                try {
                    const ctx = previewCanvas.getContext('2d');
                    const mainCtx = mainCanvas.getContext('2d');
                    
                    // Get selection coordinates
                    const rect = selection.getBoundingClientRect();
                    const canvasRect = mainCanvas.getBoundingClientRect();
                    
                    const scaleX = mainCanvas.width / canvasRect.width;
                    const scaleY = mainCanvas.height / canvasRect.height;
                    
                    const cropX = (rect.left - canvasRect.left) * scaleX;
                    const cropY = (rect.top - canvasRect.top) * scaleY;
                    const cropWidth = rect.width * scaleX;
                    const cropHeight = rect.height * scaleY;
                    
                    // Clear preview canvas
                    ctx.clearRect(0, 0, 80, 80);
                    
                    // Draw scaled version of crop area
                    const scale = Math.min(80 / cropWidth, 80 / cropHeight);
                    const scaledWidth = cropWidth * scale;
                    const scaledHeight = cropHeight * scale;
                    const offsetX = (80 - scaledWidth) / 2;
                    const offsetY = (80 - scaledHeight) / 2;
                    
                    ctx.drawImage(mainCanvas, cropX, cropY, cropWidth, cropHeight, offsetX, offsetY, scaledWidth, scaledHeight);
                } catch (error) {
                }
            }

            // Reset crop selection
            resetCropSelection() {
                const canvas = document.getElementById('cropCanvas');
                this.initializeCropSelection(canvas.width, canvas.height);
            }

            // Center crop selection
            centerCropSelection() {
                const canvas = document.getElementById('cropCanvas');
                const selection = document.getElementById('cropSelection');
                const selectionRect = selection.getBoundingClientRect();
                
                const x = (canvas.width - selection.offsetWidth) / 2;
                const y = (canvas.height - selection.offsetHeight) / 2;
                
                this.updateCropSelection(x, y, selection.offsetWidth, selection.offsetHeight);
            }

            // Fit crop selection to canvas
            fitCropSelection() {
                const canvas = document.getElementById('cropCanvas');
                this.initializeCropSelection(canvas.width, canvas.height);
            }

            // Accept current crop
            async acceptCurrentCrop() {
                try {
                    const croppedBlob = await this.performCrop();
                    const fileData = this.cropData.files[this.cropData.currentIndex];
                    const croppedName = this.generateCropName(fileData.convertedName);
                    
                    this.cropData.croppedImages.push({
                        originalFile: fileData,
                        croppedBlob,
                        croppedName
                    });
                    
                    if (this.cropData.currentIndex < this.cropData.files.length - 1) {
                        await this.loadImageForCropping(this.cropData.currentIndex + 1);
                    } else {
                        this.finishManualCropping();
                    }
                } catch (error) {
                    console.error('Error accepting crop:', error);
                    this.showToast('Lỗi khi cắt ảnh!', 'error');
                }
            }

            // Skip current crop
            skipCurrentCrop() {
                if (this.cropData.currentIndex < this.cropData.files.length - 1) {
                    this.loadImageForCropping(this.cropData.currentIndex + 1);
                } else {
                    this.finishManualCropping();
                }
            }

            // Navigate to previous image
            previousCropImage() {
                if (this.cropData.currentIndex > 0) {
                    this.loadImageForCropping(this.cropData.currentIndex - 1);
                }
            }

            // Navigate to next image
            nextCropImage() {
                if (this.cropData.currentIndex < this.cropData.files.length - 1) {
                    this.loadImageForCropping(this.cropData.currentIndex + 1);
                }
            }

            // Perform actual crop
            async performCrop() {
                const canvas = document.getElementById('cropCanvas');
                const selection = document.getElementById('cropSelection');
                const fileData = this.cropData.files[this.cropData.currentIndex];
                
                // Get crop coordinates
                const cropX = parseInt(selection.style.left);
                const cropY = parseInt(selection.style.top);
                const cropWidth = selection.offsetWidth;
                const cropHeight = selection.offsetHeight;
                
                // Scale to original image dimensions
                const scaleX = fileData.qualityAnalysis.width / canvas.width;
                const scaleY = fileData.qualityAnalysis.height / canvas.height;
                
                const originalCropX = cropX * scaleX;
                const originalCropY = cropY * scaleY;
                const originalCropWidth = cropWidth * scaleX;
                const originalCropHeight = cropHeight * scaleY;
                
                return await this.cropImageToSize(
                    fileData, 
                    originalCropX, 
                    originalCropY, 
                    originalCropWidth, 
                    originalCropHeight
                );
            }

            // Crop image to exact size
            async cropImageToSize(fileData, sourceX, sourceY, sourceWidth, sourceHeight) {
                // CÔNG THỨC CHÍNH XÁC: (kích_thước_cm ÷ 2.54) × 300
                // Cố định DPI = 300 (KHÔNG BAO GIỜ thay đổi)
                const DPI = 300;
                const targetWidth = Math.round((this.cropData.config.width / 2.54) * DPI);
                const targetHeight = Math.round((this.cropData.config.height / 2.54) * DPI);
                
                console.log(`✅ KÍCH THƯỚC CHÍNH XÁC: ${this.cropData.config.width}×${this.cropData.config.height}cm at ${DPI}DPI → ${targetWidth}×${targetHeight}px`);
                console.log(`📐 Công thức: (${this.cropData.config.width}÷2.54)×${DPI} × (${this.cropData.config.height}÷2.54)×${DPI} = ${targetWidth}×${targetHeight} pixels`);
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                
                // Load original image
                const img = new Image();
                const imageUrl = this.safeCreateObjectURL(fileData.file);
                if (!imageUrl) {
                    resolve({ success: false, error: 'Cannot create blob URL for this file type' });
                    return;
                }
                
                return new Promise((resolve) => {
                    img.onload = async () => {
                        // Draw cropped and resized image
                        ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, targetWidth, targetHeight);
                        
                        // Convert to blob với chất lượng tối đa
                        canvas.toBlob(async (blob) => {
                            // LUÔN thêm DPI metadata = 300
                            try {
                                const enhancedBlob = await this.addDPIMetadata(blob, DPI);
                                resolve(enhancedBlob);
                            } catch (error) {
                                console.warn('Không thể thêm DPI metadata:', error);
                                resolve(blob);
                            }
                        }, 'image/jpeg', 1.0);
                        
                        URL.revokeObjectURL(imageUrl);
                    };
                    img.src = imageUrl;
                });
            }

            // Auto crop image (center or smart)
            async cropImageAuto(fileData) {
                const img = new Image();
                const imageUrl = URL.createObjectURL(fileData.convertedBlob); // Safe: convertedBlob is always valid
                
                return new Promise((resolve) => {
                    img.onload = async () => {
                        const targetRatio = this.cropData.config.width / this.cropData.config.height;
                        const sourceRatio = img.width / img.height;
                        
                        let sourceX, sourceY, sourceWidth, sourceHeight;
                        
                        if (this.cropData.config.mode === 'smart') {
                            // Smart cropping - try to detect subject
                            const cropArea = await this.detectSmartCropArea(img, targetRatio);
                            ({ sourceX, sourceY, sourceWidth, sourceHeight } = cropArea);
                        } else {
                            // Center cropping
                            if (sourceRatio > targetRatio) {
                                // Source is wider, crop sides
                                sourceHeight = img.height;
                                sourceWidth = sourceHeight * targetRatio;
                                sourceX = (img.width - sourceWidth) / 2;
                                sourceY = 0;
                            } else {
                                // Source is taller, crop top/bottom
                                sourceWidth = img.width;
                                sourceHeight = sourceWidth / targetRatio;
                                sourceX = 0;
                                sourceY = (img.height - sourceHeight) / 2;
                            }
                        }
                        
                        const croppedBlob = await this.cropImageToSize(fileData, sourceX, sourceY, sourceWidth, sourceHeight);
                        URL.revokeObjectURL(imageUrl);
                        resolve(croppedBlob);
                    };
                    img.src = imageUrl;
                });
            }

            // Detect smart crop area (basic implementation)
            async detectSmartCropArea(img, targetRatio) {
                // For now, use center cropping with slight bias toward upper third
                const sourceRatio = img.width / img.height;
                let sourceX, sourceY, sourceWidth, sourceHeight;
                
                if (sourceRatio > targetRatio) {
                    sourceHeight = img.height;
                    sourceWidth = sourceHeight * targetRatio;
                    sourceX = (img.width - sourceWidth) / 2;
                    sourceY = 0;
                } else {
                    sourceWidth = img.width;
                    sourceHeight = sourceWidth / targetRatio;
                    sourceX = 0;
                    sourceY = img.height * 0.1; // Slight upward bias
                }
                
                return { sourceX, sourceY, sourceWidth, sourceHeight };
            }

            // Generate crop file name
            generateCropName(originalName) {
                const naming = this.cropData.config.naming;
                const pixelWidth = Math.round((this.cropData.config.width * this.cropData.config.dpi) / 2.54);
                const pixelHeight = Math.round((this.cropData.config.height * this.cropData.config.dpi) / 2.54);
                const size = `${this.cropData.config.width}x${this.cropData.config.height}cm_${pixelWidth}x${pixelHeight}px_${this.cropData.config.dpi}DPI`;
                
                const nameWithoutExt = originalName.replace(/\.[^/.]+$/, "");
                const ext = 'jpg'; // Always output as JPG for consistency
                
                switch (naming) {
                    case 'append':
                        return `${nameWithoutExt}_${size}.${ext}`;
                    case 'replace':
                        return `cropped_${size}_${Date.now()}.${ext}`;
                    case 'keep':
                    default:
                        return `${nameWithoutExt}.${ext}`;
                }
            }

            // Finish manual cropping
            async finishManualCropping() {
                this.hideCropEditor();
                await this.saveCroppedImages();
            }

            // Hide crop editor
            hideCropEditor() {
                document.getElementById('cropEditorModal').style.display = 'none';
                
                // Cleanup resize listener if exists
                if (this.multiCropData?.resizeHandler) {
                    window.removeEventListener('resize', this.multiCropData.resizeHandler);
                    this.multiCropData.resizeHandler = null;
                }
            }

            // Download all cropped images
            // Save cropped images for later download (don't auto-download)
            async saveCroppedImages() {
                if (this.cropData.croppedImages.length === 0) {
                    this.showToast('Không có ảnh nào được cắt!', 'error');
                    return;
                }
                
                this.showToast('✂️ Đã cắt xong ảnh, sẵn sàng tải về!', 'success');
                
                // Save to cropProcessedFiles for ZIP download
                this.cropProcessedFiles = [];
                for (let i = 0; i < this.cropData.croppedImages.length; i++) {
                    const { croppedBlob, croppedName } = this.cropData.croppedImages[i];
                    
                    this.cropProcessedFiles.push({
                        blob: croppedBlob,
                        name: croppedName,
                        size: croppedBlob.size
                    });
                    
                    // Auto-save to gallery
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        await this.addImageToGallery(e.target.result, croppedName, true);
                    };
                    reader.readAsDataURL(croppedBlob);
                }
                
                const message = `✅ Đã cắt xong ${this.cropData.croppedImages.length} ảnh kích thước ${this.cropData.config.width}×${this.cropData.config.height}cm!\n\n🎯 QUAN TRỌNG: Dùng nút "✂️ Tải từng file đã cắt" hoặc "📦 Tải ZIP đã cắt" để tải ảnh đã cắt!`;
                this.showToast(message);
                
                // Show crop actions after processing
                this.showCropActions();
                
                // Auto-sync crop data
                this.syncCropProcessedFiles();
            }

            // Keep original method for backward compatibility 
            async downloadCroppedImages() {
                if (this.cropData.croppedImages.length === 0) {
                    this.showToast('Không có ảnh nào được cắt!', 'error');
                    return;
                }
                
                this.showToast('Đang tải xuống ảnh đã cắt...', 'success');
                
                // Download individual files
                for (let i = 0; i < this.cropData.croppedImages.length; i++) {
                    const { croppedBlob, croppedName } = this.cropData.croppedImages[i];
                    
                    const url = URL.createObjectURL(croppedBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = croppedName;
                    a.setAttribute('rel', 'noopener noreferrer');
                    
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                    
                    // Small delay between downloads
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                const message = `✅ Đã tải xuống ${this.cropData.croppedImages.length} ảnh đã cắt kích thước ${this.cropData.config.width}×${this.cropData.config.height}cm!`;
                this.showToast(message);
                
                // Clear crop data
                this.cropData = null;
            }

            // Show PDF configuration modal
            showPdfModal() {
                const successFiles = this.files.filter(f => f.status === 'success');
                if (successFiles.length === 0) {
                    this.showToast('Không có ảnh nào để tạo PDF!', 'error');
                    return;
                }
                document.getElementById('pdfModal').style.display = 'flex';
            }

            // Hide PDF modal
            hidePdfModal() {
                document.getElementById('pdfModal').style.display = 'none';
            }

            // Generate PDF with custom configuration
            async generatePDF() {
                const successFiles = this.files.filter(f => f.status === 'success');
                if (successFiles.length === 0) {
                    this.showToast('Không có ảnh nào để tạo PDF!', 'error');
                    return;
                }

                // Get configuration
                const config = {
                    pageSize: document.getElementById('pdfPageSize').value,
                    orientation: document.getElementById('pdfOrientation').value,
                    layout: document.getElementById('pdfLayout').value,
                    imagesPerPage: parseInt(document.getElementById('imagesPerPage').value),
                    title: document.getElementById('pdfTitle').value.trim(),
                    description: document.getElementById('pdfDescription').value.trim(),
                    showFilenames: document.getElementById('showFilenames').checked,
                    showImageInfo: document.getElementById('showImageInfo').checked,
                    addTimestamp: document.getElementById('addTimestamp').checked
                };

                this.hidePdfModal();
                
                try {
                    const generateBtn = document.getElementById('generatePdf');
                    generateBtn.disabled = true;
                    generateBtn.textContent = '📄 Đang tạo PDF...';

                    this.showToast('Đang tạo PDF bản in...', 'success');
                    
                    await this.createPDFDocument(successFiles, config);
                    
                    this.showToast(`✅ Đã tạo PDF thành công với ${successFiles.length} ảnh!`);

                } catch (error) {
                    console.error('Error creating PDF:', error);
                    this.showToast('Lỗi khi tạo PDF!', 'error');
                } finally {
                    const generateBtn = document.getElementById('generatePdf');
                    generateBtn.disabled = false;
                    generateBtn.textContent = '📄 Tạo PDF';
                }
            }

            // Create PDF document
            async createPDFDocument(files, config) {
                const { jsPDF } = window.jspdf;
                
                // Page dimensions
                const pageSizes = {
                    a4: [210, 297],
                    a3: [297, 420],
                    letter: [216, 279],
                    legal: [216, 356]
                };
                
                const [pageWidth, pageHeight] = pageSizes[config.pageSize];
                const pdf = new jsPDF({
                    orientation: config.orientation,
                    unit: 'mm',
                    format: config.pageSize
                });

                // Set PDF metadata
                pdf.setProperties({
                    title: config.title || 'Converted Images',
                    subject: config.description || 'Image conversion result',
                    author: 'Image Converter Tool',
                    creator: 'Image Converter Tool v1.0'
                });

                let currentPage = 1;
                let imagesOnCurrentPage = 0;
                
                // Calculate layout dimensions
                const margin = 20;
                const availableWidth = (config.orientation === 'landscape' ? pageHeight : pageWidth) - (margin * 2);
                const availableHeight = (config.orientation === 'landscape' ? pageWidth : pageHeight) - (margin * 3) - 30; // Extra space for title/footer
                
                // Add title page
                this.addPDFTitlePage(pdf, config, files.length);
                pdf.addPage();
                currentPage++;

                for (let i = 0; i < files.length; i++) {
                    const fileData = files[i];
                    
                    if (config.layout === 'single') {
                        // One image per page
                        if (i > 0) {
                            pdf.addPage();
                            currentPage++;
                        }
                        await this.addImageToPDF(pdf, fileData, config, margin, availableWidth, availableHeight, true);
                        
                    } else {
                        // Multiple images per page
                        if (imagesOnCurrentPage >= config.imagesPerPage) {
                            pdf.addPage();
                            currentPage++;
                            imagesOnCurrentPage = 0;
                        }
                        
                        const position = this.calculateImagePosition(
                            imagesOnCurrentPage, 
                            config.imagesPerPage, 
                            availableWidth, 
                            availableHeight, 
                            margin,
                            config.layout
                        );
                        
                        await this.addImageToPDF(pdf, fileData, config, position.x, position.width, position.height, false, position.y);
                        imagesOnCurrentPage++;
                    }
                }

                // Add footer to all pages
                const totalPages = pdf.internal.getNumberOfPages();
                for (let i = 1; i <= totalPages; i++) {
                    pdf.setPage(i);
                    this.addPDFFooter(pdf, config, i, totalPages, pageWidth, pageHeight);
                }

                // Download PDF
                const timestamp = new Date().toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '-');
                const fileName = `${config.title.replace(/[^a-zA-Z0-9]/g, '_')}_${timestamp}.pdf`;
                
                pdf.save(fileName);
            }

            // Add title page to PDF
            addPDFTitlePage(pdf, config, imageCount) {
                const pageWidth = pdf.internal.pageSize.width;
                const pageHeight = pdf.internal.pageSize.height;
                
                // Title
                pdf.setFontSize(24);
                pdf.setFont(undefined, 'bold');
                pdf.text(config.title, pageWidth / 2, 60, { align: 'center' });
                
                // Description
                if (config.description) {
                    pdf.setFontSize(12);
                    pdf.setFont(undefined, 'normal');
                    const lines = pdf.splitTextToSize(config.description, pageWidth - 40);
                    pdf.text(lines, pageWidth / 2, 80, { align: 'center' });
                }
                
                // Statistics
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text('📊 Thống kê:', 20, 120);
                
                pdf.setFontSize(12);
                pdf.setFont(undefined, 'normal');
                pdf.text(`• Tổng số ảnh: ${imageCount}`, 20, 135);
                pdf.text(`• Định dạng trang: ${config.pageSize.toUpperCase()} ${config.orientation}`, 20, 150);
                pdf.text(`• Layout: ${config.layout}`, 20, 165);
                
                if (config.addTimestamp) {
                    pdf.text(`• Ngày tạo: ${new Date().toLocaleString('vi-VN')}`, 20, 180);
                }
            }

            // Calculate image position based on layout
            calculateImagePosition(index, imagesPerPage, availableWidth, availableHeight, margin, layout) {
                let cols, rows;
                
                if (layout === 'list') {
                    cols = 1;
                    rows = imagesPerPage;
                } else { // grid
                    cols = Math.ceil(Math.sqrt(imagesPerPage));
                    rows = Math.ceil(imagesPerPage / cols);
                }
                
                const cellWidth = availableWidth / cols;
                const cellHeight = availableHeight / rows;
                
                const col = index % cols;
                const row = Math.floor(index / cols);
                
                return {
                    x: margin + (col * cellWidth),
                    y: margin + 30 + (row * cellHeight), // 30mm for page header
                    width: cellWidth - 5, // 5mm padding
                    height: cellHeight - 10 // 10mm padding for text
                };
            }

            // Add single image to PDF
            async addImageToPDF(pdf, fileData, config, x, width, height, fullPage = false, y = null) {
                try {
                    // Convert blob to base64
                    const base64 = await this.blobToBase64(fileData.convertedBlob);
                    const imageFormat = this.getImageFormat(fileData.convertedName);
                    
                    // Calculate image dimensions maintaining aspect ratio
                    const img = new Image();
                    await new Promise((resolve) => {
                        img.onload = resolve;
                        img.src = base64;
                    });
                    
                    const aspectRatio = img.width / img.height;
                    let imgWidth, imgHeight, imgX, imgY;
                    
                    if (fullPage) {
                        // Full page image
                        if (aspectRatio > width / height) {
                            imgWidth = width;
                            imgHeight = width / aspectRatio;
                        } else {
                            imgHeight = height - 20; // Space for filename
                            imgWidth = imgHeight * aspectRatio;
                        }
                        imgX = x + (width - imgWidth) / 2;
                        imgY = y || (pdf.internal.pageSize.height - imgHeight) / 2;
                    } else {
                        // Grid/list image
                        const textSpace = config.showFilenames || config.showImageInfo ? 15 : 5;
                        const availableImgHeight = height - textSpace;
                        
                        if (aspectRatio > width / availableImgHeight) {
                            imgWidth = width;
                            imgHeight = width / aspectRatio;
                        } else {
                            imgHeight = availableImgHeight;
                            imgWidth = imgHeight * aspectRatio;
                        }
                        imgX = x + (width - imgWidth) / 2;
                        imgY = y;
                    }
                    
                    // Add image
                    pdf.addImage(base64, imageFormat, imgX, imgY, imgWidth, imgHeight);
                    
                    // Add filename and info
                    if (config.showFilenames || config.showImageInfo) {
                        const textY = imgY + imgHeight + 5;
                        pdf.setFontSize(8);
                        
                        if (config.showFilenames) {
                            pdf.text(fileData.convertedName, imgX + imgWidth / 2, textY, { align: 'center' });
                        }
                        
                        if (config.showImageInfo) {
                            const info = `${img.width}×${img.height} ${fileData.actualFormat?.toUpperCase() || 'IMG'}`;
                            pdf.text(info, imgX + imgWidth / 2, textY + 7, { align: 'center' });
                        }
                    }
                    
                } catch (error) {
                    console.error('Error adding image to PDF:', error);
                }
            }

            // Add footer to PDF
            addPDFFooter(pdf, config, pageNum, totalPages, pageWidth, pageHeight) {
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'normal');
                
                // Page number
                pdf.text(`Trang ${pageNum}/${totalPages}`, pageWidth - 20, pageHeight - 10, { align: 'right' });
                
                // Generator info
                pdf.text('Tạo bởi Image Converter Tool', 20, pageHeight - 10);
                
                if (config.addTimestamp && pageNum === 1) {
                    const timestamp = new Date().toLocaleString('vi-VN');
                    pdf.text(timestamp, pageWidth / 2, pageHeight - 10, { align: 'center' });
                }
            }

            // Convert blob to base64
            async blobToBase64(blob) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });
            }

            // Get image format for jsPDF
            getImageFormat(fileName) {
                const ext = fileName.split('.').pop().toLowerCase();
                if (ext === 'jpg' || ext === 'jpeg') return 'JPEG';
                if (ext === 'png') return 'PNG';
                if (ext === 'webp') return 'WEBP';
                return 'JPEG'; // Default
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }

            showToast(message, type = 'success') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast ${type}`;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }

            // Generate crop preview for a file
            async generateCropPreview(fileData) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        try {
                            // Create preview canvas
                            const previewCanvas = document.createElement('canvas');
                            const previewCtx = previewCanvas.getContext('2d');
                            
                            // Set preview size
                            const previewSize = 200;
                            previewCanvas.width = previewSize;
                            previewCanvas.height = previewSize;
                            
                            // Calculate crop area based on current config and mode
                            const targetRatio = this.cropData.config.width / this.cropData.config.height;
                            const sourceRatio = img.width / img.height;
                            
                            let sourceX, sourceY, sourceWidth, sourceHeight;
                            
                            // Apply crop logic based on mode
                            switch (this.cropData.config.mode) {
                                case 'smart':
                                    // Smart crop - detect interesting areas
                                    const smartCrop = this.detectSmartCropAreaSync(img, targetRatio);
                                    ({ sourceX, sourceY, sourceWidth, sourceHeight } = smartCrop);
                                    break;
                                case 'center':
                                    // Center crop
                                    if (sourceRatio > targetRatio) {
                                        sourceHeight = img.height;
                                        sourceWidth = sourceHeight * targetRatio;
                                        sourceX = (img.width - sourceWidth) / 2;
                                        sourceY = 0;
                                    } else {
                                        sourceWidth = img.width;
                                        sourceHeight = sourceWidth / targetRatio;
                                        sourceX = 0;
                                        sourceY = (img.height - sourceHeight) / 2;
                                    }
                                    break;
                                case 'manual':
                                default:
                                    // For manual, show full image with overlay indication
                                    sourceX = 0;
                                    sourceY = 0;
                                    sourceWidth = img.width;
                                    sourceHeight = img.height;
                                    break;
                            }
                            
                            // Draw preview with crop area highlighted
                            previewCtx.fillStyle = '#f8f9fa';
                            previewCtx.fillRect(0, 0, previewSize, previewSize);
                            
                            // Calculate how to fit the image in preview
                            const scale = Math.min(previewSize / sourceWidth, previewSize / sourceHeight);
                            const scaledWidth = sourceWidth * scale;
                            const scaledHeight = sourceHeight * scale;
                            const offsetX = (previewSize - scaledWidth) / 2;
                            const offsetY = (previewSize - scaledHeight) / 2;
                            
                            // Draw the cropped area
                            previewCtx.drawImage(
                                img, 
                                sourceX, sourceY, sourceWidth, sourceHeight,
                                offsetX, offsetY, scaledWidth, scaledHeight
                            );
                            
                            // Add border
                            previewCtx.strokeStyle = 'var(--primary-blue)';
                            previewCtx.lineWidth = 2;
                            previewCtx.strokeRect(offsetX, offsetY, scaledWidth, scaledHeight);
                            
                            // Convert to blob
                            previewCanvas.toBlob((blob) => {
                                resolve({
                                    fileData,
                                    previewBlob: blob,
                                    previewUrl: URL.createObjectURL(blob),
                                    cropArea: { sourceX, sourceY, sourceWidth, sourceHeight }
                                });
                            }, 'image/jpeg', 0.8);
                            
                        } catch (error) {
                            console.error('Error generating preview:', error);
                            resolve({ fileData, previewBlob: null, previewUrl: null, cropArea: null });
                        }
                    };
                    
                    const imageUrl = this.safeCreateObjectURL(fileData.file);
                    if (!imageUrl) {
                        reject(new Error('Cannot create blob URL for this file type'));
                        return;
                    }
                    img.src = imageUrl;
                });
            }

            // Synchronous version of smart crop detection for preview
            detectSmartCropAreaSync(img, targetRatio) {
                const sourceRatio = img.width / img.height;
                let sourceX, sourceY, sourceWidth, sourceHeight;
                
                if (sourceRatio > targetRatio) {
                    sourceHeight = img.height;
                    sourceWidth = sourceHeight * targetRatio;
                    sourceX = (img.width - sourceWidth) / 2;
                    sourceY = 0;
                } else {
                    sourceWidth = img.width;
                    sourceHeight = sourceWidth / targetRatio;
                    sourceX = 0;
                    sourceY = img.height * 0.1; // Slight upward bias
                }
                
                return { sourceX, sourceY, sourceWidth, sourceHeight };
            }

            // Show preview gallery with all cropped images
            showPreviewGallery() {
                const modal = document.getElementById('cropPreviewModal');
                const gallery = document.getElementById('previewGallery');
                const modeTitle = document.getElementById('previewModeTitle');
                const previewCount = document.getElementById('previewCount');
                
                // Update title based on mode
                const modeNames = {
                    'smart': 'Chế độ thông minh',
                    'center': 'Chế độ trung tâm', 
                    'manual': 'Chế độ thủ công'
                };
                modeTitle.textContent = modeNames[this.cropData.config.mode] || 'Chế độ mẫu';
                
                // Update count
                previewCount.textContent = `${this.cropData.previewData.length} ảnh`;
                
                // Clear gallery
                gallery.innerHTML = '';
                
                // Create preview grid
                this.cropData.previewData.forEach((preview, index) => {
                    const previewItem = document.createElement('div');
                    previewItem.className = 'preview-item';
                    previewItem.innerHTML = `
                        <div class="preview-image-container">
                            <img src="${preview.previewUrl}" alt="${preview.fileData.name}" class="preview-image">
                            <div class="preview-overlay">
                                <div class="preview-info">
                                    <div class="preview-name">${preview.fileData.name}</div>
                                    <div class="preview-size">${this.cropData.config.width}×${this.cropData.config.height}cm</div>
                                </div>
                            </div>
                        </div>
                        <div class="preview-controls">
                            <button class="preview-btn edit" onclick="converter.editPreviewCrop(${index})">
                                Chỉnh sửa
                            </button>
                            <button class="preview-btn remove" onclick="converter.removeFromPreview(${index})">
                                Loại bỏ
                            </button>
                        </div>
                    `;
                    gallery.appendChild(previewItem);
                });
                
                modal.style.display = 'flex';
            }

            // Edit individual crop in preview
            editPreviewCrop(index) {
                // Store current preview state
                this.cropData.currentPreviewIndex = index;
                const preview = this.cropData.previewData[index];
                
                // Switch to manual editing mode for this specific image
                document.getElementById('cropPreviewModal').style.display = 'none';
                document.getElementById('cropEditorModal').style.display = 'flex';
                
                // Load the specific image
                this.loadImageForPreviewEdit(preview);
            }

            // Load image for preview editing
            async loadImageForPreviewEdit(preview) {
                const canvas = document.getElementById('cropCanvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    // Set canvas size to image size with max constraints
                    const maxSize = 800;
                    let displayWidth = img.width;
                    let displayHeight = img.height;
                    
                    if (img.width > maxSize || img.height > maxSize) {
                        const scale = Math.min(maxSize / img.width, maxSize / img.height);
                        displayWidth = img.width * scale;
                        displayHeight = img.height * scale;
                    }
                    
                    canvas.width = displayWidth;
                    canvas.height = displayHeight;
                    
                    // Clear and draw image
                    ctx.clearRect(0, 0, displayWidth, displayHeight);
                    ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                    
                    // Update UI
                    document.getElementById('currentImageName').textContent = preview.fileData.name;
                    document.getElementById('cropProgress').textContent = `Chỉnh sửa preview`;
                    
                    // Initialize crop selection based on existing crop area
                    if (preview.cropArea) {
                        const scale = displayWidth / img.width;
                        const scaledCropArea = {
                            x: preview.cropArea.sourceX * scale,
                            y: preview.cropArea.sourceY * scale,
                            width: preview.cropArea.sourceWidth * scale,
                            height: preview.cropArea.sourceHeight * scale
                        };
                        this.updateCropSelection(scaledCropArea.x, scaledCropArea.y, scaledCropArea.width, scaledCropArea.height);
                    } else {
                        this.initializeCropSelection(displayWidth, displayHeight);
                    }
                    
                    // Setup interactions with pixel-perfect precision
                    this.setupPixelPerfectCropInteractions();
                };
                
                const imgUrl = this.safeCreateObjectURL(preview.fileData.file);
                if (!imgUrl) {
                    console.error('Cannot create blob URL for file:', preview.fileData.file.name);
                    return;
                }
                img.src = imgUrl;
            }

            // Setup pixel-perfect crop interactions
            setupPixelPerfectCropInteractions() {
                const selection = document.getElementById('cropSelection');
                const canvas = document.getElementById('cropCanvas');
                
                let isDragging = false;
                let isResizing = false;
                let resizeDirection = '';
                let startX = 0, startY = 0, startLeft = 0, startTop = 0, startWidth = 0, startHeight = 0;
                // Get aspect lock setting from global controls
                let aspectLocked = this.multiCropData.globalSettings.aspectLocked;
                let sizeLocked = false;
                let targetAspectRatio = this.cropData?.config ? this.cropData.config.width / this.cropData.config.height : 1;
                
                // Pixel-perfect movement with sub-pixel precision
                let rafId = null;
                
                const onMouseMove = (e) => {
                    if (rafId) cancelAnimationFrame(rafId);
                    
                    rafId = requestAnimationFrame(() => {
                        if (isDragging) {
                            const deltaX = e.clientX - startX;
                            const deltaY = e.clientY - startY;
                            
                            // Calculate new position with pixel precision
                            let newLeft = Math.round(startLeft + deltaX);
                            let newTop = Math.round(startTop + deltaY);
                            
                            // Constrain within canvas with pixel precision
                            newLeft = Math.max(0, Math.min(canvas.width - selection.offsetWidth, newLeft));
                            newTop = Math.max(0, Math.min(canvas.height - selection.offsetHeight, newTop));
                            
                            // Apply with transform for smooth animation
                            selection.style.transform = `translate(${newLeft}px, ${newTop}px)`;
                            selection.style.left = '0px';
                            selection.style.top = '0px';
                            
                            this.updateCropDisplayInfo();
                        } else if (isResizing && !sizeLocked) {
                            const deltaX = e.clientX - startX;
                            const deltaY = e.clientY - startY;
                            let newWidth = startWidth, newHeight = startHeight;
                            let newLeft = startLeft, newTop = startTop;
                            
                            // Apply resize based on direction with pixel precision
                            switch (resizeDirection) {
                                case 'se': 
                                    newWidth = Math.round(startWidth + deltaX); 
                                    newHeight = Math.round(startHeight + deltaY); 
                                    break;
                                case 'nw': 
                                    newWidth = Math.round(startWidth - deltaX); 
                                    newHeight = Math.round(startHeight - deltaY); 
                                    newLeft = Math.round(startLeft + deltaX); 
                                    newTop = Math.round(startTop + deltaY); 
                                    break;
                                case 'ne': 
                                    newWidth = Math.round(startWidth + deltaX); 
                                    newHeight = Math.round(startHeight - deltaY); 
                                    newTop = Math.round(startTop + deltaY); 
                                    break;
                                case 'sw': 
                                    newWidth = Math.round(startWidth - deltaX); 
                                    newHeight = Math.round(startHeight + deltaY); 
                                    newLeft = Math.round(startLeft + deltaX); 
                                    break;
                            }
                            
                            // Maintain aspect ratio if locked
                            if (aspectLocked && ['nw', 'ne', 'sw', 'se'].includes(resizeDirection)) {
                                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                    newHeight = Math.round(newWidth / targetAspectRatio);
                                } else {
                                    newWidth = Math.round(newHeight * targetAspectRatio);
                                }
                            }
                            
                            // Apply constraints with pixel precision
                            newWidth = Math.max(20, Math.min(newWidth, canvas.width - newLeft));
                            newHeight = Math.max(20, Math.min(newHeight, canvas.height - newTop));
                            newLeft = Math.max(0, Math.min(canvas.width - newWidth, newLeft));
                            newTop = Math.max(0, Math.min(canvas.height - newHeight, newTop));
                            
                            // Apply with pixel-perfect positioning
                            selection.style.transform = `translate(${newLeft}px, ${newTop}px)`;
                            selection.style.width = newWidth + 'px';
                            selection.style.height = newHeight + 'px';
                            selection.style.left = '0px';
                            selection.style.top = '0px';
                            
                            this.updateCropDisplayInfo();
                        }
                    });
                };
                
                // Setup event listeners for pixel-perfect interactions
                // ... (rest of the interaction setup)
            }

            // Remove image from preview
            removeFromPreview(index) {
                this.cropData.previewData.splice(index, 1);
                this.showPreviewGallery(); // Refresh gallery
            }

            // Show multi-image crop editor
            async showMultiCropEditor() {
                const modal = document.getElementById('cropEditorModal');
                const container = document.getElementById('multiCropContainer');
                const progress = document.getElementById('multiCropProgress');
                const globalTargetSize = document.getElementById('globalTargetSize');
                const globalAspectRatio = document.getElementById('globalAspectRatio');
                
                // Detect predominant orientation and adapt crop size
                let adaptedCropSize = { width: this.cropData.config.width, height: this.cropData.config.height };
                if (this.multiCropData.files.length > 0) {
                    // Count landscape vs portrait images
                    let landscapeCount = 0;
                    let portraitCount = 0;
                    
                    for (const fileData of this.multiCropData.files) {
                        const orientation = await this.detectImageOrientationFromFileData(fileData);
                        if (orientation === 'landscape') {
                            landscapeCount++;
                        } else {
                            portraitCount++;
                        }
                    }
                    
                    // If majority is landscape, adapt crop size
                    if (landscapeCount > portraitCount) {
                        const originalOrientation = adaptedCropSize.width > adaptedCropSize.height ? 'landscape' : 'portrait';
                        if (originalOrientation === 'portrait') {
                            adaptedCropSize = { width: adaptedCropSize.height, height: adaptedCropSize.width };
                            console.log('Multi-crop: Adapted to landscape crop size:', adaptedCropSize);
                        }
                    }
                    
                    // Update crop config with adapted size
                    this.cropData.config.width = adaptedCropSize.width;
                    this.cropData.config.height = adaptedCropSize.height;
                    this.cropData.config.aspectRatio = adaptedCropSize.width / adaptedCropSize.height;
                }
                
                // Update global info
                progress.textContent = `${this.multiCropData.files.length} ảnh`;
                globalTargetSize.textContent = `${adaptedCropSize.width}×${adaptedCropSize.height}cm`;
                globalAspectRatio.textContent = `${adaptedCropSize.width}:${adaptedCropSize.height}`;
                
                // Clear container
                container.innerHTML = '';
                
                // Create crop cards for each image (display all)
                for (let i = 0; i < this.multiCropData.files.length; i++) {
                    const fileData = this.multiCropData.files[i];
                    this.createMultiCropCard(fileData, i, container);
                }
                
                // Setup global controls
                this.setupGlobalCropControls();
                
                modal.style.display = 'flex';
                
                // Auto-select all files initially
                this.multiCropData.files.forEach((_, index) => {
                    this.multiCropData.selectedFiles.add(index);
                });
                this.updateMultiCropSelections();

                // Add resize listener to re-sync overlays
                const resizeHandler = () => {
                    for (let i = 0; i < this.multiCropData.files.length; i++) {
                        this.syncOverlayWithCanvas(i);
                    }
                };
                window.addEventListener('resize', resizeHandler);
                
                // Store handler for cleanup
                this.multiCropData.resizeHandler = resizeHandler;
            }

            // Create individual crop card
            async createMultiCropCard(fileData, index, container) {
                const cardId = `crop-card-${index}`;
                const card = document.createElement('div');
                card.className = 'multi-crop-card selected';
                card.id = cardId;
                
                // Create card HTML
                card.innerHTML = `
                    <div class="multi-crop-header">
                        <div class="multi-crop-name" title="${fileData.name}">${fileData.name}</div>
                        <div class="multi-crop-selector">
                            <div class="multi-crop-checkbox checked" data-action="toggle" data-index="${index}">
                                ✓
                            </div>
                        </div>
                    </div>
                    <div class="multi-crop-canvas-container">
                        <canvas class="multi-crop-canvas" id="canvas-${index}"></canvas>
                        <div class="multi-crop-overlay">
                            <div class="multi-crop-selection" id="selection-${index}">
                                <!-- Move handle -->
                                <div class="multi-crop-move-handle">✥</div>
                                
                                <!-- Resize handles for changing crop size -->
                                <div class="multi-crop-resize-handle nw" data-direction="nw" data-index="${index}"></div>
                                <div class="multi-crop-resize-handle ne" data-direction="ne" data-index="${index}"></div>
                                <div class="multi-crop-resize-handle sw" data-direction="sw" data-index="${index}"></div>
                                <div class="multi-crop-resize-handle se" data-direction="se" data-index="${index}"></div>
                            </div>
                        </div>
                    </div>
                    <div class="multi-crop-controls">
                        <button class="multi-crop-btn" data-action="reset" data-index="${index}">Đặt lại</button>
                        <button class="multi-crop-btn" data-action="center" data-index="${index}">Căn giữa</button>
                        <button class="multi-crop-btn" data-action="fit" data-index="${index}">Tối đa</button>
                    </div>
                    <div class="multi-crop-info">
                        <span id="crop-info-${index}">Chờ tải ảnh...</span>
                    </div>
                `;
                
                container.appendChild(card);
                
                // Setup button event listeners
                this.setupMultiCropCardButtons(index);
                
                // Setup resize handles
                this.setupMultiCropResizeHandles(index);
                
                // Load image into canvas
                await this.loadImageIntoMultiCropCard(fileData, index);
            }

            // Load image into crop card
            async loadImageIntoMultiCropCard(fileData, index) {
                const canvas = document.getElementById(`canvas-${index}`);
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    // Wait for container to be properly sized
                    setTimeout(() => {
                        try {
                            // Always use full container size for maximum visibility
                            const container = canvas.parentElement;
                            const containerWidth = container.clientWidth || 380;
                            const containerHeight = container.clientHeight || 320;
                            
                            // Use full container width, dynamically scale height based on image aspect ratio
                            const maxWidth = containerWidth;
                            const maxHeight = containerHeight;
                        
                        console.log(`Image ${index}: ${img.width}x${img.height}, Container max: ${maxWidth}x${maxHeight}`);
                        
                        // Calculate scale to fit within max dimensions
                        const scaleX = maxWidth / img.width;
                        const scaleY = maxHeight / img.height;
                        const scale = Math.min(scaleX, scaleY, 1); // Don't scale up
                        
                        // Calculate final display size
                        const displayWidth = Math.floor(img.width * scale);
                        const displayHeight = Math.floor(img.height * scale);
                        
                        // Set canvas dimensions
                        canvas.width = displayWidth;
                        canvas.height = displayHeight;
                        
                        // Style canvas to be centered in container
                        canvas.style.display = 'block';
                        canvas.style.margin = 'auto';
                        canvas.style.maxWidth = '100%';
                        canvas.style.maxHeight = '100%';
                        
                        // Clear canvas and set white background
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, displayWidth, displayHeight);
                        
                        // Draw image
                        ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                        
                        console.log(`Canvas ${index}: ${displayWidth}x${displayHeight}, scale: ${scale}`);
                        
                        // Wait for layout to settle, then sync overlay
                        setTimeout(async () => {
                            this.syncOverlayWithCanvas(index);
                            // Initialize crop selection
                            await this.initializeMultiCropSelection(index, displayWidth, displayHeight);
                        }, 100);
                        
                        // Setup interactions
                        this.setupMultiCropInteractions(index);
                        
                        // Update info
                        this.updateMultiCropInfo(index);
                        
                        // Setup ResizeObserver to handle zoom changes and layout updates
                        if (window.ResizeObserver) {
                            const resizeObserver = new ResizeObserver(() => {
                                setTimeout(() => {
                                    this.syncOverlayWithCanvas(index);
                                    // Apply size lock after zoom if it's active
                                    this.applySizeLockAfterZoom(index);
                                }, 50);
                            });
                            resizeObserver.observe(canvas.parentElement);
                            resizeObserver.observe(canvas);
                            resizeObserver.observe(container);
                        }
                        } catch (error) {
                            console.error(`Error loading image for canvas ${index}:`, error);
                        }
                    }, 100); // 100ms delay to ensure container is sized
                };
                
                img.onerror = (error) => {
                    console.error(`Failed to load image for canvas ${index}:`, error);
                    // Show error message in canvas
                    canvas.width = 200;
                    canvas.height = 100;
                    ctx.fillStyle = '#f8f9fa';
                    ctx.fillRect(0, 0, 200, 100);
                    ctx.fillStyle = '#dc3545';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Lỗi tải ảnh', 100, 50);
                };
                
                const imgUrl = this.safeCreateObjectURL(fileData.file);
                if (!imgUrl) {
                    console.error('Cannot create blob URL for file:', fileData.file.name);
                    return;
                }
                img.src = imgUrl;
            }

            // Initialize crop selection for a card
            async initializeMultiCropSelection(index, canvasWidth, canvasHeight) {
                // Get individual crop size adapted to this specific image's orientation
                const fileData = this.multiCropData.files[index];
                const imageOrientation = await this.detectImageOrientationFromFileData(fileData);
                
                // Use base crop size from config
                const baseCropSize = { 
                    width: this.cropData.config.width, 
                    height: this.cropData.config.height 
                };
                
                // Adapt crop size for this specific image
                const adaptedCropSize = this.adaptCropSizeToOrientation(baseCropSize, imageOrientation);
                const targetRatio = adaptedCropSize.width / adaptedCropSize.height;
                const canvasRatio = canvasWidth / canvasHeight;
                
                console.log(`Image ${index} (${imageOrientation}): Using crop ${adaptedCropSize.width}×${adaptedCropSize.height} (ratio: ${targetRatio.toFixed(3)})`);
                
                let selectionWidth, selectionHeight;
                
                // Use 100% of available canvas space for MAXIMUM crop area
                console.log(`Target ratio: ${targetRatio.toFixed(3)}, Canvas ratio: ${canvasRatio.toFixed(3)}`);
                
                // Calculate MAXIMUM selection size while maintaining aspect ratio
                if (targetRatio > canvasRatio) {
                    // Target is wider than canvas - limit by width (use full width)
                    selectionWidth = canvasWidth; // 100% width - MAXIMUM!
                    selectionHeight = selectionWidth / targetRatio;
                    
                    console.log(`Width-limited: ${selectionWidth}x${selectionHeight}`);
                } else {
                    // Target is taller than canvas - limit by height (use full height)
                    selectionHeight = canvasHeight; // 100% height - MAXIMUM!
                    selectionWidth = selectionHeight * targetRatio;
                    
                    console.log(`Height-limited: ${selectionWidth}x${selectionHeight}`);
                }
                
                // Final bounds check (should not be needed with proper calculation)
                selectionWidth = Math.min(selectionWidth, canvasWidth);
                selectionHeight = Math.min(selectionHeight, canvasHeight);
                
                // Center the selection within canvas bounds
                const x = Math.max(0, (canvasWidth - selectionWidth) / 2);
                const y = Math.max(0, (canvasHeight - selectionHeight) / 2);
                
                console.log(`MAXIMUM Canvas ${index}: ${canvasWidth}x${canvasHeight}, Selection: ${Math.round(selectionWidth)}x${Math.round(selectionHeight)} at (${Math.round(x)}, ${Math.round(y)})`);
                console.log(`Selection uses ${((selectionWidth/canvasWidth)*100).toFixed(1)}% width, ${((selectionHeight/canvasHeight)*100).toFixed(1)}% height`);
                
                // Store crop selection with bounds checking
                this.multiCropData.cropSelections.set(index, {
                    x: Math.round(x), 
                    y: Math.round(y), 
                    width: Math.round(selectionWidth), 
                    height: Math.round(selectionHeight)
                });
                
                // Update visual selection
                this.updateMultiCropSelectionVisual(index);
            }

            // Update visual crop selection
            updateMultiCropSelectionVisual(index) {
                const selection = document.getElementById(`selection-${index}`);
                const cropArea = this.multiCropData.cropSelections.get(index);
                const canvas = document.getElementById(`canvas-${index}`);
                
                if (selection && cropArea && canvas) {
                    // Ensure overlay is properly positioned first
                    this.syncOverlayWithCanvas(index);
                    
                    // Validate crop area bounds
                    const maxX = canvas.width - cropArea.width;
                    const maxY = canvas.height - cropArea.height;
                    
                    const validX = Math.max(0, Math.min(cropArea.x, maxX));
                    const validY = Math.max(0, Math.min(cropArea.y, maxY));
                    const validWidth = Math.min(cropArea.width, canvas.width - validX);
                    const validHeight = Math.min(cropArea.height, canvas.height - validY);
                    
                    // Update crop area if bounds were adjusted
                    if (validX !== cropArea.x || validY !== cropArea.y || 
                        validWidth !== cropArea.width || validHeight !== cropArea.height) {
                        this.multiCropData.cropSelections.set(index, {
                            x: validX, y: validY, width: validWidth, height: validHeight
                        });
                    }
                    
                    // Set crop selection position relative to overlay with validated bounds
                    selection.style.position = 'absolute';
                    selection.style.left = validX + 'px';
                    selection.style.top = validY + 'px';
                    selection.style.width = validWidth + 'px';
                    selection.style.height = validHeight + 'px';
                    
                    console.log(`Selection ${index}: ${validWidth}x${validHeight} at (${validX}, ${validY}) within canvas ${canvas.width}x${canvas.height}`);
                }
            }

            // Setup crop interactions for a card
            setupMultiCropInteractions(index) {
                const selection = document.getElementById(`selection-${index}`);
                const canvas = document.getElementById(`canvas-${index}`);
                
                if (!selection || !canvas) return;
                
                let isDragging = false;
                let isResizing = false;
                let resizeDirection = '';
                let startX = 0, startY = 0;
                let startCropArea = null;
                let animationId = null;
                
                // Handle move
                const moveHandle = selection.querySelector('.multi-crop-move-handle');
                moveHandle?.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startCropArea = { ...this.multiCropData.cropSelections.get(index) };
                    selection.classList.add('dragging');
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
                
                // DISABLED - NO RESIZE HANDLES IN MULTI-CROP
                // const handles = selection.querySelectorAll('.multi-crop-handle.corner');
                // handles.forEach(handle => {
                //     handle.addEventListener('mousedown', (e) => {
                //         e.preventDefault();
                //         
                //         if (this.multiCropData.globalSettings.sizeLocked) {
                //             this.showToast('Kích thước đã bị khóa!', 'warning');
                //             return;
                //         }
                //         
                //         isResizing = true;
                //         resizeDirection = handle.getAttribute('data-direction');
                //         startX = e.clientX;
                //         startY = e.clientY;
                //         startCropArea = { ...this.multiCropData.cropSelections.get(index) };
                //         
                //         document.addEventListener('mousemove', onMouseMove);
                //         document.addEventListener('mouseup', onMouseUp);
                //     });
                // }); // DISABLED MULTI-CROP RESIZE
                
                const onMouseMove = (e) => {
                    if (animationId) cancelAnimationFrame(animationId);
                    
                    animationId = requestAnimationFrame(() => {
                        if (!startCropArea) return;
                        
                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;
                        
                        if (isDragging) {
                            // Move crop area with pixel precision
                            const newX = Math.round(Math.max(0, Math.min(canvas.width - startCropArea.width, startCropArea.x + deltaX)));
                            const newY = Math.round(Math.max(0, Math.min(canvas.height - startCropArea.height, startCropArea.y + deltaY)));
                            
                            this.multiCropData.cropSelections.set(index, {
                                ...startCropArea,
                                x: newX,
                                y: newY
                            });
                        }
                        // REMOVED RESIZE LOGIC - ONLY DRAG IS ALLOWED
                        
                        this.updateMultiCropSelectionVisual(index);
                        this.updateMultiCropInfo(index);
                    });
                };
                
                const onMouseUp = () => {
                    if (animationId) cancelAnimationFrame(animationId);
                    isDragging = false;
                    isResizing = false;
                    resizeDirection = '';
                    startCropArea = null;
                    selection.classList.remove('dragging');
                    
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
            }

            // Toggle crop selection
            toggleCropSelection(index) {
                const checkbox = document.querySelector(`#crop-card-${index} .multi-crop-checkbox`);
                const card = document.getElementById(`crop-card-${index}`);
                
                if (this.multiCropData.selectedFiles.has(index)) {
                    this.multiCropData.selectedFiles.delete(index);
                    checkbox.classList.remove('checked');
                    card.classList.remove('selected');
                } else {
                    this.multiCropData.selectedFiles.add(index);
                    checkbox.classList.add('checked');
                    card.classList.add('selected');
                }
                
                this.updateMultiCropSelections();
            }

            // Setup global crop controls
            setupGlobalCropControls() {
                // Remove existing listeners first
                const globalControls = ['resetAllCrops', 'centerAllCrops', 'fitAllCrops', 'globalAspectLock', 'globalSizeLock', 'selectAllCrops', 'acceptAllCrops'];
                globalControls.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.replaceWith(element.cloneNode(true));
                    }
                });
                
                // Global aspect lock - allow toggle
                const globalAspectLockBtn = document.getElementById('globalAspectLock');
                if (globalAspectLockBtn) {
                    globalAspectLockBtn.classList.add('active'); // Start as active
                }
                
                // Global aspect lock toggle functionality
                document.getElementById('globalAspectLock')?.addEventListener('click', () => {
                    const btn = document.getElementById('globalAspectLock');
                    const isActive = btn.classList.toggle('active');
                    
                    // Update global setting
                    this.multiCropData.globalSettings.aspectLocked = isActive;
                    
                    // Show status
                    if (isActive) {
                        this.showToast('🔒 Khóa tỷ lệ: BẬT - Giữ nguyên tỷ lệ khi kéo', 'success');
                    } else {
                        this.showToast('🔓 Khóa tỷ lệ: TẮT - Có thể kéo tự do', 'info');
                    }
                });
                
                // Global size lock
                document.getElementById('globalSizeLock')?.addEventListener('click', () => {
                    this.multiCropData.globalSettings.sizeLocked = !this.multiCropData.globalSettings.sizeLocked;
                    const btn = document.getElementById('globalSizeLock');
                    btn.classList.toggle('active', this.multiCropData.globalSettings.sizeLocked);
                    
                    if (this.multiCropData.globalSettings.sizeLocked) {
                        // Store current actual sizes for all selected cards
                        this.multiCropData.selectedFiles.forEach(index => {
                            const selection = document.querySelector(`#selection-${index}`);
                            const canvas = document.getElementById(`canvas-${index}`);
                            if (selection && canvas) {
                                const rect = selection.getBoundingClientRect();
                                const canvasRect = canvas.getBoundingClientRect();
                                
                                // Calculate scale factors
                                const scaleX = canvas.width / canvasRect.width;
                                const scaleY = canvas.height / canvasRect.height;
                                
                                // Store actual dimensions for this card
                                const cropData = this.multiCropData.cropSelections.get(index) || {};
                                cropData.lockedActualWidth = Math.round(rect.width * scaleX);
                                cropData.lockedActualHeight = Math.round(rect.height * scaleY);
                                this.multiCropData.cropSelections.set(index, cropData);
                                
                                console.log(`Locked card ${index}: ${cropData.lockedActualWidth}x${cropData.lockedActualHeight}px actual`);
                            }
                        });
                        this.showToast('🔒 Đã khóa kích thước tất cả khung cắt', 'info');
                    } else {
                        // Clear locked sizes
                        this.multiCropData.selectedFiles.forEach(index => {
                            const cropData = this.multiCropData.cropSelections.get(index);
                            if (cropData) {
                                delete cropData.lockedActualWidth;
                                delete cropData.lockedActualHeight;
                                this.multiCropData.cropSelections.set(index, cropData);
                            }
                        });
                        this.showToast('🔓 Đã mở khóa kích thước tất cả khung cắt', 'info');
                    }
                });
                
                // Global actions
                document.getElementById('resetAllCrops')?.addEventListener('click', async () => {
                    for (const index of this.multiCropData.selectedFiles) {
                        await this.resetCropCard(index);
                    }
                });
                
                document.getElementById('centerAllCrops')?.addEventListener('click', () => {
                    this.multiCropData.selectedFiles.forEach(index => this.centerCropCard(index));
                });
                
                document.getElementById('fitAllCrops')?.addEventListener('click', async () => {
                    for (const index of this.multiCropData.selectedFiles) {
                        await this.fitCropCard(index);
                    }
                });
                
                document.getElementById('selectAllCrops')?.addEventListener('click', () => {
                    this.multiCropData.files.forEach((_, index) => {
                        this.multiCropData.selectedFiles.add(index);
                    });
                    this.updateAllCropCardSelections();
                });
                
                document.getElementById('acceptAllCrops')?.addEventListener('click', () => {
                    this.processMultiCropSelection();
                });
            }

            // Update multi-crop selections
            updateMultiCropSelections() {
                const selectedCount = this.multiCropData.selectedFiles.size;
                const acceptButton = document.getElementById('acceptAllCrops');
                
                if (acceptButton) {
                    acceptButton.textContent = `Cắt ${selectedCount} ảnh đã chọn`;
                    acceptButton.disabled = selectedCount === 0;
                }
            }

            // Reset, center, fit crop cards
            async resetCropCard(index) {
                const canvas = document.getElementById(`canvas-${index}`);
                if (canvas) {
                    await this.initializeMultiCropSelection(index, canvas.width, canvas.height);
                }
            }

            centerCropCard(index) {
                const cropArea = this.multiCropData.cropSelections.get(index);
                const canvas = document.getElementById(`canvas-${index}`);
                
                if (cropArea && canvas) {
                    const newX = (canvas.width - cropArea.width) / 2;
                    const newY = (canvas.height - cropArea.height) / 2;
                    
                    this.multiCropData.cropSelections.set(index, {
                        ...cropArea, x: newX, y: newY
                    });
                    this.updateMultiCropSelectionVisual(index);
                }
            }

            async fitCropCard(index) {
                const canvas = document.getElementById(`canvas-${index}`);
                if (canvas) {
                    await this.initializeMultiCropSelection(index, canvas.width, canvas.height);
                }
            }
            
            // Multi-crop resize handles setup
            setupMultiCropResizeHandles(index) {
                const selection = document.getElementById(`selection-${index}`);
                const canvas = document.getElementById(`canvas-${index}`);
                const resizeHandles = selection.querySelectorAll('.multi-crop-resize-handle');
                
                if (!selection || !canvas || !resizeHandles.length) return;
                
                resizeHandles.forEach(handle => {
                    let isResizing = false;
                    let startX = 0, startY = 0;
                    let startWidth = 0, startHeight = 0;
                    let startLeft = 0, startTop = 0;
                    const direction = handle.getAttribute('data-direction');
                    
                    const onMouseDown = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        isResizing = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        startWidth = selection.offsetWidth;
                        startHeight = selection.offsetHeight;
                        startLeft = parseInt(selection.style.left);
                        startTop = parseInt(selection.style.top);
                        
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    };
                    
                    const onMouseMove = (e) => {
                        if (!isResizing) return;
                        
                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;
                        const aspectLocked = this.multiCropData.globalSettings.aspectLocked;
                        const targetAspectRatio = this.cropData.config.width / this.cropData.config.height;
                        
                        let newWidth, newHeight, newLeft, newTop;
                        
                        // Calculate new dimensions based on direction and aspect lock
                        if (aspectLocked) {
                            // Maintain aspect ratio
                            switch (direction) {
                                case 'se':
                                    newWidth = Math.max(50, startWidth + deltaX);
                                    newHeight = newWidth / targetAspectRatio;
                                    newLeft = startLeft;
                                    newTop = startTop;
                                    break;
                                case 'sw':
                                    newWidth = Math.max(50, startWidth - deltaX);
                                    newHeight = newWidth / targetAspectRatio;
                                    newLeft = startLeft + (startWidth - newWidth);
                                    newTop = startTop;
                                    break;
                                case 'ne':
                                    newWidth = Math.max(50, startWidth + deltaX);
                                    newHeight = newWidth / targetAspectRatio;
                                    newLeft = startLeft;
                                    newTop = startTop + (startHeight - newHeight);
                                    break;
                                case 'nw':
                                    newWidth = Math.max(50, startWidth - deltaX);
                                    newHeight = newWidth / targetAspectRatio;
                                    newLeft = startLeft + (startWidth - newWidth);
                                    newTop = startTop + (startHeight - newHeight);
                                    break;
                            }
                        } else {
                            // Free resize
                            switch (direction) {
                                case 'se':
                                    newWidth = Math.max(50, startWidth + deltaX);
                                    newHeight = Math.max(50, startHeight + deltaY);
                                    newLeft = startLeft;
                                    newTop = startTop;
                                    break;
                                case 'sw':
                                    newWidth = Math.max(50, startWidth - deltaX);
                                    newHeight = Math.max(50, startHeight + deltaY);
                                    newLeft = startLeft + (startWidth - newWidth);
                                    newTop = startTop;
                                    break;
                                case 'ne':
                                    newWidth = Math.max(50, startWidth + deltaX);
                                    newHeight = Math.max(50, startHeight - deltaY);
                                    newLeft = startLeft;
                                    newTop = startTop + (startHeight - newHeight);
                                    break;
                                case 'nw':
                                    newWidth = Math.max(50, startWidth - deltaX);
                                    newHeight = Math.max(50, startHeight - deltaY);
                                    newLeft = startLeft + (startWidth - newWidth);
                                    newTop = startTop + (startHeight - newHeight);
                                    break;
                            }
                        }
                        
                        // Keep within canvas bounds
                        newWidth = Math.min(newWidth, canvas.width - Math.max(0, newLeft));
                        newHeight = Math.min(newHeight, canvas.height - Math.max(0, newTop));
                        newLeft = Math.max(0, Math.min(canvas.width - newWidth, newLeft));
                        newTop = Math.max(0, Math.min(canvas.height - newHeight, newTop));
                        
                        // Apply changes
                        selection.style.width = Math.round(newWidth) + 'px';
                        selection.style.height = Math.round(newHeight) + 'px';
                        selection.style.left = Math.round(newLeft) + 'px';
                        selection.style.top = Math.round(newTop) + 'px';
                        
                        // Update stored crop data
                        this.multiCropData.cropSelections.set(index, {
                            x: Math.round(newLeft),
                            y: Math.round(newTop),
                            width: Math.round(newWidth),
                            height: Math.round(newHeight)
                        });
                        
                        this.updateMultiCropInfo(index);
                    };
                    
                    const onMouseUp = () => {
                        isResizing = false;
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };
                    
                    handle.addEventListener('mousedown', onMouseDown);
                });
            }

            updateAllCropCardSelections() {
                this.multiCropData.files.forEach((_, index) => {
                    const checkbox = document.querySelector(`#crop-card-${index} .multi-crop-checkbox`);
                    const card = document.getElementById(`crop-card-${index}`);
                    
                    if (this.multiCropData.selectedFiles.has(index)) {
                        checkbox?.classList.add('checked');
                        card?.classList.add('selected');
                    } else {
                        checkbox?.classList.remove('checked');
                        card?.classList.remove('selected');
                    }
                });
                this.updateMultiCropSelections();
            }

            updateMultiCropInfo(index) {
                const infoElement = document.getElementById(`crop-info-${index}`);
                const cropArea = this.multiCropData.cropSelections.get(index);
                const canvas = document.getElementById(`canvas-${index}`);
                
                if (infoElement && cropArea && canvas) {
                    const scaleX = canvas.width / canvas.offsetWidth;
                    const scaleY = canvas.height / canvas.offsetHeight;
                    const actualWidth = Math.round(cropArea.width * scaleX);
                    const actualHeight = Math.round(cropArea.height * scaleY);
                    
                    infoElement.textContent = `${actualWidth}×${actualHeight}px`;
                }
            }

            // Process multi-crop selection
            async processMultiCropSelection() {
                const selectedFiles = Array.from(this.multiCropData.selectedFiles);
                
                if (selectedFiles.length === 0) {
                    this.showToast('Chọn ít nhất 1 ảnh để cắt!', 'warning');
                    return;
                }
                
                this.showToast(`Đang cắt ${selectedFiles.length} ảnh...`, 'success');
                
                // Process each selected file
                for (const index of selectedFiles) {
                    const fileData = this.multiCropData.files[index];
                    const cropArea = this.multiCropData.cropSelections.get(index);
                    const canvas = document.getElementById(`canvas-${index}`);
                    
                    if (fileData && cropArea && canvas) {
                        try {
                            const croppedBlob = await this.performMultiCrop(fileData, cropArea, canvas);
                            const croppedName = this.generateCropName(fileData.convertedName || fileData.name);
                            
                            this.cropData.croppedImages.push({
                                originalFile: fileData,
                                croppedBlob,
                                croppedName
                            });
                        } catch (error) {
                            console.error(`Error cropping ${fileData.name}:`, error);
                        }
                    }
                }
                
                // Close editor and download
                this.hideCropEditor(); // Use hideCropEditor to properly cleanup
                await this.saveCroppedImages();
                
                // Auto-sync crop data
                this.syncCropProcessedFiles();
            }

            // Perform crop for multi-crop
            async performMultiCrop(fileData, cropArea, canvas) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const cropCanvas = document.createElement('canvas');
                        const cropCtx = cropCanvas.getContext('2d');
                        
                        // Calculate actual crop coordinates
                        const scaleX = img.width / canvas.width;
                        const scaleY = img.height / canvas.height;
                        
                        const sourceX = cropArea.x * scaleX;
                        const sourceY = cropArea.y * scaleY;
                        const sourceWidth = cropArea.width * scaleX;
                        const sourceHeight = cropArea.height * scaleY;
                        
                        // CÔNG THỨC CHÍNH XÁC: Cố định DPI = 300
                        const DPI = 300;
                        const targetWidth = Math.round((this.cropData.config.width / 2.54) * DPI); // (cm ÷ 2.54) × 300
                        const targetHeight = Math.round((this.cropData.config.height / 2.54) * DPI); // (cm ÷ 2.54) × 300
                        
                        cropCanvas.width = targetWidth;
                        cropCanvas.height = targetHeight;
                        
                        // Draw cropped image
                        cropCtx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, targetWidth, targetHeight);
                        
                        // Convert to blob with DPI metadata for exact physical dimensions
                        cropCanvas.toBlob(async (blob) => {
                            try {
                                // CRITICAL: Add DPI metadata to ensure exact physical dimensions
                                const blobWithDPI = await this.addDPIMetadata(blob, DPI);
                                
                                // Verify dimensions match expected physical size
                                const expectedPhysicalWidth = targetWidth / DPI * 2.54; // Convert px to cm
                                const expectedPhysicalHeight = targetHeight / DPI * 2.54; // Convert px to cm
                                
                                console.log(`✅ Multi-crop output: ${targetWidth}x${targetHeight}px at ${DPI} DPI = ${this.cropData.config.width}x${this.cropData.config.height}cm`);
                                console.log(`🔍 Verification: ${targetWidth}px ÷ ${DPI} × 2.54 = ${expectedPhysicalWidth.toFixed(2)}cm (should be ${this.cropData.config.width}cm)`);
                                console.log(`🔍 Verification: ${targetHeight}px ÷ ${DPI} × 2.54 = ${expectedPhysicalHeight.toFixed(2)}cm (should be ${this.cropData.config.height}cm)`);
                                
                                resolve(blobWithDPI);
                            } catch (error) {
                                console.warn('Failed to add DPI metadata to crop:', error);
                                resolve(blob); // Return original if DPI metadata fails
                            }
                        }, 'image/jpeg', 0.95);
                    };
                    
                    const imgUrl = this.safeCreateObjectURL(fileData.file);
                    if (!imgUrl) {
                        console.error('Cannot create blob URL for file:', fileData.file.name);
                        return;
                    }
                    img.src = imgUrl;
                });
            }

            // Setup button event listeners for a crop card
            setupMultiCropCardButtons(index) {
                const card = document.getElementById(`crop-card-${index}`);
                if (!card) return;
                
                // Handle control buttons (reset, center, fit)
                const buttons = card.querySelectorAll('.multi-crop-btn[data-action]');
                buttons.forEach(button => {
                    const action = button.getAttribute('data-action');
                    const buttonIndex = parseInt(button.getAttribute('data-index'));
                    
                    button.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        switch (action) {
                            case 'reset':
                                await this.resetCropCard(buttonIndex);
                                break;
                            case 'center':
                                this.centerCropCard(buttonIndex);
                                break;
                            case 'fit':
                                await this.fitCropCard(buttonIndex);
                                break;
                        }
                    });
                });
                
                // Handle checkbox toggle
                const checkbox = card.querySelector('.multi-crop-checkbox[data-action="toggle"]');
                if (checkbox) {
                    checkbox.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const checkboxIndex = parseInt(checkbox.getAttribute('data-index'));
                        this.toggleCropSelection(checkboxIndex);
                    });
                }
            }

            // Apply size lock after zoom changes
            applySizeLockAfterZoom(index) {
                // Check if this is for multi-crop or single crop
                const isMultiCrop = this.multiCropData && this.multiCropData.files;
                
                if (isMultiCrop) {
                    // Multi-crop mode - check global size lock
                    if (!this.multiCropData.globalSettings.sizeLocked) return;
                    
                    const selection = document.querySelector(`#selection-${index}`);
                    const canvas = document.getElementById(`canvas-${index}`);
                    if (!selection || !canvas) return;
                    
                    // Get stored locked dimensions for this card (if any)
                    const cropData = this.multiCropData.cropSelections.get(index);
                    if (!cropData || !cropData.lockedActualWidth || !cropData.lockedActualHeight) return;
                    
                    this.applySizeConstraint(selection, canvas, cropData.lockedActualWidth, cropData.lockedActualHeight);
                } else {
                    // Single crop mode - check individual size lock
                    const selection = document.getElementById('cropSelection');
                    const canvas = document.getElementById('cropCanvas');
                    if (!selection || !canvas) return;
                    
                    // Get locked dimensions from global storage
                    if (!window.cropSizeLockData || !window.cropSizeLockData.sizeLocked) return;
                    
                    this.applySizeConstraint(selection, canvas, window.cropSizeLockData.lockedWidth, window.cropSizeLockData.lockedHeight);
                }
            }
            
            // Apply size constraint to selection
            applySizeConstraint(selection, canvas, lockedActualWidth, lockedActualHeight) {
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calculate current scale factors
                const scaleX = canvas.width / canvasRect.width;
                const scaleY = canvas.height / canvasRect.height;
                
                // Convert locked actual dimensions back to display dimensions
                const displayWidth = lockedActualWidth / scaleX;
                const displayHeight = lockedActualHeight / scaleY;
                
                // Apply the locked size
                selection.style.width = Math.round(displayWidth) + 'px';
                selection.style.height = Math.round(displayHeight) + 'px';
                
                // Ensure selection stays within canvas bounds
                const currentLeft = parseInt(selection.style.left) || 0;
                const currentTop = parseInt(selection.style.top) || 0;
                const maxLeft = canvasRect.width - displayWidth;
                const maxTop = canvasRect.height - displayHeight;
                
                if (currentLeft > maxLeft) selection.style.left = Math.max(0, maxLeft) + 'px';
                if (currentTop > maxTop) selection.style.top = Math.max(0, maxTop) + 'px';
                
                console.log(`Applied size lock: ${lockedActualWidth}x${lockedActualHeight}px actual -> ${Math.round(displayWidth)}x${Math.round(displayHeight)}px display`);
            }

            // Sync overlay position with canvas position
            syncOverlayWithCanvas(index) {
                const canvas = document.getElementById(`canvas-${index}`);
                const overlay = document.querySelector(`#canvas-${index}`).parentElement.querySelector('.multi-crop-overlay');
                
                if (!canvas || !overlay) return;
                
                // Use immediate sync for single crop mode
                if (index === undefined) {
                    overlay.style.width = canvas.style.width || canvas.width + 'px';
                    overlay.style.height = canvas.style.height || canvas.height + 'px';
                    return;
                }
                
                // For multi-crop, get precise canvas position
                const container = canvas.parentElement;
                const containerRect = container.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calculate canvas position relative to container
                const offsetX = canvasRect.left - containerRect.left;
                const offsetY = canvasRect.top - containerRect.top;
                
                // Set overlay to match canvas exactly
                overlay.style.position = 'absolute';
                overlay.style.left = offsetX + 'px';
                overlay.style.top = offsetY + 'px';
                overlay.style.width = canvas.width + 'px';
                overlay.style.height = canvas.height + 'px';
                overlay.style.pointerEvents = 'auto'; // Enable interactions
                overlay.style.border = '1px solid rgba(255,255,255,0.3)'; // Debug border
                
                console.log(`Overlay ${index}: positioned at (${offsetX}, ${offsetY}) with size ${canvas.width}x${canvas.height}`);
            }

            // Preview Modal Functions
            hideCropPreviewModal() {
                document.getElementById('cropPreviewModal').style.display = 'none';
            }

            async cropAllFromPreviews() {
                if (!this.cropData.previewData || this.cropData.previewData.length === 0) {
                    this.showToast('Không có preview nào để xử lý!', 'error');
                    return;
                }
                
                // Select all previews
                this.cropData.selectedFiles.clear();
                for (let i = 0; i < this.cropData.previewData.length; i++) {
                    this.cropData.selectedFiles.add(i);
                }
                
                await this.processSelectedPreviews();
            }

            async cropSelectedFromPreviews() {
                if (!this.cropData.selectedFiles || this.cropData.selectedFiles.size === 0) {
                    this.showToast('Vui lòng chọn ít nhất một ảnh để cắt!', 'error');
                    return;
                }
                
                await this.processSelectedPreviews();
            }

            async processSelectedPreviews() {
                this.showToast('🚀 Bắt đầu cắt ảnh...', 'success');
                this.hideCropPreviewModal();
                
                try {
                    const selectedIndices = Array.from(this.cropData.selectedFiles);
                    this.cropData.croppedImages = [];
                    
                    for (let i = 0; i < selectedIndices.length; i++) {
                        const index = selectedIndices[i];
                        const fileData = this.cropData.files[index];
                        
                        try {
                            const croppedBlob = await this.cropImageAuto(fileData);
                            const croppedName = this.generateCropName(fileData.convertedName);
                            
                            this.cropData.croppedImages.push({
                                originalFile: fileData,
                                croppedBlob,
                                croppedName
                            });
                            
                            this.showToast(`✂️ Đã cắt ${i + 1}/${selectedIndices.length} ảnh`, 'success');
                        } catch (error) {
                            console.error('Error cropping image:', fileData.name, error);
                        }
                    }
                    
                    await this.saveCroppedImages();
                    
                    // Auto-sync crop data
                    this.syncCropProcessedFiles();
                } catch (error) {
                    console.error('Process previews error:', error);
                    this.showToast('❌ Lỗi khi xử lý preview!', 'error');
                }
            }

            selectAllPreviews() {
                if (!this.cropData.previewData) return;
                
                this.cropData.selectedFiles.clear();
                for (let i = 0; i < this.cropData.previewData.length; i++) {
                    this.cropData.selectedFiles.add(i);
                }
                
                this.updatePreviewSelections();
                this.updateSelectedCount();
            }

            clearAllPreviews() {
                if (!this.cropData.selectedFiles) return;
                
                this.cropData.selectedFiles.clear();
                this.updatePreviewSelections();
                this.updateSelectedCount();
            }

            acceptAllPreviews() {
                this.selectAllPreviews();
                this.cropAllFromPreviews();
            }

            updatePreviewSelections() {
                const gallery = document.getElementById('previewGallery');
                const items = gallery.querySelectorAll('.preview-item');
                
                items.forEach((item, index) => {
                    const checkbox = item.querySelector('.preview-checkbox');
                    if (this.cropData.selectedFiles.has(index)) {
                        item.classList.add('selected');
                        checkbox.classList.add('checked');
                    } else {
                        item.classList.remove('selected');
                        checkbox.classList.remove('checked');
                    }
                });
            }

            updateSelectedCount() {
                const count = this.cropData.selectedFiles ? this.cropData.selectedFiles.size : 0;
                const selectedCountElement = document.getElementById('selectedCount');
                if (selectedCountElement) {
                    selectedCountElement.textContent = count;
                }
            }

            // Template crop editor functions
            showTemplateCropEditor() {
            const modal = document.getElementById('templateCropModal');
            modal.style.display = 'flex';
            
            // Update UI elements
            const config = this.templateCropData.config;
            document.getElementById('templateSizeDisplay').textContent = `${config.width}×${config.height} ${config.unit}`;
            document.getElementById('templateCropProgress').textContent = `1/${this.templateCropData.files.length}`;
            document.getElementById('templateAspectRatio').textContent = `1:${(config.aspectRatio).toFixed(2)}`;
            document.getElementById('templateTargetSize').textContent = `${config.width}×${config.height} ${config.unit} (${config.targetWidth}×${config.targetHeight}px)`;
            
            // Initialize template crop handlers
            this.initializeTemplateCropHandlers();
        }
        
        async loadImageForTemplateCropping(index) {
            if (index < 0 || index >= this.templateCropData.files.length) return;
            
            this.templateCropData.currentIndex = index;
            const fileData = this.templateCropData.files[index];
            
            // Update navigation
            document.getElementById('templateImageName').textContent = fileData.name;
            document.getElementById('prevTemplateImage').disabled = index === 0;
            document.getElementById('nextTemplateImage').disabled = index === this.templateCropData.files.length - 1;
            
            // Load image
            const canvas = document.getElementById('templateCropCanvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            // Handle dataURL (from template mode) or file/blob (from regular crop mode)
            let imageUrl;
            if (fileData.dataURL) {
                imageUrl = fileData.dataURL; // Direct dataURL from template
            } else if (fileData.convertedBlob) {
                imageUrl = URL.createObjectURL(fileData.convertedBlob);
            } else if (fileData.file) {
                imageUrl = this.safeCreateObjectURL(fileData.file);
            } else {
                console.error('Cannot create image URL for template crop - no data source found');
                return;
            }
            
            console.log('🖼️ Loading image for template crop:', imageUrl?.substring(0, 50) + '...');
            
            img.onload = () => {
                // Calculate canvas size to fit container while maintaining image aspect ratio
                const container = canvas.parentElement;
                
                // Use larger minimum sizes for better visibility
                const minCanvasWidth = 400;
                const minCanvasHeight = 300;
                const maxWidth = Math.max(container.clientWidth - 40, minCanvasWidth);
                const maxHeight = Math.max(container.clientHeight - 40, minCanvasHeight);
                
                const imgAspect = img.width / img.height;
                let canvasWidth, canvasHeight;
                
                if (imgAspect > maxWidth / maxHeight) {
                    canvasWidth = Math.max(maxWidth, minCanvasWidth);
                    canvasHeight = Math.max(canvasWidth / imgAspect, minCanvasHeight);
                } else {
                    canvasHeight = Math.max(maxHeight, minCanvasHeight);
                    canvasWidth = Math.max(canvasHeight * imgAspect, minCanvasWidth);
                }
                
                console.log(`🖼️ Canvas size: ${canvasWidth}×${canvasHeight} (image: ${img.width}×${img.height}, container: ${container.clientWidth}×${container.clientHeight})`);
                
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                
                // Draw image
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                
                // Initialize template crop selection
                this.initializeTemplateCropSelection();
                
                // Only revoke URL if it's a blob URL, not a dataURL
                if (imageUrl && imageUrl.startsWith('blob:')) {
                    URL.revokeObjectURL(imageUrl);
                }
            };
            
            img.src = imageUrl;
        }
        
        initializeTemplateCropSelection() {
            const canvas = document.getElementById('templateCropCanvas');
            const selection = document.getElementById('templateCropSelection');
            const config = this.templateCropData.config;
            
            // ENSURE EXACT ASPECT RATIO from the start
            const targetAspectRatio = config.width / config.height; // Exact ratio from config
            const canvasAspectRatio = canvas.width / canvas.height;
            
            console.log(`Initializing template crop: Target size ${config.width}x${config.height}${config.unit}, aspect ratio: ${targetAspectRatio.toFixed(4)}`);
            
            let cropWidth, cropHeight;
            
            // Fit template within canvas while maintaining EXACT aspect ratio - USE MAXIMUM SIZE
            if (targetAspectRatio > canvasAspectRatio) {
                // Template is wider relative to canvas - limit by width (use FULL width)
                cropWidth = canvas.width; // 100% width - MAXIMUM!
                cropHeight = Math.round(cropWidth / targetAspectRatio); // EXACT division
            } else {
                // Template is taller relative to canvas - limit by height (use FULL height)  
                cropHeight = canvas.height; // 100% height - MAXIMUM!
                cropWidth = Math.round(cropHeight * targetAspectRatio); // EXACT multiplication
            }
            
            // VALIDATE: Check final aspect ratio after rounding
            const actualRatio = cropWidth / cropHeight;
            const ratioError = Math.abs(actualRatio - targetAspectRatio) / targetAspectRatio;
            
            console.log(`Initial crop size: ${cropWidth}x${cropHeight}px, ratio: ${actualRatio.toFixed(4)}, error: ${(ratioError * 100).toFixed(2)}%`);
            
            // If rounding caused ratio drift, correct it
            if (ratioError > 0.001) { // 0.1% tolerance
                if (targetAspectRatio > canvasAspectRatio) {
                    // Re-calculate height to maintain exact ratio
                    cropHeight = Math.round(cropWidth / targetAspectRatio);
                } else {
                    // Re-calculate width to maintain exact ratio
                    cropWidth = Math.round(cropHeight * targetAspectRatio);
                }
                console.log(`Corrected to: ${cropWidth}x${cropHeight}px`);
            }
            
            // Center the selection within canvas
            const x = Math.round((canvas.width - cropWidth) / 2);
            const y = Math.round((canvas.height - cropHeight) / 2);
            
            // Position selection
            selection.style.left = x + 'px';
            selection.style.top = y + 'px';
            selection.style.width = cropWidth + 'px';
            selection.style.height = cropHeight + 'px';
            
            // Store current crop scale
            this.templateCropData.currentScale = 1;
            
            console.log(`Template crop initialized: ${cropWidth}x${cropHeight}px at (${x}, ${y}) with scale 1.0`);
            
            // Update displays
            this.updateTemplateCropInfo();
        }
        
        initializeTemplateCropHandlers() {
            console.log('🔧 initializeTemplateCropHandlers() called');
            const selection = document.getElementById('templateCropSelection');
            const canvas = document.getElementById('templateCropCanvas');
            const moveHandle = document.querySelector('.template-move-handle');
            
            let isDragging = false;
            let startX = 0, startY = 0, startLeft = 0, startTop = 0;
            
            // Drag functionality
            moveHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = parseInt(selection.style.left) || 0;
                startTop = parseInt(selection.style.top) || 0;
                
                selection.classList.add('dragging');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
            
            const onMouseMove = (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;
                
                // Keep within canvas bounds
                newLeft = Math.max(0, Math.min(canvas.width - selection.offsetWidth, newLeft));
                newTop = Math.max(0, Math.min(canvas.height - selection.offsetHeight, newTop));
                
                selection.style.left = newLeft + 'px';
                selection.style.top = newTop + 'px';
                
                this.updateTemplateCropInfo();
            };
            
            const onMouseUp = () => {
                if (isDragging) {
                    isDragging = false;
                    selection.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
            };
            
            // Resize handles functionality
            const resizeHandles = document.querySelectorAll('.template-resize-handle');
            
            resizeHandles.forEach(handle => {
                let isResizing = false;
                let startX = 0, startY = 0;
                let startWidth = 0, startHeight = 0;
                let startLeft = 0, startTop = 0;
                const direction = handle.getAttribute('data-direction');
                
                const onMouseDown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = selection.offsetWidth;
                    startHeight = selection.offsetHeight;
                    startLeft = parseInt(selection.style.left);
                    startTop = parseInt(selection.style.top);
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };
                
                const onMouseMove = (e) => {
                    if (!isResizing) return;
                    
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    const config = this.templateCropData.config;
                    const targetAspectRatio = config.width / config.height;
                    
                    // Check if aspect ratio should be locked (always true for template crop)
                    const aspectLocked = true; // Template crop always maintains aspect ratio
                    
                    let newWidth, newHeight, newLeft, newTop;
                    
                    // Calculate new dimensions based on direction
                    if (aspectLocked) {
                        // Maintain aspect ratio
                        switch (direction) {
                            case 'se': // Southeast - expand/contract from bottom-right
                                newWidth = Math.max(50, startWidth + deltaX);
                                newHeight = newWidth / targetAspectRatio;
                                newLeft = startLeft;
                                newTop = startTop;
                                break;
                                
                            case 'sw': // Southwest - expand/contract from bottom-left
                                newWidth = Math.max(50, startWidth - deltaX);
                                newHeight = newWidth / targetAspectRatio;
                                newLeft = startLeft + (startWidth - newWidth);
                                newTop = startTop;
                                break;
                                
                            case 'ne': // Northeast - expand/contract from top-right
                                newWidth = Math.max(50, startWidth + deltaX);
                                newHeight = newWidth / targetAspectRatio;
                                newLeft = startLeft;
                                newTop = startTop + (startHeight - newHeight);
                                break;
                                
                            case 'nw': // Northwest - expand/contract from top-left
                                newWidth = Math.max(50, startWidth - deltaX);
                                newHeight = newWidth / targetAspectRatio;
                                newLeft = startLeft + (startWidth - newWidth);
                                newTop = startTop + (startHeight - newHeight);
                                break;
                        }
                    } else {
                        // Free resize (not applicable to template crop, but keeping for completeness)
                        switch (direction) {
                            case 'se':
                                newWidth = Math.max(50, startWidth + deltaX);
                                newHeight = Math.max(50, startHeight + deltaY);
                                newLeft = startLeft;
                                newTop = startTop;
                                break;
                            case 'sw':
                                newWidth = Math.max(50, startWidth - deltaX);
                                newHeight = Math.max(50, startHeight + deltaY);
                                newLeft = startLeft + (startWidth - newWidth);
                                newTop = startTop;
                                break;
                            case 'ne':
                                newWidth = Math.max(50, startWidth + deltaX);
                                newHeight = Math.max(50, startHeight - deltaY);
                                newLeft = startLeft;
                                newTop = startTop + (startHeight - newHeight);
                                break;
                            case 'nw':
                                newWidth = Math.max(50, startWidth - deltaX);
                                newHeight = Math.max(50, startHeight - deltaY);
                                newLeft = startLeft + (startWidth - newWidth);
                                newTop = startTop + (startHeight - newHeight);
                                break;
                        }
                    }
                    
                    // Ensure selection stays within canvas bounds
                    const maxWidth = canvas.width - Math.max(0, newLeft);
                    const maxHeight = canvas.height - Math.max(0, newTop);
                    
                    if (newWidth > maxWidth) {
                        newWidth = maxWidth;
                        newHeight = newWidth / targetAspectRatio;
                    }
                    if (newHeight > maxHeight) {
                        newHeight = maxHeight;
                        newWidth = newHeight * targetAspectRatio;
                    }
                    
                    // Adjust position if needed
                    newLeft = Math.max(0, Math.min(canvas.width - newWidth, newLeft));
                    newTop = Math.max(0, Math.min(canvas.height - newHeight, newTop));
                    
                    // Apply changes
                    selection.style.width = Math.round(newWidth) + 'px';
                    selection.style.height = Math.round(newHeight) + 'px';
                    selection.style.left = Math.round(newLeft) + 'px';
                    selection.style.top = Math.round(newTop) + 'px';
                    
                    this.updateTemplateCropInfo();
                };
                
                const onMouseUp = () => {
                    isResizing = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                handle.addEventListener('mousedown', onMouseDown);
            });
            
            // Position controls
            document.getElementById('templateCenter').addEventListener('click', () => {
                this.centerTemplateCropModal();
            });
            
            document.getElementById('templateReset').addEventListener('click', () => {
                this.resetTemplateCropModal();
            });
            
            // templateCropEdit button listener is handled in setupTemplateEventListeners()
            
            // Navigation controls
            document.getElementById('prevTemplateImage').addEventListener('click', () => {
                if (this.templateCropData.currentIndex > 0) {
                    this.loadImageForTemplateCropping(this.templateCropData.currentIndex - 1);
                }
            });
            
            document.getElementById('nextTemplateImage').addEventListener('click', () => {
                if (this.templateCropData.currentIndex < this.templateCropData.files.length - 1) {
                    this.loadImageForTemplateCropping(this.templateCropData.currentIndex + 1);
                }
            });
            
            // Action controls - handled by setupTemplateCropModalListeners()
            console.log('📝 Modal button listeners are handled by setupTemplateCropModalListeners()');
        }
        
        // Removed applyTemplateCropZoom - now using resize handles instead
        
        centerTemplateCropModal() {
            const selection = document.getElementById('templateCropSelection');
            const canvas = document.getElementById('templateCropCanvas');
            
            const x = (canvas.width - selection.offsetWidth) / 2;
            const y = (canvas.height - selection.offsetHeight) / 2;
            
            selection.style.left = x + 'px';
            selection.style.top = y + 'px';
            
            this.updateTemplateCropInfo();
        }
        
        resetTemplateCropModal() {
            document.getElementById('templateZoomSlider').value = 1;
            document.getElementById('templateZoomValue').textContent = '100%';
            this.templateCropData.currentScale = 1;
            this.initializeTemplateCropSelection();
        }
        
        updateTemplateCropInfo() {
            const selection = document.getElementById('templateCropSelection');
            const canvas = document.getElementById('templateCropCanvas');
            const config = this.templateCropData.config;
            
            // Calculate actual pixel dimensions
            const scaleX = canvas.width / canvas.offsetWidth;
            const scaleY = canvas.height / canvas.offsetHeight;
            const actualWidth = Math.round(selection.offsetWidth * scaleX);
            const actualHeight = Math.round(selection.offsetHeight * scaleY);
            
            // Update displays
            document.getElementById('templateSelectionSize').textContent = `${actualWidth}×${actualHeight}px`;
            document.getElementById('templateCurrentSize').textContent = `${actualWidth}×${actualHeight}px`;
            
            // Check if ratio is correct using exact target aspect ratio
            const currentRatio = actualWidth / actualHeight;
            const targetRatio = config.width / config.height; // Use exact ratio from config
            const ratioDiff = Math.abs(currentRatio - targetRatio) / targetRatio;
            
            console.log(`Template info update: ${actualWidth}x${actualHeight}px, ratio: ${currentRatio.toFixed(4)}, target: ${targetRatio.toFixed(4)}, diff: ${(ratioDiff * 100).toFixed(2)}%`);
            
            const ratioStatus = document.getElementById('templateRatioStatus');
            if (ratioDiff < 0.005) { // Tighter tolerance: 0.5%
                ratioStatus.textContent = `✅ Đúng tỷ lệ (${config.width}:${config.height})`;
                ratioStatus.style.color = 'green';
            } else {
                ratioStatus.textContent = `⚠️ Sai tỷ lệ (hiện tại: ${currentRatio.toFixed(3)}, cần: ${targetRatio.toFixed(3)})`;
                ratioStatus.style.color = 'orange';
            }
            
            // Show that output will always be correct regardless of template zoom
            const outputInfo = document.getElementById('templateOutputInfo');
            if (outputInfo) {
                outputInfo.textContent = `🎯 Output: ${config.targetWidth}×${config.targetHeight}px = ${config.width}×${config.height}${config.unit} @ 300 DPI`;
                outputInfo.style.color = 'blue';
                outputInfo.style.fontWeight = 'bold';
            }
        }
        
        async cropCurrentTemplateImage() {
            console.log('🚀 cropCurrentTemplateImage() called');
            console.log('templateCropData:', this.templateCropData);
            
            const selection = document.getElementById('templateCropSelection');
            const canvas = document.getElementById('templateCropCanvas');
            const config = this.templateCropData?.config;
            const fileData = this.templateCropData?.files?.[this.templateCropData?.currentIndex];
            
            console.log('Elements found:', { selection, canvas, config, fileData });
            
            try {
                // Get crop coordinates
                const scaleX = canvas.width / canvas.offsetWidth;
                const scaleY = canvas.height / canvas.offsetHeight;
                
                const cropX = parseInt(selection.style.left) * scaleX;
                const cropY = parseInt(selection.style.top) * scaleY;
                const cropWidth = selection.offsetWidth * scaleX;
                const cropHeight = selection.offsetHeight * scaleY;
                
                // Create output canvas with exact target dimensions
                // Ensure canvas dimensions match exactly the requested physical size at 300 DPI
                const targetDPI = 300;
                const exactTargetWidth = Math.round((config.width / 2.54) * targetDPI);
                const exactTargetHeight = Math.round((config.height / 2.54) * targetDPI);
                
                const outputCanvas = document.createElement('canvas');
                outputCanvas.width = exactTargetWidth;
                outputCanvas.height = exactTargetHeight;
                
                console.log(`🎯 Creating canvas: ${exactTargetWidth}x${exactTargetHeight}px for ${config.width}x${config.height}cm at ${targetDPI} DPI`);
                const outputCtx = outputCanvas.getContext('2d');
                
                // Load original image for cropping
                const img = new Image();
                let imageUrl;
                
                // Handle different data sources (dataURL from template mode, or file/blob from regular crop mode)
                if (fileData.dataURL) {
                    imageUrl = fileData.dataURL; // Direct dataURL from template
                } else if (fileData.convertedBlob) {
                    imageUrl = URL.createObjectURL(fileData.convertedBlob);
                } else if (fileData.file) {
                    imageUrl = this.safeCreateObjectURL(fileData.file);
                } else {
                    console.error('Cannot create image URL for template crop - no data source found', fileData);
                    return;
                }
                
                img.onload = () => {
                    // Calculate scale from canvas to original image
                    const imageScaleX = img.width / canvas.width;
                    const imageScaleY = img.height / canvas.height;
                    
                    // Apply crop to original image
                    const originalCropX = cropX * imageScaleX;
                    const originalCropY = cropY * imageScaleY;
                    const originalCropWidth = cropWidth * imageScaleX;
                    const originalCropHeight = cropHeight * imageScaleY;
                    
                    // Draw cropped area to output canvas with exact dimensions
                    outputCtx.fillStyle = '#ffffff';
                    outputCtx.fillRect(0, 0, exactTargetWidth, exactTargetHeight);
                    outputCtx.drawImage(
                        img,
                        originalCropX, originalCropY, originalCropWidth, originalCropHeight,
                        0, 0, exactTargetWidth, exactTargetHeight
                    );
                    
                    // Convert to blob with DPI metadata for exact output size
                    outputCanvas.toBlob(async (blob) => {
                        try {
                            // CRITICAL: Add DPI metadata to ensure exact physical dimensions
                            // LUÔN sử dụng DPI = 300 cho chất lượng tối đa
                            const blobWithDPI = await this.addDPIMetadata(blob, 300);
                            
                            // Verify dimensions match expected physical size
                            const expectedPhysicalWidth = exactTargetWidth / 300 * 2.54; // Convert px to cm
                            const expectedPhysicalHeight = exactTargetHeight / 300 * 2.54; // Convert px to cm
                            
                            console.log(`✅ Template crop output: ${exactTargetWidth}x${exactTargetHeight}px at 300 DPI = ${config.width}x${config.height}${config.unit}`);
                            console.log(`🔍 Verification: ${exactTargetWidth}px ÷ 300 × 2.54 = ${expectedPhysicalWidth.toFixed(2)}cm (should be ${config.width}cm)`);
                            console.log(`🔍 Verification: ${exactTargetHeight}px ÷ 300 × 2.54 = ${expectedPhysicalHeight.toFixed(2)}cm (should be ${config.height}cm)`);
                            
                            // Store cropped result with DPI metadata
                            const croppedImage = {
                                originalFile: fileData,
                                blob: blobWithDPI, // Use blob with DPI metadata
                                filename: this.generateTemplateCropFilename(fileData.name),
                                dimensions: `${exactTargetWidth}×${exactTargetHeight}px`,
                                size: `${config.width}×${config.height} ${config.unit}`,
                                dpi: 300 // Cố định 300 DPI
                            };
                            
                            // Update template data with cropped result
                            const currentTemplateImage = this.templateData.images[this.templateData.currentIndex];
                            if (currentTemplateImage) {
                                // Convert blob to dataURL for template use
                                const reader = new FileReader();
                                reader.onload = () => {
                                    currentTemplateImage.croppedDataURL = reader.result;
                                    currentTemplateImage.cropSettings = {
                                        offsetX: originalCropX,
                                        offsetY: originalCropY,
                                        drawWidth: originalCropWidth,
                                        drawHeight: originalCropHeight,
                                        mode: 'manual'
                                    };
                                    
                                    // Update template preview and gallery
                                    this.updateTemplatePreview();
                                    this.updateTemplateGallery();
                                    
                                    // Close modal
                                    document.getElementById('templateCropModal').style.display = 'none';
                                    this.templateCropData = null;
                                    
                                    this.showToast(`✅ Đã cắt ảnh theo template ${config.width}×${config.height}${config.unit}`, 'success');
                                };
                                reader.readAsDataURL(blobWithDPI);
                            }
                            
                        } catch (error) {
                            console.error('Error adding DPI metadata to template crop:', error);
                            // Fallback: use original blob without DPI for template
                            const currentTemplateImage = this.templateData.images[this.templateData.currentIndex];
                            if (currentTemplateImage) {
                                const reader = new FileReader();
                                reader.onload = () => {
                                    currentTemplateImage.croppedDataURL = reader.result;
                                    this.updateTemplatePreview();
                                    this.updateTemplateGallery();
                                    document.getElementById('templateCropModal').style.display = 'none';
                                    this.templateCropData = null;
                                    this.showToast(`✅ Đã cắt ảnh (không có DPI metadata)`, 'warning');
                                };
                                reader.readAsDataURL(blob);
                            }
                        }
                        
                        // Only revoke URL if it's a blob URL, not a dataURL
                        if (imageUrl && imageUrl.startsWith('blob:')) {
                            URL.revokeObjectURL(imageUrl);
                        }
                    }, 'image/jpeg', 0.95);
                };
                
                img.src = imageUrl;
                
            } catch (error) {
                console.error('Error cropping template image:', error);
                this.showToast('❌ Lỗi khi cắt ảnh: ' + error.message, 'error');
            }
        }
        
        generateTemplateCropFilename(originalName) {
            const config = this.templateCropData.config;
            const naming = config.naming;
            
            // Define known image extensions
            const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff', 'tif', 'svg', 'ico'];
            
            // Get current extension (if any)
            const lastDotIndex = originalName.lastIndexOf('.');
            let baseName = originalName;
            
            if (lastDotIndex > 0) {
                const originalExt = originalName.substring(lastDotIndex + 1).toLowerCase();
                
                // Only remove extension if it's a known image extension
                if (imageExtensions.includes(originalExt)) {
                    baseName = originalName.substring(0, lastDotIndex);
                    console.log(`Template crop: Removed image extension .${originalExt} from ${originalName}`);
                } else {
                    // Keep the "extension" as part of filename if it's not an image extension
                    baseName = originalName;
                    console.log(`Template crop: Keeping non-image extension .${originalExt} in filename: ${originalName}`);
                }
            }
            
            const extension = '.jpg';
            
            let finalName;
            switch (naming) {
                case 'size_prefix':
                    finalName = `${config.width}x${config.height}_${baseName}${extension}`;
                    break;
                case 'size_suffix':
                    finalName = `${baseName}_${config.width}x${config.height}${extension}`;
                    break;
                case 'original':
                default:
                    finalName = `${baseName}_cropped${extension}`;
                    break;
            }
            
            console.log(`Template crop filename: ${originalName} → ${finalName}`);
            return finalName;
        }
        
        skipCurrentTemplateImage() {
            if (this.templateCropData.currentIndex < this.templateCropData.files.length - 1) {
                this.loadImageForTemplateCropping(this.templateCropData.currentIndex + 1);
            } else {
                this.finishTemplateCropping();
            }
        }
        
        async finishTemplateCropping() {
            if (this.templateCropData.croppedImages.length === 0) {
                this.showToast('Không có ảnh nào được cắt!', 'warning');
                return;
            }
            
            this.hideTemplateCropEditor();
            
            // Download all cropped images
            await this.downloadTemplateCroppedImages();
            
            this.showToast(`🎉 Hoàn thành! Đã cắt ${this.templateCropData.croppedImages.length} ảnh với kích thước chính xác ${this.templateCropData.config.width}×${this.templateCropData.config.height} ${this.templateCropData.config.unit}`, 'success');
        }
        
        async downloadTemplateCroppedImages() {
            for (let i = 0; i < this.templateCropData.croppedImages.length; i++) {
                const croppedImage = this.templateCropData.croppedImages[i];
                const url = URL.createObjectURL(croppedImage.blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = croppedImage.filename;
                a.click();
                
                URL.revokeObjectURL(url);
                
                // Small delay between downloads
                if (i < this.templateCropData.croppedImages.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
        }
        
        hideTemplateCropEditor() {
            document.getElementById('templateCropModal').style.display = 'none';
        }

        // Try alternative ZIP creation without JSZip first
        async createSafeZip(files, zipName, comment = 'Safe image archive created by MEU Layout') {
            // For small number of files, offer individual downloads to avoid ZIP security warnings
            if (files.length <= 5) {
                const userChoice = confirm(
                    `⚠️ WINDOWS SECURITY WARNING FIX:\n\n` +
                    `Để tránh cảnh báo "potentially harmful", bạn có muốn:\n\n` +
                    `✅ Tải từng file riêng lẻ (AN TOÀN - khuyên dùng)\n` +
                    `❌ Tải file ZIP (có thể bị cảnh báo bảo mật)\n\n` +
                    `Nhấn OK để tải từng file riêng, Cancel để tạo ZIP`
                );
                
                if (userChoice) {
                    // Download individual files
                    await this.downloadIndividualFiles(files);
                    return null; // Signal that individual downloads were used
                }
            }
            
            // Fallback to safer JSZip approach
            return await this.createSaferZip(files, zipName, comment);
        }
        
        // Download files individually to avoid ZIP security warnings
        async downloadIndividualFiles(files) {
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                
                try {
                    let blob;
                    if (file.data instanceof Blob) {
                        blob = file.data;
                    } else if (typeof file.data === 'string') {
                        blob = await this.createSingleFileDownload(file);
                    } else {
                        continue;
                    }
                    
                    // Create individual download
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = file.filename || `image_${i + 1}.jpg`;
                    link.style.display = 'none';
                    
                    document.body.appendChild(link);
                    
                    // Delay between downloads to avoid browser blocking
                    setTimeout(() => {
                        link.click();
                        setTimeout(() => {
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                        }, 100);
                    }, i * 500); // 500ms delay between each download
                    
                } catch (error) {
                    console.error('Error downloading individual file:', error);
                    continue;
                }
            }
            
            // Show success message
            setTimeout(() => {
                this.showToast(`✅ Đã bắt đầu tải ${files.length} file riêng lẻ (tránh cảnh báo bảo mật)!`, 'success');
            }, 1000);
        }
        
        // Create single file download (bypasses ZIP completely)
        async createSingleFileDownload(file) {
            if (file.data instanceof Blob) {
                return file.data;
            } else if (typeof file.data === 'string') {
                let base64Data = file.data;
                if (base64Data.startsWith('data:')) {
                    const commaIndex = base64Data.indexOf(',');
                    if (commaIndex !== -1) {
                        const mimeType = base64Data.substring(5, commaIndex).split(';')[0];
                        base64Data = base64Data.substring(commaIndex + 1);
                        
                        const byteCharacters = atob(base64Data);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        return new Blob([byteArray], { type: mimeType });
                    }
                }
            }
            throw new Error('Invalid file data');
        }
        
        // Safer ZIP Generation with minimal JSZip usage
        async createSaferZip(files, zipName, comment = 'Safe image archive created by MEU Layout') {
            const zip = new JSZip();
            
            // Add safe comment
            zip.comment = comment;
            
            let validFileCount = 0;
            
            for (const fileData of files) {
                try {
                    const { filename, data, blob } = fileData;
                    
                    // Validate filename
                    if (!filename || filename.trim() === '') {
                        console.warn('Skipping file with empty filename');
                        continue;
                    }
                    
                    // Sanitize filename - remove potentially harmful characters
                    const safeFilename = filename.replace(/[<>:"|?*]/g, '_').replace(/\.\.+/g, '_');
                    
                    // Validate file data
                    if (blob) {
                        // Validate blob size
                        if (blob.size === 0) {
                            console.warn(`Skipping empty file: ${safeFilename}`);
                            continue;
                        }
                        
                        if (blob.size > 50 * 1024 * 1024) { // 50MB limit per file
                            console.warn(`Skipping large file: ${safeFilename}`);
                            continue;
                        }
                        
                        // Add blob to ZIP with proper attributes
                        zip.file(safeFilename, blob, {
                            date: new Date(),
                            createFolders: false,
                            compression: 'DEFLATE',
                            compressionOptions: { level: 6 }
                        });
                        validFileCount++;
                    } else if (data) {
                        // Handle base64 data
                        if (typeof data !== 'string' || data.length === 0) {
                            console.warn(`Skipping invalid data for: ${safeFilename}`);
                            continue;
                        }
                        
                        // Extract base64 data (remove data URL prefix if present)
                        const base64Data = data.includes(',') ? data.split(',')[1] : data;
                        
                        if (!base64Data || base64Data.length === 0) {
                            console.warn(`Skipping empty base64 data for: ${safeFilename}`);
                            continue;
                        }
                        
                        // Add base64 to ZIP with proper attributes
                        zip.file(safeFilename, base64Data, {
                            base64: true,
                            date: new Date(),
                            createFolders: false,
                            compression: 'DEFLATE',
                            compressionOptions: { level: 6 }
                        });
                        validFileCount++;
                    }
                } catch (error) {
                    console.error('Error processing file for ZIP:', error);
                    continue;
                }
            }
            
            if (validFileCount === 0) {
                throw new Error('Không có file hợp lệ để tạo ZIP');
            }
            
            console.log(`Creating ZIP with ${validFileCount} valid files`);
            
            // Generate ZIP with safe options
            const zipBlob = await zip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: { level: 6 },
                mimeType: 'application/zip',
                platform: 'DOS', // More compatible
                streamFiles: false,
                encodeFileName: function(name) {
                    // Ensure safe filename encoding
                    return name;
                }
            });
            
            // Validate generated ZIP
            if (zipBlob.size === 0) {
                throw new Error('Generated ZIP is empty');
            }
            
            if (zipBlob.size > 500 * 1024 * 1024) { // 500MB limit
                throw new Error('Generated ZIP is too large');
            }
            
            console.log(`Generated ZIP size: ${(zipBlob.size / 1024 / 1024).toFixed(2)} MB`);
            
            return zipBlob;
        }
        
        // Ultra-Safe ZIP Download Utility
        downloadSafeZip(zipBlob, filename) {
            // Handle case where individual downloads were used instead of ZIP
            if (!zipBlob) {
                return; // Individual downloads already handled
            }
            // Create the safest possible blob
            const safeBlob = new Blob([zipBlob], { 
                type: 'application/zip'
            });
            
            // Add virus-safe header information  
            const reader = new FileReader();
            reader.onload = () => {
                const arrayBuffer = reader.result;
                const view = new Uint8Array(arrayBuffer);
                
                // Verify ZIP signature
                if (view[0] !== 0x50 || view[1] !== 0x4B) {
                    throw new Error('Invalid ZIP signature');
                }
                
                // Create clean download with safe headers
                const cleanBlob = new Blob([view], {
                    type: 'application/zip, application/x-zip-compressed'
                });
                
                const url = URL.createObjectURL(cleanBlob);
                
                // Create download link with maximum security attributes
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.rel = 'noopener'; // Security attribute
                link.style.display = 'none';
                
                // Add to DOM, click, and clean up
                document.body.appendChild(link);
                link.click();
                
                // Clean up immediately
                setTimeout(() => {
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }, 1000);
            };
            
            reader.readAsArrayBuffer(safeBlob);
        }

        // Gallery Management Methods
        initializeGalleryEventListeners() {
            // Classification mode toggle
            const classifyBtn = document.getElementById('classifyBtn');
            if (classifyBtn) {
                classifyBtn.addEventListener('click', () => this.enterClassificationMode());
            }

            // Auto-classification based on filename
            const autoClassifyBtn = document.getElementById('autoClassifyBtn');
            if (autoClassifyBtn) {
                autoClassifyBtn.addEventListener('click', () => this.autoClassifyByFilename());
            }

            // Clear gallery
            const clearGalleryBtn = document.getElementById('clearGalleryBtn');
            if (clearGalleryBtn) {
                clearGalleryBtn.addEventListener('click', () => this.clearGallery());
            }

            // Exit classification
            const exitClassifyBtn = document.getElementById('exitClassifyBtn');
            if (exitClassifyBtn) {
                exitClassifyBtn.addEventListener('click', () => this.exitClassificationMode());
            }

            // Preview download
            const previewDownloadBtn = document.getElementById('previewDownloadBtn');
            if (previewDownloadBtn) {
                previewDownloadBtn.addEventListener('click', () => this.showDownloadPreview());
            }

            // Modal event listeners (removed - using hover actions now)

            // Download buttons
            const downloadBtns = {
                'downloadAllBtn': () => this.downloadAllImages(),
                'downloadFrontBtn': () => this.downloadFrontImages(),
                'downloadBackBtn': () => this.downloadBackImages(),
                'downloadZipAllBtn': () => this.downloadAllImagesZip(),
                'downloadZipFrontBtn': () => this.downloadFrontImagesZip(),
                'downloadZipBackBtn': () => this.downloadBackImagesZip()
            };

            Object.entries(downloadBtns).forEach(([id, handler]) => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.addEventListener('click', handler);
                }
            });

            // Download settings event listeners
            const saveDownloadSettingsBtn = document.getElementById('saveDownloadSettings');
            if (saveDownloadSettingsBtn) {
                saveDownloadSettingsBtn.addEventListener('click', () => this.saveDownloadSettings());
            }

            const useSubfoldersCheckbox = document.getElementById('useSubfolders');
            if (useSubfoldersCheckbox) {
                useSubfoldersCheckbox.addEventListener('change', (e) => {
                    const subfolderSettings = document.getElementById('subfolderSettings');
                    if (subfolderSettings) {
                        subfolderSettings.style.display = e.target.checked ? 'block' : 'none';
                    }
                });
            }
            
            // New individual download buttons for classified images
            const downloadFrontIndividualBtn = document.getElementById('downloadFrontIndividualBtn');
            if (downloadFrontIndividualBtn) {
                downloadFrontIndividualBtn.addEventListener('click', () => this.downloadFrontImagesIndividual());
            }
            
            const downloadBackIndividualBtn = document.getElementById('downloadBackIndividualBtn');
            if (downloadBackIndividualBtn) {
                downloadBackIndividualBtn.addEventListener('click', () => this.downloadBackImagesIndividual());
            }
            
            const downloadAllIndividualBtn = document.getElementById('downloadAllIndividualBtn');
            if (downloadAllIndividualBtn) {
                downloadAllIndividualBtn.addEventListener('click', () => this.downloadAllClassifiedImagesIndividual());
            }

            // Upload button and file input
            const uploadBtn = document.getElementById('uploadBtn');
            const galleryFileInput = document.getElementById('galleryFileInput');
            
            if (uploadBtn && galleryFileInput) {
                uploadBtn.addEventListener('click', () => {
                    galleryFileInput.click();
                });
                
                galleryFileInput.addEventListener('change', (e) => {
                    if (e.target.files && e.target.files.length > 0) {
                        this.handleGalleryFileUpload(e.target.files);
                    }
                });
            }

            // Search and filter functionality
            const searchInput = document.getElementById('gallerySearchInput');
            const filterSelect = document.getElementById('galleryFilterSelect');
            
            if (searchInput) {
                searchInput.addEventListener('input', () => this.filterGalleryImages());
            }
            
            if (filterSelect) {
                filterSelect.addEventListener('change', () => this.filterGalleryImages());
            }

            // Prefix input change handlers
            const frontPrefix = document.getElementById('frontPrefix');
            const backPrefix = document.getElementById('backPrefix');
            if (frontPrefix) {
                frontPrefix.addEventListener('input', () => this.updateRenamePatterns());
            }
            if (backPrefix) {
                backPrefix.addEventListener('input', () => this.updateRenamePatterns());
            }

            // Setup drag and drop for classification
            this.setupClassificationDragDrop();
            
            // Quick selection event listeners - Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                console.log('🔍 Đang tìm nút quickSelectFrontBtn...');
                const quickSelectFrontBtn = document.getElementById('quickSelectFrontBtn');
                console.log('🔍 Tìm thấy quickSelectFrontBtn:', !!quickSelectFrontBtn);
                
                if (quickSelectFrontBtn) {
                    console.log('🔍 Nội dung text của nút:', quickSelectFrontBtn.textContent);
                    console.log('🔍 Nút bị vô hiệu hóa:', quickSelectFrontBtn.disabled);
                    console.log('🔍 Thuộc tính display của nút:', quickSelectFrontBtn.style.display);
                    console.log('🔍 Phần tử cha của nút:', quickSelectFrontBtn.parentElement);
                    
                    // Remove any existing listeners first
                    const newFrontBtn = quickSelectFrontBtn.cloneNode(true);
                    quickSelectFrontBtn.parentNode.replaceChild(newFrontBtn, quickSelectFrontBtn);
                    
                    newFrontBtn.addEventListener('click', (event) => {
                        console.log('🔥🔥🔥 FRONT BUTTON CLICKED! 🔥🔥🔥');
                        console.log('Event:', event);
                        console.log('Button element:', newFrontBtn);
                        console.log('Current state before startQuickSelection:', {
                            selectionMode: this.selectionMode,
                            selectionType: this.selectionType,
                            classificationMode: this.classificationMode
                        });
                        event.preventDefault();
                        event.stopPropagation();
                        this.startQuickSelection('front');
                        console.log('🔥🔥🔥 startQuickSelection(front) completed 🔥🔥🔥');
                    });
                    console.log('✅ Đã tìm thấy nút chọn nhanh MẶT TRƯỚC và thêm listener');
                } else {
                    console.error('❌ Không tìm thấy quickSelectFrontBtn trong DOM');
                    console.log('❌ Các phần tử có ID tương tự:');
                    const similarElements = document.querySelectorAll('[id*="Front"], [id*="front"]');
                    similarElements.forEach(el => {
                        console.log('❌ Tìm thấy phần tử:', el.id, el.tagName, el.textContent);
                    });
                }
                
                const quickSelectBackBtn = document.getElementById('quickSelectBackBtn');
                if (quickSelectBackBtn) {
                    quickSelectBackBtn.addEventListener('click', () => {
                        console.log('🔥 Đã nhấn nút chọn nhanh MẶT SAU');
                        this.startQuickSelection('back');
                    });
                    console.log('✅ Đã tìm thấy nút chọn nhanh MẶT SAU và thêm listener');
                } else {
                    console.error('❌ Không tìm thấy quickSelectBackBtn');
                }
                
                const selectAllFrontBtn = document.getElementById('selectAllFrontBtn');
                if (selectAllFrontBtn) {
                    selectAllFrontBtn.addEventListener('click', () => {
                        console.log('🔥 Đã nhấn nút chọn tất cả MẶT TRƯỚC');
                        this.selectAllAs('front');
                    });
                    console.log('✅ Đã tìm thấy nút chọn tất cả MẶT TRƯỚC và thêm listener');
                } else {
                    console.error('❌ Không tìm thấy selectAllFrontBtn');
                }
                
                const selectAllBackBtn = document.getElementById('selectAllBackBtn');
                if (selectAllBackBtn) {
                    selectAllBackBtn.addEventListener('click', () => {
                        console.log('🔥 Đã nhấn nút chọn tất cả MẶT SAU');
                        this.selectAllAs('back');
                    });
                    console.log('✅ Đã tìm thấy nút chọn tất cả MẶT SAU và thêm listener');
                } else {
                    console.error('❌ Không tìm thấy selectAllBackBtn');
                }
                
                const applySelectionBtn = document.getElementById('applySelectionBtn');
                if (applySelectionBtn) {
                    applySelectionBtn.addEventListener('click', (event) => {
                        console.log('🔥 Đã nhấn nút áp dụng lựa chọn!');
                        console.log('Chi tiết sự kiện:', {
                            target: event.target,
                            currentTarget: event.currentTarget,
                            bubbles: event.bubbles,
                            defaultPrevented: event.defaultPrevented
                        });
                        console.log('Trạng thái hiện tại TRƯỚC preventDefault:', {
                            selectedImages: this.selectedImages,
                            selectionType: this.selectionType,
                            selectionMode: this.selectionMode,
                            currentTab: this.getCurrentActiveTab()
                        });
                        
                        event.preventDefault();
                        event.stopPropagation();
                        
                        console.log('Trạng thái hiện tại SAU preventDefault:', {
                            selectedImages: this.selectedImages,
                            selectionType: this.selectionType,
                            selectionMode: this.selectionMode
                        });
                        
                        this.applySelectionOnly();
                    });
                    console.log('✅ Đã tìm thấy nút áp dụng lựa chọn và thêm listener');
                } else {
                    console.error('❌ Không tìm thấy applySelectionBtn');
                }
                
                const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
                if (cancelSelectionBtn) {
                    cancelSelectionBtn.addEventListener('click', () => {
                        console.log('🔥 Đã nhấn nút hủy lựa chọn');
                        this.cancelSelectionMode();
                    });
                    console.log('✅ Đã tìm thấy nút hủy lựa chọn và thêm listener');
                } else {
                    console.error('❌ Không tìm thấy cancelSelectionBtn');
                }
            }, 1000);
        }

        loadGalleryFromStorage() {
            try {
                const stored = localStorage.getItem('meu-layout-gallery');
                return stored ? JSON.parse(stored) : [];
            } catch (error) {
                console.error('Error loading gallery from storage:', error);
                return [];
            }
        }

        saveGalleryToStorage() {
            try {
                const dataString = JSON.stringify(this.galleryImages);
                localStorage.setItem('meu-layout-gallery', dataString);
            } catch (error) {
                console.error('Error saving gallery to storage:', error);
                
                if (error.name === 'QuotaExceededError') {
                    // Storage is full - try to free up space
                    this.handleStorageQuotaExceeded();
                } else {
                    this.showToast('Lỗi lưu trữ dữ liệu!', 'error');
                }
            }
        }

        handleStorageQuotaExceeded() {
            const currentCount = this.galleryImages.length;
            const maxImages = Math.floor(currentCount * 0.7); // Keep 70% of images
            
            const confirmCleanup = confirm(
                `⚠️ BỘ NHỚ STORAGE ĐÃ ĐẦY!\n\n` +
                `Hiện tại: ${currentCount} ảnh\n` +
                `Đề xuất: Chỉ giữ lại ${maxImages} ảnh mới nhất\n\n` +
                `Bạn có muốn dọn dẹp để tiếp tục sử dụng không?\n` +
                `(Các ảnh sẽ bị xóa khỏi kho nhưng vẫn có thể tải lại)`
            );
            
            if (confirmCleanup) {
                try {
                    // Sort by newest first and keep only the most recent ones
                    this.galleryImages.sort((a, b) => new Date(b.timestamp || 0) - new Date(a.timestamp || 0));
                    this.galleryImages = this.galleryImages.slice(0, maxImages);
                    
                    // Try saving again
                    const dataString = JSON.stringify(this.galleryImages);
                    localStorage.setItem('meu-layout-gallery', dataString);
                    
                    this.updateGalleryDisplay();
                    this.showToast(`✅ Đã dọn dẹp! Giữ lại ${maxImages}/${currentCount} ảnh mới nhất`, 'success');
                    
                } catch (retryError) {
                    console.error('Still quota exceeded after cleanup:', retryError);
                    this.showToast('⚠️ Vẫn không đủ bộ nhớ. Hãy xóa thêm ảnh hoặc tải về và xóa toàn bộ!', 'error');
                }
            } else {
                this.showToast('⚠️ Không thể lưu ảnh mới. Kho đã đầy!', 'error');
            }
        }

        // Compress image data before storing (reduce quality for storage)
        async compressImageForStorage(imageData, maxWidth = 800, quality = 0.8) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    // Calculate new dimensions
                    let { width, height } = img;
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                    
                    // Resize canvas and draw
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to compressed data URL
                    const compressedData = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedData);
                };
                
                img.src = imageData;
            });
        }

        async addImageToGallery(imageData, filename, isCropped = false) {
            try {
                // Compress image for storage to save space
                const compressedData = await this.compressImageForStorage(imageData);
                
                const galleryItem = {
                    id: Date.now() + Math.random(),
                    data: compressedData,
                    filename: filename,
                    originalName: isCropped ? null : filename, // null means uploaded, not cropped
                    timestamp: new Date().toISOString(),
                    size: Math.round(compressedData.length * 0.75), // Approximate size
                    type: isCropped ? 'cropped' : 'uploaded'
                };

                this.galleryImages.push(galleryItem);
                this.saveGalleryToStorage();
                this.updateGalleryDisplay();
            } catch (error) {
                console.error('Error adding image to gallery:', error);
                this.showToast('Lỗi thêm ảnh vào kho!', 'error');
            }
        }

        // Handle multiple file upload with progress
        async handleGalleryFileUpload(files) {
            const validFiles = [];
            const supportedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
            
            // Filter valid image files
            for (let file of files) {
                if (supportedTypes.includes(file.type.toLowerCase())) {
                    validFiles.push(file);
                } else {
                    this.showToast(`File ${file.name} không được hỗ trợ`, 'error');
                }
            }

            if (validFiles.length === 0) {
                this.showToast('Không có file hợp lệ để tải lên', 'error');
                return;
            }

            // Show progress bar
            const uploadProgress = document.getElementById('uploadProgress');
            const progressFill = document.getElementById('progressFill');
            const progressCount = document.getElementById('progressCount');
            const progressDetails = document.getElementById('progressDetails');
            
            uploadProgress.style.display = 'block';
            progressCount.textContent = `0/${validFiles.length}`;
            progressFill.style.width = '0%';
            progressDetails.textContent = 'Bắt đầu tải lên...';

            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < validFiles.length; i++) {
                const file = validFiles[i];
                
                try {
                    progressDetails.textContent = `Đang xử lý: ${file.name}`;
                    
                    // Convert file to base64
                    const imageData = await this.fileToBase64(file);
                    
                    // Add to gallery
                    await this.addImageToGallery(imageData, file.name, false);
                    
                    successCount++;
                    
                } catch (error) {
                    console.error(`Error processing file ${file.name}:`, error);
                    errorCount++;
                }

                // Update progress
                const progress = ((i + 1) / validFiles.length) * 100;
                progressFill.style.width = progress + '%';
                progressCount.textContent = `${i + 1}/${validFiles.length}`;
                
                // Small delay to show progress
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Hide progress bar after delay
            setTimeout(() => {
                uploadProgress.style.display = 'none';
            }, 1000);

            // Show completion message
            if (successCount > 0) {
                this.showToast(`✅ Đã tải lên thành công ${successCount} ảnh${errorCount > 0 ? `, ${errorCount} ảnh lỗi` : ''}!`, 'success');
            } else {
                this.showToast('Không thể tải lên ảnh nào', 'error');
            }

            // Reset file input
            document.getElementById('galleryFileInput').value = '';
        }

        // Convert file to base64
        fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Gallery Management Functions
        renameGalleryItem(imageId) {
            const image = this.galleryImages.find(img => img.id == imageId);
            if (!image) return;

            const newName = prompt('Nhập tên mới cho ảnh:', image.filename);
            if (newName && newName.trim() !== '' && newName !== image.filename) {
                // Ensure proper extension
                const extension = image.filename.split('.').pop();
                const finalName = newName.includes('.') ? newName : `${newName}.${extension}`;
                
                image.filename = finalName;
                this.saveGalleryToStorage();
                this.updateGalleryDisplay();
                this.showToast(`Đã đổi tên thành: ${finalName}`, 'success');
            }
        }

        deleteGalleryItem(imageId) {
            const image = this.galleryImages.find(img => img.id == imageId);
            if (!image) return;

            if (confirm(`Bạn có chắc muốn xóa ảnh "${image.filename}"?`)) {
                this.galleryImages = this.galleryImages.filter(img => img.id != imageId);
                this.saveGalleryToStorage();
                this.updateGalleryDisplay();
                this.showToast('Đã xóa ảnh khỏi kho', 'success');
            }
        }

        downloadGalleryItem(imageId) {
            const image = this.galleryImages.find(img => img.id == imageId);
            if (!image) return;

            const link = document.createElement('a');
            link.href = image.data;
            
            // Apply download folder settings for gallery items
            const fileName = this.applyDownloadFolderSettings(image.filename, 'gallery');
            link.download = fileName;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            this.showToast(`Đã tải về: ${image.filename}`, 'success');
        }

        updateGalleryDisplay() {
            const galleryGrid = document.getElementById('galleryGrid');
            const galleryCount = document.getElementById('galleryCount');
            const classifyBtn = document.getElementById('classifyBtn');
            const clearGalleryBtn = document.getElementById('clearGalleryBtn');
            
            // Auto-update duplex grid if in duplex mode (để tránh cần reload)
            if (this.printData?.config?.printMode === 'duplex') {
                setTimeout(() => this.updateGalleryGridDuplex(), 50);
            }

            if (!galleryGrid) return;

            // Update count
            if (galleryCount) {
                galleryCount.textContent = `${this.galleryImages.length} ảnh`;
            }

            // Update button states
            const hasImages = this.galleryImages.length > 0;
            if (classifyBtn) classifyBtn.disabled = !hasImages;
            if (clearGalleryBtn) clearGalleryBtn.disabled = !hasImages;
            
            const autoClassifyBtn = document.getElementById('autoClassifyBtn');
            if (autoClassifyBtn) autoClassifyBtn.disabled = !hasImages;

            // Clear existing content
            galleryGrid.innerHTML = '';

            if (this.galleryImages.length === 0) {
                galleryGrid.innerHTML = `
                    <div class="empty-gallery">
                        <div class="empty-icon">📷</div>
                        <div class="empty-text">Chưa có ảnh nào trong kho</div>
                        <div class="empty-hint">Nhấn "Tải ảnh lên" để thêm ảnh hoặc sử dụng Template Crop</div>
                    </div>
                `;
                return;
            }

            // Show loading state for large galleries
            if (this.galleryImages.length > 30) {
                galleryGrid.innerHTML = `
                    <div class="gallery-loading" id="galleryLoading">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Đang tải ${this.galleryImages.length} ảnh...</div>
                    </div>
                `;
                
                // Use batch processing for better performance
                requestAnimationFrame(() => {
                    galleryGrid.innerHTML = '';
                    this.renderGalleryWithLazyLoading(galleryGrid);
                });
                return;
            }

            // Render gallery items normally for small galleries
            const fragment = document.createDocumentFragment();
            this.galleryImages.forEach((item, index) => {
                const itemEl = this.createGalleryItemOptimized(item, index);
                fragment.appendChild(itemEl);
            });
            
            galleryGrid.appendChild(fragment);
        }
        
        createGalleryItemOptimized(item, index) {
            const itemEl = document.createElement('div');
            itemEl.className = 'gallery-item';
            itemEl.draggable = true;
            itemEl.dataset.imageId = item.id;
            itemEl.dataset.index = index;

            // Use thumbnail for better performance
            const imageSrc = this.galleryImages.length > 50 ? this.createThumbnail(item.data) : item.data;

            itemEl.innerHTML = `
                <div class="gallery-item-image-container">
                    <img src="${imageSrc}" alt="${item.filename}" class="gallery-item-image" loading="lazy">
                    <div class="selection-checkbox">✓</div>
                    <div class="gallery-item-actions">
                        <button class="gallery-action-btn rename-btn" onclick="converter.renameGalleryItem('${item.id}')" title="Đổi tên">
                            <span>✏️</span>
                        </button>
                        <button class="gallery-action-btn download-btn" onclick="converter.downloadGalleryItem('${item.id}')" title="Tải về">
                            <span>📥</span>
                        </button>
                        <button class="gallery-action-btn delete-btn" onclick="converter.deleteGalleryItem('${item.id}')" title="Xóa">
                            <span>🗑️</span>
                        </button>
                    </div>
                </div>
                <div class="gallery-item-info">
                    <div class="gallery-item-name" title="${item.filename}">${item.filename}</div>
                    <div class="gallery-item-details">
                        <span class="gallery-item-size">${this.formatFileSize(item.size)}</span>
                        <span class="gallery-item-type">${item.type === 'cropped' ? 'Crop' : 'Upload'}</span>
                    </div>
                </div>
            `;

            // Add drag event listeners
            itemEl.addEventListener('dragstart', (e) => this.handleGalleryDragStart(e));
            itemEl.addEventListener('dragend', (e) => this.handleGalleryDragEnd(e));
            
            // Add selection mode click listener
            itemEl.addEventListener('click', (e) => this.handleGalleryItemSelection(e, item.id));

            return itemEl;
        }

        formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
            return Math.round(bytes / (1024 * 1024)) + ' MB';
        }
        
        // Performance optimization methods
        renderGalleryWithLazyLoading(galleryGrid) {
            const batchSize = 15; // Render 15 items at a time
            let currentBatch = 0;
            
            const renderBatch = () => {
                const startIndex = currentBatch * batchSize;
                const endIndex = Math.min(startIndex + batchSize, this.galleryImages.length);
                const fragment = document.createDocumentFragment();
                
                for (let i = startIndex; i < endIndex; i++) {
                    const item = this.galleryImages[i];
                    const itemEl = this.createGalleryItemFast(item, i);
                    fragment.appendChild(itemEl);
                }
                
                galleryGrid.appendChild(fragment);
                currentBatch++;
                
                // Continue rendering if more items exist
                if (endIndex < this.galleryImages.length) {
                    requestAnimationFrame(() => {
                        setTimeout(renderBatch, 10); // Small delay to prevent blocking
                    });
                }
            };
            
            renderBatch();
        }
        
        createGalleryItemFast(item, index) {
            const itemEl = document.createElement('div');
            itemEl.className = 'gallery-item';
            itemEl.draggable = true;
            itemEl.dataset.imageId = item.id;
            itemEl.dataset.index = index;
            
            // Create thumbnail on demand instead of using full image
            const thumbnailSrc = this.createThumbnail(item.data);
            
            itemEl.innerHTML = `
                <div class="gallery-item-image-container">
                    <img src="${thumbnailSrc}" alt="${item.filename}" class="gallery-item-image" loading="lazy">
                    <div class="selection-checkbox">✓</div>
                    <div class="gallery-item-actions">
                        <button class="gallery-action-btn rename-btn" onclick="converter.renameGalleryItem('${item.id}')" title="Đổi tên">
                            <span>✏️</span>
                        </button>
                        <button class="gallery-action-btn download-btn" onclick="converter.downloadGalleryItem('${item.id}')" title="Tải về">
                            <span>📅</span>
                        </button>
                        <button class="gallery-action-btn delete-btn" onclick="converter.deleteGalleryItem('${item.id}')" title="Xóa">
                            <span>🗑️</span>
                        </button>
                    </div>
                </div>
                <div class="gallery-item-info">
                    <div class="gallery-item-name" title="${item.filename}">${item.filename}</div>
                    <div class="gallery-item-details">
                        <span class="gallery-item-size">${this.formatFileSize(item.size)}</span>
                        <span class="gallery-item-type">${item.type === 'cropped' ? 'Cắt' : 'Tải'}</span>
                    </div>
                </div>
            `;
            
            // Add event listeners
            itemEl.addEventListener('dragstart', (e) => this.handleGalleryDragStart(e));
            itemEl.addEventListener('dragend', (e) => this.handleGalleryDragEnd(e));
            itemEl.addEventListener('click', (e) => this.handleGalleryItemSelection(e, item.id));
            
            return itemEl;
        }
        
        createThumbnail(imageData, maxSize = 150) {
            // Check cache first
            const cacheKey = `thumb_${this.hashString(imageData.substring(0, 100))}`;
            if (this.thumbnailCache.has(cacheKey)) {
                return this.thumbnailCache.get(cacheKey);
            }
            
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    const ratio = Math.min(maxSize / img.width, maxSize / img.height);
                    canvas.width = Math.floor(img.width * ratio);
                    canvas.height = Math.floor(img.height * ratio);
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const thumbnail = canvas.toDataURL('image/jpeg', 0.9);
                    
                    // Cache with size limit
                    if (this.thumbnailCache.size > 200) {
                        const firstKey = this.thumbnailCache.keys().next().value;
                        this.thumbnailCache.delete(firstKey);
                    }
                    this.thumbnailCache.set(cacheKey, thumbnail);
                };
                
                img.src = imageData;
                return imageData; // Return original while thumbnail processes
            } catch (error) {
                return imageData; // Fallback to original
            }
        }
        
        hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash.toString();
        }

        // New method for filtering gallery images
        filterGalleryImages() {
            const searchInput = document.getElementById('gallerySearchInput');
            const filterSelect = document.getElementById('galleryFilterSelect');
            
            if (!searchInput || !filterSelect) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            const filterType = filterSelect.value;
            
            let filteredImages = this.galleryImages;
            
            // Apply type filter
            if (filterType !== 'all') {
                filteredImages = filteredImages.filter(image => {
                    if (filterType === 'uploaded') return image.type === 'uploaded';
                    if (filterType === 'cropped') return image.type === 'cropped';
                    return true;
                });
            }
            
            // Apply search filter
            if (searchTerm) {
                filteredImages = filteredImages.filter(image => 
                    image.filename.toLowerCase().includes(searchTerm)
                );
            }
            
            this.renderFilteredGallery(filteredImages);
        }

        // New method to render filtered results
        renderFilteredGallery(filteredImages) {
            const galleryGrid = document.getElementById('galleryGrid');
            const galleryCount = document.getElementById('galleryCount');
            
            if (!galleryGrid) return;
            
            // Update count display
            if (galleryCount) {
                if (filteredImages.length !== this.galleryImages.length) {
                    galleryCount.textContent = `${filteredImages.length}/${this.galleryImages.length} ảnh`;
                } else {
                    galleryCount.textContent = `${this.galleryImages.length} ảnh`;
                }
            }
            
            galleryGrid.innerHTML = '';
            
            if (filteredImages.length === 0) {
                if (this.galleryImages.length === 0) {
                    galleryGrid.innerHTML = `
                        <div class="empty-gallery">
                            <div class="empty-icon">📷</div>
                            <div class="empty-text">Chưa có ảnh nào trong kho</div>
                            <div class="empty-hint">Nhấn "Tải ảnh lên" để thêm ảnh hoặc sử dụng Template Crop</div>
                        </div>
                    `;
                } else {
                    galleryGrid.innerHTML = `
                        <div class="empty-gallery">
                            <div class="empty-icon">🔍</div>
                            <div class="empty-text">Không tìm thấy ảnh</div>
                            <div class="empty-hint">Thử thay đổi từ khóa tìm kiếm hoặc bộ lọc</div>
                        </div>
                    `;
                }
                return;
            }
            
            // Render filtered gallery items
            filteredImages.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'gallery-item';
                itemEl.dataset.imageId = item.id;
                itemEl.draggable = true;
                
                // Add type indicator for better visual distinction
                const typeIndicator = item.type === 'cropped' ? '✂️' : '📷';
                
                itemEl.innerHTML = `
                    <div class="gallery-item-image-container">
                        <img src="${item.data}" alt="${item.filename}" class="gallery-item-image" loading="lazy">
                        <div class="gallery-image-tooltip">
                            <img src="${item.data}" alt="${item.filename}" class="tooltip-image">
                            <div class="tooltip-info">
                                <div><strong>${item.filename}</strong></div>
                                <div>${this.formatFileSize(item.size)} • ${item.type === 'cropped' ? 'Đã cắt' : 'Tải lên'}</div>
                                <div style="color: #6b7280; font-size: 0.7rem;">
                                    ${new Date(item.timestamp).toLocaleDateString('vi-VN')}
                                </div>
                            </div>
                        </div>
                        <div class="gallery-item-actions">
                            <button class="gallery-action-btn rename-btn" onclick="converter.renameGalleryItem('${item.id}')" title="Đổi tên">
                                <span>✏️</span>
                            </button>
                            <button class="gallery-action-btn download-btn" onclick="converter.downloadGalleryItem('${item.id}')" title="Tải về">
                                <span>💾</span>
                            </button>
                            <button class="gallery-action-btn delete-btn" onclick="converter.deleteGalleryItem('${item.id}')" title="Xóa">
                                <span>🗑️</span>
                            </button>
                        </div>
                    </div>
                    <div class="gallery-item-info">
                        <div class="gallery-item-name" title="${item.filename}">${typeIndicator} ${item.filename}</div>
                        <div class="gallery-item-details">
                            <span class="gallery-item-size">${this.formatFileSize(item.size)}</span>
                            <span class="gallery-item-type">${item.type === 'cropped' ? 'Đã cắt' : 'Tải lên'}</span>
                        </div>
                    </div>
                `;

                // Event listeners
                itemEl.addEventListener('dragstart', (e) => this.handleGalleryDragStart(e));
                itemEl.addEventListener('dragend', (e) => this.handleGalleryDragEnd(e));
                itemEl.addEventListener('click', (e) => this.handleGalleryItemSelection(e, item.id));
                
                galleryGrid.appendChild(itemEl);
            });
        }

        clearGallery() {
            if (confirm('Bạn có chắc muốn xóa tất cả ảnh trong kho?')) {
                this.galleryImages = [];
                this.saveGalleryToStorage();
                this.updateGalleryDisplay();
                this.showToast('Đã xóa tất cả ảnh khỏi kho');
            }
        }

        // Quick Selection Methods
        startQuickSelection(type) {
            console.log('🔍🔍🔍 GALLERY startQuickSelection called with type:', type);
            
            if (type === 'front') {
                console.log('🎯 DEBUGGING FRONT SELECTION SPECIFICALLY');
            }
            
            // Auto-enter classification mode if not already in it
            if (!this.classificationMode) {
                console.log('🔍 Auto-entering classification mode for quick selection');
                this.enterClassificationMode();
            }
            
            this.selectionMode = true;
            this.selectionType = type;
            this.selectedImages = [];
            console.log('🎯 RESET selectedImages in startQuickSelection');
            
            // Add active-selection class to hide hover actions during selection
            const printContainer = document.querySelector('.print-container');
            if (printContainer) {
                printContainer.classList.add('active-selection');
            }
            
            console.log('🔍 GALLERY Selection mode state AFTER setting:', {
                selectionMode: this.selectionMode,
                selectionType: this.selectionType,
                selectedImages: this.selectedImages,
                classificationMode: this.classificationMode,
                galleryImagesCount: this.galleryImages?.length
            });
            
            // Update UI
            console.log('🔍 Calling updateSelectionUI...');
            this.updateSelectionUI();
            
            // Force refresh source grid to ensure visual effects work
            console.log('🔍 GALLERY Updating source grid...');
            this.updateSourceGrid();
            console.log('🔍 Calling updateSourceGridSelectionMode...');
            this.updateSourceGridSelectionMode();
            
            // Show status
            const typeText = type === 'front' ? 'Mặt Trước' : 'Mặt Sau';
            this.showToast(`🎯 📂 KHO ẢNH: Chế độ chọn ${typeText} đã bật! Click ảnh để chọn, sau đó nhấn "📂 Kho: Áp dụng".`, 'info');
            
            if (type === 'front') {
                console.log('🎯 FRONT SELECTION SETUP COMPLETED');
            }
        }
        
        exitSelectionMode() {
            // Apply selection if there are selected images
            if (this.selectedImages.length > 0) {
                const typeText = this.selectionType === 'front' ? 'Mặt Trước' : 'Mặt Sau';
                const confirmApply = confirm(`Áp dụng ${this.selectedImages.length} ảnh đã chọn làm ${typeText}?`);
                
                if (confirmApply) {
                    this.applySelection();
                }
            }
            
            // Reset selection state
            this.selectionMode = false;
            this.selectionType = null;
            this.selectedImages = [];
            
            // Update UI
            this.updateSelectionUI();
            this.updateSourceGridSelectionMode();
            
            this.showToast('Đã thoát chế độ chọn', 'success');
        }
        
        applySelectionOnly() {
            console.log('🔍 applySelectionOnly called');
            console.log('Selected images:', this.selectedImages);
            console.log('Selection type:', this.selectionType);
            console.log('Current tab:', this.getCurrentActiveTab());
            console.log('Classification mode:', this.classificationMode);
            
            if (this.selectedImages.length === 0) {
                this.showToast('⚠️ Chưa chọn ảnh nào để áp dụng!', 'error');
                return;
            }
            
            const typeText = this.selectionType === 'front' ? 'Mặt Trước' : 'Mặt Sau';
            const selectedCount = this.selectedImages.length;
            const currentSelectionType = this.selectionType; // Store before reset
            
            console.log('🔄 About to apply selection:', selectedCount, 'images as', typeText);
            
            // Apply selection to classification system
            this.applySelection();
            
            // Update UI immediately
            this.updateClassificationDisplay();
            
            console.log('✅ Selection applied successfully');
            
            // Reset selection state after applying
            this.selectionMode = false;
            this.selectionType = null;
            this.selectedImages = [];
            console.log('🔄 Selection state reset after apply');
            
            // Remove active-selection class to show hover actions again
            const printContainer = document.querySelector('.print-container');
            if (printContainer) {
                printContainer.classList.remove('active-selection');
            }
            
            // Update UI
            this.updateSelectionUI();
            this.updateSourceGridSelectionMode();
            
            this.showToast(`✅ Đã áp dụng ${selectedCount} ảnh làm ${typeText}!`, 'success');
        }

        applyDuplexClassification() {
            if (this.selectedImages.length === 0) {
                this.showToast('Vui lòng chọn ít nhất 1 ảnh', 'warning');
                return;
            }

            const type = this.selectionType;
            const targetArray = type === 'front' ? this.printData.frontImages : this.printData.backImages;
            
            // Add selected images to classification
            this.selectedImages.forEach(imageData => {
                // Check if already classified
                const existsInFront = this.printData.frontImages.some(img => img.id === imageData.id);
                const existsInBack = this.printData.backImages.some(img => img.id === imageData.id);
                
                if (!existsInFront && !existsInBack) {
                    targetArray.push({
                        id: imageData.id,
                        src: imageData.data,
                        name: imageData.filename,
                        file: imageData.file || null
                    });
                }
            });

            const selectedCount = this.selectedImages.length;
            const typeText = type === 'front' ? 'mặt trước' : 'mặt sau';
            
            // Reset selection state
            this.selectionMode = false;
            this.selectionType = null;
            this.selectedImages = [];
            
            // Update UI
            this.updateClassificationUI();
            this.updateSourceGridSelectionMode();
            this.updateDuplexStats();
            this.updateClassificationDisplay();
            this.updateDuplexPreview();
            
            this.showToast(`✅ Đã phân loại ${selectedCount} ảnh làm ${typeText}!`, 'success');
        }
        
        applyDuplexClassificationAuto() {
            // Auto-apply for immediate feedback in duplex mode
            if (!this.selectionType) return;
            
            const type = this.selectionType;
            const targetArray = type === 'front' ? this.printData.frontImages : this.printData.backImages;
            
            // Process each selected image immediately
            if (this.selectedImages.length > 0) {
                const lastImage = this.selectedImages[this.selectedImages.length - 1];
                
                // Check if already classified
                const existsInFront = this.printData.frontImages.some(img => img.id === lastImage.id);
                const existsInBack = this.printData.backImages.some(img => img.id === lastImage.id);
                
                if (!existsInFront && !existsInBack) {
                    targetArray.push({
                        id: lastImage.id,
                        src: lastImage.data,
                        name: lastImage.filename,
                        file: lastImage.file || null
                    });
                    
                    const typeText = type === 'front' ? 'mặt trước' : 'mặt sau';
                    this.showToast(`📌 Đã thêm vào ${typeText}`, 'success');
                } else {
                    this.showToast('Ảnh đã được phân loại trước đó', 'info');
                }
            }
            
            // Update UI immediately
            this.updateClassificationDisplay();
            this.updateDuplexStats();
            this.updateDuplexPreview();
            
            // Update printData.selectedImages with all classified images for preview
            this.updatePrintDataSelectedImages();
            
            // Clear current selection but keep selection mode active
            this.selectedImages = [];
            this.updateSourceGridSelectionMode();
        }
        
        updatePrintDataSelectedImages() {
            // Combine all classified images into selectedImages for preview
            if (this.printData.config.printMode === 'duplex') {
                const allClassifiedImages = [];
                
                // Add front images
                this.printData.frontImages.forEach(img => {
                    // Kiểm tra để tránh lỗi undefined
                    if (img && img.src && img.name) {
                        allClassifiedImages.push({
                            id: img.id,
                            name: img.name,
                            data: img.src,  // img.src chứa base64 data
                            file: img.file
                        });
                    } else {
                        console.warn('Invalid front image data:', img);
                    }
                });
                
                // Add back images
                this.printData.backImages.forEach(img => {
                    // Kiểm tra để tránh lỗi undefined
                    if (img && img.src && img.name) {
                        allClassifiedImages.push({
                            id: img.id,
                            name: img.name,
                            data: img.src,  // img.src chứa base64 data
                            file: img.file
                        });
                    } else {
                        console.warn('Invalid back image data:', img);
                    }
                });
                
                console.log('📊 Updated printData.selectedImages with', allClassifiedImages.length, 'classified images');
                
                // Update printData.selectedImages
                this.printData.selectedImages = allClassifiedImages;
                
                // Update display and preview
                this.updateSelectedImagesDisplay();
                this.updateTotalPages();
                this.updatePreview();
            }
        }
        
        cancelSelectionMode() {
            // Reset selection state without applying
            this.selectionMode = false;
            this.selectionType = null;
            this.selectedImages = [];
            
            // Remove active-selection class to show hover actions again
            const printContainer = document.querySelector('.print-container');
            if (printContainer) {
                printContainer.classList.remove('active-selection');
            }
            
            // Update UI
            this.updateSelectionUI();
            this.updateSourceGridSelectionMode();
            
            this.showToast('🚫 Đã hủy chế độ chọn', 'info');
        }
        
        handleGalleryItemSelection(event, imageId) {
            // Only handle clicks in selection mode
            if (!this.selectionMode) return;
            
            // Prevent event bubbling
            event.preventDefault();
            event.stopPropagation();
            
            // For duplex classification, we need image objects, not just IDs
            if (this.printData.config.printMode === 'duplex' && this.selectionType) {
                this.handleDuplexImageSelection(imageId);
            } else {
                // Original logic for gallery classification
                const isSelected = this.selectedImages.includes(imageId);
                
                if (isSelected) {
                    this.selectedImages = this.selectedImages.filter(id => id !== imageId);
                } else {
                    this.selectedImages.push(imageId);
                }
            }
            
            // Update visual feedback
            this.updateSourceGridSelectionMode();
            this.updateSelectionCounter();
        }

        handleDuplexImageSelection(imageId) {
            // Find the image object in gallery
            const imageObj = this.galleryImages.find(img => img.id == imageId);
            if (!imageObj) return;
            
            // For duplex classification, store consistent data format (objects)
            const isSelected = this.selectedImages.some(img => 
                (typeof img === 'object' ? img.id : img) == imageId
            );
            
            if (isSelected) {
                this.selectedImages = this.selectedImages.filter(img => 
                    (typeof img === 'object' ? img.id : img) != imageId
                );
            } else {
                this.selectedImages.push(imageObj);
            }
            
            // Auto-apply selection for better UX in duplex mode
            this.applyDuplexClassificationAuto();
        }
        
        handleSourceGridItemSelection(event, imageId) {
            console.log('handleSourceGridItemSelection called with:', { imageId, selectionMode: this.selectionMode });
            
            // Only handle clicks in selection mode
            if (!this.selectionMode) {
                console.log('Not in selection mode, ignoring click');
                return;
            }
            
            // Prevent event bubbling
            event.preventDefault();
            event.stopPropagation();
            
            console.log('Source grid item clicked:', imageId, 'Selection mode:', this.selectionMode, 'Print mode:', this.printData?.config?.printMode);
            
            console.log('🎯 About to check selection logic');
            console.log('🎯 Current selectedImages:', this.selectedImages);
            console.log('🎯 ImageId to check:', imageId);
            
            // Regular gallery selection logic for classification mode
            const isSelected = this.selectedImages.includes(imageId);
            console.log('🎯 Is image already selected?', isSelected);
            
            if (isSelected) {
                console.log('🎯 DESELECTING image:', imageId);
                this.selectedImages = this.selectedImages.filter(id => id !== imageId);
                console.log('Deselected image:', imageId);
            } else {
                console.log('🎯 SELECTING image:', imageId);
                this.selectedImages.push(imageId);
                console.log('Selected image:', imageId);
            }
            
            console.log('Selected images after toggle:', this.selectedImages);
            console.log('🎯 Selection toggle completed');
            
            // Update visual feedback
            this.updateSourceGridSelectionMode();
            this.updateSelectionCounter();
            
            // CRITICAL: Update selection UI to show/hide Apply button
            this.updateSelectionUI();
            
            // Show current selection status
            const typeText = this.selectionType === 'front' ? 'mặt trước' : 'mặt sau';
            const currentTab = this.getCurrentActiveTab();
            
            if (this.selectedImages.length > 0) {
                // Auto-apply for duplex mode, manual apply for gallery mode
                if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                    this.showToast(`📌 Đã chọn ${this.selectedImages.length} ảnh làm ${typeText}. Click "❌ Thoát chế độ chọn" để hoàn tất!`, 'info');
                } else {
                    this.showToast(`📌 Đã chọn ${this.selectedImages.length} ảnh làm ${typeText}. Click "✅ Áp dụng lựa chọn" để hoàn tất!`, 'info');
                }
            } else {
                this.showToast(`🔄 Chế độ chọn ${typeText} - Click ảnh để chọn`, 'info');
            }
        }
        
        selectAllAs(type) {
            // Only work in classification mode
            if (!this.classificationMode) {
                this.showToast('⚠️ Chức năng này chỉ hoạt động trong chế độ phân loại!', 'error');
                return;
            }
            
            if (this.galleryImages.length === 0) {
                this.showToast('Không có ảnh nào để chọn', 'error');
                return;
            }
            
            const typeText = type === 'front' ? 'Mặt Trước' : 'Mặt Sau';
            const confirmAll = confirm(`Đặt tất cả ${this.galleryImages.length} ảnh làm ${typeText}?`);
            
            if (confirmAll) {
                // Apply to all images directly in classification system
                this.galleryImages.forEach(image => {
                    this.moveImageToClassification(image.id, type);
                });
                
                // Update classification UI
                this.updateClassificationDisplay();
                
                this.showToast(`✅ Đã đặt tất cả ${this.galleryImages.length} ảnh làm ${typeText}`, 'success');
            }
        }
        
        applySelection() {
            console.log('🔍 applySelection called');
            console.log('Selected images to apply:', this.selectedImages);
            console.log('Selection type:', this.selectionType);
            
            if (this.selectedImages.length === 0) return;
            
            const currentTab = this.getCurrentActiveTab();
            console.log('Current tab context:', currentTab);
            console.log('Print mode:', this.printData?.config?.printMode);
            
            // Apply selection to appropriate classification system
            this.selectedImages.forEach(imageId => {
                console.log('Moving image to classification:', imageId, this.selectionType);
                this.moveImageToClassification(imageId, this.selectionType);
            });
            
            // Update appropriate UI
            if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                // Update duplex UI
                console.log('Updating duplex UI');
                this.updateClassificationDisplay();
                this.updateDuplexPreview();
                this.updateDuplexStats();
            } else {
                // Update gallery UI
                console.log('Updating gallery UI');
                this.updateClassificationDisplay();
            }
            
            const typeText = this.selectionType === 'front' ? 'Mặt Trước' : 'Mặt Sau';
            this.showToast(`✅ Đã áp dụng ${this.selectedImages.length} ảnh làm ${typeText}`, 'success');
            
            console.log('✅ applySelection completed');
        }
        
        updateSelectionUI() {
            console.log('updateSelectionUI called');
            
            const selectionStatus = document.getElementById('selectionStatus');
            const selectionType = document.getElementById('selectionType');
            
            const quickSelectFrontBtn = document.getElementById('quickSelectFrontBtn');
            const quickSelectBackBtn = document.getElementById('quickSelectBackBtn');
            const applySelectionBtn = document.getElementById('applySelectionBtn');
            const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
            
            console.log('UI elements found:', {
                selectionStatus: !!selectionStatus,
                selectionType: !!selectionType,
                quickSelectFrontBtn: !!quickSelectFrontBtn,
                quickSelectBackBtn: !!quickSelectBackBtn,
                applySelectionBtn: !!applySelectionBtn,
                cancelSelectionBtn: !!cancelSelectionBtn
            });
            
            if (this.selectionMode) {
                // Show selection status
                if (selectionStatus) selectionStatus.style.display = 'flex';
                
                // Only show Apply button if there are selected images
                if (applySelectionBtn) {
                    applySelectionBtn.style.display = this.selectedImages.length > 0 ? 'inline-flex' : 'none';
                    console.log(`Apply button display: ${this.selectedImages.length > 0 ? 'show' : 'hide'} (${this.selectedImages.length} images selected)`);
                }
                
                if (cancelSelectionBtn) cancelSelectionBtn.style.display = 'inline-flex';
                
                // Update selection type text
                const typeText = this.selectionType === 'front' ? 'Mặt Trước' : 'Mặt Sau';
                if (selectionType) selectionType.textContent = typeText;
                
                // Update button states
                if (quickSelectFrontBtn) {
                    quickSelectFrontBtn.classList.toggle('active', this.selectionType === 'front');
                }
                if (quickSelectBackBtn) {
                    quickSelectBackBtn.classList.toggle('active', this.selectionType === 'back');
                }
                
                this.updateSelectionCounter();
            } else {
                // Hide selection controls
                if (selectionStatus) selectionStatus.style.display = 'none';
                if (applySelectionBtn) applySelectionBtn.style.display = 'none';
                if (cancelSelectionBtn) cancelSelectionBtn.style.display = 'none';
                
                // Reset button states
                if (quickSelectFrontBtn) quickSelectFrontBtn.classList.remove('active');
                if (quickSelectBackBtn) quickSelectBackBtn.classList.remove('active');
            }
        }
        
        updateSelectionCounter() {
            const selectionCounter = document.getElementById('selectionCounter');
            if (selectionCounter && this.selectionMode) {
                selectionCounter.textContent = `(${this.selectedImages.length} ảnh đã chọn)`;
            }
        }
        
        updateSourceGridSelectionMode() {
            console.log('🔍🔍🔍 updateSourceGridSelectionMode called', {
                selectionMode: this.selectionMode,
                selectionType: this.selectionType,
                selectedImages: this.selectedImages
            });
            
            if (this.selectionType === 'front') {
                console.log('🎯🎯🎯 FRONT SELECTION MODE - updateSourceGridSelectionMode');
            }
            
            const sourceGrid = document.getElementById('sourceGrid');
            if (!sourceGrid) {
                console.error('❌ Không tìm thấy sourceGrid');
                return;
            }
            
            console.log('✅ Đã tìm thấy sourceGrid:', sourceGrid);
            
            const galleryItems = sourceGrid.querySelectorAll('.gallery-item');
            console.log('✅ Tìm thấy các gallery items trong source grid:', galleryItems.length);
            
            galleryItems.forEach((item, index) => {
                const imageId = item.dataset.imageId;
                console.log(`🔄 Đang xử lý item ${index}:`, {
                    imageId,
                    hasSelectionCheckbox: !!item.querySelector('.selection-checkbox'),
                    currentClasses: item.className
                });
                
                if (this.selectionMode) {
                    // Add selection mode class
                    item.classList.add('selection-mode');
                    
                    // For duplex mode, check selection differently (objects vs IDs)
                    let isSelected = false;
                    if (this.printData?.config?.printMode === 'duplex') {
                        isSelected = this.selectedImages.some(img => 
                            (typeof img === 'object' ? img.id : img) == imageId
                        );
                    } else {
                        isSelected = this.selectedImages.includes(imageId);
                    }
                    console.log(`Item ${imageId} is selected:`, isSelected);
                    
                    if (isSelected) {
                        const selectionClass = this.selectionType === 'front' ? 'selected-front' : 'selected-back';
                        item.classList.add(selectionClass);
                        
                        // Remove other selection class
                        const otherClass = this.selectionType === 'front' ? 'selected-back' : 'selected-front';
                        item.classList.remove(otherClass);
                        
                        console.log(`Added class ${selectionClass} to item ${imageId}`);
                    } else {
                        item.classList.remove('selected-front', 'selected-back');
                    }
                    
                    console.log(`Item ${imageId} final classes:`, item.className);
                } else {
                    // Remove all selection classes
                    item.classList.remove('selection-mode', 'selected-front', 'selected-back');
                }
            });
        }

        enterClassificationMode() {
            console.log('🔍🔍🔍 enterClassificationMode called');
            
            this.classificationMode = true;
            this.frontImages = [];
            this.backImages = [];
            
            console.log('🔍 Classification mode state set:', {
                classificationMode: this.classificationMode,
                frontImages: this.frontImages,
                backImages: this.backImages
            });

            // Show classification UI
            const galleryGrid = document.getElementById('galleryGrid');
            const classificationMode = document.getElementById('classificationMode');
            const downloadOptions = document.getElementById('downloadOptions');
            
            console.log('🔍 UI elements found:', {
                galleryGrid: !!galleryGrid,
                classificationMode: !!classificationMode,
                downloadOptions: !!downloadOptions
            });
            
            if (galleryGrid) galleryGrid.style.display = 'none';
            if (classificationMode) classificationMode.style.display = 'block';
            if (downloadOptions) downloadOptions.style.display = 'block';

            // Populate source grid
            console.log('🔍 Calling updateSourceGrid from enterClassificationMode...');
            this.updateSourceGrid();
            console.log('🔍 Calling updateClassificationPanels from enterClassificationMode...');
            this.updateClassificationPanels();
            console.log('🔍 Calling updateDownloadButtons from enterClassificationMode...');
            this.updateDownloadButtons();
            
            console.log('✅ enterClassificationMode completed');
        }

        // Auto-classify images based on filename patterns
        autoClassifyByFilename() {
            console.log('🤖 Starting auto-classification by filename...');

            if (!this.galleryImages || this.galleryImages.length === 0) {
                this.showToast('❌ Không có ảnh nào để phân loại!', 'warning');
                return;
            }

            // Enter classification mode if not already active
            if (!this.classificationMode) {
                this.enterClassificationMode();
            }

            let frontCount = 0;
            let backCount = 0;
            let unclassified = 0;

            // Reset arrays
            this.frontImages = [];
            this.backImages = [];

            // Process each image
            this.galleryImages.forEach(image => {
                const filename = image.originalName || image.name || '';
                const classification = this.detectFilenamePattern(filename);

                console.log(`📋 File: ${filename} -> ${classification}`);

                if (classification === 'front') {
                    this.frontImages.push(image);
                    frontCount++;
                } else if (classification === 'back') {
                    this.backImages.push(image);
                    backCount++;
                } else {
                    unclassified++;
                }
            });

            // Update UI
            this.updateClassificationPanels();
            this.updateDownloadButtons();

            // Show results
            const message = `🤖 Phân loại tự động hoàn thành:
                📂 Mặt trước: ${frontCount} ảnh
                📂 Mặt sau: ${backCount} ảnh
                ❓ Không nhận diện: ${unclassified} ảnh`;
            
            this.showToast(message, 'success', 4000);
            
            console.log('✅ Auto-classification completed', {
                front: frontCount,
                back: backCount,
                unclassified: unclassified
            });
        }

        // Detect filename pattern for front/back classification
        detectFilenamePattern(filename) {
            if (!filename) return 'unknown';
            
            const lowerName = filename.toLowerCase();
            
            // Front patterns (mặt trước, front, truoc, mat truoc, etc.)
            const frontPatterns = [
                /mặt\s*trước/i,
                /mat\s*truoc/i,
                /front/i,
                /truoc/i,
                /phải/i,
                /phai/i,
                /trước/i,
                /_mt_/i,        // _mt_ abbreviation
                /_front_/i,     // _front_
                /_f_/i,         // _f_
                /\bmặt\s*1\b/i, // mặt 1
                /\bmat\s*1\b/i  // mat 1
            ];

            // Back patterns (mặt sau, back, sau, mat sau, etc.)  
            const backPatterns = [
                /mặt\s*sau/i,
                /mat\s*sau/i,
                /back/i,
                /sau/i,
                /trái/i,
                /trai/i,
                /_ms_/i,        // _ms_ abbreviation
                /_back_/i,      // _back_
                /_b_/i,         // _b_
                /\bmặt\s*2\b/i, // mặt 2
                /\bmat\s*2\b/i  // mat 2
            ];

            // Check front patterns
            for (const pattern of frontPatterns) {
                if (pattern.test(lowerName)) {
                    return 'front';
                }
            }

            // Check back patterns
            for (const pattern of backPatterns) {
                if (pattern.test(lowerName)) {
                    return 'back';
                }
            }

            return 'unknown';
        }

        exitClassificationMode() {
            this.classificationMode = false;

            // Hide classification UI
            document.getElementById('galleryGrid').style.display = 'grid';
            document.getElementById('classificationMode').style.display = 'none';
            document.getElementById('downloadOptions').style.display = 'none';
        }

        updateSourceGrid() {
            console.log('🔍 updateSourceGrid called');
            const sourceGrid = document.getElementById('sourceGrid');
            if (!sourceGrid) {
                console.error('🔍 sourceGrid element not found!');
                return;
            }

            console.log('🔍 Clearing sourceGrid, galleryImages count:', this.galleryImages?.length);
            sourceGrid.innerHTML = '';
            
            // Clear existing listeners by getting a fresh reference
            const newSourceGrid = sourceGrid;
            
            newSourceGrid.addEventListener('click', (e) => {
                console.log('SourceGrid clicked, target:', e.target.className, 'tagName:', e.target.tagName);
                if (this.selectionMode) {
                    const galleryItem = e.target.closest('.gallery-item');
                    if (galleryItem) {
                        const imageId = galleryItem.dataset.imageId;
                        console.log('Event delegation click:', imageId);
                        this.handleSourceGridItemSelection(e, imageId);
                    } else {
                        console.log('No gallery item found for target:', e.target);
                    }
                } else {
                    console.log('Not in selection mode:', {
                        selectionMode: this.selectionMode
                    });
                }
            }, true); // Use capture phase

            console.log('🔍 Creating gallery items for sourceGrid...');
            this.galleryImages.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'gallery-item';
                itemEl.draggable = true;
                itemEl.dataset.imageId = item.id;
                itemEl.dataset.index = index;

                itemEl.innerHTML = `
                    <img src="${item.data}" alt="${item.filename}" class="gallery-item-image">
                    <div class="selection-checkbox">✓</div>
                    <div class="gallery-item-info">
                        <div class="gallery-item-name">${item.filename}</div>
                    </div>
                    <!-- Rotation & Duplicate Controls -->
                    <div class="classification-hover-actions">
                        <button class="classification-action-btn rotation-action" onclick="converter.rotateImage('${item.id}', 90)" title="Xoay 90°">
                            <span class="action-icon">🔄</span>
                            <span class="action-text">90°</span>
                        </button>
                        <button class="classification-action-btn rotation-action" onclick="converter.rotateImage('${item.id}', 180)" title="Xoay 180°">
                            <span class="action-icon">↻</span>
                            <span class="action-text">180°</span>
                        </button>
                        <button class="classification-action-btn rotation-action" onclick="converter.rotateImage('${item.id}', 270)" title="Xoay 270°">
                            <span class="action-icon">↺</span>
                            <span class="action-text">270°</span>
                        </button>
                        <button class="classification-action-btn duplicate-action" onclick="converter.duplicateImage('${item.id}')" title="Nhân bản ảnh">
                            <span class="action-icon">⧉</span>
                            <span class="action-text">Nhân bản</span>
                        </button>
                    </div>
                `;

                // Note: Removed direct listener to avoid conflicts - using event delegation only

                newSourceGrid.appendChild(itemEl);
                console.log(`🔍 Added item ${index + 1}/${this.galleryImages.length}: ${item.filename}`);
                
                // Debug: Check if hover actions were added
                const hoverActions = itemEl.querySelector('.classification-hover-actions');
                if (hoverActions) {
                    console.log(`✅ Hover actions added to ${item.filename}:`, hoverActions.innerHTML);
                } else {
                    console.log(`❌ No hover actions found for ${item.filename}`);
                }
            });
            
            console.log('🔍 updateSourceGrid completed, total items added:', this.galleryImages.length);
        }

        setupClassificationDragDrop() {
            const dropZones = ['frontDropZone', 'backDropZone'];
            
            dropZones.forEach(zoneId => {
                const zone = document.getElementById(zoneId);
                if (zone) {
                    zone.addEventListener('dragover', (e) => this.handleDropZoneDragOver(e));
                    zone.addEventListener('dragleave', (e) => this.handleDropZoneDragLeave(e));
                    zone.addEventListener('drop', (e) => this.handleDropZoneDrop(e));
                }
            });
        }

        handleGalleryDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.imageId);
        }

        handleGalleryDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        handleClassificationDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.imageId);
            e.dataTransfer.setData('source', 'gallery');
        }

        handleClassificationDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        handleDropZoneDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        handleDropZoneDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        handleDropZoneDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const imageId = e.dataTransfer.getData('text/plain');
            const dropType = e.currentTarget.dataset.type;
            const source = e.dataTransfer.getData('source');
            
            console.log('Drop event:', { imageId, dropType, source });

            // Try both source types
            if (source === 'gallery' || imageId) {
                this.moveImageToClassification(imageId, dropType);
            }
        }

        moveImageToClassification(imageId, type) {
            console.log('Moving image:', { imageId, type });
            console.log('Current context:', {
                activeTab: this.getCurrentActiveTab(),
                classificationMode: this.classificationMode,
                printMode: this.printData?.config?.printMode
            });
            console.log('Available gallery images:', this.galleryImages.map(img => ({ id: img.id, filename: img.filename })));
            
            // Try to find image by ID first, then by data (base64) if ID doesn't work
            let image = this.galleryImages.find(img => img.id == imageId);
            
            if (!image && typeof imageId === 'string' && imageId.startsWith('data:')) {
                // If imageId is base64 data, find by data instead
                console.log('ImageId appears to be base64 data, searching by data field');
                image = this.galleryImages.find(img => img.data === imageId);
            }
            
            console.log('Found image:', image);
            if (!image) {
                console.error('Image not found in gallery. ImageId:', imageId?.substring(0, 50) + '...', 'Type:', typeof imageId);
                console.error('Available IDs:', this.galleryImages.map(img => `${img.id} (${typeof img.id})`));
                console.error('Searching by data failed as well');
                return;
            }

            // Determine which classification system to use based on context
            const currentTab = this.getCurrentActiveTab();
            let targetArray;
            
            if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                // Duplex classification in Print tab
                console.log('Using duplex classification system');
                if (!this.printData.frontImages) this.printData.frontImages = [];
                if (!this.printData.backImages) this.printData.backImages = [];
                targetArray = type === 'front' ? this.printData.frontImages : this.printData.backImages;
            } else {
                // Regular classification in Gallery tab
                console.log('Using gallery classification system');
                if (!this.frontImages) this.frontImages = [];
                if (!this.backImages) this.backImages = [];
                targetArray = type === 'front' ? this.frontImages : this.backImages;
            }
            // Check if already classified in the appropriate system
            let alreadyInFront, alreadyInBack;
            
            if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                // Check duplex classification
                alreadyInFront = this.printData.frontImages?.find(img => img.id == imageId);
                alreadyInBack = this.printData.backImages?.find(img => img.id == imageId);
            } else {
                // Check gallery classification
                alreadyInFront = this.frontImages?.find(img => img.id == imageId);
                alreadyInBack = this.backImages?.find(img => img.id == imageId);
            }
            
            // Remove from previous classification in the appropriate system
            if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                if (alreadyInFront) {
                    this.printData.frontImages = this.printData.frontImages.filter(img => img.id != imageId);
                }
                if (alreadyInBack) {
                    this.printData.backImages = this.printData.backImages.filter(img => img.id != imageId);
                }
            } else {
                if (alreadyInFront) {
                    this.frontImages = this.frontImages.filter(img => img.id != imageId);
                }
                if (alreadyInBack) {
                    this.backImages = this.backImages.filter(img => img.id != imageId);
                }
            }

            // Add to target array
            targetArray.push({...image});
            console.log('Added to', type, 'array. Length now:', targetArray.length);
            
            // Update appropriate UI based on context
            if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                // Update duplex UI
                this.updateClassificationDisplay();
                this.updateDuplexPreview();
                this.updateDuplexStats();
            } else {
                // Update gallery UI
                this.updateClassificationPanels();
                this.updateDownloadButtons();
                this.updateRenamePatterns();
            }
        }

        updateClassificationPanels() {
            this.updatePanel('frontDropZone', this.frontImages, 'front');
            this.updatePanel('backDropZone', this.backImages, 'back');
        }
        
        updateClassificationDisplay() {
            // Update both panels and source grid
            this.updateClassificationPanels();
            this.updateSourceGrid();
            
            // Update download button states
            this.updateDownloadButtons();
        }

        updatePanel(zoneId, images, type) {
            const zone = document.getElementById(zoneId);
            if (!zone) return;

            zone.innerHTML = '';
            
            if (images.length === 0) {
                zone.classList.add('empty');
                zone.innerHTML = '<div class="drop-hint">Kéo ảnh vào đây</div>';
                return;
            }

            zone.classList.remove('empty');
            
            // Re-sort images by their order (in case of reordering)
            const sortedImages = [...images];
            
            sortedImages.forEach((image, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'classified-item';
                itemEl.dataset.imageId = image.id;
                itemEl.dataset.index = index;
                itemEl.dataset.type = type;

                const newName = this.generateNewName(type, index);
                
                itemEl.innerHTML = `
                    <img src="${image.data}" alt="${newName}" class="classified-item-image">
                    <div class="classified-item-controls">
                        <button class="item-control-btn" onclick="converter.moveClassifiedImageUp('${image.id}', '${type}')" title="Lên trên">↑</button>
                        <button class="item-control-btn" onclick="converter.moveClassifiedImageDown('${image.id}', '${type}')" title="Xuống dưới">↓</button>
                        <button class="item-control-btn" onclick="converter.duplicateClassifiedImage('${image.id}', '${type}')" title="Nhân bản">⧉</button>
                        <button class="item-control-btn" onclick="converter.removeClassifiedImage('${image.id}', '${type}')" title="Xóa">×</button>
                    </div>
                    <div class="classified-item-name">${newName}</div>
                `;

                zone.appendChild(itemEl);
            });
            
            console.log(`Updated ${type} panel with ${sortedImages.length} images`);
        }

        generateNewName(type, index) {
            const prefix = type === 'front' 
                ? document.getElementById('frontPrefix')?.value || ''
                : document.getElementById('backPrefix')?.value || '';
            const suffix = type === 'front' ? 'a' : 'b';
            const number = index + 1;
            
            return `${prefix}${number}${suffix}.jpg`;
        }

        removeClassifiedImage(imageId, type) {
            if (type === 'front') {
                this.frontImages = this.frontImages.filter(img => img.id != imageId);
            } else {
                this.backImages = this.backImages.filter(img => img.id != imageId);
            }
            
            this.updateClassificationPanels();
            this.updateDownloadButtons();
            this.updateRenamePatterns();
        }

        duplicateClassifiedImage(imageId, type) {
            const sourceArray = type === 'front' ? this.frontImages : this.backImages;
            const imageIndex = sourceArray.findIndex(img => img.id == imageId);
            
            if (imageIndex !== -1) {
                const image = sourceArray[imageIndex];
                const duplicate = {
                    ...image,
                    id: Date.now() + Math.random()
                };
                // Insert right after the original
                sourceArray.splice(imageIndex + 1, 0, duplicate);
                
                this.updateClassificationPanels();
                this.updateDownloadButtons();
                this.updateRenamePatterns();
                
                const newName = this.generateNewName(type, imageIndex + 1);
                this.showToast(`Đã nhân bản ảnh với tên: ${newName}`);
            }
        }

        moveClassifiedImageUp(imageId, type) {
            const sourceArray = type === 'front' ? this.frontImages : this.backImages;
            const imageIndex = sourceArray.findIndex(img => img.id == imageId);
            
            if (imageIndex > 0) {
                // Swap with previous item
                [sourceArray[imageIndex - 1], sourceArray[imageIndex]] = 
                [sourceArray[imageIndex], sourceArray[imageIndex - 1]];
                
                this.updateClassificationPanels();
                this.updateDownloadButtons();
                this.updateRenamePatterns();
                
                const newName = this.generateNewName(type, imageIndex - 1);
                this.showToast(`Đã chuyển ảnh lên vị trí: ${newName}`);
            }
        }

        moveClassifiedImageDown(imageId, type) {
            const sourceArray = type === 'front' ? this.frontImages : this.backImages;
            const imageIndex = sourceArray.findIndex(img => img.id == imageId);
            
            if (imageIndex < sourceArray.length - 1 && imageIndex !== -1) {
                // Swap with next item
                [sourceArray[imageIndex], sourceArray[imageIndex + 1]] = 
                [sourceArray[imageIndex + 1], sourceArray[imageIndex]];
                
                this.updateClassificationPanels();
                this.updateDownloadButtons();
                this.updateRenamePatterns();
                
                const newName = this.generateNewName(type, imageIndex + 1);
                this.showToast(`Đã chuyển ảnh xuống vị trí: ${newName}`);
            }
        }

        updateRenamePatterns() {
            const frontPattern = document.querySelector('#frontPrefix').closest('.panel-controls').querySelector('.rename-pattern');
            const backPattern = document.querySelector('#backPrefix').closest('.panel-controls').querySelector('.rename-pattern');
            
            const frontPrefix = document.getElementById('frontPrefix')?.value || '';
            const backPrefix = document.getElementById('backPrefix')?.value || '';
            
            if (frontPattern) {
                frontPattern.textContent = `${frontPrefix}1a, ${frontPrefix}2a, ${frontPrefix}3a...`;
            }
            if (backPattern) {
                backPattern.textContent = `${backPrefix}1b, ${backPrefix}2b, ${backPrefix}3b...`;
            }
        }

        updateDownloadButtons() {
            const hasFront = this.frontImages.length > 0;
            const hasBack = this.backImages.length > 0;
            const hasAny = hasFront || hasBack;
            const totalCount = this.frontImages.length + this.backImages.length;
            
            // Update legacy buttons (for backward compatibility)
            const downloadFrontBtn = document.getElementById('downloadFrontBtn');
            const downloadBackBtn = document.getElementById('downloadBackBtn');
            const downloadZipFrontBtn = document.getElementById('downloadZipFrontBtn');
            const downloadZipBackBtn = document.getElementById('downloadZipBackBtn');
            const previewDownloadBtn = document.getElementById('previewDownloadBtn');
            
            if (downloadFrontBtn) downloadFrontBtn.disabled = !hasFront;
            if (downloadBackBtn) downloadBackBtn.disabled = !hasBack;
            if (downloadZipFrontBtn) downloadZipFrontBtn.disabled = !hasFront;
            if (downloadZipBackBtn) downloadZipBackBtn.disabled = !hasBack;
            if (previewDownloadBtn) previewDownloadBtn.disabled = !hasAny;
            
            // Update new individual download buttons
            const downloadFrontIndividualBtn = document.getElementById('downloadFrontIndividualBtn');
            const downloadBackIndividualBtn = document.getElementById('downloadBackIndividualBtn');
            const downloadAllIndividualBtn = document.getElementById('downloadAllIndividualBtn');
            
            if (downloadFrontIndividualBtn) {
                downloadFrontIndividualBtn.disabled = !hasFront;
            }
            if (downloadBackIndividualBtn) {
                downloadBackIndividualBtn.disabled = !hasBack;
            }
            if (downloadAllIndividualBtn) {
                downloadAllIndividualBtn.disabled = !hasAny;
            }
            
            // Update new ZIP download buttons
            const downloadZipAllBtn = document.getElementById('downloadZipAllBtn');
            if (downloadZipAllBtn) {
                downloadZipAllBtn.disabled = !hasAny;
            }
            
            // Update count displays
            const frontCount = document.getElementById('frontCount');
            const backCount = document.getElementById('backCount');
            const allCount = document.getElementById('allCount');
            const frontZipCount = document.getElementById('frontZipCount');
            const backZipCount = document.getElementById('backZipCount');
            const allZipCount = document.getElementById('allZipCount');
            
            if (frontCount) frontCount.textContent = `${this.frontImages.length} file`;
            if (backCount) backCount.textContent = `${this.backImages.length} file`;
            if (allCount) allCount.textContent = `${totalCount} file`;
            if (frontZipCount) frontZipCount.textContent = `${this.frontImages.length} file`;
            if (backZipCount) backZipCount.textContent = `${this.backImages.length} file`;
            if (allZipCount) allZipCount.textContent = `${totalCount} file`;
        }

        showDownloadPreview() {
            const allFiles = [];
            
            this.frontImages.forEach((image, index) => {
                allFiles.push({
                    name: this.generateNewName('front', index),
                    type: 'Mặt trước',
                    data: image.data
                });
            });
            
            this.backImages.forEach((image, index) => {
                allFiles.push({
                    name: this.generateNewName('back', index),
                    type: 'Mặt sau',
                    data: image.data
                });
            });
            
            if (allFiles.length === 0) {
                this.showToast('Chưa có file nào để tải xuống', 'error');
                return;
            }
            
            // Create and show preview modal
            this.showFileListPreview(allFiles);
        }

        showFileListPreview(files) {
            const modal = document.createElement('div');
            modal.className = 'preview-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 24px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            content.innerHTML = `
                <h3 style="margin: 0 0 16px 0;">Danh sách file sẽ tải xuống</h3>
                <div style="margin-bottom: 16px;">
                    <strong>Tổng cộng: ${files.length} file</strong>
                </div>
                <div style="max-height: 400px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 6px;">
                    ${files.map(file => `
                        <div style="padding: 8px 12px; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between;">
                            <span>${file.name}</span>
                            <span style="color: #6b7280; font-size: 0.85rem;">${file.type}</span>
                        </div>
                    `).join('')}
                </div>
                <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
                    <button id="previewCancelBtn" style="padding: 8px 16px; border: 2px solid #d1d5db; background: #f8fafc; border-radius: 4px; cursor: pointer; transition: all 0.2s ease;">Hủy</button>
                    <button id="previewDownloadConfirmBtn" style="padding: 8px 16px; border: none; background: var(--primary-blue); color: white; border-radius: 4px; cursor: pointer;">Tải xuống</button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Event listeners
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            document.getElementById('previewCancelBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            document.getElementById('previewDownloadConfirmBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
                this.downloadClassifiedImages();
            });
        }

        async downloadClassifiedImages() {
            const files = [];
            
            // Prepare front images
            this.frontImages.forEach((image, index) => {
                files.push({
                    filename: this.generateNewName('front', index),
                    data: image.data
                });
            });
            
            // Prepare back images
            this.backImages.forEach((image, index) => {
                files.push({
                    filename: this.generateNewName('back', index),
                    data: image.data
                });
            });
            
            try {
                const zipBlob = await this.createSafeZip(
                    files,
                    `classified-images-${new Date().toISOString().slice(0, 10)}.zip`,
                    'Safe classified images archive - Created by MEU Layout'
                );
                
                this.downloadSafeZip(
                    zipBlob,
                    `classified-images-${new Date().toISOString().slice(0, 10)}.zip`
                );
                
                this.showToast('Đã tải xuống file ZIP thành công!');
            } catch (error) {
                console.error('Error creating safe ZIP:', error);
                this.showToast('Lỗi khi tạo file ZIP: ' + error.message, 'error');
            }
        }


        // Convert image to high quality JPG with 300 DPI
        async convertToHighQualityJPG(imageData, originalFilename) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    // Create canvas with high resolution
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Calculate dimensions for 300 DPI (assuming original is 72 DPI)
                    const dpiScale = 300 / 72; // 4.167x scale for 300 DPI
                    canvas.width = img.naturalWidth * dpiScale;
                    canvas.height = img.naturalHeight * dpiScale;
                    
                    // Enable high quality rendering
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // Draw image at high resolution
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    // Convert to high quality JPG blob
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Failed to create high quality JPG blob'));
                        }
                    }, 'image/jpeg', 1.0); // Maximum quality for printing
                };
                
                img.onerror = () => {
                    reject(new Error('Failed to load image for conversion'));
                };
                
                img.src = imageData;
            });
        }

        // Ensure filename has JPG extension
        ensureJPGExtension(filename) {
            const extension = filename.toLowerCase().split('.').pop();
            if (extension === 'jpg' || extension === 'jpeg') {
                return filename;
            }
            
            // Replace extension with .jpg
            const nameWithoutExt = filename.substring(0, filename.lastIndexOf('.')) || filename;
            return `${nameWithoutExt}.jpg`;
        }

        async downloadAllImages() {
            if (this.galleryImages.length === 0) {
                this.showToast('Không có ảnh để tải xuống', 'error');
                return;
            }
            
            // Fast batch download for gallery images
            const batchSize = 6; // Browser parallel limit
            
            for (let i = 0; i < this.galleryImages.length; i += batchSize) {
                const batch = this.galleryImages.slice(i, i + batchSize);
                
                batch.forEach((image, indexInBatch) => {
                    setTimeout(() => {
                        const link = document.createElement('a');
                        link.href = image.data;
                        link.download = image.filename;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }, indexInBatch * 30); // 30ms between files in batch
                });
                
                // Small delay between batches
                if (i + batchSize < this.galleryImages.length) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }
            
            this.showToast('Đã bắt đầu tải xuống tất cả ảnh!');
        }

        async downloadAllImagesZip() {
            if (this.galleryImages.length === 0) {
                this.showToast('Không có ảnh để tải xuống', 'error');
                return;
            }
            
            const files = this.galleryImages.map(image => ({
                filename: image.filename,
                data: image.data
            }));
            
            try {
                const zipBlob = await this.createSafeZip(
                    files,
                    `all-gallery-images-${new Date().toISOString().slice(0, 10)}.zip`,
                    'Safe gallery images archive - Created by MEU Layout'
                );
                
                this.downloadSafeZip(
                    zipBlob,
                    `all-gallery-images-${new Date().toISOString().slice(0, 10)}.zip`
                );
                
                this.showToast('Đã tải xuống file ZIP thành công!');
            } catch (error) {
                console.error('Error creating safe ZIP:', error);
                this.showToast('Lỗi khi tạo file ZIP: ' + error.message, 'error');
            }
        }

        async downloadFrontImages() {
            this.downloadImageArray(this.frontImages, 'front');
        }

        async downloadBackImages() {
            this.downloadImageArray(this.backImages, 'back');
        }

        // High-quality individual downloads for classified images
        async downloadFrontImagesIndividual() {
            await this.downloadClassifiedImagesIndividual(this.frontImages, 'front');
        }

        async downloadBackImagesIndividual() {
            await this.downloadClassifiedImagesIndividual(this.backImages, 'back');
        }

        async downloadAllClassifiedImagesIndividual() {
            const allImages = [...this.frontImages, ...this.backImages];
            await this.downloadClassifiedImagesIndividual(allImages, 'all');
        }

        async downloadClassifiedImagesIndividual(images, type) {
            if (images.length === 0) {
                const typeLabel = type === 'front' ? 'mặt trước' : (type === 'back' ? 'mặt sau' : 'đã phân loại');
                this.showToast(`Không có ảnh ${typeLabel} để tải xuống`, 'error');
                return;
            }

            const btnId = type === 'front' ? 'downloadFrontIndividualBtn' : 
                         (type === 'back' ? 'downloadBackIndividualBtn' : 'downloadAllIndividualBtn');
            const btn = document.getElementById(btnId);
            
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = `
                    <span class="btn-label">Đang tải...</span>
                    <span class="btn-count">⏳</span>
                `;
            }

            try {
                const typeLabel = type === 'front' ? 'mặt trước' : (type === 'back' ? 'mặt sau' : 'tất cả');
                this.showToast(`Bắt đầu tải ${images.length} ảnh ${typeLabel} (300 DPI, JPG)...`, 'success');

                for (let i = 0; i < images.length; i++) {
                    const image = images[i];
                    
                    try {
                        // Convert to high quality JPG with 300 DPI
                        const highQualityBlob = await this.convertToHighQualityJPG(image.data);
                        
                        // Generate filename based on classification with proper pattern
                        let filename;
                        if (type === 'all') {
                            // For "all", determine if image belongs to front or back and generate accordingly  
                            const frontIndex = this.frontImages.findIndex(img => img.id === image.id);
                            const backIndex = this.backImages.findIndex(img => img.id === image.id);
                            
                            if (frontIndex !== -1) {
                                filename = this.generateNewName('front', frontIndex);
                            } else if (backIndex !== -1) {
                                filename = this.generateNewName('back', backIndex);
                            } else {
                                filename = image.filename; // fallback
                            }
                        } else {
                            // For specific type (front/back), use proper index
                            const imageIndex = images.findIndex(img => img.id === image.id);
                            filename = this.generateNewName(type, imageIndex);
                        }
                        const jpgFilename = this.ensureJPGExtension(filename);
                        
                        console.log(`Processing ${type} image ${i + 1}: ${jpgFilename}`);
                        
                        // Create download
                        const url = URL.createObjectURL(highQualityBlob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = jpgFilename;
                        link.style.display = 'none';
                        
                        document.body.appendChild(link);
                        
                        // Staggered download with delay
                        setTimeout(() => {
                            link.click();
                            setTimeout(() => {
                                document.body.removeChild(link);
                                URL.revokeObjectURL(url);
                            }, 100);
                        }, i * 800);
                        
                    } catch (error) {
                        console.error(`Error processing image ${i + 1}:`, error);
                        continue;
                    }
                }
                
                setTimeout(() => {
                    this.showToast(`✅ Đã bắt đầu tải ${images.length} file ${typeLabel} JPG (300 DPI)!`, 'success');
                }, 1000);

            } catch (error) {
                console.error(`Error in download${type}ImagesIndividual:`, error);
                this.showToast('Lỗi khi tải file!', 'error');
            } finally {
                setTimeout(() => {
                    if (btn) {
                        btn.disabled = false;
                        const typeLabel = type === 'front' ? 'Mặt trước' : (type === 'back' ? 'Mặt sau' : 'Tất cả');
                        const count = `${images.length} file`;
                        btn.innerHTML = `
                            <span class="btn-label">${typeLabel}</span>
                            <span class="btn-count">${count}</span>
                        `;
                    }
                }, images.length * 800 + 2000);
            }
        }

        downloadImageArray(images, type) {
            if (images.length === 0) {
                this.showToast(`Không có ảnh ${type === 'front' ? 'mặt trước' : 'mặt sau'} để tải xuống`, 'error');
                return;
            }
            
            images.forEach((image, index) => {
                const filename = this.generateNewName(type, index);
                const link = document.createElement('a');
                link.href = image.data;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
            
            this.showToast(`Đã bắt đầu tải xuống ${images.length} ảnh ${type === 'front' ? 'mặt trước' : 'mặt sau'}!`);
        }

        async downloadFrontImagesZip() {
            await this.downloadImageArrayZip(this.frontImages, 'front');
        }

        async downloadBackImagesZip() {
            await this.downloadImageArrayZip(this.backImages, 'back');
        }

        async downloadImageArrayZip(images, type) {
            if (images.length === 0) {
                this.showToast(`Không có ảnh ${type === 'front' ? 'mặt trước' : 'mặt sau'} để tải xuống`, 'error');
                return;
            }
            
            const files = images.map((image, index) => ({
                filename: this.generateNewName(type, index),
                data: image.data
            }));
            
            const typeLabel = type === 'front' ? 'mặt trước' : 'mặt sau';
            
            try {
                const zipBlob = await this.createSafeZip(
                    files,
                    `${type}-images-${new Date().toISOString().slice(0, 10)}.zip`,
                    `Safe ${typeLabel} images archive - Created by MEU Layout`
                );
                
                this.downloadSafeZip(
                    zipBlob,
                    `${type}-images-${new Date().toISOString().slice(0, 10)}.zip`
                );
                
                this.showToast(`Đã tải xuống file ZIP ${typeLabel} thành công!`);
            } catch (error) {
                console.error('Error creating safe ZIP:', error);
                this.showToast('Lỗi khi tạo file ZIP: ' + error.message, 'error');
            }
        }

        // Image Action Modal Methods
        showImageActionModal(imageId) {
            this.selectedImageForAction = imageId;
            const image = this.galleryImages.find(img => img.id == imageId);
            if (!image) return;

            const modal = document.getElementById('imageActionModal');
            const preview = document.getElementById('selectedImagePreview');
            const name = document.getElementById('selectedImageName');

            if (preview) preview.src = image.data;
            if (name) name.textContent = image.filename;
            if (modal) modal.style.display = 'flex';
        }

        hideImageActionModal() {
            const modal = document.getElementById('imageActionModal');
            if (modal) modal.style.display = 'none';
            this.selectedImageForAction = null;
        }

        // Direct classification without modal (new hover method)
        addImageToClassificationDirect(imageId, type) {
            this.moveImageToClassification(imageId, type);
            
            // Show success message with new position
            const targetArray = type === 'front' ? this.frontImages : this.backImages;
            const position = targetArray.length;
            const newName = this.generateNewName(type, position - 1);
            this.showToast(`✅ Đã thêm vào ${type === 'front' ? 'mặt trước' : 'mặt sau'}: ${newName}`, 'success');
        }

        // Legacy modal method (kept for compatibility)
        addImageToClassification(type) {
            if (!this.selectedImageForAction) return;
            
            this.moveImageToClassification(this.selectedImageForAction, type);
            this.hideImageActionModal();
            
            // Show success message with new position
            const targetArray = type === 'front' ? this.frontImages : this.backImages;
            const position = targetArray.length;
            const newName = this.generateNewName(type, position - 1);
            
            this.showToast(`Đã thêm ảnh vào ${type === 'front' ? 'mặt trước' : 'mặt sau'} với tên: ${newName}`);
        }

        // Print functionality methods
        initializePrintSection() {
            this.printData = {
                selectedImages: [],
                frontImages: {},     // { pageIndex: { slotIndex: imageData } }
                backImages: {},      // { pageIndex: { slotIndex: imageData } }
                currentPage: 0,
                currentSide: 'front', // 'front' or 'back'
                totalPages: 0,
                masterCanvas: null,  // Master Canvas for WYSIWYG
                previewCanvas: null, // Scaled preview canvas
                context: null,
                config: {
                    paperSize: { width: 210, height: 297 }, // A4 in mm
                    photoSize: { width: 5.5, height: 8.5 }, // in cm
                    margins: { top: 10, bottom: 10, left: 10, right: 10 }, // in mm
                    gutter: { x: 5, y: 5 }, // in mm
                    dpi: 300,
                    orientation: 'portrait',
                    fitMode: 'fill',
                    printMode: 'single', // 'single' or 'duplex'
                    duplexFlip: 'long-edge', // 'long-edge' or 'short-edge'
                    cuttingGuides: {
                        outerCuttingLines: true,
                        betweenImages: true,
                        cornerMarks: true,
                        gridHelperLines: false,
                        color: '#000000',
                        thickness: 0.5,
                        lineStyle: 'solid'
                    }
                }
            };

            this.setupPrintEventListeners();
            this.setupCuttingGuidesListeners();
            this.setupPreviewControls();
            this.setupDuplexControls();
            this.calculateLayout();
            
            // Ensure gallery images (kho ảnh) are displayed in print section
            this.updateSourceGrid();
        }

        setupPrintEventListeners() {
            // Setup new compact interface event listeners
            this.setupCompactInterface();
            
            // Paper size selection (Legacy support)
            document.querySelectorAll('.size-preset').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.size-preset').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const size = btn.dataset.size;
                    this.selectPaperSize(size);
                });
            });

            // Photo size selection (Legacy support)
            document.querySelectorAll('.photo-preset').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.photo-preset').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const size = btn.dataset.size;
                    this.selectPhotoSize(size);
                });
            });

            // Orientation selection (Legacy support)
            document.querySelectorAll('.orientation-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.orientation-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const orientation = btn.dataset.orientation;
                    this.printData.config.orientation = orientation;
                    this.calculateLayout();
                });
            });

            // DPI is fixed at 300 for professional printing quality

            // Fit mode selection
            document.querySelectorAll('.fit-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.fit-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const fit = btn.dataset.fit;
                    this.printData.config.fitMode = fit;
                    this.updatePreview();
                });
            });

            // File input
            const printFileInput = document.getElementById('printFileInput');
            if (printFileInput) {
                printFileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handlePrintImages(e.target.files);
                        e.target.value = ''; // Clear để tránh duplicate
                    }
                });
            }

            // Use gallery images button
            const useGalleryBtn = document.getElementById('useGalleryImagesBtn');
            if (useGalleryBtn) {
                useGalleryBtn.addEventListener('click', () => this.useGalleryImages());
            }

            // Clear selected button
            const clearSelectedBtn = document.getElementById('clearSelectedBtn');
            if (clearSelectedBtn) {
                clearSelectedBtn.addEventListener('click', () => this.clearSelectedImages());
            }

            // Preview navigation
            const prevPageBtn = document.getElementById('prevPageBtn');
            const nextPageBtn = document.getElementById('nextPageBtn');
            if (prevPageBtn) {
                prevPageBtn.addEventListener('click', () => this.showPreviousPage());
            }
            if (nextPageBtn) {
                nextPageBtn.addEventListener('click', () => this.showNextPage());
            }

            // Export buttons
            const generatePrintBtn = document.getElementById('generatePrintBtn');
            if (generatePrintBtn) {
                generatePrintBtn.addEventListener('click', () => this.generatePrintFiles());
            }
            
            const generatePrintBtnNew = document.getElementById('generatePrintBtnNew');
            if (generatePrintBtnNew) {
                generatePrintBtnNew.addEventListener('click', () => this.generatePrintFiles());
            }

            // Input change listeners for real-time updates
            const inputs = [
                'paperWidth', 'paperHeight', 'photoWidth', 'photoHeight',
                'marginTop', 'marginBottom', 'marginLeft', 'marginRight',
                'gutterX', 'gutterY'
            ];
            
            inputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('input', () => {
                        console.log(`🔧 Input changed: ${id} = ${input.value}`);
                        this.updateConfigFromInputs();
                    });
                } else {
                    console.error(`❌ Input not found: ${id}`);
                }
            });
        }

        setupCompactInterface() {
            // Setup preset cards
            document.querySelectorAll('.preset-card').forEach(card => {
                card.addEventListener('click', () => {
                    document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    
                    const preset = card.dataset.preset;
                    this.applyPreset(preset);
                });
            });

            // Setup card toggles
            document.querySelectorAll('.card-toggle').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const targetId = toggle.dataset.target;
                    const content = document.getElementById(targetId);
                    if (content) {
                        const isCollapsed = content.classList.contains('collapsed');
                        if (isCollapsed) {
                            content.classList.remove('collapsed');
                            toggle.textContent = '▲';
                            toggle.classList.add('expanded');
                        } else {
                            content.classList.add('collapsed');
                            toggle.textContent = '▼';
                            toggle.classList.remove('expanded');
                        }
                    }
                });
            });

            // Setup compact selects
            const paperSizeSelect = document.getElementById('paperSizeSelect');
            if (paperSizeSelect) {
                paperSizeSelect.addEventListener('change', () => {
                    const size = paperSizeSelect.value;
                    this.selectPaperSize(size);
                });
            }

            const photoSizeSelect = document.getElementById('photoSizeSelect');
            if (photoSizeSelect) {
                photoSizeSelect.addEventListener('change', () => {
                    const size = photoSizeSelect.value;
                    this.selectPhotoSize(size);
                });
            }

            const printModeSelect = document.getElementById('printModeSelect');
            if (printModeSelect) {
                printModeSelect.addEventListener('change', () => {
                    const mode = printModeSelect.value;
                    this.printData.config.printMode = mode;
                    this.toggleDuplexInterface(mode === 'duplex');
                    this.calculateLayout();
                });
            }

            // Setup orientation buttons
            document.querySelectorAll('.orient-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.orient-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const orientation = btn.dataset.orientation;
                    this.printData.config.orientation = orientation;
                    this.calculateLayout();
                });
            });

            // Setup fit buttons
            document.querySelectorAll('.fit-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.fit-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const fit = btn.dataset.fit;
                    this.printData.config.fitMode = fit;
                    this.updatePreview();
                });
            });

            // Setup margin expand button
            const marginExpandBtn = document.getElementById('marginExpandBtn');
            const marginDetailed = document.getElementById('marginDetailed');
            const marginAll = document.getElementById('marginAll');
            
            if (marginExpandBtn && marginDetailed) {
                marginExpandBtn.addEventListener('click', () => {
                    const isVisible = marginDetailed.style.display !== 'none';
                    marginDetailed.style.display = isVisible ? 'none' : 'block';
                    marginExpandBtn.textContent = isVisible ? '⚙' : '✕';
                });
            }

            if (marginAll) {
                marginAll.addEventListener('input', () => {
                    const value = parseInt(marginAll.value);
                    if (!isNaN(value)) {
                        ['marginTop', 'marginBottom', 'marginLeft', 'marginRight'].forEach(id => {
                            const input = document.getElementById(id);
                            if (input) input.value = value;
                        });
                        this.printData.config.margins = { 
                            top: value, bottom: value, left: value, right: value 
                        };
                        this.calculateLayout();
                    }
                });
            }

            // Setup cutting presets
            document.querySelectorAll('.cutting-preset').forEach(preset => {
                preset.addEventListener('click', () => {
                    document.querySelectorAll('.cutting-preset').forEach(p => p.classList.remove('active'));
                    preset.classList.add('active');
                    
                    const cutting = preset.dataset.cutting;
                    this.applyCuttingPreset(cutting);
                });
            });

            // Setup color dots (new compact version)
            document.querySelectorAll('.color-dot').forEach(dot => {
                dot.addEventListener('click', () => {
                    document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
                    dot.classList.add('active');
                    this.printData.config.cuttingGuides.color = dot.dataset.color;
                    this.updateMasterCanvas();
                });
            });

            // Setup export format tabs
            document.querySelectorAll('.format-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.format-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    this.selectedExportFormat = tab.dataset.format;
                });
            });

            // Setup action buttons
            const generatePreviewBtn = document.getElementById('generatePreviewBtn');
            if (generatePreviewBtn) {
                generatePreviewBtn.addEventListener('click', () => {
                    this.generatePreview();
                });
            }

            const resetConfigBtn = document.getElementById('resetConfigBtn');
            if (resetConfigBtn) {
                resetConfigBtn.addEventListener('click', () => {
                    this.resetToDefaults();
                });
            }

            // Setup format tab selection
            document.querySelectorAll('.format-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.format-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                });
            });

            // Setup images toggle button
            const toggleImagesView = document.getElementById('toggleImagesView');
            if (toggleImagesView) {
                toggleImagesView.addEventListener('click', () => {
                    const imagesGrid = document.getElementById('selectedImagesGrid');
                    if (imagesGrid) {
                        const isCollapsed = imagesGrid.style.display === 'none';
                        if (isCollapsed) {
                            imagesGrid.style.display = 'grid';
                            toggleImagesView.textContent = '▼';
                            toggleImagesView.title = 'Thu gọn';
                        } else {
                            imagesGrid.style.display = 'none';
                            toggleImagesView.textContent = '▶';
                            toggleImagesView.title = 'Mở rộng';
                        }
                    }
                });
            }

            console.log('✅ Compact interface event listeners setup complete');
        }

        setupCuttingGuidesListeners() {
            // Cutting guide checkboxes
            const checkboxes = ['outerCuttingLines', 'betweenImages', 'cornerMarks', 'gridHelperLines'];
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', () => {
                        this.printData.config.cuttingGuides[id] = checkbox.checked;
                        this.updateMasterCanvas();
                    });
                }
            });

            // Color selection
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.printData.config.cuttingGuides.color = btn.dataset.color;
                    this.updateMasterCanvas();
                });
            });

            // Thickness selection
            document.querySelectorAll('.thickness-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.thickness-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.printData.config.cuttingGuides.thickness = parseFloat(btn.dataset.thickness);
                    this.updateMasterCanvas();
                });
            });

            // Line style selection
            document.querySelectorAll('.line-style-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.line-style-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.printData.config.cuttingGuides.lineStyle = btn.dataset.style;
                    this.updateMasterCanvas();
                });
            });
        }

        setupPreviewControls() {
            this.previewState = {
                scale: 1,
                showGuides: true,
                showRuler: false,
                showGrid: false,
                viewMode: 'fitWidth'
            };

            // View controls
            const fitToWidthBtn = document.getElementById('fitToWidthBtn');
            const actualSizeBtn = document.getElementById('actualSizeBtn');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');

            if (fitToWidthBtn) fitToWidthBtn.addEventListener('click', () => this.setViewMode('fitWidth'));
            if (actualSizeBtn) actualSizeBtn.addEventListener('click', () => this.setViewMode('actualSize'));
            if (zoomInBtn) zoomInBtn.addEventListener('click', () => this.zoomPreview(1.2));
            if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => this.zoomPreview(0.8));

            // Guide toggles
            const toggleGuides = document.getElementById('toggleGuides');
            const toggleRuler = document.getElementById('toggleRuler');
            const toggleGrid = document.getElementById('toggleGrid');

            if (toggleGuides) {
                toggleGuides.addEventListener('click', () => {
                    this.previewState.showGuides = !this.previewState.showGuides;
                    toggleGuides.classList.toggle('active', this.previewState.showGuides);
                    this.updateMasterCanvas();
                });
            }

            if (toggleRuler) {
                toggleRuler.addEventListener('click', () => {
                    this.previewState.showRuler = !this.previewState.showRuler;
                    toggleRuler.classList.toggle('active', this.previewState.showRuler);
                    this.updateRulerDisplay();
                });
            }

            if (toggleGrid) {
                toggleGrid.addEventListener('click', () => {
                    this.previewState.showGrid = !this.previewState.showGrid;
                    toggleGrid.classList.toggle('active', this.previewState.showGrid);
                    this.updateGridDisplay();
                });
            }
        }

        setViewMode(mode) {
            // Update active button
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            
            this.previewState.viewMode = mode;
            
            switch(mode) {
                case 'fitWidth':
                    document.getElementById('fitToWidthBtn').classList.add('active');
                    this.fitPreviewToWidth();
                    break;
                case 'actualSize':
                    document.getElementById('actualSizeBtn').classList.add('active');
                    this.setPreviewScale(1);
                    break;
            }
        }

        fitPreviewToWidth() {
            const container = document.getElementById('canvasContainer');
            const canvas = document.getElementById('printCanvas');
            if (!container || !canvas || !this.printData.masterCanvas) return;

            const containerWidth = container.parentElement.clientWidth - 40; // Padding
            const canvasWidth = this.printData.masterCanvas.width;
            const scale = Math.min(containerWidth / canvasWidth, 1);
            
            this.setPreviewScale(scale);
        }

        setPreviewScale(scale) {
            this.previewState.scale = Math.max(0.1, Math.min(scale, 3)); // Limit scale between 10% and 300%
            this.updatePreviewFromMaster();
            this.updatePreviewInfo();
        }

        zoomPreview(factor) {
            const newScale = this.previewState.scale * factor;
            this.setPreviewScale(newScale);
        }

        updatePreviewInfo() {
            const config = this.printData.config;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            // Update preview stats
            const dimensionsEl = document.getElementById('previewDimensions');
            const dpiEl = document.getElementById('previewDPI');
            const imageCountEl = document.getElementById('previewImageCount');
            const scaleEl = document.getElementById('previewScale');

            if (dimensionsEl) dimensionsEl.textContent = `${paperWidthMm}×${paperHeightMm}mm`;
            if (dpiEl) dpiEl.textContent = `${config.dpi} DPI`;
            if (imageCountEl) {
                const imagesOnPage = Math.min(
                    this.printData.selectedImages.length - this.printData.currentPage * this.printData.maxPhotosPerPage,
                    this.printData.maxPhotosPerPage
                );
                imageCountEl.textContent = `${imagesOnPage} ảnh`;
            }
            if (scaleEl) scaleEl.textContent = `${Math.round(this.previewState.scale * 100)}%`;
        }

        updateRulerDisplay() {
            const rulerH = document.getElementById('rulerHorizontal');
            const rulerV = document.getElementById('rulerVertical');
            
            if (rulerH && rulerV) {
                const display = this.previewState.showRuler ? 'block' : 'none';
                rulerH.style.display = display;
                rulerV.style.display = display;
                
                if (this.previewState.showRuler) {
                    this.drawRulers();
                }
            }
        }

        updateGridDisplay() {
            // Grid will be drawn on canvas overlay
            this.updateCanvasOverlay();
        }

        drawRulers() {
            const config = this.printData.config;
            const canvas = document.getElementById('printCanvas');
            if (!canvas) return;

            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            // Create ruler markings based on canvas size and scale
            const rulerH = document.getElementById('rulerHorizontal');
            const rulerV = document.getElementById('rulerVertical');
            
            if (rulerH && rulerV) {
                rulerH.innerHTML = this.generateRulerMarks(paperWidthMm, canvas.width, 'horizontal');
                rulerV.innerHTML = this.generateRulerMarks(paperHeightMm, canvas.height, 'vertical');
            }
        }

        generateRulerMarks(sizeMm, sizePx, orientation) {
            const stepMm = 10; // 10mm increments
            const steps = Math.ceil(sizeMm / stepMm);
            let html = '';
            
            for (let i = 0; i <= steps; i++) {
                const mm = i * stepMm;
                const position = (mm / sizeMm) * 100;
                
                if (orientation === 'horizontal') {
                    html += `<div style="position: absolute; left: ${position}%; top: 0; height: 100%; border-left: 1px solid #9ca3af; font-size: 8px; padding-left: 2px;">${mm}</div>`;
                } else {
                    html += `<div style="position: absolute; top: ${position}%; left: 0; width: 100%; border-top: 1px solid #9ca3af; font-size: 8px; padding-top: 1px; writing-mode: vertical-rl;">${mm}</div>`;
                }
            }
            
            return html;
        }

        updateCanvasOverlay() {
            const overlay = document.getElementById('canvasOverlay');
            if (!overlay || !this.previewState.showGrid) {
                if (overlay) overlay.innerHTML = '';
                return;
            }

            // Draw grid pattern
            const canvas = document.getElementById('printCanvas');
            if (!canvas) return;

            const gridSize = 20; // 20px grid
            let html = '';
            
            for (let x = 0; x < canvas.width; x += gridSize) {
                html += `<div style="position: absolute; left: ${x}px; top: 0; bottom: 0; width: 1px; background: rgba(156, 163, 175, 0.3);"></div>`;
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                html += `<div style="position: absolute; top: ${y}px; left: 0; right: 0; height: 1px; background: rgba(156, 163, 175, 0.3);"></div>`;
            }
            
            overlay.innerHTML = html;
        }

        setupDuplexControls() {
            // Print mode radio buttons
            const singleSide = document.getElementById('singleSide');
            const duplexManual = document.getElementById('duplexManual');
            const duplexOptions = document.getElementById('duplexOptions');

            if (singleSide) {
                singleSide.addEventListener('change', () => {
                    if (singleSide.checked) {
                        this.printData.config.printMode = 'single';
                        if (duplexOptions) duplexOptions.style.display = 'none';
                        this.hideDuplexMode();
                        this.updateDuplexInstructions();
                    }
                });
            }

            if (duplexManual) {
                duplexManual.addEventListener('change', () => {
                    if (duplexManual.checked) {
                        this.printData.config.printMode = 'duplex';
                        if (duplexOptions) duplexOptions.style.display = 'block';
                        this.showDuplexMode();
                        this.updateDuplexInstructions();
                    }
                });
            }

            // Flip direction buttons
            document.querySelectorAll('.flip-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.flip-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.printData.config.duplexFlip = btn.dataset.flip;
                    this.updateDuplexInstructions();
                });
            });

            // Side toggle buttons for duplex preview
            const frontSideBtn = document.getElementById('frontSideBtn');
            const backSideBtn = document.getElementById('backSideBtn');
            
            if (frontSideBtn) {
                frontSideBtn.addEventListener('click', () => {
                    this.switchSide('front');
                });
            }
            
            if (backSideBtn) {
                backSideBtn.addEventListener('click', () => {
                    this.switchSide('back');
                });
            }

        }

        updateDuplexInstructions() {
            const instructionsEl = document.getElementById('duplexInstructions');
            if (!instructionsEl) return;

            const config = this.printData.config;
            
            if (config.printMode === 'single') {
                instructionsEl.innerHTML = 'In thông thường trên 1 mặt giấy';
                return;
            }

            const isPortrait = config.orientation === 'portrait';
            const isLongEdge = config.duplexFlip === 'long-edge';
            
            let instructions = '';
            
            if (isPortrait) {
                if (isLongEdge) {
                    instructions = `
                        1. In tất cả trang lẻ (mặt trước)<br>
                        2. Lật giấy theo cạnh dài (trái-phải)<br>
                        3. Đặt lại vào khay in với mặt trống hướng xuống<br>
                        4. In tất cả trang chẵn (mặt sau)
                    `;
                } else {
                    instructions = `
                        1. In tất cả trang lẻ (mặt trước)<br>
                        2. Lật giấy theo cạnh ngắn (trên-dưới)<br>
                        3. Đặt lại vào khay in với mặt trống hướng xuống<br>
                        4. In tất cả trang chẵn (mặt sau)
                    `;
                }
            } else {
                if (isLongEdge) {
                    instructions = `
                        1. In tất cả trang lẻ (mặt trước)<br>
                        2. Lật giấy theo cạnh dài (trên-dưới)<br>
                        3. Đặt lại vào khay in với mặt trống hướng xuống<br>
                        4. In tất cả trang chẵn (mặt sau)
                    `;
                } else {
                    instructions = `
                        1. In tất cả trang lẻ (mặt trước)<br>
                        2. Lật giấy theo cạnh ngắn (trái-phải)<br>
                        3. Đặt lại vào khay in với mặt trống hướng xuống<br>
                        4. In tất cả trang chẵn (mặt sau)
                    `;
                }
            }
            
            // Add coordinate mirroring information
            instructions += `<br><br><strong>🔄 Tọa độ nghịch đảo:</strong> Mặt sau mirror hoàn toàn qua ${isLongEdge ? 'trục dọc' : 'trục ngang'}`;
            
            instructionsEl.innerHTML = instructions;
        }

        // Duplex Mode Management
        showDuplexMode() {
            console.log('🔍 showDuplexMode called');
            const duplexControls = document.getElementById('duplexPreviewControls');
            const duplexSection = document.getElementById('duplexClassificationSection');
            const singleCanvasContainer = document.getElementById('canvasContainer');
            const duplexCanvasContainer = document.getElementById('duplexCanvasContainer');
            
            console.log('🔍 Duplex elements found:', {
                duplexControls: !!duplexControls,
                duplexSection: !!duplexSection,
                singleCanvasContainer: !!singleCanvasContainer,
                duplexCanvasContainer: !!duplexCanvasContainer
            });
            
            console.log('🔍 Gallery images available:', this.galleryImages ? this.galleryImages.length : 'undefined');
            
            if (duplexControls) {
                duplexControls.style.display = 'flex';
                console.log('✅ duplexControls displayed');
            }
            if (duplexSection) {
                duplexSection.style.display = 'block';
                console.log('✅ duplexSection displayed');
            } else {
                console.error('❌ duplexSection not found!');
            }
            
            // Switch to dual canvas layout
            if (singleCanvasContainer) singleCanvasContainer.style.display = 'none';
            if (duplexCanvasContainer) duplexCanvasContainer.style.display = 'flex';
            
            this.initializeDuplexClassification();
            this.setupDuplexClassificationListeners();
            
            // Hide old selectedImages section and show gallery grid for duplex
            const selectedImagesContainer = document.getElementById('selectedImagesContainer');
            if (selectedImagesContainer) selectedImagesContainer.style.display = 'none';
            
            // Populate gallery grid for duplex mode (with delay to ensure DOM is ready)
            setTimeout(() => {
                this.updateGalleryGridDuplex();
            }, 100);
            
            this.updateDuplexPreview();
            
            console.log('showDuplexMode completed');
        }

        hideDuplexMode() {
            const duplexControls = document.getElementById('duplexPreviewControls');
            const duplexSection = document.getElementById('duplexClassificationSection');
            const singleCanvasContainer = document.getElementById('canvasContainer');
            const duplexCanvasContainer = document.getElementById('duplexCanvasContainer');
            
            if (duplexControls) duplexControls.style.display = 'none';
            if (duplexSection) duplexSection.style.display = 'none';
            
            // Switch back to single canvas layout
            if (singleCanvasContainer) singleCanvasContainer.style.display = 'flex';
            if (duplexCanvasContainer) duplexCanvasContainer.style.display = 'none';
            
            // Show back selectedImages section and clear gallery grid duplex
            const selectedImagesContainer = document.getElementById('selectedImagesContainer');
            if (selectedImagesContainer) selectedImagesContainer.style.display = 'block';
            
            // Clear gallery grid duplex
            this.clearGalleryGridDuplex();
            
            this.printData.config.printMode = 'single';
            this.exitDuplexClassification();
        }

        initializeDuplexClassification() {
            // Initialize classification arrays if not exists or if they are objects
            if (!this.printData.frontImages || !Array.isArray(this.printData.frontImages)) {
                this.printData.frontImages = [];
            }
            if (!this.printData.backImages || !Array.isArray(this.printData.backImages)) {
                this.printData.backImages = [];
            }
            
            console.log('Duplex classification initialized:', {
                frontImages: this.printData.frontImages,
                backImages: this.printData.backImages
            });
            
            this.updateDuplexStats();
            this.updateClassificationDisplay();
        }

        setupDuplexClassificationListeners() {
            console.log('setupDuplexClassificationListeners called');
            
            // Classification buttons
            const classifyFrontBtn = document.getElementById('classifyFrontBtn');
            const classifyBackBtn = document.getElementById('classifyBackBtn');
            const exitClassifyBtn = document.getElementById('exitClassifyBtn');
            
            console.log('Duplex buttons found:', {
                classifyFrontBtn: !!classifyFrontBtn,
                classifyBackBtn: !!classifyBackBtn,
                exitClassifyBtn: !!exitClassifyBtn
            });
            
            if (classifyFrontBtn) {
                // Remove existing listeners to prevent duplicates
                classifyFrontBtn.replaceWith(classifyFrontBtn.cloneNode(true));
                const newFrontBtn = document.getElementById('classifyFrontBtn');
                newFrontBtn.addEventListener('click', () => {
                    console.log('Front classify button clicked');
                    this.startDuplexClassification('front');
                });
                console.log('Front classify button listener added');
            }
            
            if (classifyBackBtn) {
                // Remove existing listeners to prevent duplicates
                classifyBackBtn.replaceWith(classifyBackBtn.cloneNode(true));
                const newBackBtn = document.getElementById('classifyBackBtn');
                newBackBtn.addEventListener('click', () => {
                    console.log('Back classify button clicked');
                    this.startDuplexClassification('back');
                });
                console.log('Back classify button listener added');
            }
            
            if (exitClassifyBtn) {
                exitClassifyBtn.addEventListener('click', () => this.exitDuplexClassification());
            }
            
            // Clear buttons
            const clearFrontBtn = document.getElementById('clearFrontBtn');
            const clearBackBtn = document.getElementById('clearBackBtn');
            
            if (clearFrontBtn) {
                clearFrontBtn.addEventListener('click', () => this.clearClassifiedImages('front'));
            }
            
            if (clearBackBtn) {
                clearBackBtn.addEventListener('click', () => this.clearClassifiedImages('back'));
            }
            
            console.log('setupDuplexClassificationListeners completed');
        }

        startDuplexClassification(type) {
            console.log('🔍 DUPLEX startDuplexClassification called with type:', type);
            
            // Check if we have images to work with
            if (!this.galleryImages || this.galleryImages.length === 0) {
                this.showToast('⚠️ Chưa có ảnh nào trong kho để phân loại!', 'error');
                return;
            }
            
            // AUTO-ENTER classification mode if not already in it (unified workflow)
            if (!this.classificationMode) {
                console.log('🔍 DUPLEX Auto-entering classification mode for duplex selection');
                this.classificationMode = true;
                
                // Show classification UI (reuse Gallery's classification UI)
                const classificationModeEl = document.getElementById('classificationMode');
                console.log('🔍 DUPLEX classificationMode element found:', !!classificationModeEl);
                if (classificationModeEl) {
                    classificationModeEl.style.display = 'block';
                    console.log('🔍 DUPLEX classificationMode displayed');
                }
            }
            
            // For duplex mode, we work with the gallery images (kho ảnh)
            this.selectionMode = true;
            this.selectionType = type;
            this.selectedImages = [];
            
            console.log('🔍 DUPLEX Selection state set:', {
                selectionMode: this.selectionMode,
                selectionType: this.selectionType,
                classificationMode: this.classificationMode,
                printMode: this.printData?.config?.printMode,
                galleryImagesCount: this.galleryImages.length
            });
            
            // USE UNIFIED WORKFLOW: Reuse existing gallery classification system
            // Make sure source grid is updated with current images
            console.log('🔍 DUPLEX Updating source grid...');
            this.updateSourceGrid();
            
            // Update UI 
            this.updateClassificationUI();
            this.updateSourceGridSelectionMode();
            this.updateSelectionUI(); // CRITICAL: Show Apply/Cancel buttons
            
            // Show instructions similar to gallery classification
            const typeText = type === 'front' ? 'mặt trước' : 'mặt sau';
            this.showToast(`🎯 🖨️ FILE IN: Chế độ chọn ${typeText}. Click ảnh trong khu vực "Tất cả ảnh đã crop" (${this.galleryImages.length} ảnh)!`, 'info');
            
            // Update hint text
            const hintEl = document.getElementById('sourceGridHint');
            if (hintEl) {
                hintEl.textContent = `🎯 Click ảnh để chọn làm ${typeText} (${this.galleryImages.length} ảnh có sẵn)`;
                hintEl.style.color = type === 'front' ? '#10b981' : '#f59e0b';
                hintEl.style.fontWeight = 'bold';
            }
            
            console.log('Duplex classification mode started successfully');
        }

        exitDuplexClassification() {
            // Auto-apply any selected images before exiting
            if (this.selectedImages.length > 0) {
                console.log('Auto-applying selected images before exit');
                this.applySelection();
            }
            
            this.selectionMode = false;
            this.selectionType = null;
            this.selectedImages = [];
            
            // Hide classification mode (unified workflow)
            this.classificationMode = false;
            const classificationModeEl = document.getElementById('classificationMode');
            if (classificationModeEl) classificationModeEl.style.display = 'none';
            
            this.updateClassificationUI();
            this.updateSourceGridSelectionMode();
            
            // Đảm bảo selectedImages được cập nhật từ classified images
            this.updatePrintDataSelectedImages();
            
            console.log('🚪 Exited duplex classification mode');
            this.showToast('✅ Đã hoàn tất phân loại! Có thể tạo file in ngay.', 'success');
        }

        updateClassificationUI() {
            const frontBtn = document.getElementById('classifyFrontBtn');
            const backBtn = document.getElementById('classifyBackBtn');
            const exitBtn = document.getElementById('exitClassifyBtn');
            
            if (frontBtn) frontBtn.classList.toggle('active', this.selectionType === 'front');
            if (backBtn) backBtn.classList.toggle('active', this.selectionType === 'back');
            if (exitBtn) exitBtn.style.display = this.selectionMode ? 'flex' : 'none';
        }

        updateDuplexPreview() {
            if (this.printData.config.printMode !== 'duplex') return;
            
            // Render both canvases asynchronously
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
        }

        updateGalleryGridDuplex() {
            const galleryGrid = document.getElementById('galleryGridDuplex');
            console.log('🔍 updateGalleryGridDuplex called');
            console.log('🔍 galleryGridDuplex element found:', !!galleryGrid);
            console.log('🔍 this.galleryImages length:', this.galleryImages ? this.galleryImages.length : 'undefined');
            console.log('🔍 this.galleryImages first 3:', this.galleryImages ? this.galleryImages.slice(0, 3).map(img => ({id: img.id, filename: img.filename})) : 'undefined');
            
            if (!galleryGrid) {
                console.error('❌ galleryGridDuplex element not found!');
                return;
            }

            galleryGrid.innerHTML = '';
            console.log('✅ Updating gallery grid duplex with', this.galleryImages.length, 'images');

            this.galleryImages.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'gallery-item-duplex';
                itemEl.dataset.imageId = item.id;

                itemEl.innerHTML = `
                    <img src="${item.data}" alt="${item.filename}">
                    <div class="image-name">${item.filename}</div>
                `;

                // Add click listener for duplex classification
                itemEl.addEventListener('click', (e) => {
                    console.log('Gallery item duplex clicked:', item.id, 'Selection mode:', this.selectionMode);
                    if (this.selectionMode) {
                        console.log('Calling handleDuplexImageSelection');
                        this.handleDuplexImageSelection(item.id);
                    } else {
                        console.log('Not in duplex selection mode');
                    }
                });

                galleryGrid.appendChild(itemEl);
            });
        }
        
        updateDuplexGridSelectionMode() {
            console.log('updateDuplexGridSelectionMode called', {
                selectionMode: this.selectionMode,
                selectionType: this.selectionType
            });
            
            const galleryGrid = document.getElementById('galleryGridDuplex');
            if (!galleryGrid) {
                console.error('galleryGridDuplex not found');
                return;
            }
            
            const galleryItems = galleryGrid.querySelectorAll('.gallery-item-duplex');
            console.log('Found duplex gallery items:', galleryItems.length);
            
            galleryItems.forEach((item, index) => {
                const imageId = item.dataset.imageId;
                
                if (this.selectionMode) {
                    // Add selection mode class
                    item.classList.add('selection-mode');
                    
                    // Check if selected (for duplex mode, selectedImages contains objects)
                    const isSelected = this.selectedImages.some(img => 
                        (typeof img === 'object' ? img.id : img) == imageId
                    );
                    
                    console.log(`Duplex item ${imageId} is selected:`, isSelected);
                    
                    if (isSelected) {
                        const selectionClass = this.selectionType === 'front' ? 'selected-front' : 'selected-back';
                        item.classList.add(selectionClass);
                        
                        // Remove other selection class
                        const otherClass = this.selectionType === 'front' ? 'selected-back' : 'selected-front';
                        item.classList.remove(otherClass);
                    } else {
                        item.classList.remove('selected-front', 'selected-back');
                    }
                } else {
                    // Remove selection mode classes
                    item.classList.remove('selection-mode', 'selected-front', 'selected-back');
                }
            });
        }

        clearGalleryGridDuplex() {
            const galleryGrid = document.getElementById('galleryGridDuplex');
            if (galleryGrid) {
                galleryGrid.innerHTML = '';
            }
        }

        async renderDuplexCanvas(side) {
            console.log(`renderDuplexCanvas called for side: ${side}`);
            const canvasId = side === 'front' ? 'frontCanvas' : 'backCanvas';
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas not found: ${canvasId}`);
                return;
            }
            console.log(`Canvas found: ${canvasId}`);
            
            const ctx = canvas.getContext('2d');
            
            // Draw loading placeholder first
            canvas.width = 400;
            canvas.height = 600;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            // Create master canvas for this side using WYSIWYG system
            let masterCanvas;
            if (side === 'back') {
                // For back side preview, use mirrored canvas
                masterCanvas = await this.createDuplexBackCanvasClassified();
            } else {
                // For front side preview, use normal canvas
                masterCanvas = await this.createDuplexMasterCanvas(side, 0);
            }
            
            if (!masterCanvas) {
                // Draw placeholder if no master canvas
                ctx.fillStyle = '#9ca3af';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `Chưa có ảnh ${side === 'front' ? 'mặt trước' : 'mặt sau'}`,
                    canvas.width / 2,
                    canvas.height / 2
                );
                return;
            }
            
            // Scale down master canvas for preview display
            const scale = Math.min(400 / masterCanvas.width, 500 / masterCanvas.height);
            canvas.width = masterCanvas.width * scale;
            canvas.height = masterCanvas.height * scale;
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Draw scaled master canvas to preview
            ctx.drawImage(masterCanvas, 0, 0, canvas.width, canvas.height);
        }

        createDuplexMasterCanvas(side, pageIndex) {
            console.log(`createDuplexMasterCanvas called for side: ${side}`);
            const images = side === 'front' ? this.printData.frontImages : this.printData.backImages;
            console.log(`Images for ${side}:`, images ? images.length : 0);
            if (!images || images.length === 0) {
                console.log(`No images for ${side}, returning null`);
                return null;
            }
            
            return new Promise((resolve) => {
                // Temporarily replace selectedImages with side-specific images
                const originalSelectedImages = this.printData.selectedImages;
                
                // Create proper img objects for each image
                const processedImages = [];
                let loadedCount = 0;
                
                if (images.length === 0) {
                    resolve(null);
                    return;
                }
                
                images.forEach((imgData, index) => {
                    const img = new Image();
                    img.onload = () => {
                        processedImages[index] = {
                            src: imgData.src,
                            img: img,
                            name: imgData.name,
                            file: imgData.file
                        };
                        
                        loadedCount++;
                        if (loadedCount === images.length) {
                            // All images loaded, create canvas
                            this.printData.selectedImages = processedImages;
                            
                            const config = this.printData.config;
                            const dpi = config.dpi;
                            
                            // Calculate exact dimensions at full DPI  
                            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
                            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
                            const paperWidthInches = paperWidthMm / 25.4;
                            const paperHeightInches = paperHeightMm / 25.4;
                            const exactWidthPx = Math.round(paperWidthInches * dpi);
                            const exactHeightPx = Math.round(paperHeightInches * dpi);

                            // Create temporary master canvas
                            const masterCanvas = document.createElement('canvas');
                            masterCanvas.width = exactWidthPx;
                            masterCanvas.height = exactHeightPx;
                            
                            const ctx = masterCanvas.getContext('2d');
                            
                            // Render page content using existing system
                            console.log(`🖼️ FRONT Canvas: ${masterCanvas.width}x${masterCanvas.height}px at ${config.dpi}DPI`);
                            this.renderPageToCanvas(masterCanvas, ctx, pageIndex, config);
                            
                            // Add cutting guides if enabled
                            this.drawCuttingGuides(ctx, masterCanvas, config);
                            
                            // Restore original selectedImages
                            this.printData.selectedImages = originalSelectedImages;
                            
                            resolve(masterCanvas);
                        }
                    };
                    img.onerror = () => {
                        console.error('Failed to load image:', imgData.src);
                        loadedCount++;
                        if (loadedCount === images.length) {
                            this.printData.selectedImages = originalSelectedImages;
                            resolve(null);
                        }
                    };
                    img.src = imgData.src;
                });
            });
        }

        switchSide(side) {
            this.printData.currentSide = side;
            
            // Update UI
            const frontBtn = document.getElementById('frontSideBtn');
            const backBtn = document.getElementById('backSideBtn');
            const sideDisplay = document.getElementById('currentSideDisplay');
            const indicator = document.getElementById('pageSideIndicator');
            
            if (frontBtn && backBtn) {
                frontBtn.classList.toggle('active', side === 'front');
                backBtn.classList.toggle('active', side === 'back');
            }
            
            if (sideDisplay) {
                sideDisplay.textContent = side === 'front' ? 'Mặt trước' : 'Mặt sau';
            }
            
            if (indicator) {
                indicator.textContent = `Trang ${this.printData.currentPage + 1} - ${side === 'front' ? 'Mặt trước' : 'Mặt sau'}`;
            }
            
            this.updateSlotDisplay();
            this.updatePreview();
            
            // Update duplex preview for both sides
            if (this.printData.config.printMode === 'duplex') {
                this.updateDuplexPreview();
            }
        }

        updateSlotDisplay() {
            const slotGrid = document.getElementById('slotGrid');
            if (!slotGrid) return;
            
            const currentPage = this.printData.currentPage;
            const currentSide = this.printData.currentSide;
            const images = currentSide === 'front' ? this.printData.frontImages : this.printData.backImages;
            const pageImages = images[currentPage] || {};
            
            const slots = slotGrid.querySelectorAll('.slot-item');
            slots.forEach((slot, index) => {
                const imageData = pageImages[index];
                
                if (imageData) {
                    slot.classList.add('filled');
                    slot.innerHTML = `
                        <div class="slot-number">${index + 1}</div>
                        <img src="${imageData.data || imageData.src || ''}" alt="${imageData.name}" class="slot-image">
                        <button class="slot-remove-btn" onclick="converter.removeSlotImage(${currentPage}, '${currentSide}', ${index})">×</button>
                    `;
                } else {
                    slot.classList.remove('filled');
                    slot.innerHTML = `
                        <div class="slot-number">${index + 1}</div>
                        <div class="slot-empty-icon">📷</div>
                        <button class="slot-remove-btn" onclick="converter.removeSlotImage(${currentPage}, '${currentSide}', ${index})" style="display: none;">×</button>
                    `;
                }
            });
        }

        // Drag & Drop handlers for slots
        handleSlotDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        handleSlotDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        handleSlotDrop(e, slotIndex) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            const imageId = e.dataTransfer.getData('image-id');
            const source = e.dataTransfer.getData('source');
            
            if (source === 'gallery' && imageId) {
                const image = this.galleryImages.find(img => img.id == imageId);
                if (image) {
                    this.assignImageToSlot(slotIndex, {
                        src: image.data,
                        name: image.filename,
                        id: image.id
                    });
                }
            }
        }

        handleSlotClick(slotIndex) {
            // Open gallery selection modal for this slot
            this.openSlotGalleryModal(slotIndex);
        }

        assignImageToSlot(slotIndex, imageData) {
            const currentPage = this.printData.currentPage;
            const currentSide = this.printData.currentSide;
            
            // Initialize page data if not exists
            if (currentSide === 'front') {
                if (!this.printData.frontImages[currentPage]) {
                    this.printData.frontImages[currentPage] = {};
                }
                this.printData.frontImages[currentPage][slotIndex] = imageData;
            } else {
                if (!this.printData.backImages[currentPage]) {
                    this.printData.backImages[currentPage] = {};
                }
                this.printData.backImages[currentPage][slotIndex] = imageData;
            }
            
            this.updateSlotDisplay();
            this.updatePreview();
            this.showToast(`✅ Đã gán ảnh "${imageData.name}" vào slot ${slotIndex + 1} - ${currentSide === 'front' ? 'Mặt trước' : 'Mặt sau'}`, 'success');
        }

        removeSlotImage(pageIndex, side, slotIndex) {
            if (side === 'front' && this.printData.frontImages[pageIndex]) {
                delete this.printData.frontImages[pageIndex][slotIndex];
            } else if (side === 'back' && this.printData.backImages[pageIndex]) {
                delete this.printData.backImages[pageIndex][slotIndex];
            }
            
            this.updateSlotDisplay();
            this.updatePreview();
            this.showToast(`🗑️ Đã xóa ảnh khỏi slot ${slotIndex + 1}`, 'info');
        }

        clearCurrentSide() {
            const currentPage = this.printData.currentPage;
            const currentSide = this.printData.currentSide;
            
            if (currentSide === 'front') {
                this.printData.frontImages[currentPage] = {};
            } else {
                this.printData.backImages[currentPage] = {};
            }
            
            this.updateSlotDisplay();
            this.updatePreview();
            this.showToast(`🗑️ Đã xóa tất cả ảnh ${currentSide === 'front' ? 'mặt trước' : 'mặt sau'} trang ${currentPage + 1}`, 'info');
        }

        fillFromGallery() {
            if (this.galleryImages.length === 0) {
                this.showToast('Kho ảnh trống. Hãy thêm ảnh vào kho trước.', 'warning');
                return;
            }
            
            const currentPage = this.printData.currentPage;
            const currentSide = this.printData.currentSide;
            const maxSlots = this.printData.maxPhotosPerPage;
            
            // Fill slots with gallery images
            for (let i = 0; i < Math.min(maxSlots, this.galleryImages.length); i++) {
                const image = this.galleryImages[i];
                this.assignImageToSlot(i, {
                    src: image.data,
                    name: image.filename,
                    id: image.id
                });
            }
            
            this.showToast(`📷 Đã điền ${Math.min(maxSlots, this.galleryImages.length)} ảnh từ kho vào ${currentSide === 'front' ? 'mặt trước' : 'mặt sau'}`, 'success');
        }

        openSlotGalleryModal(slotIndex) {
            // Create a simple selection modal
            if (this.galleryImages.length === 0) {
                this.showToast('Kho ảnh trống. Hãy thêm ảnh vào kho trước.', 'warning');
                return;
            }
            
            const modal = document.createElement('div');
            modal.className = 'slot-selection-modal';
            modal.innerHTML = `
                <div class="slot-modal-content">
                    <div class="slot-modal-header">
                        <h3>Chọn ảnh cho Slot ${slotIndex + 1}</h3>
                        <button class="close-slot-modal">×</button>
                    </div>
                    <div class="slot-modal-body">
                        <div class="slot-gallery-grid">
                            ${this.galleryImages.map(image => `
                                <div class="slot-gallery-item" data-image-id="${image.id}">
                                    <img src="${image.data}" alt="${image.filename}">
                                    <div class="slot-image-name">${image.filename}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Event listeners
            modal.querySelector('.close-slot-modal').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            modal.querySelectorAll('.slot-gallery-item').forEach(item => {
                item.addEventListener('click', () => {
                    const imageId = item.dataset.imageId;
                    const image = this.galleryImages.find(img => img.id == imageId);
                    if (image) {
                        this.assignImageToSlot(slotIndex, {
                            src: image.data,
                            name: image.filename,
                            id: image.id
                        });
                    }
                    document.body.removeChild(modal);
                });
            });
            
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }

        updateDuplexStats() {
            const frontCount = this.printData.frontImages?.length || 0;
            const backCount = this.printData.backImages?.length || 0;
            const maxPages = Math.max(
                Math.ceil(frontCount / (this.printData.maxPhotosPerPage || 1)),
                Math.ceil(backCount / (this.printData.maxPhotosPerPage || 1))
            );

            const frontCountEl = document.getElementById('frontImageCount');
            const backCountEl = document.getElementById('backImageCount');
            const maxPagesEl = document.getElementById('maxDuplexPages');
            const frontCountHeader = document.getElementById('frontCount');
            const backCountHeader = document.getElementById('backCount');

            if (frontCountEl) frontCountEl.textContent = frontCount;
            if (backCountEl) backCountEl.textContent = backCount;
            if (maxPagesEl) maxPagesEl.textContent = maxPages;
            if (frontCountHeader) frontCountHeader.textContent = frontCount;
            if (backCountHeader) backCountHeader.textContent = backCount;
        }

        updateClassificationDisplay() {
            this.updateFrontImagesList();
            this.updateBackImagesList();
        }

        updateFrontImagesList() {
            const container = document.getElementById('frontImagesList');
            if (!container) return;

            // Use the correct frontImages based on context
            const frontImages = this.printData?.frontImages || this.frontImages || [];
            
            if (!frontImages || frontImages.length === 0) {
                container.innerHTML = `
                    <div class="empty-classification">
                        <div class="empty-icon">📄</div>
                        <div class="empty-text">Chưa có ảnh mặt trước</div>
                        <div class="empty-hint">Chọn ảnh và nhấn "Chọn làm mặt trước"</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = frontImages.map((image, index) => `
                <div class="classified-image">
                    <img src="${image.src}" alt="${image.name}" class="classified-image-thumb">
                    <div class="classified-image-info">
                        <div class="classified-image-name">${image.name}</div>
                        <div class="classified-image-size">Mặt trước #${index + 1}</div>
                    </div>
                    <button class="classified-image-remove" onclick="converter.removeClassifiedImage('front', ${index})">×</button>
                </div>
            `).join('');
        }

        updateBackImagesList() {
            const container = document.getElementById('backImagesList');
            if (!container) return;

            // Use the correct backImages based on context
            const backImages = this.printData?.backImages || this.backImages || [];
            
            if (!backImages || backImages.length === 0) {
                container.innerHTML = `
                    <div class="empty-classification">
                        <div class="empty-icon">📃</div>
                        <div class="empty-text">Chưa có ảnh mặt sau</div>
                        <div class="empty-hint">Chọn ảnh và nhấn "Chọn làm mặt sau"</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = backImages.map((image, index) => `
                <div class="classified-image">
                    <img src="${image.src}" alt="${image.name}" class="classified-image-thumb">
                    <div class="classified-image-info">
                        <div class="classified-image-name">${image.name}</div>
                        <div class="classified-image-size">Mặt sau #${index + 1}</div>
                    </div>
                    <button class="classified-image-remove" onclick="converter.removeClassifiedImage('back', ${index})">×</button>
                </div>
            `).join('');
        }

        removeClassifiedImage(type, index) {
            if (type === 'front') {
                this.printData.frontImages.splice(index, 1);
            } else {
                this.printData.backImages.splice(index, 1);
            }

            this.updateDuplexStats();
            this.updateClassificationDisplay();
            this.showToast(`🗑️ Đã xóa ảnh khỏi ${type === 'front' ? 'mặt trước' : 'mặt sau'}`, 'info');
        }

        clearClassifiedImages(type) {
            const typeText = type === 'front' ? 'mặt trước' : 'mặt sau';
            if (!confirm(`Bạn có chắc muốn xóa tất cả ảnh ${typeText}?`)) return;

            if (type === 'front') {
                this.printData.frontImages = [];
            } else {
                this.printData.backImages = [];
            }

            this.updateDuplexStats();
            this.updateClassificationDisplay();
            this.showToast(`🗑️ Đã xóa tất cả ảnh ${typeText}`, 'info');
        }

        selectPaperSize(size) {
            const customInput = document.getElementById('customPaperInputs');
            const customInputsSection = document.getElementById('customInputsSection');
            
            switch(size) {
                case 'a4':
                    this.printData.config.paperSize = { width: 210, height: 297 };
                    customInput.style.display = 'none';
                    break;
                case 'a3':
                    this.printData.config.paperSize = { width: 297, height: 420 };
                    customInput.style.display = 'none';
                    break;
                case 'letter':
                    this.printData.config.paperSize = { width: 216, height: 279 };
                    customInput.style.display = 'none';
                    break;
                case 'custom':
                    // Show both the main custom inputs section and paper inputs
                    if (customInputsSection) customInputsSection.style.display = 'block';
                    customInput.style.display = 'block';
                    this.updateConfigFromInputs();
                    return;
            }
            
            // Hide custom inputs section when not using custom
            if (customInputsSection) customInputsSection.style.display = 'none';
            
            this.calculateLayout();
        }

        selectPhotoSize(size) {
            const customInput = document.getElementById('customPhotoInputs');
            const customInputsSection = document.getElementById('customInputsSection');
            
            switch(size) {
                case '5.5x8.5':
                    this.printData.config.photoSize = { width: 5.5, height: 8.5 };
                    customInput.style.display = 'none';
                    break;
                case '4x6':
                    this.printData.config.photoSize = { width: 4, height: 6 };
                    customInput.style.display = 'none';
                    break;
                case '5x7':
                    this.printData.config.photoSize = { width: 5, height: 7 };
                    customInput.style.display = 'none';
                    break;
                case '6x9':
                    this.printData.config.photoSize = { width: 6, height: 9 };
                    customInput.style.display = 'none';
                    break;
                case '7x10':
                    this.printData.config.photoSize = { width: 7, height: 10 };
                    customInput.style.display = 'none';
                    break;
                case 'polaroid':
                    this.printData.config.photoSize = { width: 5.4, height: 6.7 };
                    customInput.style.display = 'none';
                    break;
                case 'custom':
                    // Show both the main custom inputs section and photo inputs
                    if (customInputsSection) customInputsSection.style.display = 'block';
                    customInput.style.display = 'block';
                    this.updateConfigFromInputs();
                    return;
            }
            
            // Hide custom inputs section when not using custom
            if (customInputsSection) customInputsSection.style.display = 'none';
            
            this.calculateLayout();
        }

        updateConfigFromInputs() {
            console.log('🔄 updateConfigFromInputs called');
            const paperWidth = document.getElementById('paperWidth');
            const paperHeight = document.getElementById('paperHeight');
            const photoWidth = document.getElementById('photoWidth');
            const photoHeight = document.getElementById('photoHeight');
            const marginTop = document.getElementById('marginTop');
            const marginBottom = document.getElementById('marginBottom');
            const marginLeft = document.getElementById('marginLeft');
            const marginRight = document.getElementById('marginRight');
            const gutterX = document.getElementById('gutterX');
            const gutterY = document.getElementById('gutterY');
            
            console.log('🔧 Current gutter values:', {
                gutterX: gutterX ? gutterX.value : 'not found',
                gutterY: gutterY ? gutterY.value : 'not found'
            });

            if (paperWidth && paperHeight) {
                this.printData.config.paperSize.width = parseFloat(paperWidth.value) || 210;
                this.printData.config.paperSize.height = parseFloat(paperHeight.value) || 297;
            }

            if (photoWidth && photoHeight) {
                this.printData.config.photoSize.width = parseFloat(photoWidth.value) || 5.5;
                this.printData.config.photoSize.height = parseFloat(photoHeight.value) || 8.5;
            }

            if (marginTop && marginBottom && marginLeft && marginRight) {
                this.printData.config.margins.top = parseFloat(marginTop.value) || 10;
                this.printData.config.margins.bottom = parseFloat(marginBottom.value) || 10;
                this.printData.config.margins.left = parseFloat(marginLeft.value) || 10;
                this.printData.config.margins.right = parseFloat(marginRight.value) || 10;
            }

            if (gutterX && gutterY) {
                this.printData.config.gutter.x = parseFloat(gutterX.value) || 5;
                this.printData.config.gutter.y = parseFloat(gutterY.value) || 5;
                console.log('✅ Updated gutter config:', this.printData.config.gutter);
            } else {
                console.error('❌ gutterX or gutterY not found!');
            }

            console.log('🔄 Calling calculateLayout...');
            this.calculateLayout();
        }

        calculateLayout() {
            console.log('📐 calculateLayout called with config:', {
                gutter: this.printData.config.gutter,
                photoSize: this.printData.config.photoSize,
                paperSize: this.printData.config.paperSize
            });
            
            const config = this.printData.config;
            
            // Convert dimensions to mm
            const paperWidth = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeight = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            const photoWidthMm = config.photoSize.width * 10; // cm to mm
            const photoHeightMm = config.photoSize.height * 10; // cm to mm

            // Calculate available space
            const availableWidth = paperWidth - config.margins.left - config.margins.right;
            const availableHeight = paperHeight - config.margins.top - config.margins.bottom;

            // Try both orientations of photos to find optimal layout
            const layouts = [
                this.calculateLayoutForOrientation(availableWidth, availableHeight, photoWidthMm, photoHeightMm, config.gutter),
                this.calculateLayoutForOrientation(availableWidth, availableHeight, photoHeightMm, photoWidthMm, config.gutter)
            ];

            // Choose the layout that fits more photos
            const optimalLayout = layouts[0].totalPhotos >= layouts[1].totalPhotos ? layouts[0] : layouts[1];
            
            // If second layout is better, we need to rotate photos
            this.printData.rotatePhotos = layouts[1].totalPhotos > layouts[0].totalPhotos;

            // Update UI
            document.getElementById('maxPhotosCount').textContent = optimalLayout.totalPhotos;
            document.getElementById('gridLayout').textContent = `${optimalLayout.cols}×${optimalLayout.rows}`;
            
            // Show optimization info
            const rotationInfo = this.printData.rotatePhotos ? ' (rotated)' : '';
            const actualSizeInfo = `${(optimalLayout.photoWidth/10).toFixed(1)}×${(optimalLayout.photoHeight/10).toFixed(1)}cm`;
            const spacingInfo = `${optimalLayout.actualSpacing.x.toFixed(1)}×${optimalLayout.actualSpacing.y.toFixed(1)}mm spacing`;
            
            // Update grid layout text with more details
            document.getElementById('gridLayout').textContent = `${optimalLayout.cols}×${optimalLayout.rows}${rotationInfo}`;
            
            // Show debug info
            const debugInfo = document.getElementById('layoutDebugInfo');
            if (debugInfo) {
                debugInfo.innerHTML = `
                    <div style="margin-bottom: 8px;">
                        <strong>◼ Thông tin giấy:</strong><br>
                        • Kích thước giấy: ${paperWidth} × ${paperHeight} mm<br>
                        • Vùng in khả dụng: ${availableWidth.toFixed(1)} × ${availableHeight.toFixed(1)} mm
                    </div>
                    <div style="margin-bottom: 8px;">
                        <strong>◻ Thông tin ảnh:</strong><br>
                        • Kích thước ảnh: ${actualSizeInfo}${rotationInfo}<br>
                        • Khoảng cách giữa ảnh: ${spacingInfo}
                    </div>
                    <div>
                        <strong>⊞ Tùy chọn bố trí tối ưu:</strong><br>
                        • Bố trí 1: ${layouts[0].totalPhotos} ảnh (${layouts[0].cols} cột × ${layouts[0].rows} hàng)<br>
                        • Bố trí 2: ${layouts[1].totalPhotos} ảnh (${layouts[1].cols} cột × ${layouts[1].rows} hàng)<br>
                        • <span style="color: #059669; font-weight: bold;">✓ Đã chọn bố trí tối ưu: ${optimalLayout.totalPhotos} ảnh (${optimalLayout.cols}×${optimalLayout.rows})</span>
                    </div>
                `;
            }
            
            this.printData.maxPhotosPerPage = optimalLayout.totalPhotos;
            this.printData.gridLayout = { 
                rows: optimalLayout.rows, 
                cols: optimalLayout.cols,
                photoWidth: optimalLayout.photoWidth,
                photoHeight: optimalLayout.photoHeight,
                actualSpacing: optimalLayout.actualSpacing
            };
            
            this.updateTotalPages();
            this.updatePreview();
            
            // Update duplex preview if in duplex mode
            if (this.printData.config.printMode === 'duplex') {
                this.updateDuplexPreview();
            }
        }

        calculateLayoutForOrientation(availableWidth, availableHeight, photoW, photoH, gutter) {
            // Advanced layout optimization algorithm
            
            // Method 1: Standard grid calculation
            let cols = Math.floor(availableWidth / photoW);
            let rows = Math.floor(availableHeight / photoH);
            
            // Ensure at least 1 photo fits
            cols = Math.max(1, cols);
            rows = Math.max(1, rows);
            
            // Method 2: Try with minimal gutters (1mm minimum)
            const minGutter = 1; // 1mm minimum
            let cols2 = Math.floor((availableWidth + minGutter) / (photoW + minGutter));
            let rows2 = Math.floor((availableHeight + minGutter) / (photoH + minGutter));
            cols2 = Math.max(1, cols2);
            rows2 = Math.max(1, rows2);
            
            // Method 3: Try tight packing with 0.5mm gutter
            const tightGutter = 0.5;
            let cols3 = Math.floor((availableWidth + tightGutter) / (photoW + tightGutter));
            let rows3 = Math.floor((availableHeight + tightGutter) / (photoH + tightGutter));
            cols3 = Math.max(1, cols3);
            rows3 = Math.max(1, rows3);
            
            // Choose the method that gives most photos
            const layouts = [
                { cols: cols, rows: rows, photos: cols * rows, gutterX: gutter.x, gutterY: gutter.y },
                { cols: cols2, rows: rows2, photos: cols2 * rows2, gutterX: minGutter, gutterY: minGutter },
                { cols: cols3, rows: rows3, photos: cols3 * rows3, gutterX: tightGutter, gutterY: tightGutter }
            ];
            
            // Find best layout
            const bestLayout = layouts.reduce((best, current) => 
                current.photos > best.photos ? current : best
            );
            
            const finalCols = bestLayout.cols;
            const finalRows = bestLayout.rows;
            
            // Calculate actual spacing for chosen layout
            let actualGutterX = bestLayout.gutterX;
            let actualGutterY = bestLayout.gutterY;
            
            // If we have extra space, distribute it evenly
            if (finalCols > 1) {
                const totalPhotoWidth = finalCols * photoW;
                const availableGutterSpace = availableWidth - totalPhotoWidth;
                actualGutterX = Math.max(0.5, availableGutterSpace / (finalCols - 1));
            }
            
            if (finalRows > 1) {
                const totalPhotoHeight = finalRows * photoH;
                const availableGutterSpace = availableHeight - totalPhotoHeight;
                actualGutterY = Math.max(0.5, availableGutterSpace / (finalRows - 1));
            }

            const layout = {
                cols: finalCols,
                rows: finalRows,
                totalPhotos: finalCols * finalRows,
                photoWidth: photoW,
                photoHeight: photoH,
                actualSpacing: {
                    x: actualGutterX,
                    y: actualGutterY
                }
            };
            
            // Store layout for use in other functions
            this.printData.gridLayout = layout;
            this.printData.maxPhotosPerPage = layout.totalPhotos;
            this.printData.totalPages = Math.ceil(this.printData.selectedImages.length / this.printData.maxPhotosPerPage);
            
            console.log('📊 Print data status:', {
                selectedImages: this.printData.selectedImages.length,
                maxPhotosPerPage: this.printData.maxPhotosPerPage,
                totalPages: this.printData.totalPages
            });
            
            console.log('📐 Layout calculated:', layout);
            console.log('🔄 Calling updatePreview...');
            this.updatePreview();
            
            return layout;
        }

        updateTotalPages() {
            const totalImages = this.printData.selectedImages.length;
            const maxPerPage = this.printData.maxPhotosPerPage || 1;
            this.printData.totalPages = Math.ceil(totalImages / maxPerPage);
            
            document.getElementById('totalPages').textContent = this.printData.totalPages;
            
            // Update preview controls
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            const pageIndicator = document.getElementById('pageIndicator');
            
            if (prevBtn) prevBtn.disabled = this.printData.currentPage <= 0;
            if (nextBtn) nextBtn.disabled = this.printData.currentPage >= this.printData.totalPages - 1;
            if (pageIndicator) pageIndicator.textContent = `Trang ${this.printData.currentPage + 1}/${this.printData.totalPages}`;
        }

        handlePrintImages(files) {
            Array.from(files).forEach(file => {
                if (file.type.startsWith('image/')) {
                    this.addImageToPrintList(file);
                }
            });
        }

        addImageToPrintList(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    this.printData.selectedImages.push({
                        file: file,
                        src: e.target.result,
                        img: img,
                        name: file.name
                    });
                    
                    this.updateSelectedImagesDisplay();
                    this.updateTotalPages();
                    this.updatePreview();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        updateSelectedImagesDisplay() {
            const container = document.getElementById('selectedImagesContainer');
            const grid = document.getElementById('selectedImagesGrid');
            const countSpan = document.getElementById('selectedCount');
            
            if (!container || !grid || !countSpan) return;

            countSpan.textContent = this.printData.selectedImages.length;
            
            if (this.printData.selectedImages.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            grid.innerHTML = '';

            this.printData.selectedImages.forEach((imageData, index) => {
                const item = document.createElement('div');
                item.className = 'selected-image-item';
                item.style.cssText = `
                    position: relative;
                    border: 2px solid #e2e8f0;
                    border-radius: 6px;
                    overflow: hidden;
                    background: white;
                    cursor: pointer;
                `;

                const img = document.createElement('img');
                img.src = imageData.data || imageData.src || '';  // Fallback để tránh undefined
                img.style.cssText = `
                    width: 100%;
                    height: 100px;
                    object-fit: cover;
                `;
                
                // Error handler để debug
                img.onerror = () => {
                    console.warn('Failed to load image in updateSelectedImagesDisplay:', {
                        data: imageData.data ? 'exists' : 'missing',
                        src: imageData.src ? 'exists' : 'missing',
                        name: imageData.name,
                        finalSrc: img.src
                    });
                };

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '×';
                removeBtn.style.cssText = `
                    position: absolute;
                    top: 4px;
                    right: 4px;
                    width: 24px;
                    height: 24px;
                    border: none;
                    border-radius: 50%;
                    background: rgba(239, 68, 68, 0.9);
                    color: white;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;

                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removeImageFromPrintList(index);
                });

                // Selected images are not used for duplex classification anymore
                // Only gallery images are used for duplex classification

                item.appendChild(img);
                item.appendChild(removeBtn);
                grid.appendChild(item);
            });

            // Show other sections
            const previewContainer = document.getElementById('printPreviewContainer');
            const exportSection = document.getElementById('exportSection');
            if (previewContainer) previewContainer.style.display = 'block';
            if (exportSection) exportSection.style.display = 'block';

            // Enable export buttons
            const generateBtn = document.getElementById('generatePrintBtn');
            if (generateBtn) generateBtn.disabled = false;
            
            const generateBtnNew = document.getElementById('generatePrintBtnNew');
            if (generateBtnNew) generateBtnNew.disabled = false;
            
            const generatePreviewBtn = document.getElementById('generatePreviewBtn');
            if (generatePreviewBtn) generatePreviewBtn.disabled = false;
        }

        // handleSelectedImageSelection removed - only use gallery images for duplex classification

        removeImageFromPrintList(index) {
            this.printData.selectedImages.splice(index, 1);
            this.updateSelectedImagesDisplay();
            this.updateTotalPages();
            this.updatePreview();
        }

        clearSelectedImages() {
            this.printData.selectedImages = [];
            this.updateSelectedImagesDisplay();
            this.updateTotalPages();
            this.updatePreview();
        }

        // Master Canvas System - Single Source of Truth
        createMasterCanvas(pageIndex) {
            const config = this.printData.config;
            const dpi = config.dpi;
            
            // Calculate exact dimensions at full DPI
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            const paperWidthInches = paperWidthMm / 25.4;
            const paperHeightInches = paperHeightMm / 25.4;
            const exactWidthPx = Math.round(paperWidthInches * dpi);
            const exactHeightPx = Math.round(paperHeightInches * dpi);

            // Create or update master canvas
            if (!this.printData.masterCanvas) {
                this.printData.masterCanvas = document.createElement('canvas');
            }
            
            const masterCanvas = this.printData.masterCanvas;
            masterCanvas.width = exactWidthPx;
            masterCanvas.height = exactHeightPx;
            
            const ctx = masterCanvas.getContext('2d');
            
            // Render page content at full resolution
            this.renderPageToCanvas(masterCanvas, ctx, pageIndex, config);
            
            // Add cutting guides if enabled
            this.drawCuttingGuides(ctx, masterCanvas, config);
            
            return masterCanvas;
        }

        updateMasterCanvas() {
            if (this.printData.selectedImages.length === 0) return;
            
            // Update master canvas
            this.createMasterCanvas(this.printData.currentPage);
            
            // Update preview from master canvas
            this.updatePreviewFromMaster();
        }

        updatePreviewFromMaster() {
            const previewCanvas = document.getElementById('printCanvas');
            if (!previewCanvas || !this.printData.masterCanvas) return;

            this.printData.previewCanvas = previewCanvas;
            const previewCtx = previewCanvas.getContext('2d');
            
            // Use custom scale if set, otherwise auto-fit
            let scale = this.previewState?.scale || 1;
            
            if (this.previewState?.viewMode === 'fitWidth') {
                const container = document.getElementById('canvasContainer');
                if (container) {
                    const containerWidth = container.parentElement.clientWidth - 40;
                    scale = Math.min(containerWidth / this.printData.masterCanvas.width, 1);
                    this.previewState.scale = scale;
                }
            }
            
            // Set preview canvas size
            previewCanvas.width = Math.round(this.printData.masterCanvas.width * scale);
            previewCanvas.height = Math.round(this.printData.masterCanvas.height * scale);
            
            // Draw scaled master canvas to preview
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(this.printData.masterCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
            
            // Update display size
            previewCanvas.style.width = previewCanvas.width + 'px';
            previewCanvas.style.height = previewCanvas.height + 'px';
            
            // Update additional preview elements
            if (this.previewState) {
                this.updatePreviewInfo();
                this.updateRulerDisplay();
                this.updateCanvasOverlay();
            }
        }

        updatePreview() {
            console.log('🖼️ updatePreview called');
            this.updateMasterCanvas();
        }

        renderPage(pageIndex) {
            const canvas = this.printData.canvas;
            const ctx = this.printData.context;
            const config = this.printData.config;

            if (!canvas || !ctx) return;

            // Convert dimensions to pixels for canvas
            const dpi = config.dpi;
            const paperWidthPx = Math.round((config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height) / 25.4 * dpi);
            const paperHeightPx = Math.round((config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width) / 25.4 * dpi);

            canvas.width = paperWidthPx;
            canvas.height = paperHeightPx;

            // Clear canvas with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, paperWidthPx, paperHeightPx);

            // Use optimized layout dimensions
            const layout = this.printData.gridLayout;
            const photoWidthPx = Math.round(layout.photoWidth / 25.4 * dpi);
            const photoHeightPx = Math.round(layout.photoHeight / 25.4 * dpi);

            // Calculate positions with optimized spacing
            const marginLeftPx = Math.round(config.margins.left / 25.4 * dpi);
            const marginTopPx = Math.round(config.margins.top / 25.4 * dpi);
            const gutterXPx = Math.round(layout.actualSpacing.x / 25.4 * dpi);
            const gutterYPx = Math.round(layout.actualSpacing.y / 25.4 * dpi);

            // Calculate available area and center the grid
            const availableWidthPx = paperWidthPx - 2 * marginLeftPx;
            const availableHeightPx = paperHeightPx - 2 * marginTopPx;
            
            const totalGridWidth = layout.cols * photoWidthPx + (layout.cols - 1) * gutterXPx;
            const totalGridHeight = layout.rows * photoHeightPx + (layout.rows - 1) * gutterYPx;
            
            const startXPx = marginLeftPx + (availableWidthPx - totalGridWidth) / 2;
            const startYPx = marginTopPx + (availableHeightPx - totalGridHeight) / 2;

            const startIndex = pageIndex * this.printData.maxPhotosPerPage;
            const endIndex = Math.min(startIndex + this.printData.maxPhotosPerPage, this.printData.selectedImages.length);

            let imageIndex = 0;
            for (let i = startIndex; i < endIndex; i++) {
                const imageData = this.printData.selectedImages[i];
                if (!imageData || !imageData.img) continue;

                const row = Math.floor(imageIndex / layout.cols);
                const col = imageIndex % layout.cols;

                const x = startXPx + col * (photoWidthPx + gutterXPx);
                const y = startYPx + row * (photoHeightPx + gutterYPx);

                this.drawImageOnCanvas(ctx, imageData.img, x, y, photoWidthPx, photoHeightPx, config.fitMode);
                imageIndex++;
            }

            // Scale canvas for display
            const maxDisplayWidth = 800;
            const maxDisplayHeight = 600;
            const scale = Math.min(maxDisplayWidth / paperWidthPx, maxDisplayHeight / paperHeightPx, 1);
            
            canvas.style.width = (paperWidthPx * scale) + 'px';
            canvas.style.height = (paperHeightPx * scale) + 'px';
        }

        drawImageOnCanvas(ctx, img, x, y, width, height, fitMode) {
            const imgAspect = img.width / img.height;
            const targetAspect = width / height;

            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

            if (fitMode === 'fill') {
                // Fill the entire area, crop if necessary
                if (imgAspect > targetAspect) {
                    drawHeight = height;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (width - drawWidth) / 2;
                } else {
                    drawWidth = width;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (height - drawHeight) / 2;
                }
            } else {
                // Fit inside the area, add padding if necessary
                if (imgAspect > targetAspect) {
                    drawWidth = width;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (height - drawHeight) / 2;
                } else {
                    drawHeight = height;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (width - drawWidth) / 2;
                }
            }

            // Draw image
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, width, height);
            ctx.clip();
            ctx.drawImage(img, x + offsetX, y + offsetY, drawWidth, drawHeight);
            ctx.restore();

            // Draw border
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, width, height);
        }

        showPreviousPage() {
            if (this.printData.currentPage > 0) {
                this.printData.currentPage--;
                this.updateTotalPages();
                this.renderPage(this.printData.currentPage);
            }
        }

        showNextPage() {
            if (this.printData.currentPage < this.printData.totalPages - 1) {
                this.printData.currentPage++;
                this.updateTotalPages();
                this.updateMasterCanvas();
            }
        }

        showPreviousPage() {
            if (this.printData.currentPage > 0) {
                this.printData.currentPage--;
                this.updateTotalPages();
                this.updateMasterCanvas();
            }
        }

        drawCuttingGuides(ctx, canvas, config) {
            const guides = config.cuttingGuides;
            
            // Check if guides are disabled in preview
            if (!this.previewState?.showGuides) {
                return; // Guides disabled in preview
            }
            
            if (!guides.outerCuttingLines && !guides.betweenImages && !guides.cornerMarks && !guides.gridHelperLines) {
                return; // No guides enabled
            }

            const dpi = config.dpi;
            const layout = this.printData.gridLayout;
            
            // Use EXACT same calculations as renderPageToCanvas for perfect alignment
            const marginLeftPx = Math.round(config.margins.left / 25.4 * dpi);
            const marginTopPx = Math.round(config.margins.top / 25.4 * dpi);
            const gutterXPx = Math.round(layout.actualSpacing.x / 25.4 * dpi);
            const gutterYPx = Math.round(layout.actualSpacing.y / 25.4 * dpi);
            const photoWidthPx = Math.round(layout.photoWidth / 25.4 * dpi);
            const photoHeightPx = Math.round(layout.photoHeight / 25.4 * dpi);

            // Calculate grid start position - EXACT same as renderPageToCanvas
            const availableWidthPx = canvas.width - 2 * marginLeftPx;
            const availableHeightPx = canvas.height - 2 * marginTopPx;
            const totalGridWidth = layout.cols * photoWidthPx + (layout.cols - 1) * gutterXPx;
            const totalGridHeight = layout.rows * photoHeightPx + (layout.rows - 1) * gutterYPx;
            const startXPx = marginLeftPx + (availableWidthPx - totalGridWidth) / 2;
            const startYPx = marginTopPx + (availableHeightPx - totalGridHeight) / 2;

            // Set line style
            ctx.strokeStyle = guides.color;
            ctx.lineWidth = guides.thickness * (dpi / 72); // Convert to canvas units
            
            // Set line dash pattern
            if (guides.lineStyle === 'dashed') {
                ctx.setLineDash([5, 5]);
            } else if (guides.lineStyle === 'dotted') {
                ctx.setLineDash([2, 2]);
            } else {
                ctx.setLineDash([]);
            }

            ctx.save();

            // Create array of actual image positions for perfect alignment
            const imagePositions = [];
            for (let row = 0; row < layout.rows; row++) {
                for (let col = 0; col < layout.cols; col++) {
                    const x = startXPx + col * (photoWidthPx + gutterXPx);
                    const y = startYPx + row * (photoHeightPx + gutterYPx);
                    imagePositions.push({ x, y, width: photoWidthPx, height: photoHeightPx, row, col });
                }
            }

            // 1. Outer cutting lines (around actual image area)
            if (guides.outerCuttingLines) {
                this.drawOuterCuttingLinesAligned(ctx, imagePositions, canvas);
            }

            // 2. Between images cutting lines (exactly between actual images)
            if (guides.betweenImages) {
                this.drawBetweenImageLinesAligned(ctx, imagePositions, layout, canvas);
            }

            // 3. Corner marks (at exact image corners)
            if (guides.cornerMarks) {
                this.drawCornerMarksAligned(ctx, imagePositions, dpi);
            }

            // 4. Grid helper lines (around exact image boundaries)
            if (guides.gridHelperLines) {
                this.drawGridHelperLinesAligned(ctx, imagePositions);
            }

            ctx.restore();
        }

        drawOuterCuttingLines(ctx, startX, startY, totalWidth, totalHeight, canvas) {
            ctx.beginPath();
            
            // Draw lines that extend to paper edges
            // Top edge of print area - extend full width
            ctx.moveTo(0, startY);
            ctx.lineTo(canvas.width, startY);
            
            // Bottom edge of print area - extend full width  
            ctx.moveTo(0, startY + totalHeight);
            ctx.lineTo(canvas.width, startY + totalHeight);
            
            // Left edge of print area - extend full height
            ctx.moveTo(startX, 0);
            ctx.lineTo(startX, canvas.height);
            
            // Right edge of print area - extend full height
            ctx.moveTo(startX + totalWidth, 0);
            ctx.lineTo(startX + totalWidth, canvas.height);
            
            ctx.stroke();
        }

        drawBetweenImageLines(ctx, layout, startX, startY, photoWidth, photoHeight, gutterX, gutterY, canvas) {
            ctx.beginPath();
            
            // Vertical lines between columns - extend full height of paper
            for (let col = 1; col < layout.cols; col++) {
                const x = startX + col * photoWidth + (col - 0.5) * gutterX;
                ctx.moveTo(x, 0);  // From top of paper
                ctx.lineTo(x, canvas.height);  // To bottom of paper
            }
            
            // Horizontal lines between rows - extend full width of paper
            for (let row = 1; row < layout.rows; row++) {
                const y = startY + row * photoHeight + (row - 0.5) * gutterY;
                ctx.moveTo(0, y);  // From left edge of paper
                ctx.lineTo(canvas.width, y);  // To right edge of paper
            }
            
            ctx.stroke();
        }

        drawCornerMarks(ctx, layout, startX, startY, photoWidth, photoHeight, gutterX, gutterY, dpi) {
            const markLength = Math.round(3 / 25.4 * dpi); // 3mm marks
            
            ctx.beginPath();
            
            for (let row = 0; row < layout.rows; row++) {
                for (let col = 0; col < layout.cols; col++) {
                    const photoX = startX + col * (photoWidth + gutterX);
                    const photoY = startY + row * (photoHeight + gutterY);
                    
                    // Top-left corner
                    ctx.moveTo(photoX - markLength, photoY);
                    ctx.lineTo(photoX + markLength, photoY);
                    ctx.moveTo(photoX, photoY - markLength);
                    ctx.lineTo(photoX, photoY + markLength);
                    
                    // Top-right corner
                    const topRightX = photoX + photoWidth;
                    ctx.moveTo(topRightX - markLength, photoY);
                    ctx.lineTo(topRightX + markLength, photoY);
                    ctx.moveTo(topRightX, photoY - markLength);
                    ctx.lineTo(topRightX, photoY + markLength);
                    
                    // Bottom-left corner
                    const bottomLeftY = photoY + photoHeight;
                    ctx.moveTo(photoX - markLength, bottomLeftY);
                    ctx.lineTo(photoX + markLength, bottomLeftY);
                    ctx.moveTo(photoX, bottomLeftY - markLength);
                    ctx.lineTo(photoX, bottomLeftY + markLength);
                    
                    // Bottom-right corner
                    const bottomRightX = photoX + photoWidth;
                    const bottomRightY = photoY + photoHeight;
                    ctx.moveTo(bottomRightX - markLength, bottomRightY);
                    ctx.lineTo(bottomRightX + markLength, bottomRightY);
                    ctx.moveTo(bottomRightX, bottomRightY - markLength);
                    ctx.lineTo(bottomRightX, bottomRightY + markLength);
                }
            }
            
            ctx.stroke();
        }

        drawGridHelperLines(ctx, layout, startX, startY, photoWidth, photoHeight, gutterX, gutterY) {
            ctx.save();
            ctx.strokeStyle = ctx.strokeStyle + '40'; // Make semi-transparent
            ctx.beginPath();
            
            // Draw grid around each photo
            for (let row = 0; row < layout.rows; row++) {
                for (let col = 0; col < layout.cols; col++) {
                    const photoX = startX + col * (photoWidth + gutterX);
                    const photoY = startY + row * (photoHeight + gutterY);
                    
                    ctx.rect(photoX, photoY, photoWidth, photoHeight);
                }
            }
            
            ctx.stroke();
            ctx.restore();
        }

        // New aligned cutting guide functions
        drawOuterCuttingLinesAligned(ctx, imagePositions, canvas) {
            if (imagePositions.length === 0) return;
            
            ctx.beginPath();
            
            // Find bounds of all images
            const leftmostX = Math.min(...imagePositions.map(pos => pos.x));
            const rightmostX = Math.max(...imagePositions.map(pos => pos.x + pos.width));
            const topmostY = Math.min(...imagePositions.map(pos => pos.y));
            const bottommostY = Math.max(...imagePositions.map(pos => pos.y + pos.height));
            
            // Calculate offset to push cutting lines outside image area
            // Use half line width to ensure cutting line doesn't overlap image
            const lineOffset = ctx.lineWidth / 2;
            
            // Draw lines that extend to paper edges but positioned OUTSIDE image boundaries
            // Top edge - positioned ABOVE the topmost image
            const topCutY = topmostY - lineOffset;
            ctx.moveTo(0, topCutY);
            ctx.lineTo(canvas.width, topCutY);
            
            // Bottom edge - positioned BELOW the bottommost image
            const bottomCutY = bottommostY + lineOffset;
            ctx.moveTo(0, bottomCutY);
            ctx.lineTo(canvas.width, bottomCutY);
            
            // Left edge - positioned LEFT of the leftmost image
            const leftCutX = leftmostX - lineOffset;
            ctx.moveTo(leftCutX, 0);
            ctx.lineTo(leftCutX, canvas.height);
            
            // Right edge - positioned RIGHT of the rightmost image
            const rightCutX = rightmostX + lineOffset;
            ctx.moveTo(rightCutX, 0);
            ctx.lineTo(rightCutX, canvas.height);
            
            ctx.stroke();
        }

        drawBetweenImageLinesAligned(ctx, imagePositions, layout, canvas) {
            ctx.beginPath();
            
            // Group images by row and column for precise cutting lines
            const imagesByRow = [];
            const imagesByCol = [];
            
            for (let i = 0; i < layout.rows; i++) imagesByRow[i] = [];
            for (let i = 0; i < layout.cols; i++) imagesByCol[i] = [];
            
            imagePositions.forEach(pos => {
                imagesByRow[pos.row].push(pos);
                imagesByCol[pos.col].push(pos);
            });
            
            // Vertical lines between columns - exactly in the middle of the gap
            for (let col = 0; col < layout.cols - 1; col++) {
                const currentColImages = imagesByCol[col];
                const nextColImages = imagesByCol[col + 1];
                
                if (currentColImages.length > 0 && nextColImages.length > 0) {
                    const rightEdge = currentColImages[0].x + currentColImages[0].width;
                    const leftEdge = nextColImages[0].x;
                    const cutLineX = (rightEdge + leftEdge) / 2;
                    
                    ctx.moveTo(cutLineX, 0);
                    ctx.lineTo(cutLineX, canvas.height);
                }
            }
            
            // Horizontal lines between rows - exactly in the middle of the gap
            for (let row = 0; row < layout.rows - 1; row++) {
                const currentRowImages = imagesByRow[row];
                const nextRowImages = imagesByRow[row + 1];
                
                if (currentRowImages.length > 0 && nextRowImages.length > 0) {
                    const bottomEdge = currentRowImages[0].y + currentRowImages[0].height;
                    const topEdge = nextRowImages[0].y;
                    const cutLineY = (bottomEdge + topEdge) / 2;
                    
                    ctx.moveTo(0, cutLineY);
                    ctx.lineTo(canvas.width, cutLineY);
                }
            }
            
            ctx.stroke();
        }

        drawCornerMarksAligned(ctx, imagePositions, dpi) {
            const markLength = Math.round(3 / 25.4 * dpi); // 3mm marks
            const offset = ctx.lineWidth / 2; // Offset to push marks outside image area
            
            ctx.beginPath();
            
            imagePositions.forEach(pos => {
                // Top-left corner - positioned outside the image
                const tlX = pos.x - offset;
                const tlY = pos.y - offset;
                ctx.moveTo(tlX - markLength, tlY);
                ctx.lineTo(tlX + markLength, tlY);
                ctx.moveTo(tlX, tlY - markLength);
                ctx.lineTo(tlX, tlY + markLength);
                
                // Top-right corner - positioned outside the image
                const trX = pos.x + pos.width + offset;
                const trY = pos.y - offset;
                ctx.moveTo(trX - markLength, trY);
                ctx.lineTo(trX + markLength, trY);
                ctx.moveTo(trX, trY - markLength);
                ctx.lineTo(trX, trY + markLength);
                
                // Bottom-left corner - positioned outside the image
                const blX = pos.x - offset;
                const blY = pos.y + pos.height + offset;
                ctx.moveTo(blX - markLength, blY);
                ctx.lineTo(blX + markLength, blY);
                ctx.moveTo(blX, blY - markLength);
                ctx.lineTo(blX, blY + markLength);
                
                // Bottom-right corner - positioned outside the image
                const brX = pos.x + pos.width + offset;
                const brY = pos.y + pos.height + offset;
                ctx.moveTo(brX - markLength, brY);
                ctx.lineTo(brX + markLength, brY);
                ctx.moveTo(brX, brY - markLength);
                ctx.lineTo(brX, brY + markLength);
            });
            
            ctx.stroke();
        }

        drawGridHelperLinesAligned(ctx, imagePositions) {
            ctx.save();
            ctx.strokeStyle = ctx.strokeStyle + '40'; // Make semi-transparent
            ctx.beginPath();
            
            // Calculate offset to position grid lines outside image area
            const offset = ctx.lineWidth / 2;
            
            // Draw rectangles positioned outside each image boundary
            imagePositions.forEach(pos => {
                const rectX = pos.x - offset;
                const rectY = pos.y - offset;
                const rectWidth = pos.width + (2 * offset);
                const rectHeight = pos.height + (2 * offset);
                ctx.rect(rectX, rectY, rectWidth, rectHeight);
            });
            
            ctx.stroke();
            ctx.restore();
        }

        async useGalleryImages() {
            // Use images from gallery if available
            if (this.galleryImages && this.galleryImages.length > 0) {
                let addedCount = 0;
                
                for (const imageData of this.galleryImages) {
                    try {
                        // Convert data URL to File object
                        const file = await this.dataURLToFile(imageData.data, imageData.filename);
                        if (file) {
                            this.addImageToPrintList(file);
                            addedCount++;
                        }
                    } catch (error) {
                        console.error('Error converting gallery image:', error);
                    }
                }
                
                if (addedCount > 0) {
                    this.showToast(`✅ Đã thêm ${addedCount} ảnh từ kho vào danh sách in`, 'success');
                    // Switch to print tab to show added images
                    this.switchToTab('print');
                } else {
                    this.showToast('Không thể thêm ảnh từ kho. Có lỗi xảy ra.', 'error');
                }
            } else {
                this.showToast('Kho ảnh trống. Hãy thêm ảnh vào kho trước.', 'warning');
            }
        }

        // Helper function to convert data URL to File object
        async dataURLToFile(dataURL, filename) {
            try {
                const response = await fetch(dataURL);
                const blob = await response.blob();
                
                // Create file with proper MIME type
                const mimeType = dataURL.split(',')[0].split(':')[1].split(';')[0];
                const file = new File([blob], filename, { 
                    type: mimeType,
                    lastModified: Date.now()
                });
                
                return file;
            } catch (error) {
                console.error('Error converting data URL to file:', error);
                return null;
            }
        }

        // Template Polaroid functionality
        initializeTemplateMode() {
            console.log('🔧 Initializing Template Mode...');
            
            // Initialize template data with configuration
            this.templateData = {
                images: [],
                currentIndex: 0,
                config: {
                    dpi: 300,
                    polaroidSizeCm: { width: 5.5, height: 8.5 },
                    border: {
                        topPx: 50,
                        leftPx: 45,
                        rightPx: 45,
                        bottomCaptionPx: 175
                    },
                    fitMode: 'cover', // 'contain' or 'cover'
                    safeAreaPx: 0,
                    bgColor: '#FFFFFF',
                    overlayFrame: false,
                    caption: {
                        text: '',
                        fontFamily: 'Arial',
                        fontSizePx: 16,
                        color: '#000000',
                        align: 'center', // 'center', 'left', 'right'
                        marginTopPx: 10
                    }
                }
            };
            
            // Setup event listeners
            this.setupTemplateEventListeners();
            
            // Update UI
            this.updateTemplateUI();
            this.updateTemplateSpecs();
        }

        setupTemplateEventListeners() {
            // File input
            const templateFileInput = document.getElementById('templateFileInput');
            if (templateFileInput) {
                templateFileInput.addEventListener('change', (e) => {
                    this.handleTemplateFileSelect(e.target.files);
                });
            }

            // Setup compact tabs functionality
            this.setupCompactTemplateTabs();

            // Configuration controls
            this.setupTemplateConfigListeners();

            // Navigation buttons
            const templatePrevBtn = document.getElementById('templatePrevBtn');
            const templateNextBtn = document.getElementById('templateNextBtn');
            if (templatePrevBtn) {
                templatePrevBtn.addEventListener('click', () => this.navigateTemplate(-1));
            }
            if (templateNextBtn) {
                templateNextBtn.addEventListener('click', () => this.navigateTemplate(1));
            }

            // Crop controls
            const templateCropReset = document.getElementById('templateCropReset');
            const templateCropCenter = document.getElementById('templateCropCenter');
            const templateCropFit = document.getElementById('templateCropFit');
            
            if (templateCropReset) {
                templateCropReset.addEventListener('click', () => this.resetTemplateCrop());
            }
            if (templateCropCenter) {
                templateCropCenter.addEventListener('click', () => this.centerTemplateCrop());
            }
            if (templateCropFit) {
                templateCropFit.addEventListener('click', () => this.fitTemplateCrop());
            }
            
            // Crop edit button
            const templateCropEdit = document.getElementById('templateCropEdit');
            console.log('🔍 Looking for templateCropEdit button:', templateCropEdit);
            if (templateCropEdit) {
                templateCropEdit.addEventListener('click', (e) => {
                    console.log('✂️ Template Crop Edit button clicked!', e);
                    console.log('Current templateData:', this.templateData);
                    console.log('Images length:', this.templateData?.images?.length);
                    this.openTemplateCropEditor();
                });
                console.log('✅ templateCropEdit event listener added successfully');
            } else {
                console.error('❌ templateCropEdit button not found!');
            }

            // Export buttons
            const exportCurrentPolaroid = document.getElementById('exportCurrentPolaroid');
            const exportAllPolaroids = document.getElementById('exportAllPolaroids');
            const exportAllIndividual = document.getElementById('exportAllIndividual');
            
            if (exportCurrentPolaroid) {
                exportCurrentPolaroid.addEventListener('click', () => this.exportCurrentPolaroid());
            }
            if (exportAllPolaroids) {
                exportAllPolaroids.addEventListener('click', () => this.exportAllPolaroids());
            }
            if (exportAllIndividual) {
                exportAllIndividual.addEventListener('click', () => this.exportAllIndividualFiles());
            }

            // Reset button
            const resetTemplateDefaults = document.getElementById('resetTemplateDefaults');
            if (resetTemplateDefaults) {
                resetTemplateDefaults.addEventListener('click', () => this.resetTemplateDefaults());
            }
        }

        setupCompactTemplateTabs() {
            console.log('🏷️ Setting up compact template tabs...');
            
            // Get all tab buttons and content
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');
            
            if (tabButtons.length === 0 || tabContents.length === 0) {
                console.warn('⚠️ Tab elements not found, skipping tab setup');
                return;
            }
            
            // Add click listeners to tab buttons
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.dataset.tab;
                    console.log('🏷️ Switching to tab:', targetTab);
                    
                    // Remove active class from all buttons and contents
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    // Add active class to clicked button and corresponding content
                    button.classList.add('active');
                    const targetContent = document.querySelector(`[data-tab="${targetTab}"].tab-content`);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                    
                    // Update quick specs when switching tabs
                    this.updateQuickSpecs();
                });
            });
            
            console.log('✅ Compact tabs setup complete');
        }

        initializeBorderTemplateMode() {
            console.log('🔧 Initializing Border Template Mode...');
            
            // Setup event listeners for border template export buttons
            const exportCurrentBorderTemplate = document.getElementById('exportCurrentBorderTemplate');
            const exportAllBorderTemplates = document.getElementById('exportAllBorderTemplates');
            const exportAllBorderIndividual = document.getElementById('exportAllBorderIndividual');
            
            if (exportCurrentBorderTemplate) {
                exportCurrentBorderTemplate.addEventListener('click', () => this.exportCurrentBorderTemplate());
            }
            if (exportAllBorderTemplates) {
                exportAllBorderTemplates.addEventListener('click', () => this.exportAllBorderTemplates());
            }
            if (exportAllBorderIndividual) {
                exportAllBorderIndividual.addEventListener('click', () => this.exportAllBorderIndividual());
            }
            
            console.log('✅ Border Template Mode initialized');
        }

        initializeStripTemplateMode() {
            console.log('🔧 Initializing Strip Template Mode...');
            
            // Setup event listeners for strip template export buttons
            const exportCurrentStripTemplate = document.getElementById('exportCurrentStripTemplate');
            const exportAllStripTemplates = document.getElementById('exportAllStripTemplates');
            const exportAllStripIndividual = document.getElementById('exportAllStripIndividual');
            
            if (exportCurrentStripTemplate) {
                exportCurrentStripTemplate.addEventListener('click', () => this.exportCurrentStripTemplate());
            }
            if (exportAllStripTemplates) {
                exportAllStripTemplates.addEventListener('click', () => this.exportAllStripTemplates());
            }
            if (exportAllStripIndividual) {
                exportAllStripIndividual.addEventListener('click', () => this.exportAllStripIndividual());
            }
            
            console.log('✅ Strip Template Mode initialized');
        }

        updateQuickSpecs() {
            const quickSpecs = document.getElementById('quickSpecs');
            if (!quickSpecs) return;
            
            const config = this.templateData.config;
            const dimensions = this.calculatePolaroidDimensions();
            
            if (dimensions.isValid && config) {
                const aspectRatio = (config.polaroidSizeCm.width / config.polaroidSizeCm.height).toFixed(2);
                quickSpecs.textContent = `${config.polaroidSizeCm.width}×${config.polaroidSizeCm.height}cm • ${config.dpi} DPI • 1:${aspectRatio}`;
            }
        }

        setupTemplateConfigListeners() {
            // DPI and size controls
            const templateDPI = document.getElementById('templateDPI');
            const templateWidth = document.getElementById('templateWidth');
            const templateHeight = document.getElementById('templateHeight');

            if (templateDPI) {
                templateDPI.addEventListener('change', (e) => {
                    this.templateData.config.dpi = parseInt(e.target.value);
                    this.updateTemplateSpecs();
                    this.updateQuickSpecs();
                    this.reprocessAllTemplateImages();
                });
            }

            if (templateWidth) {
                templateWidth.addEventListener('input', (e) => {
                    this.templateData.config.polaroidSizeCm.width = parseFloat(e.target.value);
                    this.updateTemplateSpecs();
                    this.updateQuickSpecs();
                    this.reprocessAllTemplateImages();
                });
            }

            if (templateHeight) {
                templateHeight.addEventListener('input', (e) => {
                    this.templateData.config.polaroidSizeCm.height = parseFloat(e.target.value);
                    this.updateTemplateSpecs();
                    this.updateQuickSpecs();
                    this.reprocessAllTemplateImages();
                });
            }

            // Border controls - sliders sync with number inputs
            this.setupBorderControls();

            // Advanced settings
            const templateFitMode = document.getElementById('templateFitMode');
            const templateSafeArea = document.getElementById('templateSafeArea');
            const templateBgColor = document.getElementById('templateBgColor');
            const templateOverlay = document.getElementById('templateOverlay');

            if (templateFitMode) {
                templateFitMode.addEventListener('change', (e) => {
                    this.templateData.config.fitMode = e.target.value;
                    this.reprocessAllTemplateImages();
                });
            }

            if (templateSafeArea) {
                templateSafeArea.addEventListener('input', (e) => {
                    this.templateData.config.safeAreaPx = parseInt(e.target.value);
                    this.updateTemplateSpecs();
                    this.reprocessAllTemplateImages();
                });
            }

            if (templateBgColor) {
                templateBgColor.addEventListener('change', (e) => {
                    this.templateData.config.bgColor = e.target.value;
                    this.reprocessAllTemplateImages();
                });
            }

            if (templateOverlay) {
                templateOverlay.addEventListener('change', (e) => {
                    this.templateData.config.overlayFrame = e.target.checked;
                    this.reprocessAllTemplateImages();
                });
            }

            // Caption controls
            this.setupCaptionControls();
        }

        setupBorderControls() {
            const borderControls = [
                { slider: 'borderTop', number: 'borderTopValue', key: 'topPx' },
                { slider: 'borderLeft', number: 'borderLeftValue', key: 'leftPx' },
                { slider: 'borderRight', number: 'borderRightValue', key: 'rightPx' },
                { slider: 'borderBottom', number: 'borderBottomValue', key: 'bottomCaptionPx' }
            ];

            borderControls.forEach(control => {
                const slider = document.getElementById(control.slider);
                const numberInput = document.getElementById(control.number);

                if (slider && numberInput) {
                    // Sync slider to number input
                    slider.addEventListener('input', (e) => {
                        const value = parseInt(e.target.value);
                        numberInput.value = value;
                        this.templateData.config.border[control.key] = value;
                        this.updateTemplateSpecs();
                        this.reprocessAllTemplateImages();
                    });

                    // Sync number input to slider
                    numberInput.addEventListener('input', (e) => {
                        const value = parseInt(e.target.value);
                        slider.value = value;
                        this.templateData.config.border[control.key] = value;
                        this.updateTemplateSpecs();
                        this.reprocessAllTemplateImages();
                    });
                }
            });
        }

        setupCaptionControls() {
            const captionText = document.getElementById('captionText');
            const captionFont = document.getElementById('captionFont');
            const captionFontSize = document.getElementById('captionFontSize');
            const captionColor = document.getElementById('captionColor');
            const captionAlign = document.getElementById('captionAlign');
            const captionMarginTop = document.getElementById('captionMarginTop');

            if (captionText) {
                captionText.addEventListener('input', (e) => {
                    this.templateData.config.caption.text = e.target.value;
                    this.reprocessAllTemplateImages();
                });
            }

            if (captionFont) {
                captionFont.addEventListener('change', (e) => {
                    this.templateData.config.caption.fontFamily = e.target.value;
                    this.reprocessAllTemplateImages();
                });
            }

            if (captionFontSize) {
                captionFontSize.addEventListener('input', (e) => {
                    this.templateData.config.caption.fontSizePx = parseInt(e.target.value);
                    this.reprocessAllTemplateImages();
                });
            }

            if (captionColor) {
                captionColor.addEventListener('change', (e) => {
                    this.templateData.config.caption.color = e.target.value;
                    this.reprocessAllTemplateImages();
                });
            }

            if (captionAlign) {
                captionAlign.addEventListener('change', (e) => {
                    this.templateData.config.caption.align = e.target.value;
                    this.reprocessAllTemplateImages();
                });
            }

            if (captionMarginTop) {
                captionMarginTop.addEventListener('input', (e) => {
                    this.templateData.config.caption.marginTopPx = parseInt(e.target.value);
                    this.reprocessAllTemplateImages();
                });
            }
        }

        calculatePolaroidDimensions() {
            const config = this.templateData.config;
            // CÔNG THỨC CHÍNH XÁC: (kích_thước_cm ÷ 2.54) × 300
            // Cố định DPI = 300 (KHÔNG BAO GIỜ thay đổi)
            const DPI = 300;
            const sizeCm = config.polaroidSizeCm;
            const border = config.border;

            // LUÔN sử dụng Math.round() cho pixel cuối cùng
            const canvasW = Math.round((sizeCm.width / 2.54) * DPI);
            const canvasH = Math.round((sizeCm.height / 2.54) * DPI);

            // Calculate image area
            const imageW = canvasW - (border.leftPx + border.rightPx);
            const imageH = canvasH - (border.topPx + border.bottomCaptionPx);

            // Apply safe area
            const safeImageW = Math.max(0, imageW - (config.safeAreaPx * 2));
            const safeImageH = Math.max(0, imageH - (config.safeAreaPx * 2));

            return {
                canvasW,
                canvasH,
                imageW,
                imageH,
                safeImageW,
                safeImageH,
                isValid: safeImageW > 0 && safeImageH > 0
            };
        }

        updateTemplateSpecs() {
            const dimensions = this.calculatePolaroidDimensions();
            const config = this.templateData.config;
            
            // Update crop modal specs if open
            this.updateTemplateCropModalSpecs();
            
            const specsDisplay = document.getElementById('currentSpecsDisplay');
            if (!specsDisplay) return;

            const bgColorName = config.bgColor === '#FFFFFF' ? 'Trắng' : config.bgColor;
            
            specsDisplay.innerHTML = `
                <div class="spec-row">
                    <span class="spec-key">Canvas:</span>
                    <span class="spec-value">${dimensions.canvasW} × ${dimensions.canvasH} px</span>
                </div>
                <div class="spec-row">
                    <span class="spec-key">Vùng ảnh:</span>
                    <span class="spec-value ${!dimensions.isValid ? 'text-red-600' : ''}">${dimensions.safeImageW} × ${dimensions.safeImageH} px</span>
                </div>
                <div class="spec-row">
                    <span class="spec-key">DPI:</span>
                    <span class="spec-value">${config.dpi}</span>
                </div>
                <div class="spec-row">
                    <span class="spec-key">Fit Mode:</span>
                    <span class="spec-value">${config.fitMode === 'cover' ? 'Cover (crop)' : 'Contain (fit)'}</span>
                </div>
                <div class="spec-row">
                    <span class="spec-key">Màu nền:</span>
                    <span class="spec-value">${bgColorName}</span>
                </div>
                ${!dimensions.isValid ? '<div style="color: #ef4444; font-weight: 600; margin-top: 8px;">⚠️ Viền quá lớn, không còn vùng ảnh khả dụng!</div>' : ''}
            `;
        }

        resetTemplateDefaults() {
            // Reset to default values
            const defaults = {
                dpi: 300,
                polaroidSizeCm: { width: 6, height: 9 },
                border: { topPx: 20, leftPx: 20, rightPx: 20, bottomCaptionPx: 178 },
                fitMode: 'cover',
                safeAreaPx: 0,
                bgColor: '#FFFFFF',
                overlayFrame: false,
                caption: {
                    text: '',
                    fontFamily: 'Arial',
                    fontSizePx: 16,
                    color: '#000000',
                    align: 'center',
                    marginTopPx: 10
                }
            };

            this.templateData.config = { ...defaults };

            // Update UI controls
            this.updateTemplateConfigUI();
            this.updateTemplateSpecs();
            this.reprocessAllTemplateImages();
            
            this.showToast('↺ Đã khôi phục cài đặt mặc định', 'info');
        }
        
        setupTemplateCropModalListeners() {
            console.log('🔧 Setting up enhanced template crop modal listeners...');
            
            // Close button
            const closeBtn = document.getElementById('closeTemplateCrop');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    console.log('🔲 Close button clicked');
                    document.getElementById('templateCropModal').style.display = 'none';
                    this.templateCropData = null;
                });
                console.log('✅ Close button listener added');
            }
            
            // Cancel button
            const cancelBtn = document.getElementById('cancelTemplateCrop');
            if (cancelBtn) {
                const newCancelBtn = cancelBtn.cloneNode(true);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                
                newCancelBtn.addEventListener('click', () => {
                    console.log('❌ Cancel button clicked');
                    document.getElementById('templateCropModal').style.display = 'none';
                    this.templateCropData = null;
                });
                console.log('✅ Cancel button listener added');
            }
            
            // Skip button
            const skipBtn = document.getElementById('skipTemplateImage');
            if (skipBtn) {
                const newSkipBtn = skipBtn.cloneNode(true);
                skipBtn.parentNode.replaceChild(newSkipBtn, skipBtn);
                
                newSkipBtn.addEventListener('click', () => {
                    console.log('⏭️ Skip button clicked');
                    document.getElementById('templateCropModal').style.display = 'none';
                    this.templateCropData = null;
                });
                console.log('✅ Skip button listener added');
            }
            
            // Crop button
            const cropBtn = document.getElementById('cropTemplateImage');
            if (cropBtn) {
                const newCropBtn = cropBtn.cloneNode(true);
                cropBtn.parentNode.replaceChild(newCropBtn, cropBtn);
                
                newCropBtn.addEventListener('click', () => {
                    console.log('✂️ Crop button clicked');
                    this.cropCurrentTemplateImage();
                });
                console.log('✅ Crop button listener added');
            }
            
            // Enhanced interface controls
            this.setupEnhancedTemplateCropControls();
            
            console.log('🎯 All enhanced modal listeners setup complete');
        }

        setupEnhancedTemplateCropControls() {
            console.log('🔧 Setting up enhanced template crop controls...');

            // Template settings change handlers
            const templateCropMode = document.getElementById('templateCropMode');
            if (templateCropMode) {
                templateCropMode.addEventListener('change', () => {
                    console.log('🎯 Crop mode changed to:', templateCropMode.value);
                    this.updateTemplateCropMode(templateCropMode.value);
                });
            }

            const templateCropDPI = document.getElementById('templateCropDPI');
            if (templateCropDPI) {
                templateCropDPI.addEventListener('change', () => {
                    console.log('📊 DPI changed to:', templateCropDPI.value);
                    this.updateTemplateDPI(templateCropDPI.value);
                });
            }

            const templateCropBackground = document.getElementById('templateCropBackground');
            if (templateCropBackground) {
                templateCropBackground.addEventListener('change', () => {
                    console.log('🎨 Background mode changed to:', templateCropBackground.value);
                    this.updateTemplateBgMode(templateCropBackground.value);
                });
            }

            // Enhanced Template Crop Section - Size Cards Event Listeners
            console.log('⚙️ Thiết lập event listeners cho Template Crop Section...');
            
            // Size card selection - Enhanced design
            const sizeCardsLarge = document.querySelectorAll('.size-card-large');
            const sizeCardsCompact = document.querySelectorAll('.size-card-compact');
            
            // Enhanced size cards (large)
            sizeCardsLarge.forEach(card => {
                card.addEventListener('click', () => {
                    // Remove active from all large cards
                    sizeCardsLarge.forEach(c => c.classList.remove('active'));
                    // Remove active from all compact cards  
                    sizeCardsCompact.forEach(c => c.classList.remove('active'));
                    
                    // Add active to clicked card
                    card.classList.add('active');
                    
                    const sizeValue = card.dataset.size;
                    console.log('✅ Chọn kích thước từ card lớn:', sizeValue);
                    if (this.updateTemplateCropInfo) this.updateTemplateCropInfo(sizeValue);
                    if (window.updateProgressSteps) window.updateProgressSteps(2); // Move to step 2 - Upload
                });
            });
            
            // Compact size cards  
            sizeCardsCompact.forEach(card => {
                card.addEventListener('click', () => {
                    // Remove active from all cards
                    sizeCardsLarge.forEach(c => c.classList.remove('active'));
                    sizeCardsCompact.forEach(c => c.classList.remove('active'));
                    
                    // Add active to clicked card
                    card.classList.add('active');
                    
                    const sizeValue = card.dataset.size;
                    console.log('✅ Chọn kích thước từ card nhỏ:', sizeValue);
                    if (this.updateTemplateCropInfo) this.updateTemplateCropInfo(sizeValue);
                    if (window.updateProgressSteps) window.updateProgressSteps(2);
                });
            });

            // Upload area interactions
            const uploadAreaModern = document.querySelector('.upload-area-modern');
            if (uploadAreaModern) {
                // Drag and drop handlers
                uploadAreaModern.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadAreaModern.classList.add('drag-over');
                });

                uploadAreaModern.addEventListener('dragleave', () => {
                    uploadAreaModern.classList.remove('drag-over');
                });

                uploadAreaModern.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadAreaModern.classList.remove('drag-over');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        if (window.handleTemplateCropUpload) window.handleTemplateCropUpload(files);
                        if (window.updateProgressSteps) window.updateProgressSteps(3); // Move to processing
                    }
                });

                // Click to upload
                uploadAreaModern.addEventListener('click', () => {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.multiple = true;
                    fileInput.accept = 'image/*';
                    fileInput.onchange = (e) => {
                        if (e.target.files.length > 0) {
                            if (window.handleTemplateCropUpload) window.handleTemplateCropUpload(e.target.files);
                            if (window.updateProgressSteps) window.updateProgressSteps(3);
                        }
                    };
                    fileInput.click();
                });
            }

            console.log('✅ Đã thiết lập Template Crop event listeners thành công');

            // Control buttons
            const templateCenter = document.getElementById('templateCenter');
            if (templateCenter) {
                templateCenter.addEventListener('click', () => {
                    console.log('📍 Center crop selection');
                    this.centerTemplateCropSelection();
                });
            }

            const templateReset = document.getElementById('templateReset');
            if (templateReset) {
                templateReset.addEventListener('click', () => {
                    console.log('🔄 Reset crop selection');
                    this.resetTemplateCropSelection();
                });
            }

            // Toggle buttons
            const templateGrid = document.getElementById('templateGrid');
            if (templateGrid) {
                templateGrid.addEventListener('click', () => {
                    templateGrid.classList.toggle('active');
                    this.toggleTemplateGrid(templateGrid.classList.contains('active'));
                });
            }

            const templateGuides = document.getElementById('templateGuides');
            if (templateGuides) {
                templateGuides.addEventListener('click', () => {
                    templateGuides.classList.toggle('active');
                    this.toggleTemplateGuides(templateGuides.classList.contains('active'));
                });
            }

            const templateBorderPreview = document.getElementById('templateBorderPreview');
            if (templateBorderPreview) {
                templateBorderPreview.addEventListener('click', () => {
                    templateBorderPreview.classList.toggle('active');
                    this.toggleTemplateBorderPreview(templateBorderPreview.classList.contains('active'));
                });
            }

            // Workspace controls
            const templateFitToScreen = document.getElementById('templateFitToScreen');
            if (templateFitToScreen) {
                templateFitToScreen.addEventListener('click', () => {
                    console.log('🔍 Fit to screen');
                    this.fitTemplateToScreen();
                });
            }

            const templateActualSize = document.getElementById('templateActualSize');
            if (templateActualSize) {
                templateActualSize.addEventListener('click', () => {
                    console.log('📏 Actual size');
                    this.showTemplateActualSize();
                });
            }

            // Process mode radio buttons
            const processRadios = document.querySelectorAll('input[name="templateProcessMode"]');
            processRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        console.log('⚡ Process mode changed to:', radio.value);
                        // Update mode card active state
                        document.querySelectorAll('.mode-card').forEach(card => card.classList.remove('active'));
                        radio.closest('.mode-card').classList.add('active');
                        this.updateTemplateProcessMode(radio.value);
                    }
                });
            });

            console.log('✅ Enhanced controls setup complete');
        }
        
        updateTemplateCropModalSpecs() {
            const dimensions = this.calculatePolaroidDimensions();
            const config = this.templateData.config;
            
            // Update current size
            const currentSizeEl = document.getElementById('templateCurrentSize');
            if (currentSizeEl) {
                currentSizeEl.textContent = `${config.polaroidSizeCm.width}×${config.polaroidSizeCm.height} cm`;
            }
            
            // Update borders
            const currentBordersEl = document.getElementById('templateCurrentBorders');
            if (currentBordersEl) {
                const b = config.border;
                currentBordersEl.textContent = `${b.topPx}-${b.leftPx}-${b.rightPx}-${b.bottomCaptionPx}px`;
            }
            
            // Calculate ideal aspect ratio
            const idealRatioEl = document.getElementById('templateIdealRatio');
            if (idealRatioEl && dimensions.isValid) {
                const imageAreaW = dimensions.canvasW - config.border.leftPx - config.border.rightPx;
                const imageAreaH = dimensions.canvasH - config.border.topPx - config.border.bottomCaptionPx;
                const aspectRatio = imageAreaW / imageAreaH;
                const ratioText = aspectRatio > 1 ? `${aspectRatio.toFixed(2)}:1 (Landscape)` : `1:${(1/aspectRatio).toFixed(2)} (Portrait)`;
                idealRatioEl.textContent = ratioText;
            }
        }

        updateTemplateConfigUI() {
            const config = this.templateData.config;

            // Update basic settings
            const templateDPI = document.getElementById('templateDPI');
            const templateWidth = document.getElementById('templateWidth');
            const templateHeight = document.getElementById('templateHeight');

            if (templateDPI) templateDPI.value = config.dpi;
            if (templateWidth) templateWidth.value = config.polaroidSizeCm.width;
            if (templateHeight) templateHeight.value = config.polaroidSizeCm.height;

            // Update border controls
            const borderControls = [
                { slider: 'borderTop', number: 'borderTopValue', value: config.border.topPx },
                { slider: 'borderLeft', number: 'borderLeftValue', value: config.border.leftPx },
                { slider: 'borderRight', number: 'borderRightValue', value: config.border.rightPx },
                { slider: 'borderBottom', number: 'borderBottomValue', value: config.border.bottomCaptionPx }
            ];

            borderControls.forEach(control => {
                const slider = document.getElementById(control.slider);
                const numberInput = document.getElementById(control.number);
                if (slider) slider.value = control.value;
                if (numberInput) numberInput.value = control.value;
            });

            // Update advanced settings
            const templateFitMode = document.getElementById('templateFitMode');
            const templateSafeArea = document.getElementById('templateSafeArea');
            const templateBgColor = document.getElementById('templateBgColor');
            const templateOverlay = document.getElementById('templateOverlay');

            if (templateFitMode) templateFitMode.value = config.fitMode;
            if (templateSafeArea) templateSafeArea.value = config.safeAreaPx;
            if (templateBgColor) templateBgColor.value = config.bgColor;
            if (templateOverlay) templateOverlay.checked = config.overlayFrame;

            // Update caption settings
            const captionText = document.getElementById('captionText');
            const captionFont = document.getElementById('captionFont');
            const captionFontSize = document.getElementById('captionFontSize');
            const captionColor = document.getElementById('captionColor');
            const captionAlign = document.getElementById('captionAlign');
            const captionMarginTop = document.getElementById('captionMarginTop');

            if (captionText) captionText.value = config.caption.text;
            if (captionFont) captionFont.value = config.caption.fontFamily;
            if (captionFontSize) captionFontSize.value = config.caption.fontSizePx;
            if (captionColor) captionColor.value = config.caption.color;
            if (captionAlign) captionAlign.value = config.caption.align;
            if (captionMarginTop) captionMarginTop.value = config.caption.marginTopPx;
        }

        // Enhanced Template Crop Control Functions
        updateTemplateCropMode(mode) {
            console.log('🎯 Updating crop mode to:', mode);
            // Store the crop mode for later use during cropping
            if (!this.templateCropData) this.templateCropData = {};
            this.templateCropData.cropMode = mode;
        }

        updateTemplateDPI(dpi) {
            console.log('📊 Updating DPI to:', dpi);
            if (!this.templateCropData) this.templateCropData = {};
            this.templateCropData.dpi = parseInt(dpi);
            this.updateEnhancedTemplateSpecs();
        }

        updateTemplateBgMode(bgMode) {
            console.log('🎨 Updating background mode to:', bgMode);
            if (!this.templateCropData) this.templateCropData = {};
            this.templateCropData.backgroundMode = bgMode;
        }

        updateTemplateProcessMode(processMode) {
            console.log('⚡ Updating process mode to:', processMode);
            if (!this.templateCropData) this.templateCropData = {};
            this.templateCropData.processMode = processMode;
        }

        centerTemplateCropSelection() {
            const canvas = document.getElementById('templateCropCanvas');
            const selection = document.getElementById('templateCropSelection');
            if (!canvas || !selection) return;

            const canvasRect = canvas.getBoundingClientRect();
            const container = document.getElementById('templateCropContainer');
            const containerRect = container.getBoundingClientRect();

            // Calculate center position
            const centerX = (canvasRect.width - selection.offsetWidth) / 2;
            const centerY = (canvasRect.height - selection.offsetHeight) / 2;

            selection.style.left = centerX + 'px';
            selection.style.top = centerY + 'px';

            console.log('📍 Crop selection centered');
        }

        resetTemplateCropSelection() {
            const canvas = document.getElementById('templateCropCanvas');
            const selection = document.getElementById('templateCropSelection');
            if (!canvas || !selection) return;

            // Reset to initial size and position based on template aspect ratio
            const config = this.templateData?.config;
            if (!config) return;

            const dimensions = this.calculatePolaroidDimensions();
            if (!dimensions.isValid) return;

            // Calculate ideal crop area
            const imageAreaW = dimensions.canvasW - config.border.leftPx - config.border.rightPx;
            const imageAreaH = dimensions.canvasH - config.border.topPx - config.border.bottomCaptionPx;
            const aspectRatio = imageAreaW / imageAreaH;

            const canvasRect = canvas.getBoundingClientRect();
            let selectionW, selectionH;

            if (canvasRect.width / canvasRect.height > aspectRatio) {
                selectionH = Math.min(canvasRect.height * 0.8, 400);
                selectionW = selectionH * aspectRatio;
            } else {
                selectionW = Math.min(canvasRect.width * 0.8, 600);
                selectionH = selectionW / aspectRatio;
            }

            selection.style.width = selectionW + 'px';
            selection.style.height = selectionH + 'px';
            
            // Center the selection
            const centerX = (canvasRect.width - selectionW) / 2;
            const centerY = (canvasRect.height - selectionH) / 2;
            selection.style.left = centerX + 'px';
            selection.style.top = centerY + 'px';

            console.log('🔄 Crop selection reset to optimal size');
            this.updateTemplateSelectionInfo();
        }

        toggleTemplateGrid(enabled) {
            console.log('📏 Grid overlay:', enabled ? 'enabled' : 'disabled');
            const canvas = document.getElementById('templateCropCanvas');
            if (!canvas) return;

            if (enabled) {
                canvas.classList.add('show-grid');
            } else {
                canvas.classList.remove('show-grid');
            }
        }

        toggleTemplateGuides(enabled) {
            console.log('📐 Guides overlay:', enabled ? 'enabled' : 'disabled');
            const container = document.getElementById('templateCropContainer');
            if (!container) return;

            if (enabled) {
                container.classList.add('show-guides');
            } else {
                container.classList.remove('show-guides');
            }
        }

        toggleTemplateBorderPreview(enabled) {
            console.log('🖼️ Border preview:', enabled ? 'enabled' : 'disabled');
            const selection = document.getElementById('templateCropSelection');
            if (!selection) return;

            if (enabled) {
                selection.classList.add('show-border-preview');
                this.drawTemplateBorderPreview();
            } else {
                selection.classList.remove('show-border-preview');
            }
        }

        fitTemplateToScreen() {
            const canvas = document.getElementById('templateCropCanvas');
            const container = document.getElementById('templateCropContainer');
            if (!canvas || !container) return;

            const containerRect = container.getBoundingClientRect();
            const maxWidth = containerRect.width - 40; // padding
            const maxHeight = containerRect.height - 40;

            const img = canvas.imageData;
            if (!img) return;

            const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
            const newWidth = img.width * scale;
            const newHeight = img.height * scale;

            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';

            console.log('🔍 Canvas fitted to screen');
        }

        showTemplateActualSize() {
            const canvas = document.getElementById('templateCropCanvas');
            if (!canvas) return;

            const img = canvas.imageData;
            if (!img) return;

            canvas.style.width = img.width + 'px';
            canvas.style.height = img.height + 'px';

            console.log('📏 Canvas set to actual size');
        }

        updateEnhancedTemplateSpecs() {
            const config = this.templateData?.config;
            if (!config) return;

            const dimensions = this.calculatePolaroidDimensions();
            
            // Update size details in sidebar
            const sizeDetail = document.getElementById('templateCurrentSizeDetail');
            if (sizeDetail) {
                sizeDetail.textContent = `${config.polaroidSizeCm.width}×${config.polaroidSizeCm.height} cm`;
            }

            const pixelDetail = document.getElementById('templateCurrentPixels');
            if (pixelDetail && dimensions.isValid) {
                const dpi = this.templateCropData?.dpi || 300;
                const pixelW = Math.round((config.polaroidSizeCm.width / 2.54) * dpi);
                const pixelH = Math.round((config.polaroidSizeCm.height / 2.54) * dpi);
                pixelDetail.textContent = `${pixelW}×${pixelH}px`;
            }

            // Update aspect ratio
            const aspectRatioEl = document.getElementById('templateAspectRatio');
            if (aspectRatioEl && dimensions.isValid) {
                const imageAreaW = dimensions.canvasW - config.border.leftPx - config.border.rightPx;
                const imageAreaH = dimensions.canvasH - config.border.topPx - config.border.bottomCaptionPx;
                const ratio = imageAreaW / imageAreaH;
                aspectRatioEl.textContent = ratio > 1 ? `${ratio.toFixed(2)}:1` : `1:${(1/ratio).toFixed(2)}`;
            }

            // Update border info
            const borderTLR = document.getElementById('templateBorderTLR');
            const borderBottom = document.getElementById('templateBorderBottom');
            if (borderTLR) {
                borderTLR.textContent = `${config.border.topPx}-${config.border.leftPx}-${config.border.rightPx}px`;
            }
            if (borderBottom) {
                borderBottom.textContent = `${config.border.bottomCaptionPx}px`;
            }
        }

        updateTemplateSelectionInfo() {
            const selection = document.getElementById('templateCropSelection');
            const selectionSize = document.getElementById('templateSelectionSize');
            const selectionStatus = document.getElementById('templateSelectionStatus');
            
            if (!selection || !selectionSize) return;

            const width = Math.round(selection.offsetWidth);
            const height = Math.round(selection.offsetHeight);
            selectionSize.textContent = `${width}×${height}px`;

            if (selectionStatus) {
                const config = this.templateData?.config;
                if (config) {
                    const dimensions = this.calculatePolaroidDimensions();
                    if (dimensions.isValid) {
                        const imageAreaW = dimensions.canvasW - config.border.leftPx - config.border.rightPx;
                        const imageAreaH = dimensions.canvasH - config.border.topPx - config.border.bottomCaptionPx;
                        const idealRatio = imageAreaW / imageAreaH;
                        const currentRatio = width / height;
                        
                        const isCorrectRatio = Math.abs(idealRatio - currentRatio) < 0.01;
                        selectionStatus.textContent = isCorrectRatio ? '✅ Tỷ lệ chuẩn' : '⚠️ Tỷ lệ sai';
                        selectionStatus.style.background = isCorrectRatio ? '#d4edda' : '#f8d7da';
                        selectionStatus.style.color = isCorrectRatio ? '#155724' : '#721c24';
                    }
                }
            }
        }

        drawTemplateBorderPreview() {
            const miniPreview = document.getElementById('templateMiniPreview');
            if (!miniPreview) return;

            const config = this.templateData?.config;
            if (!config) return;

            const ctx = miniPreview.getContext('2d');
            const dimensions = this.calculatePolaroidDimensions();
            if (!dimensions.isValid) return;

            // Set mini preview size
            const scale = 0.3;
            miniPreview.width = dimensions.canvasW * scale;
            miniPreview.height = dimensions.canvasH * scale;

            // Draw Polaroid frame
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, miniPreview.width, miniPreview.height);

            // Draw image area
            const imageX = config.border.leftPx * scale;
            const imageY = config.border.topPx * scale;
            const imageW = (dimensions.canvasW - config.border.leftPx - config.border.rightPx) * scale;
            const imageH = (dimensions.canvasH - config.border.topPx - config.border.bottomCaptionPx) * scale;

            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(imageX, imageY, imageW, imageH);

            // Draw caption area
            const captionY = dimensions.canvasH - config.border.bottomCaptionPx;
            ctx.fillStyle = '#e8e8e8';
            ctx.fillRect(imageX, captionY * scale, imageW, config.border.bottomCaptionPx * scale);

            console.log('🖼️ Border preview drawn');
        }

        async handleTemplateFileSelect(files) {
            if (!files || files.length === 0) return;

            console.log(`📁 Processing ${files.length} files for template...`);
            this.showToast(`Đang xử lý ${files.length} ảnh...`, 'info');

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    const imageData = await this.processTemplateImage(file);
                    if (imageData) {
                        this.templateData.images.push(imageData);
                    }
                } catch (error) {
                    console.error('Error processing template image:', error);
                }
            }

            this.updateTemplateUI();
            this.showToast(`✅ Đã tải ${this.templateData.images.length} ảnh thành công`, 'success');
        }

        async processTemplateImage(file) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const imageData = {
                        file: file,
                        originalImage: img,
                        filename: file.name,
                        croppedDataURL: null,
                        cropSettings: {}
                    };
                    
                    // Process with current config
                    this.reprocessSingleTemplateImage(imageData);
                    resolve(imageData);
                };
                
                img.onerror = () => resolve(null);
                img.src = URL.createObjectURL(file);
            });
        }

        reprocessSingleTemplateImage(imageData) {
            if (!imageData || !imageData.originalImage) return;

            const dimensions = this.calculatePolaroidDimensions();
            if (!dimensions.isValid) return;

            const config = this.templateData.config;
            const img = imageData.originalImage;

            // Create canvas for image area only
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = dimensions.safeImageW;
            canvas.height = dimensions.safeImageH;

            // Calculate fit parameters
            const imgAspect = img.width / img.height;
            const targetAspect = dimensions.safeImageW / dimensions.safeImageH;

            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

            if (config.fitMode === 'contain') {
                // Contain mode - fit entire image with padding
                if (imgAspect > targetAspect) {
                    drawWidth = dimensions.safeImageW;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (dimensions.safeImageH - drawHeight) / 2;
                } else {
                    drawHeight = dimensions.safeImageH;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (dimensions.safeImageW - drawWidth) / 2;
                }
                
                // Fill background with template background color
                ctx.fillStyle = config.bgColor;
                ctx.fillRect(0, 0, dimensions.safeImageW, dimensions.safeImageH);
                
                ctx.drawImage(img, 0, 0, img.width, img.height, Math.round(offsetX), Math.round(offsetY), Math.round(drawWidth), Math.round(drawHeight));
            } else {
                // Cover mode - crop to fill
                if (imgAspect > targetAspect) {
                    drawHeight = img.height;
                    drawWidth = drawHeight * targetAspect;
                    offsetX = (img.width - drawWidth) / 2;
                } else {
                    drawWidth = img.width;
                    drawHeight = drawWidth / targetAspect;
                    offsetY = (img.height - drawHeight) / 2;
                }
                
                ctx.drawImage(img, Math.round(offsetX), Math.round(offsetY), Math.round(drawWidth), Math.round(drawHeight), 0, 0, dimensions.safeImageW, dimensions.safeImageH);
            }

            // Update image data
            imageData.croppedDataURL = canvas.toDataURL('image/jpeg', 1.0);
            imageData.cropSettings = { 
                offsetX: Math.round(offsetX), 
                offsetY: Math.round(offsetY), 
                drawWidth: Math.round(drawWidth), 
                drawHeight: Math.round(drawHeight), 
                mode: config.fitMode 
            };
        }

        async reprocessAllTemplateImages() {
            if (!this.templateData || !this.templateData.images) return;
            
            const dimensions = this.calculatePolaroidDimensions();
            if (!dimensions.isValid) {
                console.warn('Invalid template dimensions, skipping reprocess');
                return;
            }

            console.log('🔄 Reprocessing all template images with new config...');
            
            // Reprocess all images
            this.templateData.images.forEach(imageData => {
                this.reprocessSingleTemplateImage(imageData);
            });

            // Update all UI elements with real-time sync
            await this.updateTemplatePreview();
            await this.updateTemplateGallery();
        }

        updateTemplateUI() {
            // Check if templateData is initialized
            if (!this.templateData || !this.templateData.images) return;
            
            // Update image count
            const templateImageCount = document.getElementById('templateImageCount');
            if (templateImageCount) {
                templateImageCount.textContent = this.templateData.images.length;
            }

            // Update navigation info
            const templateNavInfo = document.getElementById('templateNavInfo');
            if (templateNavInfo) {
                const total = this.templateData.images.length;
                const current = total > 0 ? this.templateData.currentIndex + 1 : 0;
                templateNavInfo.textContent = `${current} / ${total}`;
            }

            // Update navigation buttons
            const templatePrevBtn = document.getElementById('templatePrevBtn');
            const templateNextBtn = document.getElementById('templateNextBtn');
            
            if (templatePrevBtn) {
                templatePrevBtn.disabled = this.templateData.currentIndex <= 0;
            }
            if (templateNextBtn) {
                templateNextBtn.disabled = this.templateData.currentIndex >= this.templateData.images.length - 1;
            }

            // Update preview and gallery with async
            this.updateTemplatePreview();
            this.updateTemplateGallery();
            
            // Show/hide crop controls
            const templateCropControls = document.getElementById('templateCropControls');
            if (templateCropControls) {
                templateCropControls.style.display = this.templateData.images.length > 0 ? 'block' : 'none';
            }
        }

        async updateTemplatePreview() {
            const polaroidImageArea = document.getElementById('polaroidImageArea');
            if (!polaroidImageArea) return;

            // Check if templateData is initialized
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                polaroidImageArea.innerHTML = '<div class="placeholder-text">Chờ ảnh...</div>';
                return;
            }

            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage || !currentImage.croppedDataURL) return;

            // Create full Polaroid preview that matches exactly with download
            try {
                const previewCanvas = await this.createPolaroidCanvas(currentImage);
                
                // Scale down for preview display while maintaining aspect ratio
                const maxPreviewWidth = 180; // Match CSS width
                const scale = maxPreviewWidth / previewCanvas.width;
                const previewHeight = previewCanvas.height * scale;
                
                // Convert to data URL for display
                const previewDataURL = previewCanvas.toDataURL('image/jpeg', 1.0);
                
                // Update preview with exact same image as download
                polaroidImageArea.innerHTML = `
                    <img src="${previewDataURL}" 
                         style="width: ${maxPreviewWidth}px; height: ${previewHeight}px; 
                                object-fit: contain; border-radius: 4px; 
                                max-width: 100%; max-height: 100%;">
                `;
            } catch (error) {
                console.error('Error creating preview:', error);
                // Fallback to basic preview
                polaroidImageArea.innerHTML = `<img src="${currentImage.croppedDataURL}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px;">`;
            }
        }

        async updateTemplateGallery() {
            const templateGrid = document.getElementById('templateGrid');
            if (!templateGrid) return;

            // Check if templateData is initialized
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                templateGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #6b7280; padding: 40px;">Chưa có ảnh nào</div>';
                return;
            }

            // Create gallery with full Polaroid previews
            const galleryItems = await Promise.all(this.templateData.images.map(async (imageData, index) => {
                try {
                    // Create mini Polaroid preview
                    const polaroidCanvas = await this.createPolaroidCanvas(imageData);
                    const previewDataURL = polaroidCanvas.toDataURL('image/jpeg', 1.0);
                    
                    return `
                        <div class="template-item ${index === this.templateData.currentIndex ? 'active' : ''}" onclick="imageConverter.selectTemplateImage(${index})">
                            <div class="template-item-preview">
                                <img src="${previewDataURL}" style="width: 100%; height: 100%; object-fit: contain; border-radius: 4px;">
                            </div>
                            <div class="template-item-name">${imageData.filename}</div>
                        </div>
                    `;
                } catch (error) {
                    console.error('Error creating gallery preview:', error);
                    // Fallback to basic preview
                    return `
                        <div class="template-item ${index === this.templateData.currentIndex ? 'active' : ''}" onclick="imageConverter.selectTemplateImage(${index})">
                            <div class="template-item-preview">
                                <img src="${imageData.croppedDataURL}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px;">
                            </div>
                            <div class="template-item-name">${imageData.filename}</div>
                        </div>
                    `;
                }
            }));

            templateGrid.innerHTML = galleryItems.join('');
        }

        selectTemplateImage(index) {
            if (!this.templateData || !this.templateData.images) return;
            
            if (index >= 0 && index < this.templateData.images.length) {
                this.templateData.currentIndex = index;
                this.updateTemplateUI();
            }
        }

        navigateTemplate(direction) {
            if (!this.templateData || !this.templateData.images) return;
            
            const newIndex = this.templateData.currentIndex + direction;
            if (newIndex >= 0 && newIndex < this.templateData.images.length) {
                this.templateData.currentIndex = newIndex;
                this.updateTemplateUI();
            }
        }

        resetTemplateCrop() {
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) return;
            
            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage) return;
            
            // Reset to original auto-crop settings
            this.reprocessCurrentTemplateImage();
            this.showToast('🔄 Đã reset crop về center crop tự động', 'info');
        }

        centerTemplateCrop() {
            this.resetTemplateCrop(); // Same as reset for now
        }

        fitTemplateCrop() {
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) return;
            
            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage) return;
            
            // Fit entire image (may add borders)
            this.reprocessCurrentTemplateImage('fit');
            this.showToast('📦 Đã áp dụng fit mode (giữ nguyên toàn ảnh)', 'info');
        }

        async reprocessCurrentTemplateImage(mode = 'fill') {
            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 669;
            canvas.height = 865;

            const img = currentImage.originalImage;
            const imgAspect = img.width / img.height;
            const targetAspect = 669 / 865;

            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

            if (mode === 'fit') {
                // Fit mode - show entire image with padding
                if (imgAspect > targetAspect) {
                    drawWidth = 669;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (865 - drawHeight) / 2;
                } else {
                    drawHeight = 865;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (669 - drawWidth) / 2;
                }
                
                // Fill background with white
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 669, 865);
                
                ctx.drawImage(img, 0, 0, img.width, img.height, offsetX, offsetY, drawWidth, drawHeight);
            } else {
                // Fill mode - crop to fill
                if (imgAspect > targetAspect) {
                    drawHeight = img.height;
                    drawWidth = drawHeight * targetAspect;
                    offsetX = (img.width - drawWidth) / 2;
                } else {
                    drawWidth = img.width;
                    drawHeight = drawWidth / targetAspect;
                    offsetY = (img.height - drawHeight) / 2;
                }
                
                ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight, 0, 0, 669, 865);
            }

            // Update image data
            currentImage.croppedDataURL = canvas.toDataURL('image/jpeg', 1.0);
            currentImage.cropSettings = { offsetX, offsetY, drawWidth, drawHeight, mode };

            this.updateTemplatePreview();
            this.updateTemplateGallery();
        }

        async exportCurrentPolaroid() {
            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage) {
                this.showToast('Không có ảnh để xuất', 'warning');
                return;
            }

            try {
                const polaroidCanvas = await this.createPolaroidCanvas(currentImage);
                
                // Convert to blob with DPI metadata and download
                polaroidCanvas.toBlob(async (blob) => {
                    try {
                        // LUÔN sử dụng DPI = 300 cho chất lượng cao
                        const blobWithDPI = await this.addDPIMetadata(blob, 300);
                        const filename = `Polaroid_${String(this.templateData.currentIndex + 1).padStart(3, '0')}.jpg`;
                        this.downloadBlob(blobWithDPI, filename);
                        this.showToast(`✅ Đã xuất ${filename} (${this.templateData.config.polaroidSizeCm.width}×${this.templateData.config.polaroidSizeCm.height}cm @ 300 DPI)`, 'success');
                    } catch (error) {
                        // Fallback to original blob if DPI metadata fails
                        const filename = `Polaroid_${String(this.templateData.currentIndex + 1).padStart(3, '0')}.jpg`;
                        this.downloadBlob(blob, filename);
                        this.showToast(`✅ Đã xuất ${filename}`, 'success');
                    }
                }, 'image/jpeg', 0.95);
            } catch (error) {
                console.error('Export error:', error);
                this.showToast('Lỗi khi xuất file', 'error');
            }
        }

        async exportAllPolaroids() {
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                this.showToast('Không có ảnh để xuất', 'warning');
                return;
            }

            try {
                // Import JSZip
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                document.head.appendChild(script);
                
                await new Promise(resolve => script.onload = resolve);

                const zip = new JSZip();
                this.showToast(`🔄 Đang tạo ${this.templateData.images.length} Polaroid...`, 'info');

                for (let i = 0; i < this.templateData.images.length; i++) {
                    const imageData = this.templateData.images[i];
                    const polaroidCanvas = await this.createPolaroidCanvas(imageData);
                    
                    const blob = await new Promise(resolve => {
                        polaroidCanvas.toBlob(resolve, 'image/jpeg', 0.95);
                    });
                    
                    // LUÔN sử dụng DPI = 300 cho chất lượng cao
                    const blobWithDPI = await this.addDPIMetadata(blob, 300);
                    
                    const filename = `Polaroid_${String(i + 1).padStart(3, '0')}.jpg`;
                    zip.file(filename, blobWithDPI);
                }

                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                const zipFilename = `Polaroids_${timestamp}.zip`;
                
                this.downloadBlob(zipBlob, zipFilename);
                this.showToast(`✅ Đã xuất ${this.templateData.images.length} Polaroid (ZIP)`, 'success');
            } catch (error) {
                console.error('Export all error:', error);
                this.showToast('Lỗi khi xuất tất cả file', 'error');
            }
        }

        async exportAllIndividualFiles() {
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                this.showToast('Không có ảnh để xuất', 'warning');
                return;
            }

            // Prevent multiple exports - disable button
            const exportBtn = document.getElementById('exportAllIndividual');
            if (exportBtn) {
                if (exportBtn.disabled) {
                    this.showToast('⏳ Đang xuất file... Vui lòng chờ!', 'warning');
                    return;
                }
                exportBtn.disabled = true;
                exportBtn.textContent = `📁 Đang xuất ${this.templateData.images.length} files...`;
            }

            try {
                const totalImages = this.templateData.images.length;
                let exportedCount = 0;

                this.showToast(`🔄 Bắt đầu xuất ${totalImages} Polaroid từng file riêng...`, 'info');

                // Export each image individually with delay
                for (let i = 0; i < totalImages; i++) {
                    const imageData = this.templateData.images[i];
                    
                    try {
                        const polaroidCanvas = await this.createPolaroidCanvas(imageData);
                        
                        // Convert to blob with DPI metadata and download
                        await new Promise((resolve) => {
                            polaroidCanvas.toBlob(async (blob) => {
                                try {
                                    // LUÔN sử dụng DPI = 300 cho chất lượng tối đa
                                    const blobWithDPI = await this.addDPIMetadata(blob, 300);
                                    const filename = `Polaroid_${String(i + 1).padStart(3, '0')}.jpg`;
                                    this.downloadBlob(blobWithDPI, filename);
                                } catch (error) {
                                    // Fallback to original blob if DPI metadata fails
                                    const filename = `Polaroid_${String(i + 1).padStart(3, '0')}.jpg`;
                                    this.downloadBlob(blob, filename);
                                }
                                
                                exportedCount++;
                                
                                // Update button text with progress
                                if (exportBtn) {
                                    exportBtn.textContent = `📁 Đang xuất ${exportedCount}/${totalImages}...`;
                                }
                                
                                resolve();
                            }, 'image/jpeg', 0.95);
                        });
                        
                        // Small delay between downloads to prevent browser blocking
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                    } catch (error) {
                        console.error(`Export error for image ${i + 1}:`, error);
                        // Continue with next image even if one fails
                        exportedCount++;
                        if (exportBtn) {
                            exportBtn.textContent = `📁 Đang xuất ${exportedCount}/${totalImages}...`;
                        }
                    }
                }

                // Success message
                this.showToast(`✅ Đã xuất thành công ${exportedCount}/${totalImages} Polaroid từng file riêng!`, 'success');

            } catch (error) {
                console.error('Export individual files error:', error);
                this.showToast('❌ Lỗi khi xuất từng file riêng!', 'error');
            } finally {
                // Re-enable button
                if (exportBtn) {
                    setTimeout(() => {
                        exportBtn.disabled = false;
                        exportBtn.textContent = '📁 Xuất từng file riêng';
                    }, 2000); // Wait 2 seconds after completion
                }
            }
        }

        // Border Template Export Functions
        async exportCurrentBorderTemplate() {
            this.showToast('🚧 Chức năng Border Template đang được phát triển...', 'info');
        }

        async exportAllBorderTemplates() {
            this.showToast('🚧 Chức năng Border Template đang được phát triển...', 'info');
        }

        async exportAllBorderIndividual() {
            this.showToast('🚧 Chức năng Border Template đang được phát triển...', 'info');
        }

        // Strip Template Export Functions
        async exportCurrentStripTemplate() {
            this.showToast('🚧 Chức năng Strip Template đang được phát triển...', 'info');
        }

        async exportAllStripTemplates() {
            this.showToast('🚧 Chức năng Strip Template đang được phát triển...', 'info');
        }

        async exportAllStripIndividual() {
            this.showToast('🚧 Chức năng Strip Template đang được phát triển...', 'info');
        }

        async createPolaroidCanvas(imageData) {
            const dimensions = this.calculatePolaroidDimensions();
            const config = this.templateData.config;
            const border = config.border;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas to calculated Polaroid size
            canvas.width = dimensions.canvasW;
            canvas.height = dimensions.canvasH;
            
            // Fill with background color
            ctx.fillStyle = config.bgColor;
            ctx.fillRect(0, 0, dimensions.canvasW, dimensions.canvasH);
            
            // Draw the image in the calculated area with borders
            const img = new Image();
            img.src = imageData.croppedDataURL;
            
            return new Promise((resolve) => {
                img.onload = () => {
                    // Calculate image position with safe area offset
                    const imageX = border.leftPx + config.safeAreaPx;
                    const imageY = border.topPx + config.safeAreaPx;
                    
                    // Draw image
                    ctx.drawImage(img, imageX, imageY, dimensions.safeImageW, dimensions.safeImageH);
                    
                    // Draw caption if text is provided
                    if (config.caption.text && config.caption.text.trim()) {
                        this.drawCaption(ctx, dimensions, config);
                    }
                    
                    // Draw overlay frame if enabled
                    if (config.overlayFrame) {
                        this.drawOverlayFrame(ctx, dimensions);
                    }
                    
                    resolve(canvas);
                };
            });
        }

        drawCaption(ctx, dimensions, config) {
            const captionConfig = config.caption;
            const border = config.border;
            
            // Caption area: bottom area
            const captionY = dimensions.canvasH - border.bottomCaptionPx + captionConfig.marginTopPx;
            const captionWidth = dimensions.canvasW - (border.leftPx + border.rightPx);
            const captionX = border.leftPx;
            
            // Set font
            ctx.font = `${captionConfig.fontSizePx}px ${captionConfig.fontFamily}`;
            ctx.fillStyle = captionConfig.color;
            ctx.textBaseline = 'top';
            
            // Calculate text position based on alignment
            let textX;
            switch (captionConfig.align) {
                case 'left':
                    ctx.textAlign = 'left';
                    textX = captionX;
                    break;
                case 'right':
                    ctx.textAlign = 'right';
                    textX = captionX + captionWidth;
                    break;
                case 'center':
                default:
                    ctx.textAlign = 'center';
                    textX = captionX + (captionWidth / 2);
                    break;
            }
            
            // Draw text with word wrapping if needed
            this.drawWrappedText(ctx, captionConfig.text, textX, captionY, captionWidth, captionConfig.fontSizePx + 4);
        }

        drawWrappedText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let currentY = y;
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && i > 0) {
                    ctx.fillText(line.trim(), x, currentY);
                    line = words[i] + ' ';
                    currentY += lineHeight;
                } else {
                    line = testLine;
                }
            }
            
            if (line.trim()) {
                ctx.fillText(line.trim(), x, currentY);
            }
        }

        drawOverlayFrame(ctx, dimensions) {
            // Draw a simple frame overlay (could be replaced with PNG image)
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, dimensions.canvasW - 2, dimensions.canvasH - 2);
            
            // Draw corner markers
            const cornerSize = 10;
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            
            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(cornerSize, 1);
            ctx.lineTo(1, 1);
            ctx.lineTo(1, cornerSize);
            ctx.stroke();
            
            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(dimensions.canvasW - cornerSize, 1);
            ctx.lineTo(dimensions.canvasW - 1, 1);
            ctx.lineTo(dimensions.canvasW - 1, cornerSize);
            ctx.stroke();
            
            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(1, dimensions.canvasH - cornerSize);
            ctx.lineTo(1, dimensions.canvasH - 1);
            ctx.lineTo(cornerSize, dimensions.canvasH - 1);
            ctx.stroke();
            
            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(dimensions.canvasW - cornerSize, dimensions.canvasH - 1);
            ctx.lineTo(dimensions.canvasW - 1, dimensions.canvasH - 1);
            ctx.lineTo(dimensions.canvasW - 1, dimensions.canvasH - cornerSize);
            ctx.stroke();
        }

        // Template Crop Editor Functions (Copy Multi-crop approach)
        openTemplateCropEditor() {
            console.log('🚀 openTemplateCropEditor() called');
            console.log('templateData:', this.templateData);
            
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                console.log('❌ No images available for cropping');
                this.showToast('❌ Không có ảnh để chỉnh sửa crop!', 'error');
                return;
            }
            
            console.log('✅ Images found, opening crop editor...');

            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage) {
                this.showToast('❌ Không thể tải ảnh hiện tại!', 'error');
                return;
            }

            // Setup templateCropData for modal
            this.templateCropData = {
                files: [{
                    name: currentImage.filename || 'Template Image',
                    file: null, // We have dataURL instead
                    dataURL: currentImage.originalDataURL || currentImage.croppedDataURL
                }],
                currentIndex: 0,
                config: {
                    width: this.templateData.config.polaroidSizeCm.width,
                    height: this.templateData.config.polaroidSizeCm.height,
                    unit: 'cm',
                    targetWidth: Math.round((this.templateData.config.polaroidSizeCm.width / 2.54) * 300),
                    targetHeight: Math.round((this.templateData.config.polaroidSizeCm.height / 2.54) * 300),
                    aspectRatio: this.templateData.config.polaroidSizeCm.height / this.templateData.config.polaroidSizeCm.width,
                    dpi: 300
                }
            };
            
            console.log('📊 Setup templateCropData:', this.templateCropData);

            // Show modal
            const modal = document.getElementById('templateCropModal');
            modal.style.display = 'block';
            
            // Setup modal click outside to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                    this.templateCropData = null;
                }
            });
            
            // Prevent modal content clicks from closing modal
            const modalContent = modal.querySelector('.template-crop-content');
            if (modalContent) {
                modalContent.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            
            // Setup modal button event listeners (after modal is shown)
            this.setupTemplateCropModalListeners();
            
            // Load image for cropping (using existing crop system)
            this.loadImageForTemplateCropping(0);
        }

        // End Template Crop Editor Functions

        // Image Rotation Functions
        async rotateImage(imageId, angle) {
            console.log('🔄 Rotating image:', { imageId, angle });
            
            try {
                // Find the image in galleryImages
                const imageIndex = this.galleryImages.findIndex(img => img.id == imageId);
                if (imageIndex === -1) {
                    this.showToast('❌ Không tìm thấy ảnh để xoay!', 'error');
                    return;
                }
                
                const imageData = this.galleryImages[imageIndex];
                
                // Create canvas for rotation
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Create image element
                const img = new Image();
                img.onload = () => {
                    // Calculate new dimensions after rotation
                    const isRotated90or270 = (angle === 90 || angle === 270);
                    canvas.width = isRotated90or270 ? img.height : img.width;
                    canvas.height = isRotated90or270 ? img.width : img.height;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Move to center and rotate
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate((angle * Math.PI) / 180);
                    
                    // Draw rotated image
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    ctx.restore();
                    
                    // Update image data with rotated version
                    imageData.data = canvas.toDataURL('image/jpeg', 1.0);
                    imageData.rotation = (imageData.rotation || 0) + angle;
                    imageData.rotation = imageData.rotation % 360; // Keep rotation within 0-359°
                    
                    // Update UI
                    this.updateSourceGrid();
                    this.updateGalleryDisplay();
                    
                    // Show success message
                    this.showToast(`🔄 Đã xoay ảnh ${angle}° (Tổng: ${imageData.rotation}°)`, 'success');
                };
                
                img.src = imageData.data;
                
            } catch (error) {
                console.error('Rotate image error:', error);
                this.showToast('❌ Lỗi khi xoay ảnh!', 'error');
            }
        }

        // Image Duplication Function  
        async duplicateImage(imageId) {
            console.log('⧉ Duplicating image:', imageId);
            
            try {
                // Find the image in galleryImages
                const imageIndex = this.galleryImages.findIndex(img => img.id == imageId);
                if (imageIndex === -1) {
                    this.showToast('❌ Không tìm thấy ảnh để nhân bản!', 'error');
                    return;
                }
                
                const originalImage = this.galleryImages[imageIndex];
                
                // Create duplicate with new ID
                const duplicateImage = {
                    ...originalImage, // Copy all properties
                    id: Date.now() + Math.random(), // New unique ID
                    filename: `${originalImage.filename.replace(/\.[^/.]+$/, '')}_copy.jpg`, // Add "_copy" to filename
                    isOriginal: false // Mark as duplicate
                };
                
                // Add to galleryImages array (right after original)
                this.galleryImages.splice(imageIndex + 1, 0, duplicateImage);
                
                // Update UI
                this.updateSourceGrid();
                this.updateGalleryDisplay();
                
                // Show success message
                this.showToast(`⧉ Đã nhân bản ảnh: ${duplicateImage.filename}`, 'success');
                
                console.log('✅ Image duplicated successfully:', {
                    original: originalImage.filename,
                    duplicate: duplicateImage.filename,
                    totalImages: this.galleryImages.length
                });
                
            } catch (error) {
                console.error('Duplicate image error:', error);
                this.showToast('❌ Lỗi khi nhân bản ảnh!', 'error');
            }
        }

        async generatePrintFiles() {
            // Kiểm tra có ảnh để in không (xử lý cả duplex và normal mode)
            let hasImages = false;
            
            if (this.printData.config.printMode === 'duplex') {
                // Duplex mode: kiểm tra frontImages và backImages
                hasImages = (this.printData.frontImages && this.printData.frontImages.length > 0) || 
                           (this.printData.backImages && this.printData.backImages.length > 0);
                
                if (!hasImages) {
                    this.showToast('Vui lòng phân loại ảnh vào mặt trước hoặc mặt sau để in', 'warning');
                    return;
                }
                
                // Tự động cập nhật selectedImages từ classified images
                this.updatePrintDataSelectedImages();
                
                console.log('📊 Duplex mode - Images ready:', {
                    frontCount: this.printData.frontImages?.length || 0,
                    backCount: this.printData.backImages?.length || 0,
                    selectedCount: this.printData.selectedImages?.length || 0,
                    frontImages: this.printData.frontImages,
                    backImages: this.printData.backImages,
                    selectedImages: this.printData.selectedImages
                });
            } else {
                // Normal mode: kiểm tra selectedImages
                hasImages = this.printData.selectedImages && this.printData.selectedImages.length > 0;
                
                if (!hasImages) {
                    this.showToast('Vui lòng chọn ảnh để in', 'warning');
                    return;
                }
            }

            // Get export format from active tab instead of radio button
            const activeFormatTab = document.querySelector('.format-tab.active');
            const exportFormat = activeFormatTab ? activeFormatTab.dataset.format : 'jpg-zip';
            const generateBtn = document.getElementById('generatePrintBtn');
            
            generateBtn.disabled = true;
            generateBtn.textContent = 'Đang tạo...';

            try {
                switch (exportFormat) {
                    case 'jpg-zip':
                        await this.generateJPGPagesZip();
                        break;
                    case 'jpg-individual':
                        await this.generateJPGPagesIndividual();
                        break;
                    case 'pdf':
                        await this.generatePDFFile();
                        break;
                    default:
                        await this.generateJPGPagesZip();
                }
            } catch (error) {
                console.error('Error generating print files:', error);
                this.showToast('Lỗi khi tạo file in', 'error');
            }

            generateBtn.disabled = false;
            generateBtn.textContent = 'Tạo file in';
        }

        async generateJPGPagesZip() {
            const zip = new JSZip();
            const config = this.printData.config;
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            if (config.printMode === 'duplex') {
                await this.generateDuplexJPGZip();
                return;
            }
            
            for (let page = 0; page < this.printData.totalPages; page++) {
                // Use Master Canvas System for WYSIWYG export
                const masterCanvas = this.createMasterCanvas(page);
                
                // Convert master canvas to blob with maximum quality
                const blob = await new Promise(resolve => {
                    masterCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                });
                
                // Create descriptive filename with cutting guides info
                const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                                 config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
                const fileName = `page-${String(page + 1).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                zip.file(fileName, blob);
                
                // Show progress
                if (this.printData.totalPages > 1) {
                    const progress = ((page + 1) / this.printData.totalPages * 100).toFixed(0);
                    const generateBtn = document.getElementById('generatePrintBtn');
                    if (generateBtn) {
                        generateBtn.textContent = `Đang tạo... ${progress}%`;
                    }
                }
            }

            const zipBlob = await zip.generateAsync({ type: 'blob' });
            
            // Create descriptive zip filename
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
            const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                             config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
            const zipFileName = `print-pages_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}_${timestamp}.zip`;
            
            this.downloadBlob(zipBlob, zipFileName);
            this.showToast(`✅ Đã tạo xong ${this.printData.totalPages} trang JPG ${dpi}DPI kích thước ${paperWidthMm}×${paperHeightMm}mm (ZIP)`, 'success');
        }

        async generateDuplexJPGZip() {
            const frontZip = new JSZip();
            const backZip = new JSZip();
            const config = this.printData.config;
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            let frontPageCount = 0;
            let backPageCount = 0;
            
            // Generate front pages (even indexes: 0, 2, 4...)
            for (let page = 0; page < this.printData.totalPages; page += 2) {
                const masterCanvas = this.createMasterCanvas(page);
                const blob = await new Promise(resolve => {
                    masterCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                });
                
                const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                                 config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
                const fileName = `FRONT_page-${String(page + 1).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                frontZip.file(fileName, blob);
                frontPageCount++;
                
                // Progress for front pages
                const progress = (frontPageCount / Math.ceil(this.printData.totalPages / 2) * 50).toFixed(0);
                const generateBtn = document.getElementById('generatePrintBtn');
                if (generateBtn) {
                    generateBtn.textContent = `Tạo ZIP mặt trước... ${progress}%`;
                }
            }
            
            // Generate back pages (odd indexes: 1, 3, 5...) with flipping
            for (let page = 1; page < this.printData.totalPages; page += 2) {
                const masterCanvas = this.createDuplexBackCanvas(page);
                const blob = await new Promise(resolve => {
                    masterCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                });
                
                const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                                 config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
                const fileName = `BACK_page-${String(page + 1).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                backZip.file(fileName, blob);
                backPageCount++;
                
                // Progress for back pages
                const progress = (50 + (backPageCount / Math.floor(this.printData.totalPages / 2) * 50)).toFixed(0);
                const generateBtn = document.getElementById('generatePrintBtn');
                if (generateBtn) {
                    generateBtn.textContent = `Tạo ZIP mặt sau... ${progress}%`;
                }
            }
            
            // Generate ZIP files
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
            const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                             config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
            
            const frontZipBlob = await frontZip.generateAsync({ type: 'blob' });
            const backZipBlob = await backZip.generateAsync({ type: 'blob' });
            
            const frontZipFileName = `FRONT_duplex-${config.duplexFlip}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}_${timestamp}.zip`;
            const backZipFileName = `BACK_duplex-${config.duplexFlip}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}_${timestamp}.zip`;
            
            // Download both ZIP files
            this.downloadBlob(frontZipBlob, frontZipFileName);
            
            // Small delay before second download
            await new Promise(resolve => setTimeout(resolve, 1000));
            this.downloadBlob(backZipBlob, backZipFileName);
            
            this.showToast(`✅ Đã tạo xong 2 file ZIP Duplex: ${frontPageCount} trang trước + ${backPageCount} trang sau (${config.duplexFlip})`, 'success');
        }

        async generateJPGPagesIndividual() {
            const config = this.printData.config;
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            if (config.printMode === 'duplex') {
                await this.generateDuplexJPGIndividual();
                return;
            }
            
            for (let page = 0; page < this.printData.totalPages; page++) {
                // Use Master Canvas System for WYSIWYG export
                const masterCanvas = this.createMasterCanvas(page);
                
                // Convert master canvas to blob with maximum quality
                const blob = await new Promise(resolve => {
                    masterCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                });
                
                // Create descriptive filename with cutting guides info
                const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                                 config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
                const fileName = `page-${String(page + 1).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                
                // Download individual file
                this.downloadBlob(blob, fileName);
                
                // Show progress and small delay between downloads
                if (this.printData.totalPages > 1) {
                    const progress = ((page + 1) / this.printData.totalPages * 100).toFixed(0);
                    const generateBtn = document.getElementById('generatePrintBtn');
                    if (generateBtn) {
                        generateBtn.textContent = `Đang tải... ${progress}%`;
                    }
                    
                    // Small delay to prevent browser blocking multiple downloads
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            
            this.showToast(`✅ Đã tải xong ${this.printData.totalPages} file JPG ${dpi}DPI kích thước ${paperWidthMm}×${paperHeightMm}mm (Riêng lẻ)`, 'success');
        }

        async generateDuplexJPGIndividual() {
            // Prevent multiple simultaneous calls
            if (this.isGeneratingDuplexJPG) {
                console.log('Duplex JPG generation already in progress, ignoring...');
                return;
            }
            
            this.isGeneratingDuplexJPG = true;
            
            const config = this.printData.config;
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            console.log('Generating duplex JPG with classification:', {
                frontImages: this.printData.frontImages?.length || 0,
                backImages: this.printData.backImages?.length || 0
            });
            
            try {
                // Check if we have classified images
                if (!this.printData.frontImages?.length && !this.printData.backImages?.length) {
                    this.showToast('⚠️ Chưa có ảnh nào được phân loại cho duplex!', 'error');
                    return;
                }
            
            let fileCount = 0;
            
            // Generate FRONT page
            if (this.printData.frontImages?.length > 0) {
                const frontCanvas = await this.createDuplexMasterCanvas('front', 0);
                if (frontCanvas) {
                    const blob = await new Promise(resolve => {
                        frontCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                    });
                    
                    const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                                     config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
                    const fileName = `FRONT_page-001_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                    
                    this.downloadBlob(blob, fileName);
                    fileCount++;
                    
                    const generateBtn = document.getElementById('generatePrintBtn');
                    if (generateBtn) generateBtn.textContent = 'Tạo mặt trước... 50%';
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            
            // Generate BACK page (with coordinate mirroring)
            if (this.printData.backImages?.length > 0) {
                try {
                    const backCanvas = await this.createDuplexBackCanvasClassified();
                    if (backCanvas) {
                        const blob = await new Promise(resolve => {
                            backCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                        });
                        
                        const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                                         config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
                        const fileName = `BACK_page-001_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                        
                        this.downloadBlob(blob, fileName);
                        fileCount++;
                        
                        const generateBtn = document.getElementById('generatePrintBtn');
                        if (generateBtn) generateBtn.textContent = 'Tạo mặt sau... 100%';
                        
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                } catch (error) {
                    console.error('Error creating back canvas:', error);
                    this.showToast('⚠️ Lỗi tạo mặt sau với coordinate mirroring', 'error');
                }
            }
            
            const generateBtn = document.getElementById('generatePrintBtn');
            if (generateBtn) {
                generateBtn.disabled = false;
                generateBtn.textContent = 'Tạo file JPG riêng lẻ';
            }
            
                this.showToast(`✅ Đã tạo xong ${fileCount} file JPG duplex (${paperWidthMm}×${paperHeightMm}mm, ${dpi}DPI)`, 'success');
            
            } catch (error) {
                console.error('Error in generateDuplexJPGIndividual:', error);
                this.showToast('⚠️ Lỗi khi tạo file JPG duplex!', 'error');
                
                const generateBtn = document.getElementById('generatePrintBtn');
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Tạo file JPG riêng lẻ';
                }
            } finally {
                // Always reset protection flag
                this.isGeneratingDuplexJPG = false;
            }
        }


        renderPageToCanvasWithCoordinateMirroring(canvas, ctx, pageIndex, config) {
            // Render images on back side with coordinate mirroring (NO image flipping)
            const selectedImages = this.printData.selectedImages;
            if (!selectedImages || selectedImages.length === 0) return;

            // Calculate layout parameters
            const dpi = config.dpi;
            const paperWidthPx = canvas.width;
            const paperHeightPx = canvas.height;
            
            // CÔNG THỨC CHÍNH XÁC: (kích_thước_cm ÷ 2.54) × 300
            const DPI = 300; // Cố định DPI
            const photoWidthPx = Math.round((config.photoSize.width / 2.54) * DPI);  // (cm ÷ 2.54) × 300
            const photoHeightPx = Math.round((config.photoSize.height / 2.54) * DPI);
            const marginTopPx = Math.round(config.margins.top / 25.4 * dpi);
            const marginLeftPx = Math.round(config.margins.left / 25.4 * dpi);
            const gutterXPx = Math.round(config.gutter.x / 25.4 * dpi);
            const gutterYPx = Math.round(config.gutter.y / 25.4 * dpi);

            // Calculate grid layout
            const availableWidth = paperWidthPx - (config.margins.left + config.margins.right) / 25.4 * dpi;
            const availableHeight = paperHeightPx - (config.margins.top + config.margins.bottom) / 25.4 * dpi;
            const cols = Math.floor((availableWidth + gutterXPx) / (photoWidthPx + gutterXPx));
            const rows = Math.floor((availableHeight + gutterYPx) / (photoHeightPx + gutterYPx));
            
            // Start position
            const startXPx = marginLeftPx;
            const startYPx = marginTopPx;

            // Calculate page start index
            const maxPhotosPerPage = cols * rows;
            const pageStartIndex = pageIndex * maxPhotosPerPage;

            // Render images with coordinate mirroring
            let imageIndex = 0;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const globalIndex = pageStartIndex + imageIndex;
                    if (globalIndex >= selectedImages.length) break;

                    const imageData = selectedImages[globalIndex];
                    if (!imageData.img) continue;

                    // Calculate ORIGINAL position (như mặt trước)
                    const originalX = startXPx + col * (photoWidthPx + gutterXPx);
                    const originalY = startYPx + row * (photoHeightPx + gutterYPx);

                    // Apply coordinate mirroring (KHÔNG flip ảnh, chỉ đảo vị trí)
                    let mirroredX, mirroredY;
                    
                    if (config.duplexFlip === 'long-edge') {
                        // Long-edge binding: mirror theo trục X qua center của available area
                        // Tính center của vùng available (không tính margins)
                        const availableAreaCenterX = marginLeftPx + (canvas.width - 2 * marginLeftPx) / 2;
                        
                        // Mirror qua center: distance from center phải bằng nhau
                        const originalCenterX = originalX + photoWidthPx / 2;
                        const distanceFromCenter = originalCenterX - availableAreaCenterX;
                        const mirroredCenterX = availableAreaCenterX - distanceFromCenter;
                        mirroredX = mirroredCenterX - photoWidthPx / 2;
                        mirroredY = originalY; // Y không đổi
                    } else {
                        // Short-edge binding: mirror theo trục Y qua center của available area
                        // Tính center của vùng available (không tính margins)
                        const availableAreaCenterY = marginTopPx + (canvas.height - 2 * marginTopPx) / 2;
                        
                        // Mirror qua center: distance from center phải bằng nhau
                        const originalCenterY = originalY + photoHeightPx / 2;
                        const distanceFromCenter = originalCenterY - availableAreaCenterY;
                        const mirroredCenterY = availableAreaCenterY - distanceFromCenter;
                        mirroredX = originalX; // X không đổi
                        mirroredY = mirroredCenterY - photoHeightPx / 2;
                        
                        // Validation cho short-edge
                        const centerY = canvas.height / 2;
                        const frontDistFromCenterY = Math.abs(originalY + photoHeightPx/2 - centerY);
                        const backDistFromCenterY = Math.abs(mirroredY + photoHeightPx/2 - centerY);
                        console.log(`  ⚖️ SHORT-EDGE Symmetry Y: Front(${frontDistFromCenterY.toFixed(1)}) vs Back(${backDistFromCenterY.toFixed(1)}) from center - ${Math.abs(frontDistFromCenterY - backDistFromCenterY) < 1 ? '✅ SYMMETRIC' : '❌ NOT SYMMETRIC'}`);
                    }

                    console.log(`Image ${imageIndex}: Original(${originalX.toFixed(0)},${originalY.toFixed(0)}) -> Mirrored(${mirroredX.toFixed(0)},${mirroredY.toFixed(0)})`);
                    console.log(`  📏 Canvas: ${canvas.width}x${canvas.height}px, Photo: ${photoWidthPx}x${photoHeightPx}px, DPI: ${config.dpi}`);
                    
                    // 🧮 VERIFICATION: Kiểm tra công thức có khớp không
                    if (config.duplexFlip === 'long-edge') {
                        const expectedX = canvas.width - (originalX + photoWidthPx);
                        const calculatedX = mirroredX;
                        console.log(`  🧮 Formula Check: Expected(${expectedX.toFixed(0)}) vs Calculated(${calculatedX.toFixed(0)}) - ${Math.abs(expectedX - calculatedX) < 1 ? '✅ MATCH' : '❌ MISMATCH'}`);
                        
                        // Kiểm tra tọa độ có đối xứng không
                        const centerX = canvas.width / 2;
                        const frontDistFromCenter = Math.abs(originalX + photoWidthPx/2 - centerX);
                        const backDistFromCenter = Math.abs(mirroredX + photoWidthPx/2 - centerX);
                        console.log(`  ⚖️ Symmetry: Front(${frontDistFromCenter.toFixed(1)}) vs Back(${backDistFromCenter.toFixed(1)}) from center - ${Math.abs(frontDistFromCenter - backDistFromCenter) < 1 ? '✅ SYMMETRIC' : '❌ NOT SYMMETRIC'}`);
                        
                        // 🎯 FINAL VALIDATION: Đảm bảo ảnh không ra ngoài canvas
                        if (mirroredX < 0 || mirroredY < 0 || mirroredX + photoWidthPx > canvas.width || mirroredY + photoHeightPx > canvas.height) {
                            console.warn(`  ⚠️ WARNING: Mirrored image out of bounds! X:${mirroredX.toFixed(0)}-${(mirroredX + photoWidthPx).toFixed(0)} Y:${mirroredY.toFixed(0)}-${(mirroredY + photoHeightPx).toFixed(0)} Canvas:${canvas.width}x${canvas.height}`);
                            
                            // Auto-fix nếu ra ngoài canvas
                            mirroredX = Math.max(0, Math.min(mirroredX, canvas.width - photoWidthPx));
                            mirroredY = Math.max(0, Math.min(mirroredY, canvas.height - photoHeightPx));
                            console.log(`  🔧 AUTO-FIX: Adjusted to X:${mirroredX.toFixed(0)} Y:${mirroredY.toFixed(0)}`);
                        }
                    }

                    // Vẽ ảnh ở vị trí đã mirror (ảnh vẫn giữ nguyên orientation - KHÔNG FLIP!)
                    // Tính toán để fit ảnh vào khung
                    const img = imageData.img;
                    const imgAspect = img.width / img.height;
                    const targetAspect = photoWidthPx / photoHeightPx;
                    
                    let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
                    
                    if (config.fitMode === 'fill') {
                        // Fill: Crop để fill toàn bộ khung
                        if (imgAspect > targetAspect) {
                            drawHeight = photoHeightPx;
                            drawWidth = drawHeight * imgAspect;
                            offsetX = (photoWidthPx - drawWidth) / 2;
                        } else {
                            drawWidth = photoWidthPx;
                            drawHeight = drawWidth / imgAspect;
                            offsetY = (photoHeightPx - drawHeight) / 2;
                        }
                    } else {
                        // Fit: Giữ tỷ lệ, có thể có viền trắng
                        if (imgAspect > targetAspect) {
                            drawWidth = photoWidthPx;
                            drawHeight = drawWidth / imgAspect;
                            offsetY = (photoHeightPx - drawHeight) / 2;
                        } else {
                            drawHeight = photoHeightPx;
                            drawWidth = drawHeight * imgAspect;
                            offsetX = (photoWidthPx - drawWidth) / 2;
                        }
                    }

                    // Vẽ nền trắng cho khung ảnh
                    ctx.fillStyle = 'white';
                    ctx.fillRect(mirroredX, mirroredY, photoWidthPx, photoHeightPx);

                    // Clip và vẽ ảnh với duplex transformation
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(mirroredX, mirroredY, photoWidthPx, photoHeightPx);
                    ctx.clip();
                    
                    // Apply duplex transformation
                    const imageCenterX = mirroredX + photoWidthPx / 2;
                    const imageCenterY = mirroredY + photoHeightPx / 2;
                    
                    if (config.duplexFlip === 'long-edge') {
                        // Long-edge: Flip ngang để khi lật giấy đọc được đúng
                        ctx.translate(imageCenterX, imageCenterY);
                        ctx.scale(-1, 1);
                        ctx.translate(-imageCenterX, -imageCenterY);
                    } else {
                        // Short-edge: Xoay 180° để khi lật giấy đọc được đúng
                        ctx.translate(imageCenterX, imageCenterY);
                        ctx.rotate(Math.PI);
                        ctx.translate(-imageCenterX, -imageCenterY);
                    }
                    
                    ctx.drawImage(img, mirroredX + offsetX, mirroredY + offsetY, drawWidth, drawHeight);
                    ctx.restore();

                    // Vẽ viền
                    ctx.strokeStyle = '#e2e8f0';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(mirroredX, mirroredY, photoWidthPx, photoHeightPx);

                    // 🎯 DEBUG: Vẽ markers để kiểm tra alignment
                    if (imageIndex < 3) { // Chỉ vẽ cho 3 ảnh đầu để không quá rối
                        ctx.fillStyle = config.duplexFlip === 'long-edge' ? '#ff6b6b' : '#4ecdc4';
                        ctx.font = '12px Arial';
                        ctx.fillText(`${imageIndex}:${mirroredX.toFixed(0)},${mirroredY.toFixed(0)}`, 
                                    mirroredX + 5, mirroredY + 15);
                        
                        // Vẽ cross mark tại center của ảnh
                        const centerX = mirroredX + photoWidthPx/2;
                        const centerY = mirroredY + photoHeightPx/2;
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX - 10, centerY);
                        ctx.lineTo(centerX + 10, centerY);
                        ctx.moveTo(centerX, centerY - 10);
                        ctx.lineTo(centerX, centerY + 10);
                        ctx.stroke();
                    }
                    imageIndex++;
                }
                if (pageStartIndex + imageIndex >= selectedImages.length) break;
            }
        }

        // Create duplex back canvas for regular printing (not classified)
        createDuplexBackCanvas(pageIndex) {
            const config = this.printData.config;
            const dpi = config.dpi;
            
            // Calculate exact dimensions at full DPI
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            const paperWidthInches = paperWidthMm / 25.4;
            const paperHeightInches = paperHeightMm / 25.4;
            const exactWidthPx = Math.round(paperWidthInches * dpi);
            const exactHeightPx = Math.round(paperHeightInches * dpi);

            const canvas = document.createElement('canvas');
            canvas.width = exactWidthPx;
            canvas.height = exactHeightPx;
            const ctx = canvas.getContext('2d');
            
            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Render page with coordinate mirroring for duplex back
            this.renderBackPageToCanvas(canvas, ctx, pageIndex, config);
            
            // Add cutting guides if enabled
            this.drawCuttingGuides(ctx, canvas, config);
            
            console.log(`Back duplex canvas created for page ${pageIndex} with coordinate mirroring`);
            return canvas;
        }

        async createDuplexBackCanvasClassified() {
            console.log('Creating duplex back canvas with coordinate mirroring (NO image flipping)');
            
            const config = this.printData.config;
            const images = this.printData.backImages;
            
            if (!images || images.length === 0) {
                console.log('No back images to process');
                return null;
            }

            return new Promise((resolve) => {
                // Create proper img objects for each back image
                const processedImages = [];
                let loadedCount = 0;
                
                images.forEach((imgData, index) => {
                    const img = new Image();
                    img.onload = () => {
                        processedImages[index] = {
                            src: imgData.src,
                            img: img,
                            name: imgData.name,
                            file: imgData.file
                        };
                        
                        loadedCount++;
                        if (loadedCount === images.length) {
                            // Create master canvas with exact dimensions
                            const dpi = config.dpi;
                            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
                            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
                            const paperWidthInches = paperWidthMm / 25.4;
                            const paperHeightInches = paperHeightMm / 25.4;
                            const exactWidthPx = Math.round(paperWidthInches * dpi);
                            const exactHeightPx = Math.round(paperHeightInches * dpi);

                            const masterCanvas = document.createElement('canvas');
                            masterCanvas.width = exactWidthPx;
                            masterCanvas.height = exactHeightPx;
                            const ctx = masterCanvas.getContext('2d');
                            
                            // Fill with white background
                            ctx.fillStyle = 'white';
                            ctx.fillRect(0, 0, masterCanvas.width, masterCanvas.height);
                            
                            // Temporarily replace selectedImages with back images
                            const originalSelectedImages = this.printData.selectedImages;
                            this.printData.selectedImages = processedImages;
                            
                            // Render page content with coordinate mirroring applied
                            // This will be handled in renderPageToCanvas with coordinate transformation
                            this.renderPageToCanvasWithCoordinateMirroring(masterCanvas, ctx, 0, config);
                            
                            // Add cutting guides if enabled
                            this.drawCuttingGuides(ctx, masterCanvas, config);
                            
                            // Restore original selectedImages
                            this.printData.selectedImages = originalSelectedImages;
                            
                            console.log('Back canvas created with coordinate mirroring only (no image flipping)');
                            resolve(masterCanvas);
                        }
                    };
                    img.onerror = () => {
                        console.error('Failed to load back image:', imgData.src);
                        loadedCount++;
                        if (loadedCount === images.length) {
                            resolve(null);
                        }
                    };
                    img.src = imgData.src;
                });
            });
        }

        async generatePDFFile() {
            const { jsPDF } = window.jspdf;
            const config = this.printData.config;
            
            if (config.printMode === 'duplex') {
                await this.generateDuplexPDF();
                return;
            }
            
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            // Create PDF with exact mm dimensions
            const pdf = new jsPDF({
                orientation: config.orientation === 'portrait' ? 'p' : 'l',
                unit: 'mm',
                format: [paperWidthMm, paperHeightMm]
            });

            for (let page = 0; page < this.printData.totalPages; page++) {
                if (page > 0) {
                    pdf.addPage();
                }
                
                // Use Master Canvas System for WYSIWYG export
                const masterCanvas = this.createMasterCanvas(page);
                const imgData = masterCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, paperWidthMm, paperHeightMm);
                
                // Show progress
                if (this.printData.totalPages > 1) {
                    const progress = ((page + 1) / this.printData.totalPages * 100).toFixed(0);
                    const generateBtn = document.getElementById('generatePrintBtn');
                    if (generateBtn) {
                        generateBtn.textContent = `Đang tạo PDF... ${progress}%`;
                    }
                }
            }

            // Create descriptive PDF filename
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
            const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                             config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
            const pdfFileName = `print-layout_${paperWidthMm}x${paperHeightMm}mm_${config.dpi}DPI${guidesInfo}_${timestamp}.pdf`;
            
            pdf.save(pdfFileName);
            this.showToast(`✅ Đã tạo xong file PDF ${config.dpi}DPI kích thước ${paperWidthMm}×${paperHeightMm}mm (WYSIWYG)`, 'success');
        }

        async generateDuplexPDF() {
            const { jsPDF } = window.jspdf;
            const config = this.printData.config;
            
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            // Create separate PDFs for front and back sides
            const frontPdf = new jsPDF({
                orientation: config.orientation === 'portrait' ? 'p' : 'l',
                unit: 'mm',
                format: [paperWidthMm, paperHeightMm]
            });
            
            const backPdf = new jsPDF({
                orientation: config.orientation === 'portrait' ? 'p' : 'l',
                unit: 'mm',
                format: [paperWidthMm, paperHeightMm]
            });

            let frontPageCount = 0;
            let backPageCount = 0;
            
            // Add front pages (even index: 0, 2, 4...)
            for (let page = 0; page < this.printData.totalPages; page += 2) {
                if (frontPageCount > 0) {
                    frontPdf.addPage();
                }
                
                const masterCanvas = this.createMasterCanvas(page);
                const imgData = masterCanvas.toDataURL('image/jpeg', 1.0);
                frontPdf.addImage(imgData, 'JPEG', 0, 0, paperWidthMm, paperHeightMm);
                frontPageCount++;
                
                // Progress for front pages
                const progress = (frontPageCount / Math.ceil(this.printData.totalPages / 2) * 50).toFixed(0);
                const generateBtn = document.getElementById('generatePrintBtn');
                if (generateBtn) {
                    generateBtn.textContent = `Tạo PDF mặt trước... ${progress}%`;
                }
            }
            
            // Add back pages (odd index: 1, 3, 5...) with proper flipping
            for (let page = 1; page < this.printData.totalPages; page += 2) {
                if (backPageCount > 0) {
                    backPdf.addPage();
                }
                
                const masterCanvas = this.createDuplexBackCanvas(page);
                const imgData = masterCanvas.toDataURL('image/jpeg', 1.0);
                backPdf.addImage(imgData, 'JPEG', 0, 0, paperWidthMm, paperHeightMm);
                backPageCount++;
                
                // Progress for back pages
                const progress = (50 + (backPageCount / Math.floor(this.printData.totalPages / 2) * 50)).toFixed(0);
                const generateBtn = document.getElementById('generatePrintBtn');
                if (generateBtn) {
                    generateBtn.textContent = `Tạo PDF mặt sau... ${progress}%`;
                }
            }

            // Generate filenames
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
            const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                             config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
            
            const frontFileName = `FRONT_duplex-${config.duplexFlip}_${paperWidthMm}x${paperHeightMm}mm_${config.dpi}DPI${guidesInfo}_${timestamp}.pdf`;
            const backFileName = `BACK_duplex-${config.duplexFlip}_${paperWidthMm}x${paperHeightMm}mm_${config.dpi}DPI${guidesInfo}_${timestamp}.pdf`;
            
            // Save both PDFs
            frontPdf.save(frontFileName);
            
            // Small delay before second download
            await new Promise(resolve => setTimeout(resolve, 1000));
            backPdf.save(backFileName);
            
            this.showToast(`✅ Đã tạo xong 2 file PDF Duplex: ${frontPageCount} trang trước + ${backPageCount} trang sau (${config.duplexFlip})`, 'success');
        }

        renderPageToCanvas(canvas, ctx, pageIndex, config) {
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            // Clear canvas with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Use optimized layout dimensions
            const layout = this.printData.gridLayout;
            const photoWidthPx = Math.round(layout.photoWidth / 25.4 * dpi);
            const photoHeightPx = Math.round(layout.photoHeight / 25.4 * dpi);

            // Calculate positions with optimized spacing
            const marginLeftPx = Math.round(config.margins.left / 25.4 * dpi);
            const marginTopPx = Math.round(config.margins.top / 25.4 * dpi);
            const gutterXPx = Math.round(layout.actualSpacing.x / 25.4 * dpi);
            const gutterYPx = Math.round(layout.actualSpacing.y / 25.4 * dpi);

            // Calculate available area and center the grid
            const availableWidthPx = canvas.width - 2 * marginLeftPx;
            const availableHeightPx = canvas.height - 2 * marginTopPx;
            
            const totalGridWidth = layout.cols * photoWidthPx + (layout.cols - 1) * gutterXPx;
            const totalGridHeight = layout.rows * photoHeightPx + (layout.rows - 1) * gutterYPx;
            
            const startXPx = marginLeftPx + (availableWidthPx - totalGridWidth) / 2;
            const startYPx = marginTopPx + (availableHeightPx - totalGridHeight) / 2;

            const startIndex = pageIndex * this.printData.maxPhotosPerPage;
            const endIndex = Math.min(startIndex + this.printData.maxPhotosPerPage, this.printData.selectedImages.length);

            let imageIndex = 0;
            for (let i = startIndex; i < endIndex; i++) {
                const imageData = this.printData.selectedImages[i];
                if (!imageData || !imageData.img) continue;

                const row = Math.floor(imageIndex / layout.cols);
                const col = imageIndex % layout.cols;

                const x = startXPx + col * (photoWidthPx + gutterXPx);
                const y = startYPx + row * (photoHeightPx + gutterYPx);

                this.drawImageOnCanvas(ctx, imageData.img, x, y, photoWidthPx, photoHeightPx, config.fitMode);
                imageIndex++;
            }
        }

        renderPageToCanvasWithCoordinateMirroring(canvas, ctx, pageIndex, config) {
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            // Clear canvas with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Use optimized layout dimensions
            const layout = this.printData.gridLayout;
            const photoWidthPx = Math.round(layout.photoWidth / 25.4 * dpi);
            const photoHeightPx = Math.round(layout.photoHeight / 25.4 * dpi);

            // Calculate positions with optimized spacing
            const marginLeftPx = Math.round(config.margins.left / 25.4 * dpi);
            const marginTopPx = Math.round(config.margins.top / 25.4 * dpi);
            const gutterXPx = Math.round(layout.actualSpacing.x / 25.4 * dpi);
            const gutterYPx = Math.round(layout.actualSpacing.y / 25.4 * dpi);

            // Calculate available area and center the grid
            const availableWidthPx = canvas.width - 2 * marginLeftPx;
            const availableHeightPx = canvas.height - 2 * marginTopPx;
            
            const totalGridWidth = layout.cols * photoWidthPx + (layout.cols - 1) * gutterXPx;
            const totalGridHeight = layout.rows * photoHeightPx + (layout.rows - 1) * gutterYPx;
            
            const startXPx = marginLeftPx + (availableWidthPx - totalGridWidth) / 2;
            const startYPx = marginTopPx + (availableHeightPx - totalGridHeight) / 2;

            const startIndex = pageIndex * this.printData.maxPhotosPerPage;
            const endIndex = Math.min(startIndex + this.printData.maxPhotosPerPage, this.printData.selectedImages.length);

            let imageIndex = 0;
            for (let i = startIndex; i < endIndex; i++) {
                const imageData = this.printData.selectedImages[i];
                if (!imageData || !imageData.img) continue;

                const row = Math.floor(imageIndex / layout.cols);
                const col = imageIndex % layout.cols;

                // Calculate original position
                const originalX = startXPx + col * (photoWidthPx + gutterXPx);
                const originalY = startYPx + row * (photoHeightPx + gutterYPx);

                // Apply coordinate mirroring (KHÔNG flip ảnh, chỉ đảo vị trí)
                let mirroredX, mirroredY;
                
                if (config.duplexFlip === 'long-edge') {
                    // Long-edge binding: mirror theo trục X qua center của available area
                    // Tính center của vùng available (không tính margins)
                    const availableAreaCenterX = marginLeftPx + (canvas.width - 2 * marginLeftPx) / 2;
                    
                    // Mirror qua center: distance from center phải bằng nhau
                    const originalCenterX = originalX + photoWidthPx / 2;
                    const distanceFromCenter = originalCenterX - availableAreaCenterX;
                    const mirroredCenterX = availableAreaCenterX - distanceFromCenter;
                    mirroredX = mirroredCenterX - photoWidthPx / 2;
                    mirroredY = originalY; // Y không đổi
                } else {
                    // Short-edge binding: mirror theo trục Y qua center của available area
                    // Tính center của vùng available (không tính margins)
                    const availableAreaCenterY = marginTopPx + (canvas.height - 2 * marginTopPx) / 2;
                    
                    // Mirror qua center: distance from center phải bằng nhau
                    const originalCenterY = originalY + photoHeightPx / 2;
                    const distanceFromCenter = originalCenterY - availableAreaCenterY;
                    const mirroredCenterY = availableAreaCenterY - distanceFromCenter;
                    mirroredX = originalX; // X không đổi
                    mirroredY = mirroredCenterY - photoHeightPx / 2;
                }

                console.log(`Image ${i}: Original(${originalX.toFixed(0)},${originalY.toFixed(0)}) -> Mirrored(${mirroredX.toFixed(0)},${mirroredY.toFixed(0)})`);

                // Vẽ ảnh ở vị trí đã mirror với duplex transformation
                this.drawImageOnCanvasWithDuplexTransform(ctx, imageData.img, mirroredX, mirroredY, photoWidthPx, photoHeightPx, config.fitMode, config.duplexFlip);
                imageIndex++;
            }
        }

        // Helper function để vẽ ảnh với duplex transformation
        drawImageOnCanvasWithDuplexTransform(ctx, img, x, y, width, height, fitMode, duplexFlip) {
            const imgAspect = img.width / img.height;
            const targetAspect = width / height;
            
            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
            
            if (fitMode === 'fill') {
                if (imgAspect > targetAspect) {
                    drawHeight = height;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (width - drawWidth) / 2;
                } else {
                    drawWidth = width;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (height - drawHeight) / 2;
                }
            } else {
                if (imgAspect > targetAspect) {
                    drawWidth = width;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (height - drawHeight) / 2;
                } else {
                    drawHeight = height;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (width - drawWidth) / 2;
                }
            }

            // Vẽ nền trắng
            ctx.fillStyle = 'white';
            ctx.fillRect(x, y, width, height);

            // Apply duplex transformation và vẽ ảnh
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, width, height);
            ctx.clip();
            
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            
            if (duplexFlip === 'long-edge') {
                // Long-edge: Flip ngang
                ctx.translate(centerX, centerY);
                ctx.scale(-1, 1);
                ctx.translate(-centerX, -centerY);
            } else {
                // Short-edge: Xoay 180°
                ctx.translate(centerX, centerY);
                ctx.rotate(Math.PI);
                ctx.translate(-centerX, -centerY);
            }
            
            ctx.drawImage(img, x + offsetX, y + offsetY, drawWidth, drawHeight);
            ctx.restore();

            // Vẽ viền
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, width, height);
        }

        // Helper methods for compact interface
        applyPreset(preset) {
            console.log('🎯 Applying preset:', preset);
            
            const paperSizeSelect = document.getElementById('paperSizeSelect');
            const photoSizeSelect = document.getElementById('photoSizeSelect');
            const printModeSelect = document.getElementById('printModeSelect');
            const marginAll = document.getElementById('marginAll');
            
            switch(preset) {
                case 'standard-5.5x8.5':
                    if (paperSizeSelect) paperSizeSelect.value = 'a4';
                    if (photoSizeSelect) photoSizeSelect.value = '5.5x8.5';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 10;
                    this.printData.config.paperSize = { width: 210, height: 297 };
                    this.printData.config.photoSize = { width: 5.5, height: 8.5 };
                    this.printData.config.printMode = 'single';
                    this.printData.config.margins = { top: 10, bottom: 10, left: 10, right: 10 };
                    break;
                case 'standard-6x9':
                    if (paperSizeSelect) paperSizeSelect.value = 'a4';
                    if (photoSizeSelect) photoSizeSelect.value = '6x9';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 15;
                    this.printData.config.paperSize = { width: 210, height: 297 };
                    this.printData.config.photoSize = { width: 6, height: 9 };
                    this.printData.config.printMode = 'single';
                    this.printData.config.margins = { top: 15, bottom: 15, left: 15, right: 15 };
                    break;
                case 'standard-7x10':
                    if (paperSizeSelect) paperSizeSelect.value = 'a4';
                    if (photoSizeSelect) photoSizeSelect.value = '7x10';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 10;
                    this.printData.config.paperSize = { width: 210, height: 297 };
                    this.printData.config.photoSize = { width: 7, height: 10 };
                    this.printData.config.printMode = 'single';
                    this.printData.config.margins = { top: 10, bottom: 10, left: 10, right: 10 };
                    break;
                case 'custom':
                    // Don't change anything, let user configure
                    this.showToast('💡 Chọn cài đặt tùy chỉnh - điều chỉnh các tùy chọn bên dưới', 'info');
                    break;
            }
            
            this.calculateLayout();
            this.showToast(`✅ Đã áp dụng preset: ${preset}`, 'success');
        }

        applyCuttingPreset(cutting) {
            console.log('✂️ Applying cutting preset:', cutting);
            
            const outerCuttingLines = document.getElementById('outerCuttingLines');
            const betweenImages = document.getElementById('betweenImages');
            const cornerMarks = document.getElementById('cornerMarks');
            const gridHelperLines = document.getElementById('gridHelperLines');
            
            switch(cutting) {
                case 'standard':
                    if (outerCuttingLines) outerCuttingLines.checked = true;
                    if (betweenImages) betweenImages.checked = true;
                    if (cornerMarks) cornerMarks.checked = false;
                    if (gridHelperLines) gridHelperLines.checked = false;
                    this.printData.config.cuttingGuides = {
                        ...this.printData.config.cuttingGuides,
                        outerCuttingLines: true,
                        betweenImages: true,
                        cornerMarks: false,
                        gridHelperLines: false
                    };
                    break;
                case 'minimal':
                    if (outerCuttingLines) outerCuttingLines.checked = true;
                    if (betweenImages) betweenImages.checked = false;
                    if (cornerMarks) cornerMarks.checked = false;
                    if (gridHelperLines) gridHelperLines.checked = false;
                    this.printData.config.cuttingGuides = {
                        ...this.printData.config.cuttingGuides,
                        outerCuttingLines: true,
                        betweenImages: false,
                        cornerMarks: false,
                        gridHelperLines: false
                    };
                    break;
                case 'detailed':
                    if (outerCuttingLines) outerCuttingLines.checked = true;
                    if (betweenImages) betweenImages.checked = true;
                    if (cornerMarks) cornerMarks.checked = true;
                    if (gridHelperLines) gridHelperLines.checked = true;
                    this.printData.config.cuttingGuides = {
                        ...this.printData.config.cuttingGuides,
                        outerCuttingLines: true,
                        betweenImages: true,
                        cornerMarks: true,
                        gridHelperLines: true
                    };
                    break;
                case 'custom':
                    // Show custom options
                    const customOptions = document.getElementById('cuttingCustomOptions');
                    if (customOptions) {
                        customOptions.style.display = customOptions.style.display === 'none' ? 'block' : 'none';
                    }
                    break;
            }
            
            this.updateMasterCanvas();
            this.showToast(`✅ Đã áp dụng cài đặt đường cắt: ${cutting}`, 'success');
        }

        generatePreview() {
            console.log('🔍 Generating preview');
            
            if (!this.printData.selectedImages || this.printData.selectedImages.length === 0) {
                this.showToast('⚠️ Chưa có ảnh nào được chọn để xem trước!', 'warning');
                return;
            }
            
            // Show preview container
            const previewContainer = document.getElementById('printPreviewContainer');
            if (previewContainer) {
                previewContainer.style.display = 'block';
                this.updateMasterCanvas();
                this.showToast('✅ Đã tạo bản xem trước!', 'success');
                
                // Scroll to preview
                previewContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            
            // Enable generate print button
            const generatePrintBtn = document.getElementById('generatePrintBtn');
            if (generatePrintBtn) {
                generatePrintBtn.disabled = false;
            }
        }

        resetToDefaults() {
            console.log('🔄 Resetting to defaults');
            
            // Reset config to defaults
            this.printData.config = {
                paperSize: { width: 210, height: 297 }, // A4
                photoSize: { width: 5.5, height: 8.5 },
                margins: { top: 10, bottom: 10, left: 10, right: 10 },
                gutter: { x: 5, y: 5 },
                dpi: 300,
                orientation: 'portrait',
                fitMode: 'fill',
                printMode: 'single',
                duplexFlip: 'long-edge',
                cuttingGuides: {
                    outerCuttingLines: true,
                    betweenImages: true,
                    cornerMarks: false,
                    gridHelperLines: false,
                    color: '#000000',
                    thickness: 0.5,
                    lineStyle: 'solid'
                }
            };
            
            // Reset UI elements
            const paperSizeSelect = document.getElementById('paperSizeSelect');
            const photoSizeSelect = document.getElementById('photoSizeSelect');
            const printModeSelect = document.getElementById('printModeSelect');
            const marginAll = document.getElementById('marginAll');
            
            if (paperSizeSelect) paperSizeSelect.value = 'a4';
            if (photoSizeSelect) photoSizeSelect.value = '5.5x8.5';
            if (printModeSelect) printModeSelect.value = 'single';
            if (marginAll) marginAll.value = 10;
            
            // Reset active states
            document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
            document.querySelector('.preset-card[data-preset="standard-5.5x8.5"]')?.classList.add('active');
            
            document.querySelectorAll('.orient-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.orient-btn[data-orientation="portrait"]')?.classList.add('active');
            
            document.querySelectorAll('.fit-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.fit-btn[data-fit="fill"]')?.classList.add('active');
            
            this.calculateLayout();
            this.showToast('🔄 Đã reset về cài đặt mặc định!', 'success');
        }

        toggleDuplexInterface(isDuplex) {
            const duplexConfig = document.getElementById('duplexConfigCompact');
            const duplexSection = document.getElementById('duplexClassificationSection');
            
            if (isDuplex) {
                if (duplexConfig) duplexConfig.style.display = 'block';
                if (duplexSection) duplexSection.style.display = 'block';
            } else {
                if (duplexConfig) duplexConfig.style.display = 'none';
                if (duplexSection) duplexSection.style.display = 'none';
            }
        }

        downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Progress bar management functions
        showProgress(fileId, text = 'Đang xử lý...') {
            const progressEl = document.getElementById(`progress-${fileId}`);
            if (progressEl) {
                progressEl.classList.add('show');
                this.updateProgress(fileId, 0, text);
            }
        }

        hideProgress(fileId) {
            const progressEl = document.getElementById(`progress-${fileId}`);
            if (progressEl) {
                progressEl.classList.remove('show');
            }
        }

        updateProgress(fileId, percentage, text, timeInfo = '') {
            const fillEl = document.getElementById(`progress-fill-${fileId}`);
            const textEl = document.getElementById(`progress-text-${fileId}`);
            const timeEl = document.getElementById(`progress-time-${fileId}`);

            if (fillEl) fillEl.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
            if (textEl) textEl.textContent = text;
            if (timeEl) timeEl.textContent = timeInfo;
        }

        formatTimeRemaining(seconds) {
            if (seconds < 60) return `~${Math.ceil(seconds)}s`;
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.ceil(seconds % 60);
            return `~${minutes}m ${remainingSeconds}s`;
        }

        // Global HEIC check function
        isHEICFile(file) {
            if (!file || !file.name) return false;
            const fileName = file.name.toLowerCase();
            return (fileName.endsWith('.heic') || fileName.endsWith('.heif')) && 
                   (!file.type || !file.type.startsWith('image/') || 
                    file.type === 'image/heic' || file.type === 'image/heif');
        }

        // Safe create object URL - returns null for HEIC files
        safeCreateObjectURL(file) {
            if (!file) {
                console.warn('safeCreateObjectURL called with null file');
                return null;
            }
            if (this.isHEICFile(file)) {
                console.log('Skipping blob URL creation for HEIC file:', file.name);
                return null;
            }
            return URL.createObjectURL(file);
        }

        // Upload Progress Management
        showUploadProgress(totalFiles) {
            const overlay = document.getElementById('uploadProgressOverlay');
            const currentFile = document.getElementById('uploadCurrentFile');
            const overallText = document.getElementById('uploadOverallText');
            const overallFill = document.getElementById('uploadOverallFill');
            
            if (overlay) overlay.classList.add('show');
            if (currentFile) currentFile.textContent = 'Đang chuẩn bị...';
            if (overallText) overallText.textContent = `Đang xử lý 0/${totalFiles} files`;
            if (overallFill) overallFill.style.width = '0%';
            
            this.uploadProgress = {
                total: totalFiles,
                completed: 0,
                startTime: Date.now(),
                currentIndex: 0
            };
        }

        updateSingleUploadProgress(fileName, status, currentIndex, stepProgress = 0) {
            const currentFile = document.getElementById('uploadCurrentFile');
            const overallText = document.getElementById('uploadOverallText');
            const overallFill = document.getElementById('uploadOverallFill');
            const overallTime = document.getElementById('uploadOverallTime');
            
            // Update current file display with styling
            if (currentFile) {
                const statusIcon = this.getStatusIcon(status);
                currentFile.textContent = `${statusIcon} ${fileName} - ${status}`;
                
                // Update CSS classes based on status
                currentFile.className = 'upload-current-file';
                if (status.includes('✅') || status.includes('Hoàn thành')) {
                    currentFile.classList.add('success');
                } else if (status.includes('❌') || status.includes('Không hợp lệ')) {
                    currentFile.classList.add('error');
                } else if (status.includes('⚠️') || status.includes('trùng lặp')) {
                    currentFile.classList.add('error');
                } else {
                    currentFile.classList.add('processing');
                }
            }
            
            // Calculate overall progress
            const baseProgress = (currentIndex / this.uploadProgress.total) * 100;
            const stepProgressPercent = (stepProgress / this.uploadProgress.total) * 100;
            const totalProgress = Math.min(100, baseProgress + stepProgressPercent);
            
            // Update overall progress
            if (overallText) {
                const completed = status.includes('✅') || status.includes('Hoàn thành') ? 
                    currentIndex + 1 : currentIndex;
                overallText.textContent = `Đang xử lý ${completed}/${this.uploadProgress.total} files`;
            }
            
            if (overallFill) {
                overallFill.style.width = `${totalProgress}%`;
            }
            
            // Calculate time remaining
            if (overallTime && totalProgress > 5) {
                const elapsedTime = (Date.now() - this.uploadProgress.startTime) / 1000;
                const estimatedTotal = (elapsedTime * 100) / totalProgress;
                const remaining = Math.max(0, estimatedTotal - elapsedTime);
                
                if (remaining > 1) {
                    overallTime.textContent = `Còn lại: ${this.formatTimeRemaining(remaining)}`;
                }
            }
        }

        getStatusIcon(status) {
            if (status.includes('Hoàn thành') || status.includes('✅')) return '✅';
            if (status.includes('trùng lặp') || status.includes('⚠️')) return '⚠️';
            if (status.includes('Không hợp lệ') || status.includes('❌')) return '❌';
            if (status.includes('chất lượng')) return '🔍';
            if (status.includes('hash')) return '🔑';
            if (status.includes('validate')) return '📝';
            return '⏳';
        }

        hideUploadProgress() {
            const overlay = document.getElementById('uploadProgressOverlay');
            if (overlay) {
                setTimeout(() => {
                    overlay.classList.remove('show');
                }, 2000); // Hide after 2 seconds
            }
        }

        // Initialize upload progress modal interactions
        initUploadProgressModal() {
            const overlay = document.getElementById('uploadProgressOverlay');
            const modal = document.querySelector('.upload-progress-modal');
            
            if (overlay && modal) {
                // Close on overlay click (but not modal click)
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        overlay.classList.remove('show');
                    }
                });
                
                // Prevent modal click from closing overlay
                modal.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
        }

        completeUploadProgress() {
            const overallText = document.getElementById('uploadOverallText');
            const overallFill = document.getElementById('uploadOverallFill');
            const overallTime = document.getElementById('uploadOverallTime');
            
            if (overallText) overallText.textContent = `✅ Hoàn thành ${this.uploadProgress?.total || 0} files`;
            if (overallFill) overallFill.style.width = '100%';
            if (overallTime) {
                const totalTime = (Date.now() - (this.uploadProgress?.startTime || Date.now())) / 1000;
                overallTime.textContent = `Hoàn thành trong ${totalTime.toFixed(1)}s`;
            }
            
            this.hideUploadProgress();
        }

        // HEIC to Image conversion using client-side library
        async convertHEICToImage(heicFile) {
            try {
                console.log('Converting HEIC file:', heicFile.name);
                
                // Read HEIC file as array buffer
                const arrayBuffer = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(heicFile);
                });
                
                // Simple HEIC to JPEG conversion using canvas approach
                // Note: This is a fallback method, real HEIC decoding requires WebAssembly
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // Try to use heic2any library if available globally
                if (typeof heic2any !== 'undefined') {
                    const convertedBlob = await heic2any({
                        blob: heicFile,
                        toType: 'image/jpeg',
                        quality: 0.95
                    });
                    
                    // Create image from converted blob
                    const img = new Image();
                    const url = URL.createObjectURL(convertedBlob);
                    
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            URL.revokeObjectURL(url);
                            resolve();
                        };
                        img.onerror = reject;
                        img.src = url;
                    });
                    
                    return img;
                } else {
                    // Fallback: Show message about HEIC support
                    throw new Error('HEIC format requires additional library. Please convert HEIC to JPG using your device first.');
                }
                
            } catch (error) {
                console.error('HEIC conversion failed:', error);
                // Fallback: Try to load as regular image (might work in some browsers)
                const img = new Image();
                const url = URL.createObjectURL(heicFile);
                
                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        URL.revokeObjectURL(url);
                        resolve(img);
                    };
                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('HEIC format not supported. Please convert to JPG/PNG first or use Safari/Chrome browser.'));
                    };
                    img.src = url;
                });
            }
        }
        
        getCurrentActiveTab() {
            // Check which tab is currently active
            const tabs = ['crop', 'gallery', 'print'];
            for (const tabName of tabs) {
                const tabElement = document.getElementById(`${tabName}Tab`);
                if (tabElement && tabElement.classList.contains('active')) {
                    return tabName;
                }
            }
            return 'gallery'; // Default fallback
        }
        
        // Border Template functionality
        initializeBorderTemplateMode() {
            console.log('🔧 Initializing Border Template Mode...');
            
            // Initialize border template data with configuration
            this.borderTemplateData = {
                images: [],
                currentIndex: 0,
                config: {
                    dpi: 300,
                    templateSizeCm: { width: 10, height: 15 },
                    border: {
                        enabled: true,
                        thickness: 5,
                        color: '#FFFFFF',
                        cornerRadius: 0
                    },
                    fitMode: 'cover',
                    safeAreaPx: 0,
                    bgColor: '#FFFFFF',
                    dropShadow: false
                }
            };
            
            // Setup event listeners for border template controls
            this.setupBorderTemplateControls();
            this.updateBorderTemplateSpecs();
            
            console.log('✅ Border Template Mode initialized');
        }
        
        setupBorderTemplateControls() {
            const borderTemplateDPI = document.getElementById('borderTemplateDPI');
            const borderTemplateWidth = document.getElementById('borderTemplateWidth');
            const borderTemplateHeight = document.getElementById('borderTemplateHeight');
            
            if (borderTemplateDPI) {
                borderTemplateDPI.addEventListener('change', (e) => {
                    this.borderTemplateData.config.dpi = parseInt(e.target.value);
                    this.updateBorderTemplateSpecs();
                    this.reprocessAllBorderTemplateImages();
                });
            }
            
            if (borderTemplateWidth) {
                borderTemplateWidth.addEventListener('input', (e) => {
                    this.borderTemplateData.config.templateSizeCm.width = parseFloat(e.target.value);
                    this.updateBorderTemplateSpecs();
                    this.reprocessAllBorderTemplateImages();
                });
            }
            
            if (borderTemplateHeight) {
                borderTemplateHeight.addEventListener('input', (e) => {
                    this.borderTemplateData.config.templateSizeCm.height = parseFloat(e.target.value);
                    this.updateBorderTemplateSpecs();
                    this.reprocessAllBorderTemplateImages();
                });
            }
            
            // Border controls
            const borderThickness = document.getElementById('borderThickness');
            const borderThicknessValue = document.getElementById('borderThicknessValue');
            const borderTemplateColor = document.getElementById('borderTemplateColor');
            const borderCornerRadius = document.getElementById('borderCornerRadius');
            const borderCornerRadiusValue = document.getElementById('borderCornerRadiusValue');
            
            if (borderThickness && borderThicknessValue) {
                borderThickness.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    borderThicknessValue.value = value;
                    this.borderTemplateData.config.border.thickness = value;
                    this.updateBorderTemplateSpecs();
                    this.reprocessAllBorderTemplateImages();
                });
                
                borderThicknessValue.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    borderThickness.value = value;
                    this.borderTemplateData.config.border.thickness = value;
                    this.updateBorderTemplateSpecs();
                    this.reprocessAllBorderTemplateImages();
                });
            }
            
            if (borderTemplateColor) {
                borderTemplateColor.addEventListener('change', (e) => {
                    this.borderTemplateData.config.border.color = e.target.value;
                    this.reprocessAllBorderTemplateImages();
                });
            }
            
            // File upload
            const borderTemplateFileInput = document.getElementById('borderTemplateFileInput');
            if (borderTemplateFileInput) {
                borderTemplateFileInput.addEventListener('change', (e) => {
                    this.handleBorderTemplateFiles(e.target.files);
                });
            }
        }
        
        updateBorderTemplateSpecs() {
            const config = this.borderTemplateData.config;
            // CÔNG THỨC CHÍNH XÁC: Cố định DPI = 300
            const DPI = 300;
            const sizeCm = config.templateSizeCm;
            
            // LUÔN sử dụng Math.round() cho pixel cuối cùng
            const canvasW = Math.round((sizeCm.width / 2.54) * DPI);
            const canvasH = Math.round((sizeCm.height / 2.54) * DPI);
            
            const specsDisplay = document.getElementById('borderTemplateSpecsDisplay');
            if (!specsDisplay) return;
            
            specsDisplay.innerHTML = `
                <div class="spec-row">
                    <span class="spec-key">Canvas:</span>
                    <span class="spec-value">${canvasW} × ${canvasH} px</span>
                </div>
                <div class="spec-row">
                    <span class="spec-key">Kích thước:</span>
                    <span class="spec-value">${sizeCm.width} × ${sizeCm.height} cm</span>
                </div>
                <div class="spec-row">
                    <span class="spec-key">DPI:</span>
                    <span class="spec-value">${dpi}</span>
                </div>
                <div class="spec-row">
                    <span class="spec-key">Viền:</span>
                    <span class="spec-value">${config.border.thickness}mm - ${config.border.color}</span>
                </div>
            `;
        }
        
        async handleBorderTemplateFiles(files) {
            if (!files || files.length === 0) return;
            
            console.log(`🔧 Processing ${files.length} files for border template...`);
            
            for (const file of files) {
                try {
                    const imageData = await this.processBorderTemplateImage(file);
                    if (imageData) {
                        this.borderTemplateData.images.push(imageData);
                    }
                } catch (error) {
                    console.error('Error processing border template image:', error);
                }
            }
            
            this.updateBorderTemplateUI();
            this.showToast(`✅ Đã tải ${this.borderTemplateData.images.length} ảnh viền thường`, 'success');
        }
        
        async processBorderTemplateImage(file) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const imageData = {
                        file: file,
                        originalImage: img,
                        filename: file.name
                    };
                    resolve(imageData);
                };
                img.onerror = () => resolve(null);
                img.src = URL.createObjectURL(file);
            });
        }
        
        updateBorderTemplateUI() {
            const borderTemplateImageCount = document.getElementById('borderTemplateImageCount');
            if (borderTemplateImageCount) {
                borderTemplateImageCount.textContent = this.borderTemplateData.images.length;
            }
        }
        
        reprocessAllBorderTemplateImages() {
            // Placeholder for reprocessing logic
            console.log('Reprocessing all border template images...');
        }
        
        // Strip Template functionality
        initializeStripTemplateMode() {
            console.log('🔧 Initializing Strip Template Mode...');
            
            // Initialize strip template data with configuration
            this.stripTemplateData = {
                images: [],
                strips: [], // Each strip contains 4 images
                currentStripIndex: 0,
                config: {
                    dpi: 300,
                    stripSizeCm: { width: 5, height: 15 },
                    frameCount: 4,
                    frameRatio: '4:3',
                    spacing: {
                        outerBorder: 5,
                        frameSpacing: 2,
                        frameBorder: 1
                    },
                    colors: {
                        stripBorder: '#FFFFFF',
                        frameBorder: '#FFFFFF',
                        background: '#000000'
                    }
                }
            };
            
            // Setup event listeners for strip template controls
            this.setupStripTemplateControls();
            this.updateStripTemplateSpecs();
            
            console.log('✅ Strip Template Mode initialized');
        }
        
        setupStripTemplateControls() {
            const stripTemplateDPI = document.getElementById('stripTemplateDPI');
            const stripTemplateWidth = document.getElementById('stripTemplateWidth');
            const stripTemplateHeight = document.getElementById('stripTemplateHeight');
            const stripFrameCount = document.getElementById('stripFrameCount');
            const stripFrameRatio = document.getElementById('stripFrameRatio');
            
            if (stripTemplateDPI) {
                stripTemplateDPI.addEventListener('change', (e) => {
                    this.stripTemplateData.config.dpi = parseInt(e.target.value);
                    this.updateStripTemplateSpecs();
                    this.reprocessAllStripTemplates();
                });
            }
            
            if (stripTemplateWidth) {
                stripTemplateWidth.addEventListener('input', (e) => {
                    this.stripTemplateData.config.stripSizeCm.width = parseFloat(e.target.value);
                    this.updateStripTemplateSpecs();
                    this.reprocessAllStripTemplates();
                });
            }
            
            if (stripTemplateHeight) {
                stripTemplateHeight.addEventListener('input', (e) => {
                    this.stripTemplateData.config.stripSizeCm.height = parseFloat(e.target.value);
                    this.updateStripTemplateSpecs();
                    this.reprocessAllStripTemplates();
                });
            }
            
            if (stripFrameCount) {
                stripFrameCount.addEventListener('change', (e) => {
                    this.stripTemplateData.config.frameCount = parseInt(e.target.value);
                    this.updateStripFramesDisplay();
                    this.updateStripTemplateSpecs();
                });
            }
            
            if (stripFrameRatio) {
                stripFrameRatio.addEventListener('change', (e) => {
                    this.stripTemplateData.config.frameRatio = e.target.value;
                    this.updateStripFramesDisplay();
                    this.updateStripTemplateSpecs();
                });
            }
            
            // Spacing controls
            const stripOuterBorder = document.getElementById('stripOuterBorder');
            const stripOuterBorderValue = document.getElementById('stripOuterBorderValue');
            const stripFrameSpacing = document.getElementById('stripFrameSpacing');
            const stripFrameSpacingValue = document.getElementById('stripFrameSpacingValue');
            
            if (stripOuterBorder && stripOuterBorderValue) {
                stripOuterBorder.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    stripOuterBorderValue.value = value;
                    this.stripTemplateData.config.spacing.outerBorder = value;
                    this.updateStripTemplateSpecs();
                });
                
                stripOuterBorderValue.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    stripOuterBorder.value = value;
                    this.stripTemplateData.config.spacing.outerBorder = value;
                    this.updateStripTemplateSpecs();
                });
            }
            
            // File upload
            const stripTemplateFileInput = document.getElementById('stripTemplateFileInput');
            if (stripTemplateFileInput) {
                stripTemplateFileInput.addEventListener('change', (e) => {
                    this.handleStripTemplateFiles(e.target.files);
                });
            }
        }
        
        updateStripTemplateSpecs() {
            const config = this.stripTemplateData.config;
            // CÔNG THỨC CHÍNH XÁC: Cố định DPI = 300
            const DPI = 300;
            const sizeCm = config.stripSizeCm;
            
            // LUÔN sử dụng Math.round() cho pixel cuối cùng
            const stripW = Math.round((sizeCm.width / 2.54) * DPI);
            const stripH = Math.round((sizeCm.height / 2.54) * DPI);
            
            // Calculate frame dimensions
            const frameHeight = Math.round((stripH - (config.spacing.outerBorder * 2) - (config.spacing.frameSpacing * (config.frameCount - 1))) / config.frameCount);
            const frameWidth = Math.round(stripW - (config.spacing.outerBorder * 2));
            
            const specsDisplay = document.getElementById('stripTemplateSpecsDisplay');
            if (!specsDisplay) return;
            
            specsDisplay.innerHTML = `
                <div class="spec-row">
                    <span class="spec-key">Strip:</span>
                    <span class="spec-value">${stripW} × ${stripH} px</span>
                </div>
                <div class="spec-row">
                    <span class="spec-key">Kích thước:</span>
                    <span class="spec-value">${sizeCm.width} × ${sizeCm.height} cm</span>
                </div>
                <div class="spec-row">
                    <span class="spec-key">Khung ảnh:</span>
                    <span class="spec-value">${frameWidth} × ${frameHeight} px (${config.frameCount} khung)</span>
                </div>
                <div class="spec-row">
                    <span class="spec-key">Tỷ lệ:</span>
                    <span class="spec-value">${config.frameRatio}</span>
                </div>
            `;
        }
        
        updateStripFramesDisplay() {
            const frameCount = this.stripTemplateData.config.frameCount;
            const stripTemplateFrame = document.getElementById('stripTemplateFrame');
            
            if (!stripTemplateFrame) return;
            
            // Clear existing frames
            stripTemplateFrame.innerHTML = '';
            
            // Create new frames
            for (let i = 1; i <= frameCount; i++) {
                const frame = document.createElement('div');
                frame.className = 'strip-frame';
                frame.id = `stripFrame${i}`;
                frame.innerHTML = `<div class="placeholder-text">Khung ${i}</div>`;
                stripTemplateFrame.appendChild(frame);
            }
        }
        
        async handleStripTemplateFiles(files) {
            if (!files || files.length === 0) return;
            
            console.log(`🔧 Processing ${files.length} files for strip template...`);
            
            for (const file of files) {
                try {
                    const imageData = await this.processStripTemplateImage(file);
                    if (imageData) {
                        this.stripTemplateData.images.push(imageData);
                    }
                } catch (error) {
                    console.error('Error processing strip template image:', error);
                }
            }
            
            // Create strips from images (4 images per strip)
            this.createStripsFromImages();
            this.updateStripTemplateUI();
            this.showToast(`✅ Đã tải ${this.stripTemplateData.images.length} ảnh cho Strip Layout`, 'success');
        }
        
        async processStripTemplateImage(file) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const imageData = {
                        file: file,
                        originalImage: img,
                        filename: file.name
                    };
                    resolve(imageData);
                };
                img.onerror = () => resolve(null);
                img.src = URL.createObjectURL(file);
            });
        }
        
        createStripsFromImages() {
            const images = this.stripTemplateData.images;
            const frameCount = this.stripTemplateData.config.frameCount;
            const strips = [];
            
            for (let i = 0; i < images.length; i += frameCount) {
                const stripImages = images.slice(i, i + frameCount);
                if (stripImages.length > 0) {
                    strips.push({
                        id: strips.length,
                        images: stripImages,
                        timestamp: Date.now()
                    });
                }
            }
            
            this.stripTemplateData.strips = strips;
            console.log(`Created ${strips.length} strips from ${images.length} images`);
        }
        
        updateStripTemplateUI() {
            const stripTemplateImageCount = document.getElementById('stripTemplateImageCount');
            if (stripTemplateImageCount) {
                stripTemplateImageCount.textContent = this.stripTemplateData.strips.length;
            }
            
            // Update preview with first strip
            if (this.stripTemplateData.strips.length > 0) {
                this.displayStripPreview(0);
            }
        }
        
        displayStripPreview(stripIndex) {
            const strip = this.stripTemplateData.strips[stripIndex];
            if (!strip) return;
            
            strip.images.forEach((imageData, frameIndex) => {
                const frameElement = document.getElementById(`stripFrame${frameIndex + 1}`);
                if (frameElement && imageData) {
                    frameElement.innerHTML = '';
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(imageData.file);
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    frameElement.appendChild(img);
                }
            });
        }
        
        reprocessAllStripTemplates() {
            // Placeholder for reprocessing logic
            console.log('Reprocessing all strip templates...');
        }
        
        // Template Sub-tab Management
        switchTemplateSubTab(subTabName) {
            console.log(`Switching to template sub-tab: ${subTabName}`);
            
            // Remove active class from all sub-tabs and content
            document.querySelectorAll('.sub-tab-button').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.template-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected sub-tab and content
            if (subTabName === 'polaroid') {
                document.getElementById('polaroidSubTab').classList.add('active');
                document.getElementById('polaroidTemplateContent').classList.add('active');
                this.initializeTemplateMode();
            } else if (subTabName === 'border') {
                document.getElementById('borderSubTab').classList.add('active');
                document.getElementById('borderTemplateContent').classList.add('active');
                this.initializeBorderTemplateMode();
            } else if (subTabName === 'strip') {
                document.getElementById('stripSubTab').classList.add('active');
                document.getElementById('stripTemplateContent').classList.add('active');
                this.initializeStripTemplateMode();
            }
        }
        
        initializeActiveTemplate() {
            // Initialize the currently active template sub-tab
            const activeSubTab = document.querySelector('.sub-tab-button.active');
            if (activeSubTab) {
                const subTabId = activeSubTab.id;
                if (subTabId === 'polaroidSubTab') {
                    this.initializeTemplateMode();
                } else if (subTabId === 'borderSubTab') {
                    this.initializeBorderTemplateMode();
                } else if (subTabId === 'stripSubTab') {
                    this.initializeStripTemplateMode();
                }
            } else {
                // Default to Polaroid if no active sub-tab
                this.switchTemplateSubTab('polaroid');
            }
        }
        }

        // Initialize the converter
        const converter = new BatchImageConverter();
        
        // Initialize upload progress modal
        converter.initUploadProgressModal();

        // Cleanup all blob URLs when page unloads to prevent memory leaks
        window.addEventListener('beforeunload', () => {
            // Cleanup all file preview URLs
            if (converter && converter.files) {
                converter.files.forEach(file => {
                    if (file.previewUrl) {
                        URL.revokeObjectURL(file.previewUrl);
                    }
                });
            }
        });

        // Enhanced Template Crop Functions - Progress Steps & Upload Handling
        window.updateProgressSteps = function(currentStep) {
            console.log('📊 Cập nhật bước tiến trình:', currentStep);
            
            const progressSteps = document.querySelectorAll('.progress-step');
            progressSteps.forEach((step, index) => {
                step.classList.remove('active', 'completed');
                
                if (index + 1 < currentStep) {
                    step.classList.add('completed');
                } else if (index + 1 === currentStep) {
                    step.classList.add('active');
                }
            });
            
            // Show/hide sections based on current step
            const sectionModern = document.querySelector('.size-selection-modern');
            const uploadArea = document.querySelector('.upload-area-modern');
            const processingArea = document.querySelector('.processing-area');
            const resultsSection = document.querySelector('.crop-results');
            
            if (sectionModern) sectionModern.style.display = currentStep === 1 ? 'block' : 'none';
            if (uploadArea) uploadArea.style.display = currentStep === 2 ? 'block' : 'none';  
            if (processingArea) processingArea.style.display = currentStep === 3 ? 'block' : 'none';
            if (resultsSection) resultsSection.style.display = currentStep === 4 ? 'block' : 'none';
            
            // Also show the crop results section when we have cropped images
            const cropResults = document.getElementById('cropResults');
            if (cropResults && currentStep === 4) {
                cropResults.style.display = 'block';
            }
        };

        // Handle Template Crop Upload
        window.handleTemplateCropUpload = function(files) {
            console.log('📤 Xử lý upload ảnh cho template crop:', files.length, 'files');
            
            const processingArea = document.querySelector('.processing-area');
            const progressBar = document.querySelector('.progress-bar');
            const processedCount = document.querySelector('.processed-count');
            const totalCount = document.querySelector('.total-count');
            
            if (processingArea) processingArea.style.display = 'block';
            if (totalCount) totalCount.textContent = files.length;
            
            let processed = 0;
            const total = files.length;
            
            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Simulate processing
                    setTimeout(() => {
                        processed++;
                        const progress = (processed / total) * 100;
                        
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (processedCount) processedCount.textContent = processed;
                        
                        // When complete, move to results
                        if (processed === total) {
                            setTimeout(() => {
                                window.updateProgressSteps(4);
                                window.showTemplateCropResults(files);
                            }, 500);
                        }
                    }, (index + 1) * 300); // Stagger processing for visual effect
                };
                reader.readAsDataURL(file);
            });
        };

        // Show Template Crop Results
        window.showTemplateCropResults = function(files) {
            console.log('📊 Hiển thị kết quả template crop');
            
            const resultsGrid = document.querySelector('.results-grid');
            const totalImages = document.querySelector('.total-images');
            const processedImagesSpan = document.querySelector('.processed-images');
            
            if (totalImages) totalImages.textContent = files.length;
            if (processedImagesSpan) processedImagesSpan.textContent = files.length;
            
            if (resultsGrid) {
                resultsGrid.innerHTML = '';
                
                Array.from(files).forEach(file => {
                    const resultItem = document.createElement('div');
                    resultItem.className = 'result-item';
                    resultItem.innerHTML = `
                        <img src="${URL.createObjectURL(file)}" alt="${file.name}">
                        <div class="result-name">${file.name}</div>
                        <div class="result-actions">
                            <button class="action-btn">💾 Tải về</button>
                            <button class="action-btn">👁️ Xem</button>
                        </div>
                    `;
                    resultsGrid.appendChild(resultItem);
                });
            }
        };

        // Function to show crop results section with downloaded images
        window.showCropResultsSection = function() {
            console.log('📊 Hiển thị section kết quả crop');
            
            const cropResults = document.getElementById('cropResults');
            if (cropResults) {
                cropResults.style.display = 'block';
                
                // Update results summary if available
                const processedImages = document.querySelector('.processed-images');
                const totalImages = document.querySelector('.total-images');
                
                // Try to get count from converter or other sources
                if (window.converter && window.converter.files) {
                    const croppedCount = window.converter.files.filter(f => f.cropped).length;
                    if (processedImages) processedImages.textContent = croppedCount;
                    if (totalImages) totalImages.textContent = croppedCount;
                } else {
                    // Fallback to show the section anyway
                    if (processedImages) processedImages.textContent = '?';
                    if (totalImages) totalImages.textContent = '?';
                }
                
                console.log('✅ Crop results section is now visible');
            } else {
                console.warn('❌ Không tìm thấy crop results section');
            }
        };

        // Auto-show crop results when there are cropped images
        window.checkAndShowCropResults = function() {
            if (window.converter && window.converter.files) {
                const hasCroppedImages = window.converter.files.some(f => f.cropped);
                if (hasCroppedImages) {
                    window.showCropResultsSection();
                }
            }
            
            // Also check converter crop data
            if (window.converter && (window.converter.cropProcessedFiles?.length > 0 || window.converter.cropData?.croppedImages?.length > 0)) {
                window.showCropResultsSection();
            }
            
            // Also check for any existing cropped files in gallery or other sources
            if (window.layoutManager && window.layoutManager.galleryImages) {
                const hasGalleryImages = window.layoutManager.galleryImages.length > 0;
                if (hasGalleryImages) {
                    window.showCropResultsSection();
                }
            }
        };

        // Call this periodically to check for cropped images
        setInterval(() => {
            window.checkAndShowCropResults();
        }, 2000);

        // Also check immediately when page loads
        setTimeout(() => {
            window.checkAndShowCropResults();
        }, 1000);

        console.log('✅ Enhanced Template Crop functions loaded successfully');
    </script>
    
    <!-- Upload Progress Overlay -->
    <div class="upload-progress-overlay" id="uploadProgressOverlay">
        <div class="upload-progress-modal">
            <div class="upload-progress-title">Đang tải ảnh lên</div>
            
            <!-- Current file being processed -->
            <div class="upload-current-file" id="uploadCurrentFile">
                Đang chuẩn bị...
            </div>
            
            <!-- Single progress bar -->
            <div class="upload-overall-progress">
                <div class="upload-overall-text" id="uploadOverallText">Đang xử lý 0/0 files</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="uploadOverallFill"></div>
                </div>
                <div class="progress-time" id="uploadOverallTime"></div>
            </div>
        </div>
    </div>
</body>
</html>