<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEU Layout</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <!-- PDF.js for PDF to Image conversion with maximum quality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // C·∫•u h√¨nh PDF.js worker ƒë·ªÉ ƒë·∫£m b·∫£o hi·ªáu su·∫•t t·ªëi ∆∞u
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Ultra High-Contrast Color Palette */
            --primary: #3730a3;
            --primary-light: #4f46e5;
            --primary-dark: #1e1b4b;
            --accent: #0284c7;
            --background: #ffffff;
            --surface: #ffffff;
            --surface-elevated: #ffffff;
            --text-primary: #000000;
            --text-secondary: #1f2937;
            --text-tertiary: #374151;
            --border: #9ca3af;
            --border-light: #d1d5db;
            --success: #15803d;
            --warning: #b45309;
            --error: #b91c1c;
            
            /* Ultra High-Contrast Gradients */
            --gradient-primary: linear-gradient(135deg, #3730a3 0%, #1e1b4b 100%);
            --gradient-surface: linear-gradient(145deg, #ffffff 0%, #ffffff 100%);
            --gradient-background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
            
            /* Refined Spacing System */
            --space-1: 0.25rem;  /* 4px */
            --space-2: 0.5rem;   /* 8px */
            --space-3: 0.75rem;  /* 12px */
            --space-4: 1rem;     /* 16px */
            --space-5: 1.25rem;  /* 20px */
            --space-6: 1.5rem;   /* 24px */
            --space-8: 2rem;     /* 32px */
            --space-10: 2.5rem;  /* 40px */
            --space-12: 3rem;    /* 48px */
            --space-16: 4rem;    /* 64px */
            
            /* Professional Border Radius */
            --radius-xs: 0.125rem; /* 2px */
            --radius-sm: 0.25rem;  /* 4px */
            --radius-md: 0.375rem; /* 6px */
            --radius-lg: 0.5rem;   /* 8px */
            --radius-xl: 0.75rem;  /* 12px */
            --radius-2xl: 1rem;   /* 16px */
            --radius-3xl: 1.5rem; /* 24px */
            
            /* Smooth Shadows */
            --shadow-xs: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            
            /* Typography Scale */
            --text-xs: 0.75rem;   /* 12px */
            --text-sm: 0.875rem;  /* 14px */
            --text-base: 1rem;    /* 16px */
            --text-lg: 1.125rem;  /* 18px */
            --text-xl: 1.25rem;   /* 20px */
            --text-2xl: 1.5rem;   /* 24px */
            --text-3xl: 1.875rem; /* 30px */
            --text-4xl: 2.25rem;  /* 36px */
            
            /* Transition System */
            --transition-fast: 150ms ease-out;
            --transition-base: 300ms ease-out;
            --transition-slow: 500ms ease-out;
            
            /* Ultra High-Contrast Input and Select */
            --input-bg: #ffffff;
            --input-border: #6b7280;
            --input-hover-bg: #f9fafb;
            --input-hover-border: #374151;
            --input-focus-bg: white;
            --input-focus-border: #3730a3;
            --input-focus-shadow: rgba(55, 48, 163, 0.25);
            
            /* Gray Scale with High Contrast */
            --gray-100: #f3f4f6;
            --gray-200: #d1d5db;
            --gray-300: #9ca3af;
            --gray-400: #6b7280;
            --gray-500: #4b5563;
            --gray-600: #374151;
            --gray-700: #1f2937;
            --gray-800: #111827;
            --gray-900: #000000;
            
            /* Utility Colors */
            --text-dark: var(--text-primary);
            --text-light: var(--text-secondary);
            --primary-600: var(--primary);
            --primary-blue: var(--primary);
            --dark-blue: var(--primary-dark);
        }

        /* Global input and select styling for consistency */
        input[type="text"],
        input[type="number"],
        input[type="email"],
        input[type="password"],
        select,
        textarea {
            background: var(--input-bg) !important;
            border: 2px solid var(--input-border) !important;
            border-radius: 6px !important;
            padding: 8px 12px !important;
            transition: all 0.2s ease !important;
            font-size: 14px !important;
        }

        input[type="text"]:hover,
        input[type="number"]:hover,
        input[type="email"]:hover,
        input[type="password"]:hover,
        select:hover,
        textarea:hover {
            border-color: var(--input-hover-border) !important;
            background: var(--input-hover-bg) !important;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="email"]:focus,
        input[type="password"]:focus,
        select:focus,
        textarea:focus {
            outline: none !important;
            border-color: var(--input-focus-border) !important;
            background: var(--input-focus-bg) !important;
            box-shadow: 0 0 0 3px var(--input-focus-shadow) !important;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Lexend', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-weight: 500;
            line-height: 1.7;
            background: var(--gradient-background);
            min-height: 100vh;
            padding: var(--space-4);
            color: var(--text-primary);
            font-size: var(--text-base);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--surface);
            border-radius: var(--radius-2xl);
            box-shadow: var(--shadow-xl), 0 0 0 1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            border: 3px solid var(--border);
        }

        .header {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: white;
            padding: var(--space-6) var(--space-6);
            position: relative;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: var(--text-2xl);
            font-weight: 600;
            margin: 0;
            letter-spacing: -0.015em;
            line-height: 1.2;
            color: #ffffff;
        }

        .header-subtitle {
            font-size: var(--text-sm);
            font-weight: 400;
            margin-top: var(--space-1);
            opacity: 0.7;
            letter-spacing: 0.3px;
        }

        /* üìÅ File System Permission Styling */
        .filesystem-permission-area {
            display: flex;
            gap: var(--space-3);
            align-items: center;
        }

        .filesystem-permission-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-md);
            padding: var(--space-2) var(--space-4);
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-weight: 500;
            font-size: var(--text-sm);
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .filesystem-permission-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .filesystem-permission-btn.granted {
            background: rgba(34, 197, 94, 0.15);
            border-color: rgba(34, 197, 94, 0.3);
        }

        .filesystem-permission-btn.granted:hover {
            background: rgba(34, 197, 94, 0.2);
        }

        .permission-icon {
            font-size: 1em;
            opacity: 0.9;
        }

        .permission-status {
            font-size: 0.9em;
        }

        #clearAllDataBtn {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.3);
        }

        #clearAllDataBtn:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
        }

        .permission-info {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: var(--space-2);
            background: rgba(255, 255, 255, 0.98);
            color: var(--text-primary);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            opacity: 0;
            transform: translateY(-5px);
            transition: all 0.2s ease;
            pointer-events: none;
            z-index: 100;
        }

        .permission-info.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .info-content {
            display: flex;
            gap: var(--space-2);
            align-items: flex-start;
        }

        .info-icon {
            font-size: 1em;
            flex-shrink: 0;
        }

        .info-text {
            font-size: var(--text-xs);
            line-height: 1.4;
        }

        .info-text strong {
            color: var(--primary);
            font-weight: 600;
        }

        /* Header branding section */
        .header-branding {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        /* Responsive cho mobile */
        @media (max-width: 768px) {
            .header {
                padding: var(--space-4);
            }

            .header-content {
                flex-direction: column;
                gap: var(--space-4);
                align-items: flex-start;
            }

            .filesystem-permission-area {
                width: 100%;
                flex-direction: column;
                gap: var(--space-2);
            }

            .filesystem-permission-btn {
                width: 100%;
                justify-content: center;
            }

            .permission-info {
                max-width: 100%;
                left: 0;
                right: 0;
            }

            .header h1 {
                font-size: var(--text-xl);
            }

            .header-subtitle {
                font-size: var(--text-xs);
            }
        }

        /* üìÅ File System Action Buttons Styling */
        .filesystem-section {
            margin: var(--space-4) 0;
            padding: var(--space-3);
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-light);
        }

        .filesystem-action-btn {
            width: 100%;
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            padding: var(--space-4) var(--space-5);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-2);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(14, 165, 233, 0.2);
        }

        .filesystem-action-btn:hover {
            background: linear-gradient(135deg, #0284c7 0%, #0369a1 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(14, 165, 233, 0.3);
        }

        .filesystem-action-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(14, 165, 233, 0.2);
        }

        .filesystem-icon {
            font-size: 1.5em;
        }

        .filesystem-text {
            font-size: 1rem;
            font-weight: 600;
        }

        .filesystem-subtitle {
            font-size: 0.85rem;
            opacity: 0.9;
            font-weight: 400;
        }

        /* Gallery Section Filesystem Button */
        .control-btn.filesystem-btn {
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            color: white;
            border: 1px solid #0284c7;
        }

        .control-btn.filesystem-btn:hover {
            background: linear-gradient(135deg, #0284c7 0%, #0369a1 100%);
            border-color: #0369a1;
            transform: translateY(-1px);
        }

        /* Print Section Filesystem Button */
        .upload-btn.filesystem {
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            color: white;
            border: 1px solid #0284c7;
        }

        .upload-btn.filesystem:hover {
            background: linear-gradient(135deg, #0284c7 0%, #0369a1 100%);
            border-color: #0369a1;
            transform: translateY(-1px);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .filesystem-action-btn {
                padding: var(--space-3) var(--space-4);
            }

            .filesystem-text {
                font-size: 0.9rem;
            }

            .filesystem-subtitle {
                font-size: 0.75rem;
            }
        }

        .main-content {
            padding: var(--space-8) var(--space-8);
            max-width: 100%;
            margin: 0 auto;
            background: var(--surface);
        }

        /* Balanced Navigation Tabs */
        .function-tabs {
            display: flex;
            gap: var(--space-2);
            margin-bottom: var(--space-8);
            justify-content: flex-start;
            background: transparent;
            padding: 0;
            border-radius: 0;
            border: none;
            max-width: 100%;
            margin-left: 0;
            margin-right: 0;
            box-shadow: none;
            border-bottom: 2px solid var(--border-light);
            padding-bottom: var(--space-2);
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
        }

        .function-tabs::-webkit-scrollbar {
            height: 4px;
        }

        .function-tabs::-webkit-scrollbar-track {
            background: var(--gray-100);
            border-radius: 2px;
        }

        .function-tabs::-webkit-scrollbar-thumb {
            background: var(--gray-300);
            border-radius: 2px;
        }

        .tab-button {
            display: inline-flex;
            flex-direction: row;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-3) var(--space-5);
            border: none;
            border-radius: var(--radius-lg);
            background: transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 0 0 auto;
            justify-content: center;
            text-align: left;
            color: var(--text-secondary);
            font-weight: 500;
            min-height: auto;
            white-space: nowrap;
            position: relative;
        }

        .tab-button::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary);
            border-radius: 3px 3px 0 0;
            transform: scaleX(0);
            transition: transform 0.2s ease;
        }

        .tab-button:hover {
            color: var(--primary);
            background: rgba(55, 48, 163, 0.05);
            transform: translateY(0);
            box-shadow: none;
        }

        .tab-button.active {
            color: var(--primary);
            background: rgba(55, 48, 163, 0.08);
            border: none;
            box-shadow: none;
            font-weight: 600;
        }

        .tab-button.active::after {
            transform: scaleX(1);
        }

        .tab-button.active:hover {
            background: rgba(55, 48, 163, 0.1);
            transform: translateY(0);
        }

        .tab-icon {
            font-size: var(--text-lg);
            margin: 0;
            transition: var(--transition-fast);
            filter: none;
            opacity: 0.8;
        }

        .tab-button.active .tab-icon {
            opacity: 1;
        }

        .tab-text {
            font-size: var(--text-sm);
            font-weight: inherit;
            margin: 0;
            transition: var(--transition-fast);
            text-shadow: none;
        }

        .tab-button.active .tab-text {
            text-shadow: none;
        }

        .tab-desc {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .tab-button.active .tab-desc {
            opacity: 1;
        }

        /* Function Sections */
        .function-section {
            display: none !important;
        }

        .function-section.active {
            display: block !important;
            position: relative;
            z-index: 1;
            pointer-events: auto;
        }

        /* Ensure cropTabSection buttons are clickable */
        #cropTabSection {
            pointer-events: auto;
        }

        #cropTabSection * {
            pointer-events: auto;
        }

        /* Override crop-page styles when inside cropTabSection */
        #cropTabSection .crop-page {
            position: static !important;
            width: 100% !important;
            height: auto !important;
            background: transparent !important;
            z-index: auto !important;
            overflow: visible !important;
            animation: none !important;
        }

        #cropTabSection .crop-header {
            position: static !important;
            width: 100% !important;
            height: auto !important;
            background: #fff !important;
            border-bottom: 1px solid #e9ecef !important;
            padding: 20px !important;
            margin-bottom: 20px !important;
        }

        #cropTabSection .crop-body {
            position: static !important;
            width: 100% !important;
            height: auto !important;
            overflow: visible !important;
            padding: 0 20px 20px 20px !important;
        }

        #cropTabSection .crop-main-content {
            position: static !important;
            width: 100% !important;
            height: auto !important;
            overflow: visible !important;
            display: block !important;
        }

        #cropTabSection .size-selection-modern {
            position: static !important;
            width: 100% !important;
            height: auto !important;
            overflow: visible !important;
        }

        /* Crop Tab Upload Zone */
        .crop-upload-zone {
            margin-bottom: 30px;
            border-radius: 12px;
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
            border: 1px solid #e9ecef;
            overflow: hidden;
        }

        .upload-area-crop {
            padding: 40px 20px;
            text-align: center;
            border: 2px dashed #dee2e6;
            border-radius: 12px;
            margin: 20px;
            background: #fafbfc;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area-crop:hover {
            border-color: #6c757d;
            background: #f8f9fa;
        }

        .upload-area-crop.dragover {
            border-color: #0066cc;
            background: #e7f3ff;
            transform: scale(1.02);
        }

        .upload-icon-crop {
            font-size: 48px;
            color: #6c757d;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .upload-area-crop h3 {
            color: #495057;
            margin: 15px 0 10px 0;
            font-size: 1.4em;
            font-weight: 600;
        }

        .upload-area-crop p {
            color: #6c757d;
            margin-bottom: 20px;
            font-size: 1em;
        }

        .select-files-btn-crop {
            background: linear-gradient(145deg, #0066cc, #004499);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .select-files-btn-crop:hover {
            background: linear-gradient(145deg, #0052a3, #003366);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3);
        }

        .select-files-btn-crop:active {
            transform: scale(0.95);
            transition: transform 0.1s ease;
        }

        /* Improve upload button responsiveness */
        .upload-btn {
            transition: transform 0.1s ease, background-color 0.2s ease !important;
        }

        .upload-btn:active {
            transform: scale(0.95) !important;
        }

        /* Navigation Controls in Export Tab */
        .navigation-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .nav-btn {
            background: linear-gradient(145deg, #6c757d, #5a6268);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .nav-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #5a6268, #495057);
            transform: translateY(-1px);
        }

        .nav-btn:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .nav-info {
            font-weight: 600;
            color: #495057;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
            min-width: 60px;
            text-align: center;
        }

        /* Crop Files Grid */
        .crop-files-grid {
            margin-top: 20px;
        }

        .files-header-crop {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        .files-header-crop h4 {
            margin: 0;
            color: #495057;
            font-size: 1.1em;
            font-weight: 600;
        }

        .files-actions-crop {
            display: flex;
            gap: 10px;
        }

        .action-btn-crop {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .action-btn-crop:hover {
            background: #c82333;
            transform: translateY(-1px);
        }

        .files-list-crop {
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .crop-file-item {
            display: flex;
            align-items: center;
            padding: 12px;
            margin-bottom: 10px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .crop-file-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }

        .crop-file-preview {
            width: 60px;
            height: 60px;
            border-radius: 6px;
            margin-right: 15px;
            object-fit: cover;
            border: 1px solid #dee2e6;
        }

        .crop-file-info {
            flex: 1;
        }

        .crop-file-name {
            font-weight: 600;
            color: #495057;
            margin-bottom: 4px;
        }

        .crop-file-size {
            color: #6c757d;
            font-size: 0.9em;
        }

        .crop-file-actions {
            display: flex;
            gap: 8px;
        }

        .crop-file-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .crop-file-btn:hover {
            background: #5a6268;
        }

        .crop-file-btn.remove {
            background: #dc3545;
        }

        .crop-file-btn.remove:hover {
            background: #c82333;
        }

        /* Crop Size Selection */
        /* Old crop styles removed - using new crop-container styles */

        .input-group input {
            padding: 8px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            text-align: center;
            width: 80px;
        }


        /* Convert Controls */
        .controls {
            margin: var(--space-8) auto;
            padding: var(--space-8);
            background: var(--surface);
            border-radius: var(--radius-2xl);
            border: 2px solid var(--border);
            max-width: 800px;
            box-shadow: var(--shadow-md);
        }

        .controls-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            align-items: start;
            gap: var(--space-8);
            margin-bottom: var(--space-6);
        }

        .controls-row:last-child {
            grid-template-columns: 1fr auto;
            align-items: end;
            margin-bottom: 0;
            gap: var(--space-6);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
        }

        .control-group label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: var(--text-base);
            margin-bottom: var(--space-1);
        }

        .control-group select {
            padding: var(--space-4) var(--space-5);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            background: var(--surface);
            font-size: var(--text-base);
            font-weight: 500;
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition-base);
            width: 100%;
        }

        .control-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.15);
        }

        .control-group input[type="text"] {
            padding: var(--space-4) var(--space-5);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            background: var(--surface);
            font-size: var(--text-base);
            font-weight: 500;
            color: var(--text-primary);
            transition: var(--transition-base);
            width: 100%;
        }

        .control-group input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.15);
        }

        .quality-container {
            display: flex;
            align-items: center;
            gap: var(--space-4);
            width: 100%;
            padding: var(--space-4);
            background: var(--background);
            border-radius: var(--radius-lg);
            border: 2px solid var(--border);
        }

        .quality-slider {
            flex: 1;
            height: 6px;
            background: var(--border);
            border-radius: var(--radius-sm);
            outline: none;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
        }

        .quality-slider::-webkit-slider-thumb {
            appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: var(--shadow-sm);
        }

        .quality-slider::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: var(--shadow-sm);
        }

        .quality-value {
            min-width: 45px;
            font-weight: 600;
            color: var(--primary);
            text-align: center;
        }

        .naming-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .naming-control label {
            font-weight: 600;
            color: #374151;
        }

        .naming-control select {
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            background: #f9fafb;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        .naming-control select:hover {
            border-color: #9ca3af;
            background: #f3f4f6;
        }

        .naming-control select:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .format-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .format-selector label {
            font-weight: 600;
            color: #374151;
        }

        .format-selector select {
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            border-radius: 8px;
            font-size: 1rem;
            background: #f9fafb;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        .format-selector select:hover {
            border-color: #9ca3af;
            background: #f3f4f6;
        }

        .format-selector select:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .quality-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .quality-control label {
            font-weight: 600;
            color: #374151;
        }

        .quality-slider {
            width: 120px;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            outline: none;
        }

        .quality-value {
            font-weight: 600;
            color: #667eea;
            min-width: 35px;
        }

        .convert-btn {
            background: var(--primary);
            color: white;
            border: 2px solid var(--primary);
            padding: var(--space-4) var(--space-8);
            border-radius: var(--radius-xl);
            font-size: var(--text-lg);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-base);
            min-width: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            box-shadow: var(--shadow-md);
        }

        .convert-btn:hover:not(:disabled) {
            background: var(--primary-dark);
            border-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .convert-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: var(--shadow-sm);
        }

        .file-list {
            margin: var(--spacing-lg) auto 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: var(--spacing-lg);
            max-width: 1000px;
        }

        @media (max-width: 768px) {
            .file-list {
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 16px;
            }
        }

        @media (max-width: 480px) {
            .file-list {
                grid-template-columns: 1fr;
                gap: 12px;
            }
        }

        .file-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .file-item:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-color: var(--primary-blue);
        }

        .file-preview {
            width: 100%;
            background: #f8fafc;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            aspect-ratio: 1;
            min-height: 100px;
        }

        .file-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.3s ease;
        }

        .file-preview:hover img {
            transform: scale(1.02);
        }

        .file-preview .file-icon {
            font-size: 3rem;
            color: var(--primary-blue);
            opacity: 0.7;
        }

        .file-preview .file-icon.heic-placeholder {
            font-size: 2rem;
            color: #8B5CF6;
            text-align: center;
            line-height: 1.2;
        }

        .file-preview .file-icon.heic-placeholder small {
            font-size: 0.7rem;
            display: block;
            margin-top: 4px;
            font-weight: 600;
        }

        .file-content {
            padding: 12px;
        }

        .file-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            color: var(--text-dark);
            font-size: 0.9rem;
            margin-bottom: 4px;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .file-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .file-size {
            font-size: 0.85rem;
            color: var(--text-light);
            font-weight: 500;
        }

        .file-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .file-status.pending {
            background: #FEF3C7;
            color: #92400E;
        }

        .file-status.converting {
            background: #DBEAFE;
            color: #1E40AF;
        }

        .file-status.success {
            background: #D1FAE5;
            color: #065F46;
        }

        .file-status.error {
            background: #FEE2E2;
            color: #991B1B;
        }

        .file-dimensions {
            font-size: 0.8rem;
            color: var(--primary);
            font-weight: 600;
            margin: 4px 0;
            padding: 2px 6px;
            background: rgba(79, 70, 229, 0.1);
            border-radius: 6px;
            display: inline-block;
            font-family: 'Courier New', monospace;
        }

        /* Progress bar for file conversion */
        .file-progress {
            margin: 8px 0;
            display: none;
        }

        .file-progress.show {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%);
            border-radius: 3px;
            transition: width 0.5s ease-out;
            width: 0%;
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
            animation: progressShimmer 2s infinite;
        }

        @keyframes progressShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Upload Progress Overlay */
        .upload-progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .upload-progress-overlay.show {
            display: flex;
        }

        .upload-progress-modal {
            background: white;
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            max-width: 450px;
            width: 90%;
            text-align: center;
            border: 2px solid var(--primary-blue);
            position: relative;
        }

        .upload-progress-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary-blue);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .upload-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #6b7280;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.2s ease;
            z-index: 10001;
            position: relative;
            min-width: 40px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-close-btn:hover {
            background: #f3f4f6;
            color: #374151;
            transform: scale(1.1);
        }

        .upload-close-btn:active {
            background: #e5e7eb;
            transform: scale(0.95);
        }

        .upload-current-file {
            font-size: 0.95rem;
            color: #374151;
            margin-bottom: 16px;
            text-align: center;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8fafc;
            padding: 12px 16px;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
            transition: all 0.3s ease;
            word-break: break-word;
            font-weight: 500;
        }

        .upload-current-file.processing {
            background: #eff6ff;
            border-color: #3b82f6;
            color: #1d4ed8;
        }

        .upload-current-file.success {
            background: #f0fdf4;
            border-color: #16a34a;
            color: #15803d;
        }

        .upload-current-file.error {
            background: #fef2f2;
            border-color: #dc2626;
            color: #991b1b;
        }

        .upload-overall-progress {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
        }

        .upload-overall-text {
            font-size: 1rem;
            font-weight: 700;
            color: var(--primary-blue);
            margin-bottom: 12px;
        }

        .progress-text {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 4px;
            text-align: center;
        }

        .progress-time {
            font-size: 0.8rem;
            color: #059669;
            margin-top: 6px;
            text-align: center;
            font-weight: 600;
        }

        .file-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .file-action-btn {
            padding: 8px 14px;
            border: 2px solid transparent;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            max-width: 80px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .file-action-btn.download {
            background: var(--primary-blue);
            color: white;
        }

        .file-action-btn.download:hover {
            background: var(--dark-blue);
            border-color: var(--dark-blue);
            box-shadow: 0 2px 8px rgba(55, 48, 163, 0.3);
            transform: translateY(-1px);
        }

        .file-action-btn.delete {
            background: var(--error);
            color: white;
        }

        .file-action-btn.delete:hover {
            background: #991b1b;
            border-color: #991b1b;
            box-shadow: 0 2px 8px rgba(185, 28, 28, 0.3);
            transform: translateY(-1px);
        }

        .file-dimensions {
            font-size: 0.8rem;
            color: var(--primary-blue);
            font-weight: 600;
            margin-bottom: 5px;
        }

        .conversion-info {
            font-size: 0.8rem;
            color: var(--text-dark);
            font-weight: 600;
            margin-bottom: 10px;
            padding: 4px 8px;
            background: var(--light-yellow);
            border-radius: 8px;
            text-align: center;
        }

        /* Crop Modal Styles */
        .crop-modal-content {
            max-width: 900px;
            width: 90vw;
            max-height: 90vh;
        }

        .crop-modal-body {
            padding: 25px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .crop-config {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .crop-section {
            background: var(--white);
            border: 2px solid var(--primary-yellow);
            border-radius: 16px;
            padding: 20px;
        }

        .crop-section h3 {
            margin: 0 0 15px 0;
            color: var(--text-dark);
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* Template Grid */
        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(7.5rem, 100%), 1fr));
            gap: clamp(0.5rem, 1.5vw, 1rem); /* 8px - 16px responsive */
            margin-bottom: 1.25rem; /* 20px */
        }

        .template-card {
            background: #f8fafc;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .template-card:hover {
            border-color: var(--primary-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .template-card.active {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
        }

        .template-preview {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 60px;
            margin-bottom: 8px;
        }

        .ratio-box {
            background: var(--primary-blue);
            border-radius: 4px;
            position: relative;
        }

        .ratio-6x9 { width: 30px; height: 45px; }
        .ratio-55x85 { width: 28px; height: 42px; }
        .ratio-10x15 { width: 32px; height: 48px; }
        .ratio-13x18 { width: 34px; height: 46px; }
        .ratio-20x25 { width: 36px; height: 45px; }

        .custom-box {
            width: 40px;
            height: 40px;
            background: #6B7280;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .template-info {
            text-align: center;
        }

        .template-name {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 0.9rem;
            margin-bottom: 2px;
        }

        .template-size {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .size-details {
            background: var(--light-yellow);
            border-radius: 12px;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(9.375rem, 100%), 1fr));
            gap: clamp(0.75rem, 2vw, 1.25rem); /* 12px - 20px responsive */
        }

        .detail-item {
            text-align: center;
        }

        .detail-label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-light);
            margin-bottom: 4px;
        }

        .detail-value {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 1rem;
        }

        .custom-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .input-row {
            display: flex;
            gap: 10px;
        }

        .input-row input {
            flex: 1;
            min-width: 80px;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-group label {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 0.9rem;
        }

        .input-with-unit {
            display: flex;
            border: 2px solid var(--primary-blue);
            border-radius: 10px;
            overflow: hidden;
        }

        .input-with-unit input {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid #d1d5db;
            font-size: 1rem;
            background: #f9fafb;
            color: var(--text-primary);
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .input-with-unit input:hover {
            border-color: #9ca3af;
            background: #f3f4f6;
        }

        .input-with-unit input:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .input-with-unit input:focus {
            outline: none;
        }

        /* Disabled input styling */
        .input-with-unit input:disabled,
        .config-section input:disabled,
        .custom-input input:disabled {
            background-color: #f1f5f9 !important;
            color: #64748b !important;
            cursor: not-allowed !important;
            opacity: 0.7 !important;
        }

        .input-with-unit input:disabled::placeholder,
        .config-section input:disabled::placeholder,
        .custom-input input:disabled::placeholder {
            color: #94a3b8 !important;
        }

        .input-with-unit .unit {
            background: var(--primary-blue);
            color: white;
            padding: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
        }

        .settings-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-item label {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 0.9rem;
        }

        .modern-select {
            padding: 12px 15px;
            border: 2px solid #d1d5db;
            border-radius: 10px;
            background: #f9fafb;
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modern-select:hover {
            border-color: #9ca3af;
            background: #f3f4f6;
        }

        .modern-select:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .modern-select:focus {
            outline: none;
            border-color: var(--dark-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .setting-help {
            font-size: 0.85rem;
            color: var(--text-light);
            font-style: italic;
            margin-top: 4px;
        }

        .process-modes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .mode-card {
            background: #f8fafc;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            position: relative;
        }

        .mode-card input[type="radio"] {
            position: absolute;
            opacity: 0;
        }

        .mode-card:hover {
            border-color: var(--primary-blue);
            transform: translateY(-2px);
        }

        .mode-card.active,
        .mode-card:has(input:checked) {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
        }

        .mode-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .mode-name {
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 4px;
        }

        .mode-desc {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .naming-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .naming-section label {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 0.9rem;
        }

        /* Enhanced Crop Page Styles - Professional & Clean */
        .crop-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
            z-index: 1000;
            overflow: hidden;
            animation: slideInFromTop 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .crop-header {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(16px);
            border-bottom: 1px solid #e2e8f0;
            padding: 24px 32px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .crop-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1400px;
            margin: 0 auto;
        }

        .nav-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--primary-blue);
            color: var(--white);
            border: none;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            background: var(--dark-blue);
            transform: translateY(-1px);
        }

        .nav-icon {
            font-size: 1.2rem;
        }

        .crop-header h1 {
            margin: 0;
            color: var(--text-dark);
            font-size: 1.5rem;
            font-weight: 600;
        }

        .crop-nav h1 {
            color: #1e293b;
            font-size: 1.75rem;
            font-weight: 600;
            margin: 0;
            letter-spacing: -0.025em;
            line-height: 1.2;
        }

        .crop-progress {
            color: #64748b;
            font-size: 0.875rem;
            font-weight: 500;
            background: #f8fafc;
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .crop-progress::before {
            content: "‚ü°";
            color: #3b82f6;
            font-size: 1rem;
        }

        .crop-body {
            display: flex;
            height: calc(100vh - 80px);
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            gap: 25px;
        }

        .crop-sidebar {
            width: 350px;
            height: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .crop-main {
            flex: 1;
            background: var(--white);
            border-radius: 20px;
            border: 2px solid var(--primary-300);
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            position: relative;
        }

        /* Enhanced Crop Canvas and Guides */
        .crop-canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            background: #fafbfc;
            overflow: hidden;
        }

        .crop-canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            position: relative;
            z-index: 1;
        }

        .crop-selection-area {
            position: absolute;
            border: 3px solid var(--primary-500);
            background: rgba(59, 130, 246, 0.1);
            cursor: move;
            z-index: 2;
            border-radius: var(--radius-sm);
        }

        .crop-selection-area::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: var(--radius-sm);
            pointer-events: none;
        }

        /* Crop Resize Handles */
        .crop-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--primary-500);
            border: 2px solid white;
            border-radius: 50%;
            z-index: 3;
            transition: all 0.2s ease;
        }

        .crop-handle:hover {
            background: var(--primary-600);
            transform: scale(1.2);
        }

        .crop-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
        .crop-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .crop-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }
        .crop-handle.n { top: -6px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .crop-handle.s { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .crop-handle.w { left: -6px; top: 50%; transform: translateY(-50%); cursor: w-resize; }
        .crop-handle.e { right: -6px; top: 50%; transform: translateY(-50%); cursor: e-resize; }

        /* Grid Overlay */
        .crop-grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 2;
        }

        .crop-grid-line {
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
            transition: opacity 0.3s ease;
        }

        .crop-grid-line.vertical {
            width: 1px;
            height: 100%;
        }

        .crop-grid-line.horizontal {
            width: 100%;
            height: 1px;
        }

        .crop-grid-line.thirds-v1 { left: 33.33%; }
        .crop-grid-line.thirds-v2 { left: 66.66%; }
        .crop-grid-line.thirds-h1 { top: 33.33%; }
        .crop-grid-line.thirds-h2 { top: 66.66%; }

        /* Crop Overlay (outside selection) */
        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1;
            pointer-events: none;
        }

        /* Crop Controls Panel */
        .crop-controls-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: var(--space-4);
            display: flex;
            gap: var(--space-3);
            align-items: center;
            box-shadow: var(--shadow-lg);
            border: 1px solid rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .crop-control-group {
            display: flex;
            gap: var(--space-2);
            align-items: center;
            padding: 0 var(--space-2);
            border-right: 1px solid var(--border-light);
        }

        .crop-control-group:last-child {
            border-right: none;
        }

        .crop-control-btn {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 1rem;
        }

        .crop-control-btn:hover {
            background: var(--gray-50);
            border-color: var(--primary-300);
        }

        .crop-control-btn.active {
            background: var(--primary-500);
            color: white;
            border-color: var(--primary-500);
        }

        .crop-ratio-btn {
            padding: var(--space-2) var(--space-3);
            font-size: 0.85rem;
            font-weight: 500;
            width: auto;
            min-width: 60px;
        }

        /* Crop Info Display */
        .crop-info-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: var(--space-3);
            font-size: 0.8rem;
            color: var(--gray-700);
            box-shadow: var(--shadow-md);
            z-index: 10;
            min-width: 120px;
        }

        .crop-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-1);
        }

        .crop-info-row:last-child {
            margin-bottom: 0;
        }

        .crop-info-label {
            font-weight: 600;
        }

        .crop-info-value {
            color: var(--primary-600);
            font-weight: 500;
        }

        .crop-preview-area {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .preview-header {
            padding: 20px 25px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-header h3 {
            margin: 0;
            color: var(--text-dark);
            font-size: 1.2rem;
        }

        .preview-stats {
            font-size: 0.9rem;
            color: var(--text-light);
            font-weight: 600;
        }

        .crop-file-grid {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            align-content: start;
        }

        .crop-file-item {
            background: #f8fafc;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .crop-file-item:hover {
            border-color: var(--primary-blue);
            transform: translateY(-2px);
        }

        .crop-file-item.selected {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
        }

        .crop-file-preview {
            width: 100%;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .crop-file-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .crop-file-info {
            padding: 10px;
            text-align: center;
        }

        .crop-file-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 4px;
            line-height: 1.2;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .crop-file-size {
            font-size: 0.75rem;
            color: var(--text-light);
        }

        .crop-actions {
            margin-top: auto;
            padding-top: 20px;
        }

        .crop-btn {
            width: 100%;
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .crop-btn.primary {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: var(--white);
        }

        .crop-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }

        .btn-icon {
            font-size: 1.2rem;
        }

        .btn-text {
            font-size: 1rem;
        }

        .quality-info {
            font-size: 0.8rem;
            color: #4b5563;
            margin-top: 2px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .dimensions {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }

        .conversion-info {
            font-size: 0.8rem;
            color: #059669;
            font-weight: 600;
            margin-top: 2px;
        }

        .file-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
            min-width: 80px;
        }

        .status-pending {
            background: #fef3c7;
            color: #d97706;
        }

        .status-processing {
            background: #dbeafe;
            color: #2563eb;
        }

        .status-success {
            background: #d1fae5;
            color: #059669;
        }

        .status-error {
            background: #fecaca;
            color: #dc2626;
        }

        .download-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .download-btn:hover {
            background: #059669;
            transform: scale(1.05);
        }

        .download-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .remove-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .remove-btn:hover {
            background: #dc2626;
            transform: scale(1.05);
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        /* New Actions Layout */
        .actions {
            margin: 0 auto var(--spacing-lg) auto;
            padding: var(--spacing-lg);
            background: #f8fafc;
            border-radius: var(--radius-lg);
            border: 1px solid #e2e8f0;
            max-width: 700px;
        }

        .actions-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
            align-items: center;
            justify-content: flex-start;
        }

        .actions-group:last-child {
            margin-bottom: 0;
        }

        .actions-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-md);
        }

        @media (min-width: 640px) {
            .actions-container {
                grid-template-columns: 1fr 1fr;
                gap: var(--spacing-lg);
            }

            .actions-group.utility-actions {
                grid-column: 1 / -1;
                justify-content: center;
            }
        }

        /* Enhanced Crop Section Styles */
        .crop-container-enhanced {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-8);
        }

        /* Modern Section Header */
        .section-header-modern {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 20px;
            padding: var(--space-12);
            margin-bottom: var(--space-8);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.2);
            position: relative;
            overflow: hidden;
        }

        .section-header-modern::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -20%;
            width: 200px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            transform: rotate(45deg);
        }

        .header-content {
            display: flex;
            align-items: center;
            gap: var(--space-6);
            margin-bottom: var(--space-6);
        }

        .header-icon {
            font-size: 3rem;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .header-text h2 {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header-text p {
            font-size: 1.1rem;
            opacity: 0.9;
            margin: var(--space-2) 0 0;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        /* Progress Steps */
        .progress-steps {
            display: flex;
            justify-content: center;
            gap: var(--space-8);
        }

        .step {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            color: rgba(255, 255, 255, 0.6);
            transition: all 0.3s ease;
        }

        .step.active {
            color: white;
            transform: scale(1.1);
        }

        .step-number {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .step.active .step-number {
            background: white;
            color: var(--primary-600);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        }

        /* Modern Size Selection */
        .size-selection-modern {
            background: white;
            border-radius: 20px;
            padding: var(--space-8);
            margin-bottom: var(--space-6);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .selection-header {
            text-align: center;
            margin-bottom: var(--space-8);
        }

        .selection-header h3 {
            font-size: 1.8rem;
            color: var(--gray-800);
            margin-bottom: var(--space-3);
            font-weight: 600;
        }

        .selection-hint {
            color: var(--gray-600);
            font-size: 1rem;
            line-height: 1.6;
        }

        /* Size Grid */
        .size-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--space-6);
        }

        .size-card {
            background: white;
            border: 2px solid var(--gray-200);
            border-radius: 16px;
            padding: var(--space-6);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .size-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-500), var(--primary-600));
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .size-card:hover {
            border-color: var(--primary-300);
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(102, 126, 234, 0.15);
        }

        .size-card.active {
            border-color: var(--primary-500);
            background: linear-gradient(135deg, #f8faff 0%, #e8f0fe 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.2);
        }

        .size-card.active::before {
            transform: scaleX(1);
        }

        .size-preview {
            display: flex;
            justify-content: center;
            margin-bottom: var(--space-4);
        }

        .ratio-box {
            width: 60px;
            background: linear-gradient(135deg, var(--primary-100), var(--primary-200));
            border: 2px solid var(--primary-300);
            border-radius: 8px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .size-card.active .ratio-box {
            background: linear-gradient(135deg, var(--primary-500), var(--primary-600));
            border-color: var(--primary-700);
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .custom-ratio {
            aspect-ratio: 1;
        }

        .custom-icon {
            font-size: 1.5rem;
        }

        .size-info {
            text-align: center;
        }

        .size-title {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--gray-800);
            margin-bottom: var(--space-2);
        }

        .size-dimensions {
            font-size: 1rem;
            color: var(--primary-600);
            font-weight: 500;
            margin-bottom: var(--space-1);
        }

        .size-pixels {
            font-size: 0.85rem;
            color: var(--gray-500);
            margin-bottom: var(--space-2);
        }

        .size-usage {
            font-size: 0.8rem;
            color: var(--gray-400);
            font-style: italic;
        }

        .size-badge {
            position: absolute;
            top: var(--space-2);
            right: var(--space-2);
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            padding: var(--space-1) var(--space-2);
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(238, 90, 82, 0.3);
        }

        /* Enhanced Custom Dimensions */
        .custom-dimensions-modern {
            background: linear-gradient(135deg, #f8fffe 0%, #f0fdfc 100%);
            border: 2px solid var(--teal-200);
            border-radius: 16px;
            padding: var(--space-6);
            margin-top: var(--space-6);
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .custom-header {
            text-align: center;
            margin-bottom: var(--space-6);
        }

        .custom-header h4 {
            font-size: 1.4rem;
            color: var(--teal-700);
            margin-bottom: var(--space-2);
            font-weight: 600;
        }

        .custom-header p {
            color: var(--teal-600);
            font-size: 0.9rem;
        }

        .dimension-inputs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-4);
            margin-bottom: var(--space-4);
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-weight: 500;
            color: var(--gray-700);
            margin-bottom: var(--space-2);
        }

        /* Toggle Switch Styles */
        .toggle-switch-container {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #667eea;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .toggle-label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--gray-700);
            min-width: 35px;
        }

        .label-icon {
            font-size: 1rem;
        }

        .input-with-unit {
            position: relative;
            display: flex;
            align-items: center;
        }

        .input-with-unit input {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            padding-right: 40px;
            border: 2px solid var(--gray-200);
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .input-with-unit input:focus {
            outline: none;
            border-color: var(--teal-500);
            box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
        }

        .unit {
            position: absolute;
            right: var(--space-3);
            color: var(--gray-500);
            font-weight: 500;
            pointer-events: none;
        }

        .dpi-select {
            width: 100%;
            padding: var(--space-3) var(--space-4);
            border: 2px solid var(--gray-200);
            border-radius: 12px;
            font-size: 1rem;
            background: white;
            transition: all 0.3s ease;
        }

        .dpi-select:focus {
            outline: none;
            border-color: var(--teal-500);
            box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
        }

        .dimension-preview {
            background: white;
            border: 1px solid var(--teal-200);
            border-radius: 12px;
            padding: var(--space-4);
            text-align: center;
        }

        .preview-info {
            display: flex;
            justify-content: center;
            gap: var(--space-6);
            flex-wrap: wrap;
        }

        .preview-size,
        .preview-pixels {
            color: var(--teal-700);
        }

        /* Modern Upload Area */
        .upload-area-modern {
            margin-bottom: var(--space-6);
        }

        .upload-zone {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 3px dashed var(--gray-300);
            border-radius: 24px;
            padding: var(--space-12);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            min-height: 320px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .upload-zone:hover {
            border-color: var(--primary-400);
            background: linear-gradient(135deg, #f0f7ff 0%, #e6f3ff 100%);
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(102, 126, 234, 0.15);
        }

        .upload-zone.dragover {
            border-color: var(--primary-500);
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            transform: scale(1.02);
            border-style: solid;
            box-shadow: 0 0 40px rgba(59, 130, 246, 0.3), inset 0 0 20px rgba(59, 130, 246, 0.1);
        }

        .upload-zone.has-files {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border-color: var(--success);
            border-style: solid;
        }

        .upload-visual {
            position: relative;
            margin-bottom: var(--space-4);
        }

        .upload-icon {
            font-size: 4rem;
            margin-bottom: var(--space-2);
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        .upload-zone:hover .upload-icon {
            opacity: 1;
            transform: scale(1.1);
        }

        .upload-animation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            border: 3px solid var(--primary-200);
            border-top: 3px solid var(--primary-500);
            border-radius: 50%;
            opacity: 0;
            animation: spin 1s linear infinite;
        }

        .upload-zone.uploading .upload-animation {
            opacity: 1;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .upload-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--gray-800);
            margin-bottom: var(--space-2);
        }

        .upload-subtitle {
            font-size: 1rem;
            color: var(--gray-600);
            margin-bottom: var(--space-4);
        }

        .upload-formats {
            display: flex;
            justify-content: center;
            gap: var(--space-2);
            margin-bottom: var(--space-3);
            flex-wrap: wrap;
        }

        .format-badge {
            background: var(--primary-100);
            color: var(--primary-700);
            padding: var(--space-1) var(--space-3);
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            border: 1px solid var(--primary-200);
        }

        .upload-limit {
            font-size: 0.85rem;
            color: var(--gray-500);
        }

        /* Enhanced Upload Zone with Preview */
        .upload-preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: var(--space-4);
            margin-top: var(--space-6);
            width: 100%;
            max-width: 600px;
        }

        .upload-preview-item {
            position: relative;
            background: white;
            border-radius: var(--radius-lg);
            padding: var(--space-3);
            border: 2px solid var(--gray-200);
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        .upload-preview-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--primary-300);
        }

        .upload-preview-thumbnail {
            width: 100%;
            height: 80px;
            background: var(--gray-100);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: var(--space-2);
            overflow: hidden;
        }

        .upload-preview-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-preview-thumbnail .file-icon {
            font-size: 2rem;
            color: var(--gray-400);
        }

        .upload-preview-info {
            text-align: center;
        }

        .upload-preview-name {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--gray-700);
            margin-bottom: var(--space-1);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .upload-preview-size {
            font-size: 0.65rem;
            color: var(--gray-500);
        }

        .upload-preview-remove {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background: var(--error);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            opacity: 0;
        }

        .upload-preview-item:hover .upload-preview-remove {
            opacity: 1;
        }

        .upload-preview-remove:hover {
            transform: scale(1.1);
            background: #dc2626;
        }

        /* Upload Zone Empty State */
        .upload-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
        }

        .upload-zone.has-files .upload-empty-state {
            display: none;
        }

        /* Drag & Drop Indicator */
        .upload-drop-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(59, 130, 246, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 10;
            border-radius: 24px;
        }

        .upload-zone.dragover .upload-drop-indicator {
            opacity: 1;
        }

        .drop-indicator-icon {
            font-size: 3rem;
            color: var(--primary-500);
            margin-bottom: var(--space-2);
            animation: bounce 1s infinite;
        }

        .drop-indicator-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary-700);
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        /* File Stats */
        .upload-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: var(--space-4);
            padding: var(--space-3) var(--space-4);
            background: rgba(255, 255, 255, 0.7);
            border-radius: var(--radius-lg);
            font-size: 0.85rem;
            color: var(--gray-600);
        }

        .upload-stats-item {
            display: flex;
            align-items: center;
            gap: var(--space-1);
        }

        .upload-stats-icon {
            font-size: 1rem;
        }

        /* Processing Area */
        .processing-area {
            background: white;
            border-radius: 20px;
            padding: var(--space-8);
            margin-bottom: var(--space-6);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.05);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .processing-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-6);
            flex-wrap: wrap;
            gap: var(--space-4);
        }

        .processing-header h3 {
            font-size: 1.5rem;
            color: var(--gray-800);
            margin: 0;
            font-weight: 600;
        }

        .processing-count {
            background: var(--orange-100);
            color: var(--orange-700);
            padding: var(--space-2) var(--space-4);
            border-radius: 20px;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .processing-progress {
            margin-bottom: var(--space-6);
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--gray-200);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: var(--space-3);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--green-500), var(--green-400));
            border-radius: 6px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.4) 50%, transparent 100%);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            text-align: center;
            color: var(--gray-600);
            font-weight: 500;
        }

        .processing-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: var(--space-4);
            margin-top: var(--space-4);
        }

        .processing-thumbnail {
            background: var(--gray-100);
            border-radius: 12px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .processing-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 12px;
        }

        .processing-thumbnail.processing::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Results Section */
        .crop-results {
            background: linear-gradient(135deg, #f0fff4 0%, #ecfdf5 100%);
            border: 2px solid var(--green-200);
            border-radius: 20px;
            padding: var(--space-8);
            margin-bottom: var(--space-6);
            animation: slideIn 0.5s ease-out 0.2s both;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: var(--space-8);
            flex-wrap: wrap;
            gap: var(--space-6);
        }

        .results-summary h3 {
            font-size: 1.8rem;
            color: var(--green-700);
            margin: 0 0 var(--space-2);
            font-weight: 600;
        }

        .results-summary p {
            color: var(--green-600);
            margin: 0;
            font-size: 1rem;
        }

        .results-stats {
            display: flex;
            gap: var(--space-6);
        }

        .stat-item {
            text-align: center;
            background: white;
            padding: var(--space-4);
            border-radius: 12px;
            border: 1px solid var(--green-200);
            min-width: 120px;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--green-700);
            margin-bottom: var(--space-1);
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--green-600);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        /* Action Grid */
        .action-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--space-4);
            margin-bottom: var(--space-6);
        }

        .action-card {
            background: white;
            border: 2px solid var(--gray-200);
            border-radius: 16px;
            padding: var(--space-6);
            display: flex;
            align-items: center;
            gap: var(--space-4);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: left;
        }

        .action-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
        }

        .action-card.primary {
            border-color: var(--blue-300);
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        }

        .action-card.primary:hover {
            border-color: var(--blue-500);
            box-shadow: 0 12px 24px rgba(59, 130, 246, 0.2);
        }

        .action-card.secondary {
            border-color: var(--purple-300);
            background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
        }

        .action-card.secondary:hover {
            border-color: var(--purple-500);
            box-shadow: 0 12px 24px rgba(147, 51, 234, 0.2);
        }

        /* Download Section Styling */
        .crop-download-section {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 2px solid var(--gray-200);
            border-radius: 16px;
            padding: var(--space-6);
            margin-top: var(--space-6);
        }

        .download-header {
            margin-bottom: var(--space-6);
            text-align: center;
        }

        .download-header h3 {
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0 0 var(--space-2) 0;
        }

        .download-header p {
            color: var(--text-secondary);
            font-size: var(--text-sm);
            margin: 0;
        }

        .download-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--space-4);
            margin-bottom: var(--space-4);
        }

        .download-card {
            background: white;
            border: 2px solid var(--gray-200);
            border-radius: 12px;
            padding: var(--space-4);
            display: flex;
            align-items: center;
            gap: var(--space-3);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .download-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        }

        .download-card.primary {
            border-color: var(--blue-300);
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        }

        .download-card.primary:hover {
            border-color: var(--blue-500);
            box-shadow: 0 8px 16px rgba(59, 130, 246, 0.15);
        }

        .download-card.secondary {
            border-color: var(--purple-300);
            background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
        }

        .download-card.secondary:hover {
            border-color: var(--purple-500);
            box-shadow: 0 8px 16px rgba(147, 51, 234, 0.15);
        }

        .download-card.tertiary {
            border-color: var(--green-300);
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        }

        .download-card.tertiary:hover {
            border-color: var(--green-500);
            box-shadow: 0 8px 16px rgba(34, 197, 94, 0.15);
        }

        .download-icon {
            font-size: 24px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            flex-shrink: 0;
        }

        .download-content {
            flex: 1;
        }

        .download-title {
            font-size: var(--text-base);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0 0 2px 0;
        }

        .download-subtitle {
            font-size: var(--text-sm);
            color: var(--text-secondary);
            margin: 0;
        }

        .download-status {
            text-align: center;
            padding: var(--space-3);
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            font-size: var(--text-sm);
            color: var(--text-secondary);
            border: 1px solid var(--gray-200);
        }

        .action-card.tertiary {
            border-color: var(--green-300);
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
        }

        .action-card.tertiary:hover {
            border-color: var(--green-500);
            box-shadow: 0 12px 24px rgba(34, 197, 94, 0.2);
        }

        .action-card.quaternary {
            border-color: var(--orange-300);
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
        }

        .action-card.quaternary:hover {
            border-color: var(--orange-500);
            box-shadow: 0 12px 24px rgba(249, 115, 22, 0.2);
        }

        .action-icon {
            font-size: 2.5rem;
            flex-shrink: 0;
        }

        .action-content {
            flex: 1;
        }

        .action-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--gray-800);
            margin-bottom: var(--space-1);
        }

        .action-subtitle {
            font-size: 0.9rem;
            color: var(--gray-600);
            line-height: 1.4;
        }

        /* Results Gallery */
        .results-gallery {
            background: white;
            border-radius: 16px;
            padding: var(--space-6);
            border: 1px solid var(--green-200);
        }

        .results-gallery h4 {
            color: var(--green-700);
            margin-bottom: var(--space-4);
            font-weight: 600;
        }

        .results-thumbnails {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: var(--space-4);
        }

        .result-thumbnail {
            background: var(--gray-50);
            border-radius: 12px;
            aspect-ratio: 1;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-thumbnail:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
        }

        .result-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .thumbnail-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent 0%, rgba(0, 0, 0, 0.7) 100%);
            color: white;
            padding: var(--space-2);
            font-size: 0.8rem;
            text-align: center;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .crop-container-enhanced {
                padding: var(--space-4);
            }

            .size-grid {
                grid-template-columns: 1fr;
            }

            .dimension-inputs-grid {
                grid-template-columns: 1fr;
            }

            .results-header {
                flex-direction: column;
                text-align: center;
            }

            .results-stats {
                justify-content: center;
            }

            .action-grid {
                grid-template-columns: 1fr;
            }
        }

        .section-header {
            text-align: left;
            margin-bottom: var(--space-8);
            padding: 0;
            position: relative;
        }

        .section-header h2 {
            font-size: var(--text-2xl);
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-2);
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: var(--space-2);
            letter-spacing: -0.02em;
            line-height: 1.3;
        }
        
        .section-header h2::before {
            font-size: var(--text-xl);
            filter: none;
        }

        .section-header p {
            font-size: var(--text-sm);
            color: var(--text-tertiary);
            font-weight: 400;
            max-width: 100%;
            margin: 0;
            line-height: 1.5;
        }
        
        .section-header::after {
            display: none;
        }

        .section-label {
            display: block;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: var(--space-4);
            font-size: var(--text-sm);
        }

        /* ========== COMPREHENSIVE BUTTON SYSTEM ========== */
        
        /* Base Button Styles */
        button, .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            padding: var(--space-3) var(--space-5);
            border: 1px solid transparent;
            border-radius: var(--radius-lg);
            font-family: inherit;
            font-size: var(--text-sm);
            font-weight: 500;
            line-height: 1.5;
            text-decoration: none;
            cursor: pointer;
            transition: var(--transition-base);
            position: relative;
            overflow: hidden;
            white-space: nowrap;
        }

        button:disabled, .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* Primary Button */
        .btn-primary, button[type="submit"], button.primary {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            box-shadow: var(--shadow-md);
            font-weight: 600;
        }

        .btn-primary:hover, button[type="submit"]:hover, button.primary:hover {
            background: var(--primary-dark);
            border-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        /* Secondary Button */
        .btn-secondary, button.secondary {
            background: var(--surface);
            color: var(--text-primary);
            border-color: var(--border);
            border-width: 2px;
            font-weight: 600;
        }

        .btn-secondary:hover, button.secondary:hover {
            background: var(--background);
            border-color: var(--primary);
            color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        /* Success Button */
        .btn-success, button.success {
            background: var(--success);
            color: white;
            border-color: var(--success);
        }

        .btn-success:hover, button.success:hover {
            background: #059669;
            border-color: #059669;
            transform: translateY(-1px);
        }

        /* Warning Button */
        .btn-warning, button.warning {
            background: var(--warning);
            color: white;
            border-color: var(--warning);
        }

        .btn-warning:hover, button.warning:hover {
            background: #d97706;
            border-color: #d97706;
            transform: translateY(-1px);
        }

        /* Danger Button */
        .btn-danger, button.danger {
            background: var(--error);
            color: white;
            border-color: var(--error);
        }

        .btn-danger:hover, button.danger:hover {
            background: #dc2626;
            border-color: #dc2626;
            transform: translateY(-1px);
        }

        /* Ghost Button */
        .btn-ghost, button.ghost {
            background: transparent;
            color: var(--text-primary);
            border-color: transparent;
        }

        .btn-ghost:hover, button.ghost:hover {
            background: var(--background);
            color: var(--primary);
        }

        /* Button Sizes */
        .btn-xs, button.xs {
            padding: var(--space-1) var(--space-3);
            font-size: var(--text-xs);
        }

        .btn-sm, button.sm {
            padding: var(--space-2) var(--space-4);
            font-size: var(--text-sm);
        }

        .btn-lg, button.lg {
            padding: var(--space-4) var(--space-8);
            font-size: var(--text-lg);
            font-weight: 600;
        }

        .btn-xl, button.xl {
            padding: var(--space-5) var(--space-10);
            font-size: var(--text-xl);
            font-weight: 600;
        }

        /* Icon Buttons */
        .btn-icon, button.icon {
            padding: var(--space-3);
            aspect-ratio: 1;
            min-width: auto;
        }

        .btn-icon.sm, button.icon.sm {
            padding: var(--space-2);
        }

        .btn-icon.lg, button.icon.lg {
            padding: var(--space-4);
        }

        /* Full Width Button */
        .btn-block, button.block {
            width: 100%;
        }

        /* Button Groups */
        .btn-group {
            display: inline-flex;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
        }

        .btn-group button, .btn-group .btn {
            border-radius: 0;
            border-right-width: 0;
        }

        .btn-group button:first-child, .btn-group .btn:first-child {
            border-top-left-radius: var(--radius-lg);
            border-bottom-left-radius: var(--radius-lg);
        }

        .btn-group button:last-child, .btn-group .btn:last-child {
            border-top-right-radius: var(--radius-lg);
            border-bottom-right-radius: var(--radius-lg);
            border-right-width: 1px;
        }

        /* ========== FORM CONTROLS ========== */
        
        input, textarea, select {
            display: block;
            width: 100%;
            padding: var(--space-4) var(--space-5);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            background: var(--surface);
            color: var(--text-primary);
            font-family: inherit;
            font-size: var(--text-base);
            font-weight: 500;
            line-height: 1.5;
            transition: var(--transition-base);
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.15);
            background: var(--surface-elevated);
        }

        input::placeholder, textarea::placeholder {
            color: var(--text-tertiary);
        }

        /* Checkbox and Radio */
        input[type="checkbox"], input[type="radio"] {
            width: auto;
            margin-right: var(--space-2);
        }

        /* Range Slider */
        input[type="range"] {
            padding: 0;
            background: transparent;
            border: none;
        }

        input[type="range"]::-webkit-slider-track {
            background: var(--border);
            height: 6px;
            border-radius: var(--radius-lg);
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        /* ========== ANIMATIONS & TRANSITIONS ========== */
        
        /* Smooth Motion Preferences */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Keyframe Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { 
                opacity: 0; 
                transform: translateY(20px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        @keyframes slideDown {
            from { 
                opacity: 0; 
                transform: translateY(-20px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        @keyframes slideLeft {
            from { 
                opacity: 0; 
                transform: translateX(20px); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }

        @keyframes slideRight {
            from { 
                opacity: 0; 
                transform: translateX(-20px); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }

        @keyframes scaleIn {
            from { 
                opacity: 0; 
                transform: scale(0.9); 
            }
            to { 
                opacity: 1; 
                transform: scale(1); 
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes bounce {
            0%, 100% { 
                transform: translateY(0); 
                animation-timing-function: cubic-bezier(0.8, 0, 1, 1); 
            }
            50% { 
                transform: translateY(-25%); 
                animation-timing-function: cubic-bezier(0, 0, 0.2, 1); 
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
            20%, 40%, 60%, 80% { transform: translateX(2px); }
        }

        /* Animation Utility Classes */
        .animate-fadeIn { animation: fadeIn 0.3s ease-out; }
        .animate-slideUp { animation: slideUp 0.3s ease-out; }
        .animate-slideDown { animation: slideDown 0.3s ease-out; }
        .animate-slideLeft { animation: slideLeft 0.3s ease-out; }
        .animate-slideRight { animation: slideRight 0.3s ease-out; }
        .animate-scaleIn { animation: scaleIn 0.3s ease-out; }
        .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        .animate-spin { animation: spin 1s linear infinite; }
        .animate-bounce { animation: bounce 1s infinite; }
        .animate-shake { animation: shake 0.5s ease-in-out; }

        /* Staggered Animation Delays */
        .animate-delay-75 { animation-delay: 75ms; }
        .animate-delay-100 { animation-delay: 100ms; }
        .animate-delay-150 { animation-delay: 150ms; }
        .animate-delay-200 { animation-delay: 200ms; }
        .animate-delay-300 { animation-delay: 300ms; }
        .animate-delay-500 { animation-delay: 500ms; }
        .animate-delay-700 { animation-delay: 700ms; }
        .animate-delay-1000 { animation-delay: 1000ms; }

        /* Loading States */
        .loading-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-dots {
            display: inline-flex;
            gap: var(--space-1);
        }

        .loading-dots span {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--primary);
            animation: bounce 1.4s ease-in-out infinite both;
        }

        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }
        .loading-dots span:nth-child(3) { animation-delay: 0s; }

        /* Hover Effects */
        .hover-lift {
            transition: var(--transition-base);
        }

        .hover-lift:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .hover-scale {
            transition: var(--transition-base);
        }

        .hover-scale:hover {
            transform: scale(1.05);
        }

        .hover-brightness {
            transition: var(--transition-base);
        }

        .hover-brightness:hover {
            filter: brightness(1.1);
        }

        /* ========== RESPONSIVE DESIGN SYSTEM ========== */
        
        /* Breakpoint System */
        /* xs: 0px and up (default) */
        /* sm: 640px and up */
        /* md: 768px and up */
        /* lg: 1024px and up */
        /* xl: 1280px and up */
        /* 2xl: 1536px and up */

        /* Container Responsive */
        .container {
            width: 100%;
        }

        @media (min-width: 640px) {
            .container { max-width: 640px; }
        }

        @media (min-width: 768px) {
            .container { max-width: 768px; }
        }

        @media (min-width: 1024px) {
            .container { max-width: 1024px; }
        }

        @media (min-width: 1280px) {
            .container { max-width: 1280px; }
        }

        @media (min-width: 1536px) {
            .container { max-width: 1536px; }
        }

        /* Mobile-First Responsive Utilities */
        
        /* Display */
        .hidden { display: none; }
        .block { display: block; }
        .inline { display: inline; }
        .inline-block { display: inline-block; }
        .flex { display: flex; }
        .inline-flex { display: inline-flex; }
        .grid { display: grid; }
        .inline-grid { display: inline-grid; }

        @media (min-width: 640px) {
            .sm\\:hidden { display: none; }
            .sm\\:block { display: block; }
            .sm\\:flex { display: flex; }
            .sm\\:grid { display: grid; }
        }

        @media (min-width: 768px) {
            .md\\:hidden { display: none; }
            .md\\:block { display: block; }
            .md\\:flex { display: flex; }
            .md\\:grid { display: grid; }
        }

        @media (min-width: 1024px) {
            .lg\\:hidden { display: none; }
            .lg\\:block { display: block; }
            .lg\\:flex { display: flex; }
            .lg\\:grid { display: grid; }
        }

        /* Flex Direction */
        .flex-row { flex-direction: row; }
        .flex-col { flex-direction: column; }

        @media (min-width: 640px) {
            .sm\\:flex-row { flex-direction: row; }
            .sm\\:flex-col { flex-direction: column; }
        }

        @media (min-width: 768px) {
            .md\\:flex-row { flex-direction: row; }
            .md\\:flex-col { flex-direction: column; }
        }

        /* Text Alignment */
        .text-left { text-align: left; }
        .text-center { text-align: center; }
        .text-right { text-align: right; }

        @media (min-width: 640px) {
            .sm\\:text-left { text-align: left; }
            .sm\\:text-center { text-align: center; }
            .sm\\:text-right { text-align: right; }
        }

        @media (min-width: 768px) {
            .md\\:text-left { text-align: left; }
            .md\\:text-center { text-align: center; }
            .md\\:text-right { text-align: right; }
        }

        /* Spacing */
        .p-0 { padding: 0; }
        .p-2 { padding: var(--space-2); }
        .p-4 { padding: var(--space-4); }
        .p-6 { padding: var(--space-6); }
        .p-8 { padding: var(--space-8); }

        .m-0 { margin: 0; }
        .m-2 { margin: var(--space-2); }
        .m-4 { margin: var(--space-4); }
        .m-6 { margin: var(--space-6); }
        .m-8 { margin: var(--space-8); }

        @media (min-width: 768px) {
            .md\\:p-2 { padding: var(--space-2); }
            .md\\:p-4 { padding: var(--space-4); }
            .md\\:p-6 { padding: var(--space-6); }
            .md\\:p-8 { padding: var(--space-8); }
            .md\\:p-10 { padding: var(--space-10); }
            .md\\:p-12 { padding: var(--space-12); }
        }

        /* Grid Columns */
        .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        .grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        .grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }

        @media (min-width: 640px) {
            .sm\\:grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
            .sm\\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
            .sm\\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
            .sm\\:grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        }

        @media (min-width: 768px) {
            .md\\:grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
            .md\\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
            .md\\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
            .md\\:grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
            .md\\:grid-cols-5 { grid-template-columns: repeat(5, minmax(0, 1fr)); }
            .md\\:grid-cols-6 { grid-template-columns: repeat(6, minmax(0, 1fr)); }
        }

        /* Enhanced Mobile Breakpoints */
        @media (max-width: 767px) {
            /* Mobile-specific adjustments */
            body {
                padding: var(--space-3);
            }

            .container {
                border-radius: var(--radius-xl);
                border-width: 1px;
            }

            .header {
                padding: var(--space-8) var(--space-5);
            }

            .header h1 {
                font-size: var(--text-3xl);
            }

            .header-subtitle {
                font-size: var(--text-base);
            }

            .main-content {
                padding: var(--space-8) var(--space-5);
            }

            .function-tabs {
                flex-wrap: nowrap;
                overflow-x: auto;
                gap: var(--space-2);
                padding: 0;
                padding-bottom: var(--space-2);
                margin-bottom: var(--space-6);
            }

            .tab-button {
                flex-direction: row;
                justify-content: flex-start;
                text-align: left;
                padding: var(--space-2) var(--space-4);
                min-height: auto;
                gap: var(--space-2);
                flex-shrink: 0;
            }

            .tab-icon {
                font-size: var(--text-base);
            }

            .tab-text {
                font-size: var(--text-xs);
            }

            .section-header h2 {
                font-size: var(--text-xl);
            }

            .section-header {
                margin-bottom: var(--space-6);
            }

            .section-header p {
                font-size: var(--text-base);
            }

            .convert-content {
                max-width: 100%;
                padding: 0 var(--space-2);
            }

            .upload-zone {
                padding: var(--space-12) var(--space-6);
                border-width: 2px;
            }

            .upload-icon {
                font-size: var(--text-3xl);
                margin-bottom: var(--space-3);
            }

            .upload-text {
                font-size: var(--text-lg);
            }

            .upload-subtext {
                font-size: var(--text-sm);
            }

            .btn-group {
                flex-direction: column;
                width: 100%;
            }

            .btn-group button,
            .btn-group .btn {
                border-radius: var(--radius-lg);
                border-right-width: 1px;
                border-bottom-width: 0;
            }

            .btn-group button:not(:last-child),
            .btn-group .btn:not(:last-child) {
                border-bottom-width: 0;
            }

            .btn-group button:last-child,
            .btn-group .btn:last-child {
                border-bottom-width: 1px;
            }
        }

        /* Tablet Adjustments */
        @media (min-width: 768px) and (max-width: 1023px) {
            .function-tabs {
                max-width: 100%;
                margin-bottom: var(--space-8);
            }

            .main-content {
                padding: var(--space-8) var(--space-6);
            }

            .convert-content {
                max-width: 700px;
            }

            .upload-zone {
                padding: var(--space-14) var(--space-8);
            }
        }

        /* Large Screen Optimizations */
        @media (min-width: 1024px) {
            .main-content {
                padding: var(--space-10) var(--space-8);
            }

            .function-tabs {
                max-width: 100%;
            }

            .tab-button:hover {
                transform: translateY(0);
            }

            .convert-content {
                max-width: 900px;
            }

            .upload-zone {
                padding: var(--space-20) var(--space-10);
                max-width: 600px;
                margin: 0 auto;
            }

            .upload-icon {
                font-size: 4.5rem;
                margin-bottom: var(--space-6);
            }

            .upload-text {
                font-size: var(--text-2xl);
                margin-bottom: var(--space-3);
            }

            .upload-subtext {
                font-size: var(--text-lg);
                margin-bottom: var(--space-4);
            }
        }

        .size-selection-container {
            margin-bottom: var(--spacing-xl);
        }

        /* ========== FINAL POLISH & CARD STYLES ========== */
        
        /* Modern Card System */
        .card, .panel, .config-panel {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius-2xl);
            box-shadow: var(--shadow-md);
            overflow: hidden;
            transition: var(--transition-base);
        }

        .card:hover, .panel:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
            border-color: var(--primary);
        }

        .card-header, .panel-header {
            padding: var(--space-6);
            border-bottom: 1px solid var(--border-light);
            background: var(--gradient-surface);
        }

        .card-body, .panel-body {
            padding: var(--space-6);
        }

        .card-footer, .panel-footer {
            padding: var(--space-6);
            border-top: 1px solid var(--border-light);
            background: var(--background);
        }

        /* Enhanced Function Sections */
        .function-section {
            animation: fadeIn 0.5s ease-out;
        }

        /* Stats and Info Cards */
        .stats-card {
            background: var(--gradient-surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-xl);
            padding: var(--space-6);
            text-align: center;
            box-shadow: var(--shadow-sm);
            transition: var(--transition-base);
        }

        .stats-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .stats-number {
            font-size: var(--text-3xl);
            font-weight: 700;
            color: var(--primary);
            margin-bottom: var(--space-2);
        }

        .stats-label {
            font-size: var(--text-sm);
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Convert Section Styles */
        .convert-content {
            max-width: 800px;
            margin: 0 auto;
        }

        /* Upload Zones */
        .upload-zone {
            border: 3px dashed var(--border);
            border-radius: var(--radius-2xl);
            background: var(--surface);
            transition: var(--transition-base);
            position: relative;
            padding: var(--space-16) var(--space-8);
            text-align: center;
            cursor: pointer;
            margin: 0 auto;
        }

        .upload-zone:hover {
            border-color: var(--primary);
            background: var(--background);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            border-style: solid;
        }

        .upload-zone.dragover {
            border-color: var(--primary);
            border-style: solid;
            background: rgba(79, 70, 229, 0.05);
            box-shadow: var(--shadow-xl);
        }

        .upload-icon {
            font-size: var(--text-4xl);
            margin-bottom: var(--space-4);
            color: var(--primary);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }

        .upload-text {
            font-size: var(--text-xl);
            color: var(--text-primary);
            margin-bottom: var(--space-2);
            font-weight: 600;
        }

        .upload-subtext {
            color: var(--text-secondary);
            font-size: var(--text-base);
            margin-bottom: var(--space-3);
            font-weight: 500;
        }

        .upload-hint {
            color: var(--text-tertiary);
            font-size: var(--text-sm);
            font-style: italic;
        }

        .file-input {
            display: none;
        }

        /* Enhanced Masonry Gallery Grid */
        .gallery-grid {
            columns: 4;
            column-gap: var(--space-4);
            animation: fadeIn 0.5s ease-out;
        }

        @media (max-width: 1200px) {
            .gallery-grid { columns: 3; }
        }

        @media (max-width: 768px) {
            .gallery-grid { columns: 2; }
        }

        @media (max-width: 480px) {
            .gallery-grid { 
                columns: 1; 
                column-gap: var(--space-2);
            }
        }

        .gallery-item {
            background: var(--surface);
            border: 2px solid var(--border-light);
            border-radius: var(--radius-xl);
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: scaleIn 0.3s ease-out;
            break-inside: avoid;
            margin-bottom: var(--space-4);
            position: relative;
            box-shadow: var(--shadow-sm);
        }

        .gallery-item:hover {
            box-shadow: var(--shadow-xl);
            transform: translateY(-4px);
            border-color: var(--primary-300);
        }

        .gallery-item-image {
            width: 100%;
            height: auto;
            display: block;
            transition: transform 0.3s ease;
        }

        .gallery-item:hover .gallery-item-image {
            transform: scale(1.05);
        }

        .gallery-item-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                180deg, 
                rgba(0,0,0,0) 0%, 
                rgba(0,0,0,0.7) 100%
            );
            opacity: 0;
            transition: opacity 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: var(--space-4);
        }

        .gallery-item:hover .gallery-item-overlay {
            opacity: 1;
        }

        .gallery-item-info {
            color: white;
            z-index: 2;
        }

        .gallery-item-name {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: var(--space-1);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .gallery-item-details {
            font-size: 0.75rem;
            opacity: 0.9;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .gallery-item-actions {
            position: absolute;
            top: var(--space-2);
            right: var(--space-2);
            display: flex;
            gap: var(--space-1);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .gallery-item:hover .gallery-item-actions {
            opacity: 1;
        }

        .gallery-action-btn {
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
        }

        .gallery-action-btn:hover {
            background: white;
            transform: scale(1.1);
        }

        /* Gallery Item Selection */
        .gallery-item.selected {
            border-color: var(--primary-500);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
        }

        .gallery-item.selected::after {
            content: '‚úì';
            position: absolute;
            top: var(--space-2);
            left: var(--space-2);
            width: 24px;
            height: 24px;
            background: var(--primary-500);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }

        /* Gallery Empty State */
        .gallery-empty-state {
            grid-column: 1 / -1;
            text-align: center;
            padding: var(--space-16) var(--space-4);
            color: var(--gray-500);
        }

        .gallery-empty-icon {
            font-size: 4rem;
            margin-bottom: var(--space-4);
            opacity: 0.5;
        }

        .gallery-empty-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: var(--space-2);
            color: var(--gray-700);
        }

        .gallery-empty-description {
            font-size: 1rem;
            line-height: 1.6;
        }

        /* Gallery Loading Animation */
        .gallery-loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: var(--space-8);
            grid-column: 1 / -1;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--gray-200);
            border-top: 3px solid var(--primary-500);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Enhanced Settings Panel with Collapsible Sections */
        .settings-panel {
            background: white;
            border-radius: var(--radius-xl);
            border: 2px solid var(--border-light);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .settings-panel.expanded {
            box-shadow: var(--shadow-xl);
        }

        .settings-header {
            padding: var(--space-4) var(--space-6);
            background: linear-gradient(135deg, var(--gray-50) 0%, var(--gray-100) 100%);
            border-bottom: 2px solid var(--border-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .settings-header:hover {
            background: linear-gradient(135deg, var(--gray-100) 0%, var(--gray-200) 100%);
        }

        .settings-title {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--gray-800);
        }

        .settings-icon {
            font-size: 1.3rem;
            color: var(--primary-500);
        }

        .settings-toggle {
            font-size: 1.2rem;
            color: var(--gray-500);
            transition: all 0.3s ease;
        }

        .settings-panel.expanded .settings-toggle {
            transform: rotate(180deg);
        }

        .settings-body {
            max-height: 0;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .settings-panel.expanded .settings-body {
            max-height: 800px;
        }

        .settings-content {
            padding: var(--space-6);
        }

        /* Collapsible Sections */
        .settings-section {
            margin-bottom: var(--space-6);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            overflow: hidden;
            background: var(--gray-50);
        }

        .settings-section:last-child {
            margin-bottom: 0;
        }

        .section-header {
            padding: var(--space-4);
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
            border-bottom: 1px solid transparent;
        }

        .section-header:hover {
            background: var(--gray-50);
        }

        .settings-section.expanded .section-header {
            border-bottom-color: var(--border-light);
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-weight: 600;
            color: var(--gray-700);
        }

        .section-icon {
            font-size: 1rem;
            color: var(--primary-500);
        }

        .section-toggle {
            font-size: 1rem;
            color: var(--gray-400);
            transition: transform 0.3s ease;
        }

        .settings-section.expanded .section-toggle {
            transform: rotate(180deg);
        }

        .section-content {
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .settings-section.expanded .section-content {
            max-height: 400px;
        }

        .section-body {
            padding: var(--space-4);
            background: white;
        }

        /* Settings Controls */
        .setting-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-3) 0;
            border-bottom: 1px solid var(--border-light);
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-label {
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
        }

        .setting-name {
            font-weight: 500;
            color: var(--gray-700);
        }

        .setting-description {
            font-size: 0.85rem;
            color: var(--gray-500);
            line-height: 1.4;
        }

        /* Custom Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 48px;
            height: 24px;
            background: var(--gray-300);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--primary-500);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-sm);
        }

        .toggle-switch.active::after {
            transform: translateX(24px);
        }

        /* Range Slider */
        .range-slider {
            width: 100px;
            height: 4px;
            background: var(--gray-200);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary-500);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
        }

        /* Select Dropdown */
        .custom-select {
            position: relative;
            min-width: 120px;
        }

        .select-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-2);
            padding: var(--space-2) var(--space-3);
            background: white;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .select-trigger:hover {
            border-color: var(--primary-300);
        }

        .select-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid var(--border);
            border-top: none;
            border-radius: 0 0 var(--radius-md) var(--radius-md);
            box-shadow: var(--shadow-md);
            z-index: 100;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .custom-select.open .select-dropdown {
            display: block;
        }

        .select-option {
            padding: var(--space-2) var(--space-3);
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s ease;
        }

        .select-option:hover {
            background: var(--gray-50);
        }

        .select-option.selected {
            background: var(--primary-50);
            color: var(--primary-600);
            font-weight: 500;
        }

        /* Settings Actions */
        .settings-actions {
            padding: var(--space-4) var(--space-6);
            background: var(--gray-50);
            border-top: 1px solid var(--border-light);
            display: flex;
            gap: var(--space-3);
            justify-content: flex-end;
        }

        .settings-btn {
            padding: var(--space-2) var(--space-4);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .settings-btn:hover {
            background: var(--gray-50);
        }

        .settings-btn.primary {
            background: var(--primary-500);
            color: white;
            border-color: var(--primary-500);
        }

        .settings-btn.primary:hover {
            background: var(--primary-600);
        }

        /* Toast Notifications Enhancement */
        .toast {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(20px);
            animation: slideRight 0.3s ease-out;
        }

        /* Progress Bars */
        .progress-bar {
            background: var(--border-light);
            border-radius: var(--radius-lg);
            overflow: hidden;
            height: 8px;
        }

        .progress-fill {
            background: var(--primary);
            height: 100%;
            transition: width 0.3s ease-out;
            border-radius: var(--radius-lg);
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: pulse 2s infinite;
        }

        /* Focus States for Accessibility */
        button:focus-visible,
        .tab-button:focus-visible,
        input:focus-visible,
        textarea:focus-visible,
        select:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        /* Smooth Page Transitions */
        .page-transition {
            animation: fadeIn 0.4s ease-out;
        }

        /* Loading States */
        .loading-skeleton {
            background: linear-gradient(90deg, var(--border-light) 25%, var(--border) 50%, var(--border-light) 75%);
            background-size: 200% 100%;
            animation: shimmer 2s infinite;
            border-radius: var(--radius-lg);
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .size-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }

        .size-option {
            padding: var(--spacing-lg);
            border: 2px solid #d1d5db;
            border-radius: var(--radius-lg);
            background: #f8fafc;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .size-option:hover {
            border-color: var(--primary-blue);
            background: #e2e8f0;
            transform: translateY(-2px);
        }

        .size-option.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        .size-main {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-xs);
        }

        .size-description {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .custom-dimensions {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
        }

        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-lg);
        }

        .input-field {
            display: flex;
            flex-direction: column;
        }

        .input-field label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-dark);
            margin-bottom: var(--spacing-sm);
        }

        .input-field input {
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: var(--radius-md);
            font-size: 0.95rem;
            transition: border-color 0.2s ease;
        }

        .input-field input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .upload-area {
            border: 2px dashed #cbd5e0;
            border-radius: var(--radius-lg);
            padding: var(--spacing-2xl) var(--spacing-lg);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #f8fafc;
            margin-bottom: var(--spacing-xl);
        }

        .upload-area:hover {
            border-color: var(--primary-blue);
            background: #eff6ff;
        }

        .upload-content {
            max-width: 400px;
            margin: 0 auto;
        }

        .upload-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: var(--spacing-sm);
        }

        .upload-subtitle {
            color: var(--text-light);
            margin-bottom: var(--spacing-md);
        }

        .upload-formats {
            font-size: 0.85rem;
            color: var(--text-light);
            font-style: italic;
        }

        .crop-actions {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
        }

        .action-section {
            margin-bottom: var(--spacing-lg);
        }

        .action-section:last-child {
            margin-bottom: 0;
        }

        .download-options,
        .tool-options {
            display: flex;
            gap: var(--spacing-md);
            flex-wrap: wrap;
        }

        .download-btn,
        .tool-btn {
            padding: 12px 20px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            min-width: 140px;
        }

        .download-btn.primary {
            background: var(--primary-blue);
            color: white;
        }

        .download-btn.primary:hover {
            background: var(--dark-blue);
        }

        .download-btn.secondary {
            background: #6b7280;
            color: white;
        }

        .download-btn.secondary:hover {
            background: #4b5563;
        }

        .tool-btn {
            background: #f1f5f9;
            color: var(--text-primary);
            border: 2px solid #cbd5e1;
        }

        .tool-btn:hover {
            background: #e2e8f0;
            border-color: var(--primary-blue);
            transform: translateY(-1px);
        }

        /* Gallery Styles */
        .gallery-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .gallery-controls {
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: var(--spacing-lg);
            align-items: center;
            margin-bottom: var(--spacing-lg);
            padding: var(--spacing-lg);
            background: white;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid #e5e7eb;
        }

        .search-section {
            display: flex;
            align-items: center;
            gap: 12px;
            justify-content: center;
        }

        .search-box {
            position: relative;
            display: flex;
            align-items: center;
        }

        .search-input {
            padding: 8px 40px 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: var(--white);
            font-size: 0.9rem;
            min-width: 200px;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .search-icon {
            position: absolute;
            right: 12px;
            color: #6b7280;
            pointer-events: none;
        }

        .filter-select {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: var(--white);
            font-size: 0.9rem;
            color: var(--text-dark);
            min-width: 120px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Gallery image preview tooltip */
        .gallery-image-tooltip {
            position: absolute;
            top: -250px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 2px solid var(--primary-blue);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .gallery-item:hover .gallery-image-tooltip {
            opacity: 1;
        }

        .tooltip-image {
            width: 200px;
            height: 150px;
            object-fit: cover;
            border-radius: 4px;
        }

        .tooltip-info {
            padding: 8px 0 0 0;
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-dark);
        }

        /* Duplex Preview Controls */
        .duplex-preview-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-left: 16px;
            padding-left: 16px;
            border-left: 2px solid #e2e8f0;
        }

        .side-toggle {
            display: flex;
            background: #f1f5f9;
            border-radius: 8px;
            padding: 2px;
            border: 1px solid #e2e8f0;
        }

        .side-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .side-btn:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        .side-btn.active {
            background: var(--primary-blue);
            color: white;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }

        .side-icon {
            font-size: 1rem;
        }

        .side-text {
            font-size: 0.8rem;
        }

        .page-side-indicator {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-dark);
            padding: 8px 12px;
            background: #fef3cd;
            border: 1px solid #fde047;
            border-radius: 6px;
        }

        /* Duplex Slot Management */
        .duplex-slot-management {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-lg);
            padding: 20px;
            margin-bottom: 20px;
        }

        .slot-management-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e2e8f0;
        }

        .slot-management-header h3 {
            margin: 0;
            color: var(--text-dark);
            font-size: 1.1rem;
        }

        .slot-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .slot-info span {
            font-size: 0.85rem;
        }

        .slot-instructions {
            color: #6b7280;
            font-style: italic;
        }

        .slot-grid-container {
            background: white;
            border-radius: 8px;
            padding: 16px;
            border: 1px solid #e2e8f0;
        }

        .slot-grid-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e2e8f0;
        }

        .current-page-info {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
        }

        .current-side {
            background: var(--primary-blue);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .slot-actions {
            display: flex;
            gap: 8px;
        }

        .slot-action-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            background: #f8fafc;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .slot-action-btn:hover {
            background: #e2e8f0;
            border-color: var(--primary-blue);
            transform: translateY(-1px);
        }

        .slot-grid {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
        }

        .slot-item {
            aspect-ratio: 1;
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #f9fafb;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            min-height: 80px;
        }

        .slot-item:hover {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .slot-item.filled {
            border-style: solid;
            border-color: #10b981;
            background: white;
        }

        .slot-item.drag-over {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
            transform: scale(1.02);
        }

        .slot-number {
            position: absolute;
            top: 4px;
            left: 4px;
            background: var(--text-dark);
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slot-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }

        .slot-empty-icon {
            font-size: 1.5rem;
            color: #9ca3af;
        }

        .slot-remove-btn {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .slot-item.filled:hover .slot-remove-btn {
            opacity: 1;
        }

        /* Duplex Classification System */
        .duplex-classification-section {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-lg);
            padding: 20px;
            margin-bottom: 20px;
        }

        .duplex-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e2e8f0;
        }

        .duplex-header h3 {
            margin: 0 0 8px 0;
            color: var(--text-dark);
            font-size: 1.2rem;
        }

        .duplex-info {
            color: #6b7280;
            font-size: 0.9rem;
        }

        .duplex-classification-controls {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
        }

        .classification-actions {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .classify-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .front-classify {
            border-color: #3b82f6;
            background: #eff6ff;
            color: #3b82f6;
        }

        .front-classify:hover, .front-classify.active {
            background: #3b82f6;
            color: white;
        }

        .back-classify {
            border-color: #10b981;
            background: #ecfdf5;
            color: #10b981;
        }

        .back-classify:hover, .back-classify.active {
            background: #10b981;
            color: white;
        }

        .exit-classify {
            border-color: #ef4444;
            background: #fef2f2;
            color: #ef4444;
        }

        .exit-classify:hover {
            background: #ef4444;
            color: white;
        }

        .duplex-stats {
            display: flex;
            justify-content: center;
            gap: 24px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            display: block;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-blue);
        }

        .stat-label {
            font-size: 0.8rem;
            color: #6b7280;
        }

        .duplex-classification-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .classification-column {
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }

        .column-header {
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .front-header {
            background: linear-gradient(135deg, #dbeafe, #bfdbfe);
        }

        .back-header {
            background: linear-gradient(135deg, #d1fae5, #a7f3d0);
        }

        .column-header h4 {
            margin: 0;
            font-size: 1rem;
            color: var(--text-dark);
        }

        .clear-column-btn {
            padding: 4px 8px;
            border: 2px solid #d1d5db;
            background: #f8fafc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .clear-column-btn:hover {
            background: #e2e8f0;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .classification-list {
            min-height: 200px;
            padding: 16px;
        }

        .empty-classification {
            text-align: center;
            color: #9ca3af;
            padding: 32px 16px;
        }

        .empty-icon {
            font-size: 3rem;
            margin-bottom: 12px;
        }

        .empty-text {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .empty-hint {
            font-size: 0.8rem;
            font-style: italic;
        }

        .classified-image {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            margin-bottom: 8px;
            background: #f9fafb;
            transition: all 0.2s ease;
        }

        .classified-image:hover {
            background: white;
            border-color: var(--primary-blue);
        }

        .classified-image-thumb {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
        }

        .classified-image-info {
            flex: 1;
            min-width: 0;
        }

        .classified-image-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-dark);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .classified-image-size {
            font-size: 0.7rem;
            color: #6b7280;
        }

        .classified-image-remove {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .classified-image-remove:hover {
            opacity: 1;
        }

        /* Slot Selection Modal */
        .slot-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .slot-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
        }

        .slot-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
        }

        .slot-modal-header h3 {
            margin: 0;
            color: var(--text-dark);
        }

        .close-slot-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 4px;
            border-radius: 4px;
        }

        .close-slot-modal:hover {
            background: #e5e7eb;
        }

        .slot-modal-body {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .slot-gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 12px;
        }

        .slot-gallery-item {
            aspect-ratio: 1;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .slot-gallery-item:hover {
            border-color: var(--primary-blue);
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }

        .slot-gallery-item img {
            width: 100%;
            height: 80%;
            object-fit: cover;
        }

        .slot-image-name {
            padding: 4px 6px;
            font-size: 0.7rem;
            text-align: center;
            color: var(--text-dark);
            background: #f9fafb;
            border-top: 1px solid #e2e8f0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .gallery-status {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .gallery-count {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--text-dark);
        }

        .gallery-info {
            font-size: 0.8rem;
            color: var(--text-light);
            background: #f0f9ff;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            border: 1px solid #e0f2fe;
        }

        /* Quick Selection Section */
        .quick-selection-section {
            margin: var(--spacing-xl) 0;
            padding: var(--spacing-lg);
            background: #f8fafc;
            border-radius: var(--radius-lg);
            border: 1px solid #e2e8f0;
        }

        .quick-select-controls {
            display: flex;
            gap: var(--spacing-md);
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .quick-select-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 120px;
            justify-content: center;
        }

        .quick-select-btn:hover {
            border-color: var(--primary-blue);
            background: #f8fafc;
            transform: translateY(-1px);
        }

        .quick-select-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        .quick-select-btn.auto-classify-btn {
            border-color: #8b5cf6;
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
            color: white;
            font-weight: 600;
        }

        .quick-select-btn.auto-classify-btn:hover {
            border-color: #7c3aed;
            background: linear-gradient(135deg, #7c3aed 0%, #5b21b6 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        .quick-select-btn.front-type {
            border-color: #10b981;
        }

        .quick-select-btn.front-type:hover,
        .quick-select-btn.front-type.active {
            border-color: #10b981;
            background: #10b981;
            color: white;
        }

        .quick-select-btn.back-type {
            border-color: #ef4444;
        }

        .quick-select-btn.back-type:hover,
        .quick-select-btn.back-type.active {
            border-color: #ef4444;
            background: #ef4444;
            color: white;
        }

        .quick-select-btn.apply-btn {
            border-color: #059669;
            background: #059669;
            color: white;
            font-weight: 600;
        }

        .quick-select-btn.apply-btn:hover {
            border-color: #047857;
            background: #047857;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(5, 150, 105, 0.3);
        }

        .quick-select-btn.cancel-btn {
            border-color: #6b7280;
            background: #6b7280;
            color: white;
        }

        .quick-select-btn.cancel-btn:hover {
            border-color: #4b5563;
            background: #4b5563;
            transform: translateY(-1px);
        }

        /* Selection Mode Styles - Simple checkbox approach */
        .gallery-item.selection-mode,
        .source-grid .gallery-item.selection-mode {
            position: relative;
            cursor: pointer;
        }

        /* Simple Checkbox Styles */
        .selection-checkbox,
        .source-grid .selection-checkbox {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 4px;
            background: rgba(100, 100, 100, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            font-size: 12px;
            font-weight: bold;
            color: white;
            opacity: 0;
        }

        /* Show checkbox when in selection mode - Force visibility */
        .gallery-item.selection-mode .selection-checkbox,
        .source-grid .gallery-item.selection-mode .selection-checkbox {
            opacity: 1 !important;
            display: flex !important;
        }

        /* Selected Front - Green checkbox */
        .gallery-item.selection-mode.selected-front .selection-checkbox,
        .source-grid .gallery-item.selection-mode.selected-front .selection-checkbox {
            background: #10b981;
            border-color: white;
            color: white;
        }

        /* Selected Back - Red checkbox */
        .gallery-item.selection-mode.selected-back .selection-checkbox,
        .source-grid .gallery-item.selection-mode.selected-back .selection-checkbox {
            background: #ef4444;
            border-color: white;
            color: white;
        }

        /* DEBUG: Force show all checkboxes for testing */
        .source-grid .selection-checkbox {
            opacity: 0.3 !important;
            display: flex !important;
        }

        .selection-status {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 0.9rem;
            font-weight: 600;
            padding: 8px 12px;
            background: var(--light-yellow);
            border-radius: var(--radius-md);
            border: 1px solid var(--primary-yellow);
        }

        .selection-counter {
            color: var(--primary-blue);
        }

        .download-section {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-sm) var(--spacing-md);
            background: #fafbfc;
            border-radius: var(--radius-md);
            border: 1px solid #e5e7eb;
        }

        .section-label {
            font-weight: 500;
            color: var(--text-light);
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .control-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: var(--spacing-sm) var(--spacing-md);
            border: none;
            border-radius: var(--radius-md);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 90px;
            text-align: center;
            position: relative;
        }

        .control-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-icon {
            font-size: 1.2rem;
            margin-bottom: 2px;
        }

        .btn-text {
            font-weight: 600;
            line-height: 1;
        }

        .btn-desc {
            font-size: 0.7rem;
            color: currentColor;
            opacity: 0.8;
            line-height: 1;
            margin-top: 2px;
        }

        /* Download buttons styling */
        .control-btn.download-individual {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
        }

        .control-btn.download-individual:hover:not(:disabled) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.4);
        }

        .control-btn.download-zip {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }

        .control-btn.download-zip:hover:not(:disabled) {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
        }

        /* Management buttons styling */
        .control-btn.classify {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3);
        }

        .control-btn.classify:hover:not(:disabled) {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(245, 158, 11, 0.4);
        }

        .control-btn.clear {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
        }

        .control-btn.clear:hover:not(:disabled) {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.4);
        }

        .control-btn.auto-classify {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(139, 92, 246, 0.3);
        }

        .control-btn.auto-classify:hover:not(:disabled) {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(139, 92, 246, 0.4);
        }

        .management {
            display: flex;
            gap: var(--spacing-sm);
        }

        .upload-section {
            position: relative;
        }

        .control-btn.upload-btn {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(139, 92, 246, 0.3);
        }

        .control-btn.upload-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(139, 92, 246, 0.4);
        }

        /* Upload Progress Bar */
        .upload-progress {
            margin: var(--spacing-md) 0;
            padding: var(--spacing-md);
            background: #f8fafc;
            border-radius: var(--radius-md);
            border: 1px solid #e5e7eb;
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
        }

        .progress-text {
            font-weight: 500;
            color: var(--text-dark);
        }

        .progress-count {
            font-size: 0.9rem;
            color: var(--text-light);
            background: white;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
        }

        .progress-bar {
            height: 8px;
            background: #e5e7eb;
            border-radius: var(--radius-sm);
            overflow: hidden;
            margin-bottom: var(--spacing-sm);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6, #7c3aed);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: var(--radius-sm);
        }

        .progress-details {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            min-height: 300px;
            padding: 24px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .empty-gallery {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 24px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
            border-radius: 12px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
        }

        .empty-icon {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: var(--spacing-sm);
        }

        .empty-text {
            margin-bottom: var(--spacing-xs);
        }

        .empty-hint {
            font-size: 0.85rem;
            font-style: italic;
        }

        .gallery-item {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: grab;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            position: relative;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .gallery-item:hover {
            border-color: rgba(59, 130, 246, 0.5);
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.2), 0 4px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.95);
        }

        .gallery-item.dragging {
            opacity: 0.7;
            transform: rotate(5deg);
            cursor: grabbing;
        }

        .gallery-item-image-container {
            position: relative;
            overflow: hidden;
        }

        .gallery-item-image {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            transition: transform 0.3s ease;
            background-color: #f3f4f6;
            background-image: 
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%),
                linear-gradient(-45deg, #e5e7eb 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #e5e7eb 75%),
                linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        
        .gallery-item-image[src]:not([src=""]) {
            background: none;
        }
        
        /* Gallery Loading States */
        .gallery-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #6b7280;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e5e7eb;
            border-top: 4px solid var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        
        .loading-text {
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Image lazy loading placeholder */
        .gallery-item-image[data-src] {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading-shimmer 1.5s infinite;
        }
        
        @keyframes loading-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .gallery-item:hover .gallery-item-image {
            transform: scale(1.02);
        }

        .gallery-item-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 6px;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateY(-4px);
        }

        .gallery-item:hover .gallery-item-actions {
            opacity: 1;
            transform: translateY(0);
        }

        .gallery-action-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .gallery-action-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 1);
        }

        .gallery-action-btn.delete-btn:hover {
            background: #fee2e2;
            color: #dc2626;
        }

        .gallery-action-btn.rename-btn:hover {
            background: #fef3c7;
            color: #d97706;
        }

        .gallery-action-btn.download-btn:hover {
            background: #dcfce7;
            color: #16a34a;
        }

        .gallery-item-info {
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 250, 252, 0.9) 100%);
        }

        .gallery-item-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-dark);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
            letter-spacing: -0.02em;
        }

        .gallery-item-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 4px;
        }

        .gallery-item-size {
            font-size: 0.75rem;
            color: var(--text-light);
        }

        .gallery-item-type {
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 600;
            background: linear-gradient(135deg, #e0f2fe 0%, #bfdbfe 100%);
            color: #0369a1;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(3, 105, 161, 0.1);
        }

        /* Classification Mode */
        .classification-mode {
            margin-top: var(--spacing-xl);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: var(--spacing-md);
        }

        .source-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
            padding: 24px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .classification-areas {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 32px;
        }

        .classification-panel {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .panel-header {
            padding: 20px 24px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(59, 130, 246, 0.05) 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .panel-header h3 {
            margin: 0 0 var(--spacing-sm) 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .panel-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .panel-controls input {
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: var(--radius-sm);
            font-size: 0.85rem;
            width: 80px;
        }

        .rename-pattern {
            font-size: 0.8rem;
            color: var(--text-light);
            font-style: italic;
        }

        .drop-zone {
            min-height: 200px;
            padding: var(--spacing-md);
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: var(--spacing-sm);
            position: relative;
        }

        .drop-zone.empty {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .drop-zone.drag-over {
            background: #eff6ff;
            border-color: var(--primary-blue);
        }

        .drop-hint {
            color: var(--text-light);
            text-align: center;
            font-style: italic;
        }

        .classified-item {
            position: relative;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-md);
            overflow: hidden;
            background: white;
        }

        .classified-item-image {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
        }

        .classified-item-controls {
            position: absolute;
            top: 4px;
            right: 4px;
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
            max-width: 50px;
        }

        .item-control-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 0.7rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .item-control-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        .classified-item-name {
            padding: 4px;
            font-size: 0.7rem;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .classification-controls {
            display: flex;
            justify-content: center;
            gap: var(--spacing-md);
        }

        .download-options {
            margin-top: var(--spacing-xl);
            background: white;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid #e5e7eb;
            overflow: hidden;
        }

        .download-header {
            padding: var(--spacing-lg);
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-bottom: 1px solid #e5e7eb;
            text-align: center;
        }

        .download-header h3 {
            margin: 0 0 4px 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .download-header p {
            margin: 0;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .download-methods-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
        }

        .download-method-card {
            padding: var(--spacing-lg);
            border-right: 1px solid #e5e7eb;
        }

        .download-method-card:last-child {
            border-right: none;
        }

        .method-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid #f1f5f9;
        }

        .method-icon {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: var(--radius-md);
            background: #f8fafc;
        }

        .method-info h4 {
            margin: 0 0 2px 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .method-info p {
            margin: 0;
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .method-buttons {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .method-btn {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) var(--spacing-md);
            border: 1px solid #e5e7eb;
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .method-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-label {
            font-weight: 500;
            color: var(--text-dark);
        }

        .btn-count {
            font-size: 0.8rem;
            color: var(--text-light);
            background: #f1f5f9;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
        }

        /* Individual download buttons */
        .individual-btn:hover:not(:disabled) {
            border-color: #10b981;
            background: #f0fdf4;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
        }

        .individual-btn:hover:not(:disabled) .btn-count {
            background: #dcfce7;
            color: #166534;
        }

        .individual-btn.all {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .individual-btn.all .btn-label {
            color: #166534;
            font-weight: 600;
        }

        .individual-btn.all .btn-count {
            background: #dcfce7;
            color: #166534;
        }

        /* ZIP download buttons */
        .zip-btn:hover:not(:disabled) {
            border-color: #3b82f6;
            background: #f0f9ff;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
        }

        .zip-btn:hover:not(:disabled) .btn-count {
            background: #dbeafe;
            color: #1e40af;
        }

        .zip-btn.all {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .zip-btn.all .btn-label {
            color: #1e40af;
            font-weight: 600;
        }

        .zip-btn.all .btn-count {
            background: #dbeafe;
            color: #1e40af;
        }

        /* Legacy styles for backward compatibility */
        .download-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--spacing-md);
        }

        .download-option {
            padding: var(--spacing-md);
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .download-option:hover:not(:disabled) {
            border-color: var(--primary-blue);
            background: #f8fafc;
        }

        .download-option:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Responsive */
        /* Image Action Modal */
        .image-action-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid #e5e7eb;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }

        .modal-header h4 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-dark);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-light);
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            color: var(--text-dark);
        }

        .modal-body {
            padding: 25px;
        }

        .selected-image-preview {
            text-align: center;
            margin-bottom: var(--spacing-lg);
        }

        .selected-image-preview img {
            width: 120px;
            height: 120px;
            object-fit: cover;
            border-radius: var(--radius-md);
            border: 1px solid #e2e8f0;
        }

        .selected-image-preview div {
            margin-top: var(--spacing-sm);
            font-size: 0.9rem;
            color: var(--text-dark);
            font-weight: 500;
        }

        .action-buttons {
            display: flex;
            gap: var(--spacing-md);
            flex-direction: column;
        }

        .add-to-btn {
            padding: 12px 20px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
        }

        .add-to-btn.front-btn {
            background: var(--primary-blue);
            color: white;
        }

        .add-to-btn.front-btn:hover {
            background: var(--dark-blue);
        }

        .add-to-btn.back-btn {
            background: #10b981;
            color: white;
        }

        .add-to-btn.back-btn:hover {
            background: #047857;
        }

        .instruction-hint {
            font-size: 0.85rem;
            color: var(--text-light);
            font-weight: 400;
            font-style: italic;
        }

        .source-grid .gallery-item {
            cursor: pointer;
            position: relative;
        }

        .source-grid .gallery-item:hover {
            transform: scale(1.02);
        }

        .source-grid .gallery-item::after {
            content: '+';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(59, 130, 246, 0.9);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .source-grid .gallery-item:hover::after {
            opacity: 1;
        }

        /* Classification Hover Actions */
        .classification-hover-actions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 100;
            pointer-events: none;
        }

        .source-grid .gallery-item:hover .classification-hover-actions {
            opacity: 1;
            pointer-events: auto;
        }

        /* Force show hover actions when NOT in active selection */
        .print-container:not(.active-selection) .source-grid .gallery-item:hover .classification-hover-actions {
            opacity: 1 !important;
            pointer-events: auto !important;
            display: flex !important;
        }

        /* Hide hover actions only when actively selecting (selectionMode is true) */
        .print-container.active-selection .source-grid .gallery-item .classification-hover-actions {
            display: none !important;
        }

        .classification-action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 12px;
            border: none;
            border-radius: var(--radius-md);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8rem;
            font-weight: 500;
            min-width: 70px;
        }

        .classification-action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        .classification-action-btn.front-action {
            border: 2px solid #10b981;
            color: #047857;
        }

        .classification-action-btn.front-action:hover {
            background: #f0fdf4;
            border-color: #047857;
        }

        .classification-action-btn.back-action {
            border: 2px solid #3b82f6;
            color: #1e40af;
        }

        .classification-action-btn.back-action:hover {
            background: #eff6ff;
            border-color: #1e40af;
        }

        .classification-action-btn.rotation-action {
            border: 2px solid #f59e0b;
            color: #d97706;
            min-width: 60px;
        }

        .classification-action-btn.rotation-action:hover {
            background: #fef3c7;
            border-color: #d97706;
        }

        .classification-action-btn.duplicate-action {
            border: 2px solid #8b5cf6;
            color: #7c3aed;
            min-width: 70px;
        }

        .classification-action-btn.duplicate-action:hover {
            background: #f3e8ff;
            border-color: #7c3aed;
        }

        .action-icon {
            font-size: 1.2rem;
            line-height: 1;
        }

        .action-text {
            line-height: 1;
            white-space: nowrap;
        }

        /* Hide the old + indicator when we have buttons */
        .source-grid .gallery-item:hover::after {
            opacity: 0;
        }

        @media (max-width: 768px) {
            .size-options {
                grid-template-columns: 1fr;
            }

            .dimension-inputs {
                grid-template-columns: 1fr;
            }

            .download-options,
            .tool-options {
                flex-direction: column;
            }

            .download-btn,
            .tool-btn {
                width: 100%;
            }

            .gallery-controls {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
                text-align: center;
            }

            .download-section {
                flex-direction: column;
                gap: var(--spacing-sm);
                padding: var(--spacing-sm);
            }

            .control-btn {
                min-width: 80px;
                padding: var(--spacing-xs) var(--spacing-sm);
            }

            .btn-desc {
                font-size: 0.65rem;
            }

            .management {
                justify-content: center;
                flex-wrap: wrap;
            }

            .download-methods-grid {
                grid-template-columns: 1fr;
            }

            .download-method-card {
                border-right: none;
                border-bottom: 1px solid #e5e7eb;
            }

            .download-method-card:last-child {
                border-bottom: none;
            }

            .classification-areas {
                grid-template-columns: 1fr;
            }

            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }

            .action-buttons {
                flex-direction: column;
            }

            .modal-content {
                width: 95%;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 16px;
            }

            .function-tabs {
                margin-bottom: 16px;
                max-width: 100%;
                padding-bottom: var(--space-2);
                gap: var(--space-1);
            }

            .upload-zone {
                max-width: 100%;
                padding: 32px 16px;
            }

            .controls {
                max-width: 100%;
                padding: 16px;
            }

            .controls-row {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .controls-row:last-child {
                grid-template-columns: 1fr;
                justify-items: center;
            }

            .actions {
                max-width: 100%;
                padding: 16px;
            }

            .actions-container {
                grid-template-columns: 1fr;
            }

            .actions-group {
                justify-content: center;
                gap: 8px;
            }

            .action-btn {
                min-width: 120px;
                font-size: 0.85rem;
                height: 36px;
            }

            .stats {
                max-width: 100%;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
        }

        @media (max-width: 480px) {
            .main-content {
                padding: 12px;
            }

            .function-tabs {
                flex-direction: row;
                gap: var(--space-1);
                overflow-x: auto;
            }

            .tab-button {
                padding: var(--space-2) var(--space-3);
                flex-shrink: 0;
            }

            .tab-button::after {
                bottom: -8px;
            }

            .upload-zone {
                padding: 24px 12px;
            }

            .stats {
                grid-template-columns: 1fr 1fr;
            }

            .actions-container {
                grid-template-columns: 1fr;
                gap: var(--spacing-sm);
            }

            .actions-group {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
                margin-bottom: 12px;
            }

            .action-btn {
                min-width: auto;
                width: 100%;
                font-size: 0.85rem;
            }
        }

        /* Enhanced Gallery Responsive Design */
        @media (max-width: 1200px) {
            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
                gap: 18px;
                padding: 20px;
            }
            
            .classification-areas {
                gap: 20px;
            }
        }

        @media (max-width: 768px) {
            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 16px;
                padding: 16px;
                min-height: 250px;
            }
            
            .gallery-item-info {
                padding: 10px 12px;
            }
            
            .gallery-item-name {
                font-size: 0.8rem;
            }
            
            .gallery-action-btn {
                width: 28px;
                height: 28px;
                font-size: 0.8rem;
            }
            
            .classification-areas {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .source-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 12px;
                padding: 16px;
            }
        }

        @media (max-width: 480px) {
            .gallery-grid {
                grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
                gap: 12px;
                padding: 12px;
                min-height: 200px;
            }
            
            .gallery-item-info {
                padding: 8px 10px;
            }
            
            .gallery-item-name {
                font-size: 0.75rem;
                margin-bottom: 2px;
            }
            
            .gallery-item-size {
                font-size: 0.7rem;
            }
            
            .gallery-item-type {
                font-size: 0.65rem;
                padding: 2px 6px;
            }
            
            .gallery-action-btn {
                width: 24px;
                height: 24px;
                font-size: 0.75rem;
            }
            
            .gallery-item-actions {
                top: 6px;
                right: 6px;
                gap: 4px;
            }
            
            .source-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 10px;
                padding: 12px;
            }
            
            .panel-header {
                padding: 16px 16px;
            }
            
            .empty-gallery {
                padding: 40px 16px;
            }
        }

        /* Dark mode enhancements for gallery */
        @media (prefers-color-scheme: dark) {
            .gallery-grid {
                background: rgba(0, 0, 0, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .gallery-item {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid rgba(255, 255, 255, 0.15);
            }
            
            .gallery-item:hover {
                background: rgba(0, 0, 0, 0.4);
                border-color: rgba(59, 130, 246, 0.6);
            }
            
            .gallery-item-info {
                background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(31, 41, 55, 0.4) 100%);
            }
            
            .classification-panel {
                background: rgba(0, 0, 0, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.15);
            }
            
            .panel-header {
                background: linear-gradient(135deg, rgba(0, 0, 0, 0.2) 0%, rgba(59, 130, 246, 0.1) 100%);
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
        }

        .actions-group:last-child {
            margin-bottom: 0;
        }

        .action-btn {
            padding: 10px 16px;
            border: 2px solid #d1d5db;
            border-radius: var(--radius-md);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 140px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            flex: 0 0 auto;
            background: #f8fafc;
        }

        .action-btn.download {
            background: var(--primary-blue);
            color: var(--white);
        }

        .action-btn.download:hover {
            background: var(--dark-blue);
        }

        .action-btn.filesystem {
            background: #27ae60;
            color: var(--white);
        }

        .action-btn.filesystem:hover {
            background: #219a52;
        }

        .action-btn.tool {
            background: var(--primary-yellow);
            color: var(--text-dark);
        }

        .action-btn.tool:hover {
            background: #F59E0B;
        }

        .action-btn.utility {
            background: #6B7280;
            color: var(--white);
        }

        .action-btn.utility:hover {
            background: #4B5563;
            transform: translateY(-2px);
        }

        .action-btn.clear {
            background: #EF4444;
        }

        .action-btn.clear:hover {
            background: #DC2626;
        }

        .quick-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-lg);
            font-size: var(--text-sm);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-base);
            height: 40px;
            min-width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-sm);
        }

        .quick-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .stat-card {
            background: #f8fafc;
            padding: 16px 12px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            text-align: center;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary-blue);
            margin-bottom: 4px;
        }

        .stat-label {
            color: #64748b;
            font-size: 0.8rem;
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.error {
            background: #ef4444;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        /* Preview Modal Specific Styles */
        .preview-modal-content {
            background: var(--white);
            border-radius: 16px;
            width: 90%;
            max-width: 800px;
            max-height: 95vh;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary-yellow);
        }

        .preview-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 2px solid var(--primary-yellow);
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: var(--white);
        }

        .preview-modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-modal-body {
            padding: 25px;
            max-height: calc(95vh - 200px);
            overflow-y: auto;
        }

        .preview-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .preview-image-container {
            position: relative;
            max-width: 100%;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: 2px solid var(--light-yellow);
        }

        .preview-image {
            max-width: 100%;
            max-height: 60vh;
            width: auto;
            height: auto;
            display: block;
            border-radius: 10px;
        }

        .preview-image-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
            color: white;
            padding: 15px 20px 20px;
            font-size: 0.9rem;
        }

        .preview-details {
            background: var(--light-yellow);
            border: 2px solid var(--primary-yellow);
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 500px;
        }

        .preview-details h3 {
            margin: 0 0 15px 0;
            color: var(--text-dark);
            font-size: 1.2rem;
            text-align: center;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .detail-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .detail-label {
            font-weight: 600;
            color: var(--text-light);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .detail-value {
            font-weight: 700;
            color: var(--text-dark);
            font-size: 1rem;
        }

        .preview-modal-footer {
            padding: 20px 25px;
            border-top: 2px solid var(--primary-yellow);
            background: var(--light-yellow);
            display: flex;
            justify-content: space-between;
            gap: 15px;
        }

        .preview-btn {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .preview-btn.cancel {
            background: #6b7280;
            color: var(--white);
        }

        .preview-btn.cancel:hover {
            background: #4b5563;
            transform: translateY(-2px);
        }

        .preview-btn.download {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: var(--white);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .preview-btn.download:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .preview-modal-content {
                width: 95%;
                max-height: 90vh;
            }

            .preview-modal-header {
                padding: 15px 20px;
            }

            .preview-modal-header h2 {
                font-size: 1.2rem;
            }

            .preview-modal-body {
                padding: 20px;
                max-height: calc(90vh - 160px);
            }

            .preview-image {
                max-height: 50vh;
            }

            .detail-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .preview-modal-footer {
                padding: 15px 20px;
                flex-direction: column;
            }

            .preview-btn {
                padding: 12px 18px;
                font-size: 0.95rem;
            }
        }

        /* Loading Animation */
        .preview-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 40px;
            color: var(--text-light);
        }

        .preview-loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--light-yellow);
            border-top: 4px solid var(--primary-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Image Info Modal Styles */
        .image-info-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            backdrop-filter: blur(5px);
        }

        .image-info-content {
            background: var(--white);
            border-radius: 16px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
            border: 2px solid var(--primary-blue);
        }

        .image-info-header {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: var(--white);
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 3px solid var(--primary-yellow);
        }

        .image-info-header h2 {
            margin: 0;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .image-info-body {
            padding: 25px;
            max-height: calc(90vh - 150px);
            overflow-y: auto;
            background: #f9fafb;
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-section-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary-blue);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--light-yellow);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: #ffffff;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e5e7eb;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .info-item-label {
            font-size: 0.8rem;
            color: #6b7280;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: block;
        }

        .info-item-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1f2937;
            word-break: break-word;
        }

        .image-info-footer {
            padding: 20px 25px;
            border-top: 2px solid var(--light-yellow);
            background: var(--white);
            display: flex;
            justify-content: flex-end;
        }

        .info-close-btn {
            padding: 12px 30px;
            background: var(--primary-blue);
            color: var(--white);
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .info-close-btn:hover {
            background: var(--dark-blue);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(59, 130, 246, 0.3);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .close {
            font-size: 24px;
            cursor: pointer;
            background: none;
            border: none;
            color: white;
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        .close:hover {
            opacity: 1;
        }

        .pdf-config {
            display: grid;
            gap: 20px;
        }

        .config-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-section label {
            font-weight: 600;
            color: #374151;
            font-size: 0.95rem;
        }

        .config-section select,
        .config-section input[type="text"],
        .config-section input[type="number"],
        .config-section textarea {
            padding: 10px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .config-section select:focus,
        .config-section input:focus,
        .config-section textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .config-section textarea {
            resize: vertical;
            font-family: inherit;
        }

        .config-section input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .modal-footer {
            padding: 20px 25px;
            border-top: 2px solid #e5e7eb;
            background: linear-gradient(to bottom, #ffffff, #f9fafb);
            display: flex;
            gap: 12px;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .modal-btn {
            padding: 12px 24px;
            border: 2px solid transparent;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            font-family: 'Lexend', sans-serif;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        .modal-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .modal-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .modal-btn.cancel {
            background: #ef4444;
            color: white;
            border-color: #dc2626;
            margin-right: auto;
        }

        .modal-btn.cancel:hover {
            background: #dc2626;
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
        }

        .modal-btn.cancel:active {
            transform: translateY(0);
        }

        .modal-btn.secondary {
            background: #f3f4f6;
            color: #374151;
            border-color: #d1d5db;
        }

        .modal-btn.secondary:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .modal-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .modal-btn.primary:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 12px 24px rgba(102, 126, 234, 0.5);
        }

        .modal-btn.primary:active {
            transform: translateY(0) scale(1);
        }

        .modal-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .modal-btn:disabled:hover {
            transform: none !important;
            box-shadow: none !important;
        }

        /* Modal footer responsive */
        @media (max-width: 768px) {
            .modal-footer {
                flex-direction: column;
                gap: 10px;
                padding: 15px 20px;
            }

            .modal-footer > div {
                width: 100%;
                display: flex !important;
                flex-direction: column;
                gap: 10px !important;
            }

            .modal-btn {
                width: 100%;
                justify-content: center;
            }

            .modal-btn.cancel {
                margin-right: 0;
                order: 3;
            }
        }

        @media (max-width: 480px) {
            .modal-footer {
                padding: 12px 15px;
            }

            .modal-btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
        }

        /* Crop Editor Styles */
        .crop-editor-content {
            max-width: 90vw;
            max-height: 95vh;
        }

        .crop-editor-body {
            padding: 15px;
        }

        .template-selector {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .template-preview {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ratio-preview {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .ratio-box {
            width: 30px;
            height: 45px;
            border: 2px solid #667eea;
            border-radius: 3px;
            background: rgba(102, 126, 234, 0.1);
            transition: all 0.3s ease;
        }

        .ratio-text {
            font-size: 0.8rem;
            font-weight: 600;
            color: #667eea;
        }

        .size-info {
            font-size: 0.85rem;
            color: #6b7280;
            background: #f3f4f6;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .custom-size {
            margin-top: 15px;
        }

        .size-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .size-input {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .preview-info {
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .preview-info h3 {
            margin: 0 0 10px 0;
            color: #374151;
        }

        .info-grid {
            display: grid;
            gap: 8px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .crop-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .crop-info-panel {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            align-items: center;
        }

        .crop-target-info, .crop-current-info, .crop-ratio-info, .crop-tip-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .crop-tip-info span:last-child {
            font-size: 0.85rem;
            color: #059669;
            font-style: italic;
        }

        .info-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #4b5563;
        }

        #targetSizeInfo, #selectionSize, #cropRatioStatus {
            font-size: 0.9rem;
            font-weight: 500;
            color: #667eea;
        }

        .crop-canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f8fafc;
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            min-height: 400px;
            overflow: hidden;
        }

        .crop-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        .crop-selection {
            position: absolute;
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
            cursor: move;
            pointer-events: all;
            transition: box-shadow 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .crop-selection:hover {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            transform: scale(1.002);
        }

        .crop-selection.dragging {
            cursor: grabbing;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
            transform: scale(1.005);
        }

        .crop-selection.resizing {
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        /* REMOVED ALL RESIZE HANDLES - Only move handle allowed */
        .crop-handle {
            display: none !important; /* DISABLE ALL RESIZE HANDLES */
            pointer-events: none !important;
        }

        .crop-handle.corner,
        .crop-handle.edge,
        .crop-handle.top-left,
        .crop-handle.top-right,
        .crop-handle.bottom-left,
        .crop-handle.bottom-right,
        .crop-handle.top,
        .crop-handle.bottom,
        .crop-handle.left,
        .crop-handle.right {
            display: none !important; /* FORCE HIDE ALL RESIZE HANDLES */
            pointer-events: none !important;
        }

        .crop-move-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px; /* Larger for easier grabbing */
            height: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            cursor: grab;
            user-select: none;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            pointer-events: all;
            transition: all 0.3s ease;
        }

        .crop-move-handle:hover {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.15);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #5a67d8 0%, #6a4c93 100%);
        }

        .crop-move-handle:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.05);
        }

        .crop-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 5;
        }

        .crop-grid.visible {
            opacity: 0.4;
        }

        .crop-grid .grid-line {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 1px rgba(0,0,0,0.3);
        }

        .crop-grid .grid-line.vertical {
            width: 1px;
            height: 100%;
            top: 0;
        }

        .crop-grid .grid-line.vertical:nth-child(1) { left: 33.33%; }
        .crop-grid .grid-line.vertical:nth-child(2) { left: 66.66%; }

        .crop-grid .grid-line.horizontal {
            width: 100%;
            height: 1px;
            left: 0;
        }

        .crop-grid .grid-line.horizontal:nth-child(3) { top: 33.33%; }
        .crop-grid .grid-line.horizontal:nth-child(4) { top: 66.66%; }

        .crop-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            background: #f8fafc;
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .crop-zoom-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px 12px;
            background: var(--light-yellow);
            border: 2px solid var(--primary-yellow);
            border-radius: 25px;
        }

        .crop-zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--primary-blue);
            color: white;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .crop-zoom-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            background: var(--dark-blue);
        }

        .crop-zoom-btn:active {
            transform: translateY(0);
        }

        .crop-zoom-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.1);
        }

        .crop-zoom-info {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-dark);
            min-width: 60px;
            text-align: center;
        }

        .crop-btn {
            padding: 8px 16px;
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .crop-btn:hover {
            background: #4b5563;
            transform: translateY(-1px);
        }

        .crop-btn.toggle {
            background: #e5e7eb;
            color: #374151;
        }

        .crop-btn.toggle:hover {
            background: #d1d5db;
        }

        .crop-btn.toggle.active {
            background: #667eea;
            color: white;
        }

        .crop-preview-mini {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .crop-preview-mini canvas {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: #f9fafb;
        }

        .crop-preview-mini span {
            font-size: 0.8rem;
            color: #6b7280;
            font-weight: 500;
        }

        .crop-mode-selector {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 12px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .radio-option:hover {
            background: #e2e8f0;
            border-color: #cbd5e1;
        }

        .radio-option input[type="radio"] {
            margin: 0;
            cursor: pointer;
        }

        .radio-option input[type="radio"]:checked + span {
            color: #667eea;
            font-weight: 600;
        }

        .radio-option:has(input[type="radio"]:checked) {
            background: #eef2ff;
            border-color: #667eea;
        }

        .crop-info {
            background: #f3f4f6;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .crop-progress {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        /* Preview Gallery Styles */
        .crop-preview-content {
            max-width: 95vw;
            max-height: 95vh;
            width: 1200px;
        }

        .preview-gallery-body {
            padding: 20px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .preview-controls-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .template-info {
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            color: #4b5563;
        }

        .batch-controls {
            display: flex;
            gap: 10px;
        }

        .preview-btn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .preview-btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .preview-btn.secondary {
            background: #6b7280;
        }

        .preview-btn.secondary:hover {
            background: #4b5563;
        }

        .preview-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(17.5rem, 100%), 1fr));
            gap: clamp(1rem, 3vw, 1.5rem); /* 16px - 24px responsive */
            padding: clamp(1rem, 3vw, 1.5rem) 0;
        }

        .preview-item {
            background: white;
            border-radius: 12px;
            border: 2px solid #e2e8f0;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .preview-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .preview-item.selected {
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .preview-item-header {
            padding: 12px 15px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-item-name {
            font-weight: 600;
            color: #374151;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .preview-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .preview-image-container {
            position: relative;
            height: 200px;
            background: #f9fafb;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .preview-image {
            max-width: 100%;
            max-height: 100%;
            border-radius: 4px;
        }

        .preview-crop-overlay {
            position: absolute;
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
            pointer-events: none;
        }

        .preview-item-info {
            padding: 12px 15px;
            font-size: 0.85rem;
            color: #6b7280;
        }

        .preview-stats {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        /* Enhanced Preview Gallery Styles */
        .preview-item {
            background: var(--white);
            border: 2px solid var(--light-yellow);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .preview-item:hover {
            border-color: var(--primary-blue);
            box-shadow: 0 8px 16px rgba(59, 130, 246, 0.2);
            transform: translateY(-2px);
        }

        .preview-image-container {
            position: relative;
            width: 100%;
            height: 200px;
            overflow: hidden;
            background: var(--light-yellow);
        }

        .preview-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }

        .preview-item:hover .preview-image {
            transform: scale(1.05);
        }

        .preview-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
            color: var(--white);
            padding: 15px;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .preview-item:hover .preview-overlay {
            transform: translateY(0);
        }

        .preview-name {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .preview-size {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        .preview-controls {
            padding: 12px;
            display: flex;
            gap: 8px;
            background: #f8f9fa;
        }

        .preview-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-family: 'Lexend', sans-serif;
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preview-btn.edit {
            background: var(--primary-blue);
            color: var(--white);
        }

        .preview-btn.edit:hover {
            background: var(--dark-blue);
            transform: translateY(-1px);
        }

        .preview-btn.remove {
            background: #ef4444;
            color: var(--white);
        }

        .preview-btn.remove:hover {
            background: #dc2626;
            transform: translateY(-1px);
        }

        /* Multi-image crop editor for manual mode */
        .crop-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            max-height: 70vh;
            overflow-y: auto;
            padding: 20px;
        }

        .crop-image-card {
            background: var(--white);
            border: 2px solid var(--light-yellow);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .crop-image-card.selected {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
        }

        .crop-card-header {
            padding: 12px 16px;
            background: var(--light-yellow);
            border-bottom: 1px solid var(--primary-yellow);
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-dark);
        }

        .crop-card-canvas-container {
            position: relative;
            height: 250px;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .crop-card-canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 4px;
        }

        .crop-card-controls {
            padding: 12px 16px;
            display: flex;
            gap: 8px;
            background: #f8f9fa;
        }

        .crop-card-btn {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid var(--primary-blue);
            background: var(--white);
            color: var(--primary-blue);
            border-radius: 4px;
            font-family: 'Lexend', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .crop-card-btn:hover {
            background: var(--primary-blue);
            color: var(--white);
        }

        .crop-card-btn.primary {
            background: var(--primary-blue);
            color: var(--white);
        }

        .crop-card-btn.primary:hover {
            background: var(--dark-blue);
        }

        /* Multi-Crop Editor Styles */
        .multi-crop-editor-content {
            max-width: 95vw;
            max-height: 95vh;
            width: 95vw;
            height: 95vh;
        }

        .multi-crop-editor-body {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            height: calc(100% - 120px);
            overflow: hidden; /* NgƒÉn tr√†n n·ªôi dung */
            min-height: 0; /* Cho ph√©p flex shrink */
        }

        .global-crop-controls {
            background: var(--light-yellow);
            padding: 16px 20px;
            border-radius: 12px;
            border: 2px solid var(--primary-yellow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
            flex-shrink: 0; /* Kh√¥ng cho controls b·ªã thu nh·ªè */
            z-index: 10; /* Lu√¥n hi·ªÉn th·ªã tr√™n c√πng */
        }

        .global-info {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .target-size-display,
        .aspect-ratio-display {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .global-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .global-btn {
            padding: 8px 16px;
            border: 2px solid var(--primary-blue);
            background: var(--white);
            color: var(--primary-blue);
            border-radius: 8px;
            font-family: 'Lexend', sans-serif;
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .global-btn:hover {
            background: var(--primary-blue);
            color: var(--white);
            transform: translateY(-1px);
        }

        .global-btn.toggle.active {
            background: var(--primary-blue);
            color: var(--white);
        }

        .multi-crop-container {
            display: grid;
            /* T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh s·ªë c·ªôt d·ª±a tr√™n kh√¥ng gian c√≥ s·∫µn */
            grid-template-columns: repeat(auto-fill, minmax(min(23.75rem, 100%), 1fr));
            gap: clamp(2rem, 3vw, 3rem); /* TƒÉng gap: 32px - 48px ƒë·ªÉ kh√¥ng che t√™n */
            row-gap: clamp(2.5rem, 4vw, 4rem); /* Row gap l·ªõn h∆°n: 40px - 64px */
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: clamp(1rem, 2.5vw, 2rem); /* TƒÉng padding */
            max-width: 100%;
            max-height: 100%; /* Gi·ªõi h·∫°n chi·ªÅu cao ƒë·ªÉ c√≥ scroll */
            min-height: 0; /* Cho ph√©p shrink trong flexbox */
            container-type: inline-size;
            /* Grid alignment */
            align-content: start;
            justify-items: center;
        }

        .multi-crop-card {
            background: var(--white);
            border: 0.1875rem solid var(--light-yellow); /* 3px */
            border-radius: 0.75rem; /* 12px */
            overflow: visible; /* Cho ph√©p hi·ªÉn th·ªã ƒë·∫ßy ƒë·ªß */
            transition: all 0.3s ease;
            position: relative;
            /* Lo·∫°i b·ªè aspect-ratio ƒë·ªÉ tr√°nh b·ªã c·∫Øt n·ªôi dung */
            min-height: clamp(22rem, 28vh, 32rem); /* 352px - 512px responsive */
            height: auto; /* T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh chi·ªÅu cao */
            width: 100%;
            max-width: 28rem; /* Gi·ªõi h·∫°n chi·ªÅu r·ªông t·ªëi ƒëa 448px */
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem; /* Th√™m kho·∫£ng c√°ch d∆∞·ªõi card */
        }

        .multi-crop-card.selected {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
        }

        .multi-crop-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .multi-crop-header {
            padding: 12px 16px;
            background: var(--light-yellow);
            border-bottom: 2px solid var(--primary-yellow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Kh√¥ng cho header b·ªã thu nh·ªè */
            border-radius: 0.75rem 0.75rem 0 0; /* Bo tr√≤n g√≥c tr√™n */
        }

        .multi-crop-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-dark);
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .multi-crop-selector {
            position: relative;
        }

        .multi-crop-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary-blue);
            border-radius: 4px;
            background: var(--white);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .multi-crop-checkbox.checked {
            background: var(--primary-blue);
            color: var(--white);
        }

        .multi-crop-canvas-container {
            position: relative;
            flex: 0 1 auto; /* Kh√¥ng chi·∫øm h·∫øt kh√¥ng gian, shrink ƒë∆∞·ª£c */
            min-height: clamp(12rem, 20vh, 18rem); /* Gi·∫£m min-height: 192px - 288px */
            max-height: clamp(20rem, 30vh, 28rem); /* Gi·ªõi h·∫°n max-height */
            width: 100%;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Prevent overflow */
            border: 0.125rem solid #e0e0e0; /* 2px */
            margin: 0;
            aspect-ratio: 4/3; /* Gi·ªØ t·ª∑ l·ªá canvas */
        }

        .multi-crop-canvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            display: block;
            border: 2px solid #007bff;
            background: white;
            object-fit: contain;
        }

        .multi-crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .multi-crop-selection {
            position: absolute;
            border: 2px solid var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
            cursor: move;
            pointer-events: all;
            transition: box-shadow 0.2s ease;
        }

        .multi-crop-selection:hover {
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .multi-crop-selection.dragging {
            cursor: grabbing;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }

        /* DISABLED ALL MULTI-CROP RESIZE HANDLES */
        .multi-crop-handle {
            display: none !important; /* COMPLETELY HIDE ALL RESIZE HANDLES */
            pointer-events: none !important;
        }

        .multi-crop-handle.corner,
        .multi-crop-handle.corner.nw,
        .multi-crop-handle.corner.ne,
        .multi-crop-handle.corner.sw,
        .multi-crop-handle.corner.se {
            display: none !important; /* FORCE HIDE CORNER HANDLES */
            pointer-events: none !important;
        }

        .multi-crop-move-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: rgba(59, 130, 246, 0.9);
            color: var(--white);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .multi-crop-move-handle:hover {
            background: var(--primary-blue);
            transform: translate(-50%, -50%) scale(1.1);
        }

        .multi-crop-move-handle:active {
            cursor: grabbing;
        }

        .multi-crop-controls {
            padding: 12px 16px;
            background: #f8f9fa;
            display: flex;
            gap: 8px;
            flex-shrink: 0; /* Kh√¥ng cho controls b·ªã thu nh·ªè */
            border-top: 1px solid #e0e0e0;
        }

        .multi-crop-btn {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid var(--primary-blue);
            background: var(--white);
            color: var(--primary-blue);
            border-radius: 6px;
            font-family: 'Lexend', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .multi-crop-btn:hover {
            background: var(--primary-blue);
            color: var(--white);
        }

        .multi-crop-info {
            padding: 10px 16px;
            background: linear-gradient(135deg, #fff9e6 0%, #fff4d6 100%);
            border-top: 1px solid #f0e68c;
            font-size: 0.75rem;
            color: var(--text-dark);
            text-align: left;
            line-height: 1.5;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Kh√¥ng cho info b·ªã thu nh·ªè */
            position: relative; /* ƒê·∫£m b·∫£o lu√¥n hi·ªÉn th·ªã */
            z-index: 1; /* Lu√¥n ·ªü tr√™n */
            border-radius: 0 0 0.75rem 0.75rem; /* Bo tr√≤n g√≥c d∆∞·ªõi */
        }

        .multi-crop-info strong {
            color: var(--primary-blue);
            font-weight: 600;
        }

        /* C·∫£i thi·ªán hi·ªÉn th·ªã khi c√≥ √≠t ·∫£nh (1-3 ·∫£nh) */
        /* S·ª≠ d·ª•ng CSS :has() ƒë·ªÉ ph√°t hi·ªán s·ªë l∆∞·ª£ng card */
        .multi-crop-container:has(.multi-crop-card:nth-child(1):last-child) {
            /* Ch·ªâ c√≥ 1 ·∫£nh - grid 1 c·ªôt center */
            grid-template-columns: minmax(min(23.75rem, 100%), min(28rem, 90vw));
            justify-content: center;
        }

        .multi-crop-container:has(.multi-crop-card:nth-child(2):last-child) {
            /* C√≥ 2 ·∫£nh - grid 2 c·ªôt v·ªõi max-width */
            grid-template-columns: repeat(2, minmax(min(20rem, 100%), min(26rem, 1fr)));
        }

        .multi-crop-container:has(.multi-crop-card:nth-child(3):last-child) {
            /* C√≥ 3 ·∫£nh - grid 3 c·ªôt v·ªõi max-width */
            grid-template-columns: repeat(3, minmax(min(18rem, 100%), min(24rem, 1fr)));
        }

        /* V·ªõi 4+ ·∫£nh, s·ª≠ d·ª•ng grid m·∫∑c ƒë·ªãnh (auto-fill) */

        /* Modern Responsive Design - Zoom-Independent Layout
           
           Key Features:
           - Uses rem units instead of px for zoom independence
           - clamp() functions for fluid responsive sizing  
           - min() function in minmax() for overflow protection
           - Container queries where supported
           - Consistent aspect ratios across all zoom levels
           
           Grid Systems:
           - file-list: Auto-fit grid with 12rem minimum cards
           - multi-crop-container: Auto-fit grid with 23.75rem minimum cards
           - template-grid: Auto-fit grid with 7.5rem minimum cards
           - stats: Auto-fit grid with 9.375rem minimum cards
           
           Responsive Breakpoints:
           - 75rem (1200px): Large desktop
           - 60rem (960px): Medium desktop  
           - 48rem (768px): Tablet
           - 30rem (480px): Mobile
        */
        
        /* Container Queries for Multi-Crop Component */
        @container (max-width: 60rem) {
            .multi-crop-container {
                grid-template-columns: repeat(auto-fill, minmax(min(18rem, 100%), 1fr));
                gap: clamp(1.5rem, 2.5vw, 2rem); /* Gi·ªØ gap l·ªõn */
                row-gap: clamp(2rem, 3vw, 2.5rem);
            }

            .multi-crop-card {
                min-height: clamp(20rem, 26vh, 30rem);
                margin-bottom: 0.75rem;
            }

            /* Override cho √≠t ·∫£nh */
            .multi-crop-container:has(.multi-crop-card:nth-child(2):last-child) {
                grid-template-columns: repeat(2, minmax(min(18rem, 100%), 1fr));
            }

            .multi-crop-container:has(.multi-crop-card:nth-child(3):last-child) {
                grid-template-columns: repeat(auto-fill, minmax(min(16rem, 100%), 1fr));
            }
        }

        @container (max-width: 40rem) {
            .multi-crop-container {
                grid-template-columns: 1fr !important; /* Force 1 c·ªôt tr√™n m√†n h√¨nh nh·ªè */
                gap: clamp(1.5rem, 2.5vw, 2rem);
                row-gap: clamp(2rem, 3vw, 2.5rem);
            }

            .multi-crop-card {
                max-width: 100%;
                min-height: auto; /* T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh */
                margin-bottom: 0.5rem;
            }

            .multi-crop-canvas-container {
                min-height: clamp(10rem, 18vh, 15rem);
                max-height: clamp(15rem, 25vh, 20rem);
            }
        }

        /* Viewport-based responsive breakpoints using rem units */
        @media (max-width: 75rem) {
            .file-list {
                grid-template-columns: repeat(auto-fit, minmax(min(10rem, 100%), 1fr));
            }
        }

        @media (max-width: 60rem) {
            .file-list {
                grid-template-columns: repeat(auto-fit, minmax(min(8rem, 100%), 1fr));
            }
            
            .multi-crop-container {
                padding: clamp(0.5rem, 1.5vw, 1rem);
            }
            
            .template-grid {
                grid-template-columns: repeat(auto-fit, minmax(min(6rem, 100%), 1fr));
            }
        }

        @media (max-width: 48rem) {
            .file-list {
                grid-template-columns: repeat(auto-fit, minmax(min(7rem, 100%), 1fr));
                gap: clamp(0.5rem, 1.5vw, 1rem);
            }
            
            .stats {
                grid-template-columns: repeat(auto-fit, minmax(min(8rem, 100%), 1fr));
            }
        }

        @media (max-width: 30rem) {
            .file-list {
                grid-template-columns: repeat(auto-fit, minmax(min(6rem, 100%), 1fr));
            }

            .multi-crop-container {
                grid-template-columns: 1fr !important; /* Force 1 c·ªôt */
                gap: clamp(0.75rem, 2vw, 1.25rem);
            }

            .multi-crop-card {
                max-width: 100%;
                min-height: clamp(16rem, 22vh, 26rem);
            }

            .stats {
                grid-template-columns: 1fr;
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .controls-row {
                flex-direction: column;
                gap: 15px;
            }

            .control-group {
                justify-content: space-between;
                margin-bottom: 10px;
            }

            .control-group label {
                min-width: 60px;
            }

            .control-group select,
            .control-group input[type="text"] {
                min-width: 200px;
            }

            .actions-group {
                justify-content: center;
            }

            .action-btn {
                min-width: 100px;
                font-size: 0.9rem;
            }

            .file-actions {
                grid-column: 1 / -1;
                display: flex;
                gap: 8px;
                justify-content: center;
                margin-top: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: clamp(0.75rem, 2vw, 1.25rem);
            }

            .multi-crop-container {
                grid-template-columns: 1fr !important; /* Force 1 c·ªôt */
                padding: clamp(1rem, 2vw, 1.5rem);
                gap: clamp(1.5rem, 2.5vw, 2rem);
                row-gap: clamp(2rem, 3vw, 2.5rem);
            }

            .multi-crop-card {
                max-width: 100%;
                min-height: auto; /* T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh */
                margin-bottom: 0.5rem;
            }

            .multi-crop-canvas-container {
                min-height: clamp(10rem, 18vh, 15rem);
                max-height: clamp(16rem, 28vh, 22rem);
            }

            .multi-crop-info {
                font-size: 0.7rem;
                min-height: 45px;
                padding: 8px 12px;
            }

            .global-crop-controls {
                padding: 12px 16px;
                gap: 12px;
            }

            .global-info {
                flex-direction: column;
                gap: 12px;
                width: 100%;
            }

            .global-actions {
                width: 100%;
                justify-content: stretch;
            }

            .global-btn {
                flex: 1;
                min-width: 0;
                font-size: 0.8rem;
                padding: 6px 12px;
            }
        }


        /* Template Crop Editor Styles */
        .template-crop-content {
            width: 90vw;
            height: 85vh;
            max-width: 1200px;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10001;
            pointer-events: auto;
        }
        
        .template-crop-content * {
            pointer-events: auto;
        }
        
        .template-crop-content button {
            pointer-events: auto !important;
            cursor: pointer !important;
        }
        
        .template-crop-body {
            padding: 15px;
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
            min-height: 500px;
        }
        
        .template-crop-main {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0;
        }
        
        .template-image-container {
            flex: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            border-radius: 8px;
            position: relative;
            overflow: visible;
            min-height: 500px;
            min-width: 600px;
            padding: 20px;
        }
        
        .template-crop-container {
            position: relative;
            max-width: 100%;
            max-height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .template-crop-canvas {
            display: block;
            min-width: 400px;
            min-height: 300px;
            max-width: 80vw;
            max-height: 60vh;
            width: auto;
            height: auto;
            border: 2px solid #007bff;
            background: white;
            margin: auto;
            border-radius: 4px;
        }
        
        .template-crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .template-crop-selection {
            position: absolute;
            border: 3px solid var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
            cursor: move;
            pointer-events: all;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .template-crop-selection:hover {
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }

        .template-crop-selection.dragging {
            cursor: grabbing;
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.5);
        }

        /* Crop handles for resize */
        .crop-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--primary-blue);
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            cursor: pointer;
        }

        .crop-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .crop-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .crop-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
        .crop-handle.n { top: -5px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .crop-handle.s { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .crop-handle.w { top: 50%; left: -5px; transform: translateY(-50%); cursor: w-resize; }
        .crop-handle.e { top: 50%; right: -5px; transform: translateY(-50%); cursor: e-resize; }

        .crop-handle:hover {
            background: #0056b3;
            box-shadow: 0 3px 6px rgba(0,0,0,0.4);
        }

        /* Crop overlay areas (darken non-selected areas) */
        .crop-overlay {
            position: absolute;
            background: rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }

        .crop-overlay.top {
            top: 0;
            left: 0;
            right: 0;
            height: 0; /* Will be set dynamically */
        }

        .crop-overlay.bottom {
            bottom: 0;
            left: 0;
            right: 0;
            height: 0; /* Will be set dynamically */  
        }

        .crop-overlay.left {
            top: 0;
            bottom: 0;
            left: 0;
            width: 0; /* Will be set dynamically */
        }

        .crop-overlay.right {
            top: 0;
            bottom: 0;
            right: 0;
            width: 0; /* Will be set dynamically */
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);
        }
        
        .template-move-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(59, 130, 246, 0.95);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            cursor: move;
            user-select: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            border: 2px solid white;
        }
        
        .template-move-handle:hover {
            background: rgba(59, 130, 246, 1);
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
        }
        
        .template-selection-info {
            position: absolute;
            top: -30px;
            left: 0;
            background: var(--primary-blue);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
        }
        
        .template-controls {
            width: 320px;
            padding: 20px;
            background: white;
            border-left: 1px solid #e0e0e0;
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .template-control-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .template-control-section:last-child {
            border-bottom: none;
        }
        
        .template-control-section h4 {
            margin: 0 0 15px 0;
            color: var(--text-dark);
            font-size: 1rem;
            font-weight: bold;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-btn:hover {
            background: var(--dark-blue);
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        #templateZoomSlider {
            flex: 1;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            outline: none;
            cursor: pointer;
            margin: 0 8px;
        }
        
        #templateZoomSlider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary-blue);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }
        
        #templateZoomSlider::-webkit-slider-thumb:hover {
            background: var(--dark-blue);
            transform: scale(1.1);
        }
        
        #templateZoomValue {
            font-size: 1rem;
            font-weight: bold;
            color: var(--primary-blue);
            min-width: 50px;
            text-align: center;
        }
        
        .position-controls, .display-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .position-btn, .toggle-btn {
            padding: 8px 12px;
            background: var(--light-yellow);
            border: 1px solid var(--primary-yellow);
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .position-btn:hover, .toggle-btn:hover {
            background: var(--primary-yellow);
            transform: translateY(-1px);
        }
        
        .toggle-btn.active {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
        }
        
        .template-info-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        /* Multi-crop controls CSS */
        .multi-crop-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .multi-crop-btn {
            padding: 4px 8px;
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .multi-crop-btn:hover {
            background: var(--dark-blue);
            transform: translateY(-1px);
        }
        
        /* Multi-crop zoom CSS removed - no longer needed */
        
        /* Template crop resize handles */
        .template-resize-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: var(--primary-blue);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            opacity: 1;
            transition: all 0.2s ease;
            z-index: 1001;
            cursor: pointer;
        }
        
        .template-resize-handle:hover {
            background: var(--dark-blue);
            transform: scale(1.3);
            opacity: 1;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .template-resize-handle.nw {
            top: -8px;
            left: -8px;
            cursor: nw-resize;
        }
        
        .template-resize-handle.ne {
            top: -8px;
            right: -8px;
            cursor: ne-resize;
        }
        
        .template-resize-handle.sw {
            bottom: -8px;
            left: -8px;
            cursor: sw-resize;
        }
        
        .template-resize-handle.se {
            bottom: -8px;
            right: -8px;
            cursor: se-resize;
        }
        
        .resize-info {
            padding: 10px;
            background: #f0f8ff;
        }

        /* Template Polaroid Styles */
        .template-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Border Template Styles */
        .border-template-preview-container {
            flex-shrink: 0;
        }

        .border-template-frame {
            width: 200px;
            height: 300px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .border-template-image-area {
            width: 100%;
            height: 100%;
            background: #f3f4f6;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        /* Enhanced Template Crop Page Styles - cropPage adapted for Polaroid templates */
        .template-crop-page-content {
            width: 95vw;
            height: 90vh;
            max-width: 1400px;
            max-height: 900px;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 10001;
            pointer-events: auto;
        }

        .template-crop-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 12px 12px 0 0;
        }

        .template-header-left h2 {
            margin: 0 0 5px 0;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .template-progress-info {
            display: flex;
            gap: 15px;
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .template-size-info {
            background: rgba(255,255,255,0.2);
            padding: 3px 8px;
            border-radius: 12px;
            font-weight: 500;
        }

        .template-crop-page-body {
            flex: 1;
            display: flex;
            min-height: 0;
            background: #f8f9fa;
        }

        .template-crop-sidebar {
            width: 320px;
            background: white;
            border-right: 1px solid #e9ecef;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .template-section {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }

        .template-section h3 {
            margin: 0 0 15px 0;
            font-size: 1.1rem;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .template-section h4 {
            margin: 0 0 10px 0;
            font-size: 1rem;
            color: #6c757d;
        }

        /* Template Type Selection */
        .template-type-selection {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .template-type-label {
            display: block;
            font-size: 0.9rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 12px;
        }

        .template-type-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .template-type-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .template-type-card:hover {
            border-color: #3b82f6;
            background: #eff6ff;
            transform: translateY(-1px);
        }

        .template-type-card.active {
            border-color: #3b82f6;
            background: #eff6ff;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }

        .template-type-card input[type="radio"] {
            display: none;
        }

        .template-type-card .type-icon {
            font-size: 1.5rem;
        }

        .template-type-card .type-info {
            flex: 1;
        }

        .template-type-card .type-name {
            font-size: 0.95rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 2px;
        }

        .template-type-card .type-desc {
            font-size: 0.75rem;
            color: #6c757d;
        }

        /* Art Template Selection */
        .polaroid2-only-section {
            transition: all 0.3s ease;
        }

        .art-template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
        }

        .art-template-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .art-template-card:hover {
            border-color: #3b82f6;
            background: #eff6ff;
            transform: translateY(-2px);
        }

        .art-template-card.active {
            border-color: #3b82f6;
            background: #eff6ff;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .art-template-card input[type="radio"] {
            display: none;
        }

        .art-template-card .art-preview {
            width: 80px;
            height: 100px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 4px;
            background: #f8f9fa;
        }

        .art-template-card .art-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        .art-template-card .art-preview-placeholder {
            font-size: 2rem;
        }

        .art-template-card .art-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: #495057;
            text-align: center;
        }

        .template-size-details {
            margin-bottom: 20px;
        }

        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .detail-label {
            color: #6c757d;
            font-weight: 500;
        }

        .detail-value {
            color: #495057;
            font-weight: 600;
        }

        .detail-value.highlight {
            color: #007bff;
            font-weight: 700;
        }

        .template-border-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
        }

        .border-details {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .border-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
        }

        .border-label {
            color: #6c757d;
        }

        .border-value {
            color: #495057;
            font-weight: 600;
        }

        .template-settings-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-item label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .modern-select {
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
            color: #495057;
            transition: border-color 0.2s ease;
        }

        .modern-select:focus {
            border-color: #007bff;
            outline: none;
        }

        .setting-help {
            font-size: 0.8rem;
            color: #6c757d;
            font-style: italic;
        }

        .template-position-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .control-btn {
            flex: 1;
            padding: 8px 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .control-btn:hover {
            background: #0056b3;
        }

        .template-display-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .toggle-btn {
            padding: 6px 10px;
            background: #f8f9fa;
            color: #6c757d;
            border: 2px solid #e9ecef;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .toggle-btn:hover,
        .toggle-btn.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .template-process-modes {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mode-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }

        .mode-card:hover {
            border-color: #007bff;
        }

        .mode-card.active {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .mode-card input[type="radio"] {
            display: none;
        }

        .mode-icon {
            font-size: 1.2rem;
            width: 30px;
            text-align: center;
        }

        .mode-info {
            flex: 1;
        }

        .mode-name {
            font-weight: 600;
            color: #495057;
            margin-bottom: 2px;
        }

        .mode-desc {
            font-size: 0.8rem;
            color: #6c757d;
        }

        .template-crop-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .template-crop-workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
        }

        .template-workspace-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 12px 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .current-image-info h4 {
            margin: 0 0 4px 0;
            color: #495057;
            font-size: 1.1rem;
        }

        .image-dimensions {
            font-size: 0.9rem;
            color: #6c757d;
        }

        .workspace-controls {
            display: flex;
            gap: 8px;
        }

        .workspace-btn {
            padding: 6px 12px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .workspace-btn:hover {
            background: #495057;
        }

        .template-image-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            position: relative;
            overflow: visible;
            min-height: 400px;
            padding: 20px;
        }

        .template-workspace-footer {
            margin-top: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            padding: 15px;
        }

        .crop-preview-mini h5 {
            margin: 0 0 10px 0;
            font-size: 0.95rem;
            color: #495057;
        }

        .mini-preview-container {
            display: flex;
            justify-content: center;
        }

        .template-mini-preview {
            max-width: 200px;
            max-height: 150px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
        }

        .template-crop-footer {
            background: white;
            border-top: 1px solid #e9ecef;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .template-nav-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .nav-btn {
            padding: 8px 15px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .nav-btn:hover:not(:disabled) {
            background: #495057;
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-status {
            font-weight: 600;
            color: #495057;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .template-action-controls {
            display: flex;
            gap: 10px;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn.cancel {
            background: #dc3545;
            color: white;
        }

        .modal-btn.cancel:hover {
            background: #c82333;
        }

        .modal-btn.secondary {
            background: #6c757d;
            color: white;
        }

        .modal-btn.secondary:hover {
            background: #545b62;
        }

        .modal-btn.primary {
            background: #007bff;
            color: white;
        }

        .modal-btn.primary:hover {
            background: #0056b3;
        }

        .selection-status {
            margin-left: 10px;
            font-size: 0.8rem;
            padding: 2px 6px;
            border-radius: 10px;
            background: #d4edda;
            color: #155724;
        }
        
        /* Polaroid Template Compact Layout Styles */
        .polaroid-compact-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .polaroid-top-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 16px 20px;
            color: white;
        }

        .polaroid-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-info h3 {
            margin: 0 0 4px 0;
            font-size: 1.3rem;
        }

        .template-quick-specs {
            font-size: 0.9rem;
            opacity: 0.9;
            font-family: monospace;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .compact-btn {
            padding: 8px 16px;
            border: 2px solid transparent;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        /* Quick Size Selection Grid */
        .quick-sizes-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .size-preset-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 8px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 60px;
            position: relative;
        }

        .size-preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .size-preset-btn .size-name {
            font-weight: 700;
            font-size: 0.9rem;
            color: #374151;
            margin-bottom: 2px;
        }

        .size-preset-btn .size-desc {
            font-size: 0.7rem;
            color: #6b7280;
            font-weight: 500;
        }

        .size-preset-btn.active {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-1px);
        }

        /* M√†u s·∫Øc ph√¢n bi·ªát cho t·ª´ng k√≠ch th∆∞·ªõc Polaroid */
        .size-preset-btn[data-width="5.5"][data-height="8.5"] {
            border-left: 5px solid #ef4444;
            background: linear-gradient(to right, #fef2f2, #ffffff);
        }

        .size-preset-btn[data-width="4"][data-height="6"] {
            border-left: 5px solid #10b981;
            background: linear-gradient(to right, #f0fdf4, #ffffff);
        }

        .size-preset-btn[data-width="5"][data-height="7"] {
            border-left: 5px solid #3b82f6;
            background: linear-gradient(to right, #eff6ff, #ffffff);
        }

        .size-preset-btn[data-width="6"][data-height="9"] {
            border-left: 5px solid #8b5cf6;
            background: linear-gradient(to right, #f5f3ff, #ffffff);
        }

        .size-preset-btn[data-width="8"][data-height="10"] {
            border-left: 5px solid #ec4899;
            background: linear-gradient(to right, #fdf2f8, #ffffff);
        }

        .size-preset-btn[data-width="8.5"][data-height="11"] {
            border-left: 5px solid #f59e0b;
            background: linear-gradient(to right, #fffbeb, #ffffff);
        }

        /* M√†u s·∫Øc khi hover */
        .size-preset-btn[data-width="5.5"][data-height="8.5"]:hover,
        .size-preset-btn[data-width="5.5"][data-height="8.5"].active {
            border-color: #ef4444;
            background: linear-gradient(to right, #fee2e2, #fef2f2);
        }

        .size-preset-btn[data-width="4"][data-height="6"]:hover,
        .size-preset-btn[data-width="4"][data-height="6"].active {
            border-color: #10b981;
            background: linear-gradient(to right, #d1fae5, #f0fdf4);
        }

        .size-preset-btn[data-width="5"][data-height="7"]:hover,
        .size-preset-btn[data-width="5"][data-height="7"].active {
            border-color: #3b82f6;
            background: linear-gradient(to right, #dbeafe, #eff6ff);
        }

        .size-preset-btn[data-width="6"][data-height="9"]:hover,
        .size-preset-btn[data-width="6"][data-height="9"].active {
            border-color: #8b5cf6;
            background: linear-gradient(to right, #ede9fe, #f5f3ff);
        }

        .size-preset-btn[data-width="8"][data-height="10"]:hover,
        .size-preset-btn[data-width="8"][data-height="10"].active {
            border-color: #ec4899;
            background: linear-gradient(to right, #fce7f3, #fdf2f8);
        }

        .size-preset-btn[data-width="8.5"][data-height="11"]:hover,
        .size-preset-btn[data-width="8.5"][data-height="11"].active {
            border-color: #f59e0b;
            background: linear-gradient(to right, #fef3c7, #fffbeb);
        }

        /* Responsive grid */
        @media (max-width: 768px) {
            .quick-sizes-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }
        }

        .compact-btn.secondary {
            background: #f1f5f9;
            color: #374151;
            border-color: #d1d5db;
        }

        .compact-btn.secondary:hover {
            background: #e2e8f0;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .compact-btn.primary {
            background: #28a745;
            color: white;
        }

        .compact-btn.primary:hover {
            background: #218838;
        }

        .compact-btn.primary:active,
        .compact-btn.primary.active {
            background: #1e7e34 !important;
            transform: translateY(1px);
        }

        .compact-btn.secondary:active,
        .compact-btn.secondary.active {
            background: #d1d5db !important;
            border-color: #6b7280 !important;
            transform: translateY(1px);
        }

        .polaroid-main-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            min-height: 500px;
            align-items: start;
        }

        .polaroid-preview-section {
            background: white;
            border-radius: 16px;
            padding: 24px;
            border: 2px solid #e9ecef;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .polaroid-preview-section:hover {
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid #f1f5f9;
        }

        .preview-title {
            font-weight: 700;
            color: #1f2937;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .preview-title::before {
            content: 'üñºÔ∏è';
            font-size: 1.3rem;
        }

        .preview-controls {
            display: flex;
            gap: 4px;
        }

        .mini-btn {
            width: 36px;
            height: 36px;
            border: 2px solid #e5e7eb;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .mini-btn:hover {
            background: #f8fafc;
            border-color: #3b82f6;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }

        .mini-btn:active,
        .mini-btn.active {
            background: #3b82f6 !important;
            border-color: #3b82f6 !important;
            color: white !important;
            transform: translateY(0px);
        }

        .polaroid-preview-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            min-height: 300px;
            overflow: visible;
        }

        .polaroid-frame {
            position: relative;
            background: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            max-width: 100%;
        }

        /* Polaroid 2 overlay mode - hide decorative frame */
        .polaroid-frame.template-overlay-mode {
            background: transparent;
            box-shadow: none;
            border: none;
            border-radius: 0;
            padding: 0;
        }

        .polaroid-image-area {
            position: relative;
            width: 100%;
            max-width: 280px; /* Larger max width for better preview */
            height: auto;
            background: #f5f5f5;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible; /* Show full template */
            margin: 0 auto; /* Center preview */
        }

        .polaroid-image-area img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .template-frame-preview {
            position: relative;
            width: 100%;
            height: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .template-frame-preview img {
            width: 100%;
            height: auto;
            object-fit: contain;
            display: block;
        }

        .image-preview-result {
            width: 100%;
            height: auto;
            object-fit: contain;
            display: block;
        }

        .placeholder-text {
            color: #9ca3af;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .polaroid-caption-area {
            padding: 8px;
            text-align: center;
            background: white;
            border-bottom-left-radius: 4px;
            border-bottom-right-radius: 4px;
        }

        /* Hide caption area in overlay mode */
        .polaroid-frame.template-overlay-mode .polaroid-caption-area {
            display: none;
        }

        /* Remove size constraints for overlay mode */
        .polaroid-frame.template-overlay-mode .polaroid-image-area {
            max-width: none;
            width: auto;
            height: auto;
            background: transparent;
            display: block;
            overflow: visible;
        }

        /* Ensure template images display at full size with proper scaling */
        .polaroid-frame.template-overlay-mode .template-frame-preview,
        .polaroid-frame.template-overlay-mode .image-preview-result {
            width: auto;
            max-width: 100%;
            height: auto;
        }

        .polaroid-frame.template-overlay-mode .template-frame-preview img,
        .polaroid-frame.template-overlay-mode .image-preview-result {
            width: auto;
            height: auto;
            max-height: 450px;
            /* Size scales based on aspect ratio */
        }

        .caption-placeholder {
            color: #9ca3af;
            font-size: 0.75rem;
            font-style: italic;
        }

        .compact-upload-zone {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .compact-upload-zone:hover {
            border-color: #007bff;
            background: #f0f9ff;
        }

        .upload-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: #6c757d;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .upload-icon {
            font-size: 1.2rem;
        }

        .polaroid-controls-section {
            background: white;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }

        /* Enhanced Settings Tabs Design */
        .settings-tabs {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .tab-header {
            display: flex;
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 16px;
        }

        .tab-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: #6b7280;
            transition: all 0.2s ease;
            border-radius: 6px;
            white-space: nowrap;
            text-align: center;
        }

        .tab-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .tab-btn.active {
            background: white;
            color: #1f2937;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            font-weight: 600;
        }

        .tab-content {
            flex: 1;
            padding: 16px;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Specific CSS for polaroid settings tabs to override conflicts */
        .polaroid-controls-section .settings-tabs .tab-content {
            flex: 1;
            padding: 16px;
            display: none !important;
            position: relative;
        }

        .polaroid-controls-section .settings-tabs .tab-content.active {
            display: block !important;
        }

        /* Absolutely ensure non-active tabs are hidden */
        .polaroid-controls-section .settings-tabs .tab-content:not(.active) {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            height: 0 !important;
            overflow: hidden !important;
        }

        .compact-settings {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Enhanced Settings Section Styling */
        .settings-section {
            margin-bottom: 24px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }

        .section-title {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 12px 16px;
            font-weight: 600;
            font-size: 0.9rem;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
        }

        .settings-section .setting-row {
            padding: 12px 16px;
            border-bottom: 1px solid #f3f4f6;
        }

        .settings-section .setting-row:last-child {
            border-bottom: none;
        }

        .multiplier {
            margin: 0 8px;
            color: #6b7280;
            font-weight: 500;
        }

        .caption-controls {
            padding: 0 16px 12px 16px;
        }

        .caption-controls .setting-row {
            padding: 8px 0;
            border-bottom: 1px solid #f3f4f6;
        }

        /* Export Actions */
        .export-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 0 16px 16px 16px;
        }

        .action-btn {
            padding: 10px 16px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
            text-align: center;
        }

        .action-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .action-btn.primary {
            background: #059669;
            color: white;
            border-color: #059669;
        }

        .action-btn.primary:hover {
            background: #047857;
        }

        .action-btn.secondary {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .action-btn.secondary:hover {
            background: #2563eb;
        }

        .action-btn.tertiary {
            background: #6b7280;
            color: white;
            border-color: #6b7280;
        }

        .action-btn.tertiary:hover {
            background: #4b5563;
        }

        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .setting-row label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #495057;
            min-width: 80px;
        }

        .compact-input {
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.9rem;
            width: 80px;
            text-align: center;
        }

        .compact-select {
            padding: 6px 10px;
            border: 2px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.9rem;
            background: #f8fafc;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .compact-select:hover {
            border-color: #9ca3af;
            background: #f1f5f9;
        }

        .compact-select:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.1);
        }

        .compact-color {
            width: 40px;
            height: 30px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            cursor: pointer;
        }

        .compact-checkbox {
            transform: scale(1.1);
            margin-right: 6px;
        }

        .size-inputs {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .size-inputs span {
            color: #6c757d;
            font-weight: bold;
        }

        .compact-border-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .border-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .border-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .border-item label {
            font-size: 0.85rem;
            font-weight: 500;
            color: #6c757d;
        }

        .border-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .compact-slider {
            flex: 1;
            height: 6px;
        }

        .compact-number {
            width: 50px;
            padding: 4px 6px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.8rem;
            text-align: center;
        }

        .current-specs-compact {
            margin-top: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .specs-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
        }

        .polaroid-bottom-section {
            background: white;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #e9ecef;
        }

        .download-settings-compact h4 {
            margin: 0 0 12px 0;
            color: #495057;
            font-size: 1rem;
        }

        .compact-download-options {
            margin-bottom: 16px;
        }

        .download-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .download-row label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: #6c757d;
            cursor: pointer;
        }

        .compact-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            padding-top: 12px;
            border-top: 1px solid #f0f0f0;
        }

        .nav-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-btn-compact {
            width: 32px;
            height: 32px;
            border: 2px solid #d1d5db;
            background: #f1f5f9;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .nav-btn-compact:hover:not(:disabled) {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        .nav-btn-compact:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-info-compact {
            font-family: monospace;
            font-size: 0.9rem;
            color: #6c757d;
            min-width: 40px;
            text-align: center;
        }

        .export-section {
            display: flex;
            gap: 8px;
        }

        .export-btn-compact {
            padding: 8px 12px;
            border: 2px solid transparent;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .export-btn-compact.primary {
            background: #28a745;
            color: white;
        }

        .export-btn-compact.primary:hover {
            background: #218838;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.2);
        }

        .export-btn-compact.secondary {
            background: #6c757d;
            color: white;
        }

        .export-btn-compact.secondary:hover {
            background: #545b62;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(108, 117, 125, 0.2);
        }

        .export-btn-compact.tertiary {
            background: #007bff;
            color: white;
        }

        .export-btn-compact.tertiary:hover {
            background: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 123, 255, 0.2);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .polaroid-main-section {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .polaroid-header {
                flex-direction: column;
                gap: 12px;
                text-align: center;
            }

            .tab-header {
                flex-wrap: wrap;
            }

            .tab-btn {
                min-width: 50%;
            }

            .compact-actions {
                flex-direction: column;
                gap: 12px;
            }

            .export-section {
                width: 100%;
                justify-content: center;
            }
        }

        /* Strip Template Styles */
        .strip-template-preview-container {
            flex-shrink: 0;
        }

        .strip-template-frame {
            width: 150px;
            height: 450px;
            background: #4a90e2;
            border: 3px solid #ffffff;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .strip-template-frame::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #4a90e2, #357abd, #2980b9);
            border-radius: 15px;
            z-index: -1;
        }

        .strip-frame {
            flex: 1;
            background: #f8fafc;
            border: 3px solid #ffffff;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            font-size: 0.8rem;
            color: #6b7280;
            min-height: 85px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .strip-frame:nth-child(1) { background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); }
        .strip-frame:nth-child(2) { background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%); }
        .strip-frame:nth-child(3) { background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%); }
        .strip-frame:nth-child(4) { background: linear-gradient(135deg, #fff3e0 0%, #ffcc02 100%); }
        
        .strip-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .strip-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .placeholder-landscape {
            width: 80%;
            height: 60%;
            background: linear-gradient(135deg, #87ceeb 0%, #98fb98 40%, #87ceeb 100%);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .placeholder-landscape::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 10%;
            width: 30%;
            height: 25%;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .placeholder-landscape::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40%;
            background: linear-gradient(180deg, transparent 0%, #7fb069 100%);
            border-radius: 0 0 4px 4px;
        }
        
        .strip-placeholder .placeholder-text {
            font-size: 0.75rem;
            color: #64748b;
            font-weight: 600;
            text-align: center;
        }
        
        /* Slider Input Styles */
        .slider-input {
            width: 80px;
            margin-right: 8px;
        }
        
        .setting-row {
            display: flex;
            gap: 20px;
            margin-bottom: 12px;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
        }
        
        .setting-item label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-dark);
        }

        .template-config-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }

        .template-specs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .spec-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }

        .spec-label {
            font-weight: 500;
            color: #6b7280;
        }

        .spec-value {
            font-weight: 600;
            color: #1f2937;
        }

        .template-upload-zone {
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fafafa;
        }

        .template-upload-zone:hover {
            border-color: var(--primary-blue);
            background: #f0f8ff;
        }

        .template-upload-zone .upload-icon {
            font-size: 48px;
            color: #9ca3af;
            margin-bottom: 12px;
        }

        .template-upload-zone .upload-text {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .template-upload-zone .upload-subtext {
            font-size: 14px;
            color: #6b7280;
        }

        .template-preview-area {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            background: #e5e7eb;
            padding: 15px;
            border-radius: 8px;
        }
        
        /* Templates Section Styles */
        .templates-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .template-sub-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 32px;
            background: rgba(248, 250, 252, 0.8);
            padding: 8px;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .sub-tab-button {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-light);
            font-weight: 500;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .sub-tab-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .sub-tab-button:hover {
            background: #f8fafc !important;
            color: var(--primary-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }
        
        .sub-tab-button:hover::before {
            left: 100%;
        }
        
        .sub-tab-button.active {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%) !important;
            color: white !important;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.3);
            transform: translateY(-1px);
        }
        
        .sub-tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 3px;
            background: white;
            border-radius: 2px;
        }
        
        .sub-tab-icon {
            font-size: 1.1rem;
        }
        
        .sub-tab-text {
            font-weight: 600;
        }
        
        .template-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .template-content.active {
            display: block;
        }
        
        .template-content-header {
            text-align: center;
            margin-bottom: 24px;
            padding: 16px 0;
        }
        
        .template-content-header h3 {
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .template-content-header p {
            font-size: 1rem;
            color: var(--text-light);
            font-weight: 500;
            opacity: 0.9;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @media (max-width: 768px) {
            .template-preview-area {
                flex-direction: column;
                gap: 20px;
            }
            
            .border-template-frame,
            .strip-template-frame {
                margin: 0 auto;
                transform: scale(0.8);
            }
            
            .strip-template-frame {
                width: 130px;
                height: 380px;
            }
            
            .template-sub-tabs {
                flex-direction: column;
                gap: 4px;
            }
            
            .sub-tab-button {
                justify-content: center;
            }
            
            .templates-container {
                padding: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .template-sub-tabs {
                padding: 6px;
            }
            
            .sub-tab-button {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
            
            .strip-template-frame {
                width: 110px;
                height: 320px;
                padding: 10px;
            }
            
            .strip-frame {
                min-height: 65px;
                border-width: 2px;
            }
            
            .placeholder-landscape {
                height: 50%;
            }
        }

        .polaroid-preview-container {
            flex-shrink: 0;
        }

        .polaroid-frame {
            width: auto;
            max-width: 100%;
            height: auto;
            background: white;
            border: 3px solid #f1f5f9;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.15), 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            position: relative;
            display: inline-block;
        }

        /* Polaroid 2 overlay mode - override decorative frame */
        .polaroid-frame.template-overlay-mode {
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            padding: 0 !important;
            box-shadow: none !important;
        }

        .polaroid-frame::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 50%, #d97706 100%);
            border-radius: 14px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .polaroid-frame:hover::before {
            opacity: 0.8;
        }

        .polaroid-frame:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }

        .polaroid-image-area {
            width: 100%;
            height: 300px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            border: 2px solid #e5e7eb;
            transition: all 0.3s ease;
        }

        .polaroid-image-area:hover {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
        }

        .polaroid-image-area img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }

        .polaroid-image-area:hover img {
            transform: scale(1.05);
        }

        .polaroid-caption-area {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #374151;
            font-size: 14px;
            font-weight: 500;
            margin-top: 8px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 6px;
            border: 1px solid #f3f4f6;
            text-align: center;
            line-height: 1.4;
            padding: 8px;
        }

        .polaroid-caption-area.has-text {
            background: white;
            border-color: #e5e7eb;
            color: #1f2937;
            font-weight: 600;
        }

        .placeholder-text {
            color: #6b7280;
            font-size: 16px;
            font-weight: 500;
            text-align: center;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .placeholder-text::before {
            content: 'üì∑';
            font-size: 3rem;
            opacity: 0.6;
        }

        /* Enhanced Preview Loading State */
        .preview-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        .preview-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #f3f4f6;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Preview Image Quality Indicator */
        .quality-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            backdrop-filter: blur(4px);
        }

        .quality-indicator.high {
            background: rgba(16, 185, 129, 0.8);
        }

        .quality-indicator.medium {
            background: rgba(245, 158, 11, 0.8);
        }

        .quality-indicator.low {
            background: rgba(239, 68, 68, 0.8);
        }

        /* Preview Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .polaroid-frame:hover .zoom-controls {
            opacity: 1;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
        }

        .zoom-btn:hover {
            background: white;
            transform: scale(1.1);
        }

        /* Responsive Polaroid Preview */
        @media (max-width: 1024px) {
            .polaroid-frame {
                width: 240px;
                height: 320px;
            }
            
            .polaroid-image-area {
                height: 240px;
            }
        }

        @media (max-width: 768px) {
            .polaroid-preview-section {
                padding: 16px;
            }
            
            .polaroid-frame {
                width: 200px;
                height: 280px;
            }
            
            .polaroid-image-area {
                height: 200px;
            }
            
            .polaroid-caption-area {
                height: 50px;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            .polaroid-frame {
                width: 180px;
                height: 240px;
            }
            
            .polaroid-image-area {
                height: 160px;
            }
            
            .preview-title {
                font-size: 1rem;
            }
            
            .mini-btn {
                width: 32px;
                height: 32px;
                font-size: 0.9rem;
            }
        }

        /* Preview Info Panel */
        .preview-info-panel {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 8px 16px;
            font-size: 0.8rem;
            color: #6b7280;
            opacity: 0;
            transition: all 0.3s ease;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .polaroid-frame:hover .preview-info-panel {
            opacity: 1;
            bottom: -30px;
        }

        /* Preview Accuracy Indicator */
        .accuracy-badge {
            position: absolute;
            top: -8px;
            left: -8px;
            background: #10b981;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
            z-index: 3;
        }

        .accuracy-badge::before {
            content: '‚úì ';
            margin-right: 2px;
        }

        .crop-controls {
            flex: 1;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .control-btn {
            padding: 8px 16px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            background: #f1f5f9;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            border-color: var(--primary-blue);
            background: #e2e8f0;
            transform: translateY(-1px);
        }

        .crop-info {
            font-size: 14px;
            color: #6b7280;
            padding: 10px;
            background: #fffbeb;
            border-radius: 6px;
            border: 1px solid #fbbf24;
        }

        .template-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .current-specs {
            background: #f8f9ff;
            border: 1px solid #e0e7ff;
            border-radius: 8px;
            padding: 12px;
        }
        
        .spec-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .spec-item:last-of-type {
            margin-bottom: 12px;
        }
        
        .spec-label {
            color: #6b7280;
            font-weight: 500;
        }
        
        .spec-value {
            color: #1f2937;
            font-weight: 600;
            font-family: monospace;
        }
        
        .spec-value.highlight {
            color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .spec-note {
            font-size: 12px;
            color: #059669;
            background: rgba(5, 150, 105, 0.05);
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid #10b981;
        }

        .navigation-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            justify-content: center;
        }

        .nav-btn {
            padding: 10px 20px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            background: #f1f5f9;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .nav-btn:hover:not(:disabled) {
            border-color: var(--primary-blue);
            background: #e2e8f0;
            transform: translateY(-1px);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-info {
            font-weight: 600;
            color: #374151;
            min-width: 60px;
            text-align: center;
        }

        .export-controls {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .export-btn {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .export-btn.primary {
            background: var(--primary-blue);
            color: white;
        }

        .export-btn.primary:hover {
            background: var(--dark-blue);
        }

        .export-btn.secondary {
            background: #f1f5f9;
            color: #374151;
            border: 2px solid #d1d5db;
        }

        .export-btn.secondary:hover {
            background: #e2e8f0;
            transform: translateY(-1px);
            border-color: #9ca3af;
        }

        .export-btn.individual {
            background: #fef3c7;
            color: #92400e;
            border: 2px solid #f59e0b;
        }

        .export-btn.individual:hover {
            background: #fde68a;
            transform: translateY(-1px);
            border-color: #d97706;
        }

        /* SK316 Export Status */
        .sk316-export-status {
            margin: 16px 0;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(241, 245, 249, 0.9) 100%);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .sk316-export-status:has(.sk316-status-badge.active) {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.08) 0%, rgba(22, 163, 74, 0.12) 100%);
            border-color: rgba(34, 197, 94, 0.3);
        }

        .sk316-status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .sk316-status-badge .status-icon {
            font-size: 16px;
            line-height: 1;
        }

        .sk316-status-badge.inactive {
            color: #64748b;
        }

        .sk316-status-badge.inactive .status-icon {
            color: #94a3b8;
        }

        .sk316-status-badge.active {
            color: #16a34a;
        }

        .sk316-status-badge.active .status-icon {
            color: #22c55e;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .sk316-profile-info {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(34, 197, 94, 0.2);
        }

        .sk316-profile-info .profile-name {
            font-size: 12px;
            font-weight: 700;
            color: #16a34a;
            margin-bottom: 4px;
        }

        .sk316-profile-info .profile-details {
            font-size: 11px;
            color: #64748b;
            line-height: 1.6;
        }

        /* File System Save Controls */
        .filesystem-save-controls {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-radius: 12px;
            border: 1px solid #e2e8f0;
        }

        .filesystem-save-btn {
            width: 100%;
            padding: 16px 24px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .filesystem-save-btn:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
        }

        .export-options-dropdown {
            margin-bottom: 16px;
            position: relative;
        }

        .dropdown-toggle {
            width: 100%;
            padding: 12px 16px;
            background: white;
            border: 2px solid #d1d5db;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .dropdown-toggle:hover {
            border-color: #9ca3af;
            background: #f9fafb;
        }

        .dropdown-arrow {
            transition: transform 0.2s ease;
        }

        .dropdown-toggle.active .dropdown-arrow {
            transform: rotate(180deg);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #d1d5db;
            border-top: none;
            border-radius: 0 0 8px 8px;
            z-index: 10;
            padding: 16px;
        }

        .dropdown-content.show {
            display: block;
        }

        .option-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .option-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-weight: 500;
        }

        .option-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .subfolder-input {
            padding: 10px 12px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s ease;
        }

        .subfolder-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .download-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
        }

        .download-option-btn {
            padding: 12px 16px;
            background: white;
            border: 2px solid #d1d5db;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s ease;
            text-align: center;
        }

        .download-option-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        @media (max-width: 768px) {
            .download-options {
                grid-template-columns: 1fr;
            }

            .filesystem-save-controls {
                padding: 16px;
            }
        }

        .export-info {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
        }

        .info-label {
            font-weight: 500;
            color: #6b7280;
        }

        .info-value {
            font-weight: 600;
            color: #1f2937;
            font-size: 14px;
        }

        .template-gallery {
            margin-top: 30px;
            padding: 20px;
            background: #fafafa;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
        }

        .gallery-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .gallery-stats {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-value {
            font-weight: 700;
            font-size: 18px;
            color: var(--primary-blue);
        }

        .stat-label {
            color: #6b7280;
            font-size: 14px;
        }

        .template-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px;
        }

        .template-item {
            background: white;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .template-item:hover {
            border-color: var(--primary-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .template-item.active {
            border-color: var(--primary-blue);
            background: #f0f8ff;
        }

        .template-item-preview {
            width: 100%;
            aspect-ratio: 2/3;
            background: #d1d5db;
            border-radius: 4px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .template-item-name {
            font-size: 12px;
            text-align: center;
            color: #6b7280;
            font-weight: 500;
        }

        /* Template Configuration Styles */
        .polaroid-basic-settings,
        .border-settings,
        .advanced-settings,
        .caption-settings,
        .current-specs,
        .reset-controls {
            margin-bottom: 20px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .subsection-label {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
            margin-bottom: 12px;
            display: block;
        }

        .setting-row {
            display: flex;
            gap: 16px;
            margin-bottom: 12px;
        }

        .setting-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .setting-item label {
            font-size: 13px;
            font-weight: 500;
            color: #6b7280;
        }

        .template-select,
        .template-input,
        .size-input,
        .caption-text-input {
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            background: #f8fafc;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        .template-select:hover,
        .template-input:hover,
        .size-input:hover {
            border-color: #9ca3af;
            background: #f1f5f9;
        }

        .template-select:focus,
        .template-input:focus,
        .size-input:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .caption-text-input:hover {
            border-color: #9ca3af;
            background: #f1f5f9;
        }

        .caption-text-input:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .size-inputs {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .size-input {
            width: 70px;
        }

        .border-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .border-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .border-input-group label {
            font-size: 13px;
            font-weight: 500;
            color: #6b7280;
        }

        .border-slider {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .border-slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-blue);
            border-radius: 50%;
            cursor: pointer;
        }

        .border-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--primary-blue);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .border-number {
            width: 60px;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }

        .color-input {
            width: 50px;
            height: 40px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            cursor: pointer;
        }

        .checkbox-input {
            width: 18px;
            height: 18px;
            accent-color: var(--primary-blue);
        }

        .advanced-controls,
        .caption-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .specs-display {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-top: 16px;
            font-size: 14px;
            overflow: hidden;
        }

        .specs-table {
            width: 100%;
            border-collapse: collapse;
        }

        .specs-table tbody tr {
            border-bottom: 1px solid #f3f4f6;
            transition: background-color 0.2s ease;
        }

        .specs-table tbody tr:last-child {
            border-bottom: none;
        }

        .specs-table tbody tr:hover {
            background-color: #f9fafb;
        }

        .spec-key {
            padding: 12px 16px;
            font-weight: 600;
            color: #374151;
            width: 40%;
            text-align: left;
            vertical-align: middle;
        }

        .spec-value {
            padding: 12px 16px;
            font-weight: 500;
            color: #1f2937;
            text-align: right;
            vertical-align: middle;
            font-family: 'Monaco', 'Menlo', monospace;
        }

        .spec-value.highlight {
            color: #059669;
            font-weight: 600;
        }

        .spec-value.error {
            color: #dc2626;
            font-weight: 600;
        }

        .spec-unit {
            font-size: 0.85rem;
            color: #6b7280;
            font-weight: 400;
            margin-left: 4px;
        }

        .spec-color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid #d1d5db;
            margin-right: 6px;
            vertical-align: middle;
        }

        .spec-detail {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 2px;
            display: block;
        }

        .quick-crop-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-left: 12px;
            padding: 6px 12px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.2);
        }

        .quick-crop-btn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        .quick-crop-btn:active {
            transform: translateY(0);
        }

        .quick-crop-btn .btn-icon {
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .spec-key, .spec-value {
                padding: 10px 12px;
                font-size: 13px;
            }
            
            .spec-key {
                width: 45%;
            }

            .quick-crop-btn {
                margin-left: 0;
                margin-top: 8px;
                display: flex;
                width: 100%;
                justify-content: center;
            }
        }

        .reset-btn {
            padding: 10px 20px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            background: #f1f5f9;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .reset-btn:hover {
            border-color: var(--primary-blue);
            color: var(--primary-blue);
            background: #e2e8f0;
            transform: translateY(-1px);
        }

        .caption-text-input {
            width: 100%;
        }

        @media (max-width: 768px) {
            .setting-row {
                flex-direction: column;
                gap: 12px;
            }
            
            .border-controls {
                grid-template-columns: 1fr;
                gap: 12px;
            }
        }
        
        .info-text {
            font-size: 12px;
            color: #5a6c7d;
            margin-bottom: 4px;
        }
        
        .info-text:last-child {
            margin-bottom: 0;
        }
        
        /* Multi-crop resize handles */
        .multi-crop-resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--primary-blue);
            border: 1px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            opacity: 0.8;
            transition: all 0.2s ease;
            z-index: 1002;
        }
        
        .multi-crop-resize-handle:hover {
            background: var(--dark-blue);
            transform: scale(1.3);
            opacity: 1;
        }
        
        .multi-crop-resize-handle.nw {
            top: -5px;
            left: -5px;
            cursor: nw-resize;
        }
        
        .multi-crop-resize-handle.ne {
            top: -5px;
            right: -5px;
            cursor: ne-resize;
        }
        
        .multi-crop-resize-handle.sw {
            bottom: -5px;
            left: -5px;
            cursor: sw-resize;
        }
        
        .multi-crop-resize-handle.se {
            bottom: -5px;
            right: -5px;
            cursor: se-resize;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }
        
        .info-row:last-child {
            margin-bottom: 0;
        }
        
        .info-label {
            color: var(--text-light);
            font-weight: 500;
        }
        
        .template-nav-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .nav-btn {
            padding: 8px 16px;
            background: var(--light-gray);
            border: 1px solid #ccc;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .nav-btn:hover:not(:disabled) {
            background: var(--primary-blue);
            color: white;
        }
        
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #templateImageName {
            font-weight: 600;
            color: var(--text-dark);
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .template-action-controls {
            display: flex;
            gap: 10px;
        }

        /* Old fixed-column media queries removed - using new responsive system above */

        @media (max-width: 480px) {
            .controls-row {
                text-align: center;
            }

            .control-group {
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }

            .control-group label {
                min-width: auto;
            }

            .actions-group {
                flex-direction: column;
                align-items: center;
            }

            .action-btn {
                width: 100%;
                max-width: 200px;
            }

            .stats {
                grid-template-columns: 1fr;
            }

            .file-list {
                grid-template-columns: repeat(auto-fit, minmax(min(6rem, 45%), 1fr));
                gap: clamp(0.5rem, 1.5vw, 0.75rem);
            }

            .file-preview {
                min-height: 100px;
            }
        }
        /* Print Section Styles */
        .print-container {
            width: 100%;
            max-width: none;
            padding: clamp(16px, 3vw, 48px);
            margin: 0 auto;
        }

        .print-config-panel {
            background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: clamp(24px, 2vw, 32px);
            margin-bottom: 24px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: clamp(20px, 3vw, 40px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            position: relative;
            overflow: hidden;
        }
        
        .print-config-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #3b82f6, #06b6d4, #10b981);
            border-radius: 16px 16px 0 0;
        }

        .config-column {
            display: flex;
            flex-direction: column;
            gap: 28px;
        }

        .config-column-left {
            /* Core settings: Paper, Photo Size, Print Mode */
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .config-column-right {
            /* Advanced settings: Margins, Cutting Guides, Fit Mode */
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .config-group {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            padding: 24px;
            border: 1px solid rgba(226, 232, 240, 0.5);
            transition: all 0.3s ease;
            margin-bottom: 0;
        }
        
        .config-group:hover {
            background: rgba(255, 255, 255, 0.9);
            border-color: #cbd5e1;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .config-label {
            display: flex;
            align-items: center;
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--text-dark);
            margin-bottom: 18px;
            gap: 10px;
        }

        /* Download Settings */
        .download-settings {
            margin-top: var(--spacing-sm);
        }

        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
        }

        .config-row label {
            font-weight: 500;
            color: var(--text-dark);
            min-width: 100px;
        }

        .config-row input[type="text"] {
            flex: 1;
            margin-left: var(--spacing-sm);
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid #ddd;
            border-radius: var(--radius-sm);
            font-family: inherit;
        }

        .config-row input[type="checkbox"] {
            margin-right: var(--spacing-xs);
        }

        .subfolder-settings {
            margin-left: var(--spacing-md);
            margin-top: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-md);
            border-left: 3px solid var(--primary-blue);
        }

        .config-btn {
            width: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            margin-top: var(--spacing-sm);
            background: var(--primary-blue);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .config-btn:hover {
            background: var(--dark-blue);
        }

        /* Paper Size Styles */
        .paper-size-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .preset-sizes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 16px;
        }

        .size-preset {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .size-preset::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .size-preset:hover {
            border-color: var(--primary-blue);
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            transform: translateY(-4px);
            box-shadow: 0 12px 30px rgba(59, 130, 246, 0.2);
        }
        
        .size-preset:hover::before {
            left: 100%;
        }

        .size-preset.active {
            border-color: var(--primary-blue);
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            color: var(--primary-blue);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.25);
            transform: translateY(-2px);
        }
        
        .size-preset.active::after {
            content: '‚úì';
            position: absolute;
            top: 8px;
            right: 8px;
            color: var(--primary-blue);
            font-weight: bold;
            font-size: 1rem;
        }

        .size-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-dark);
            margin-bottom: 4px;
        }

        .size-dim {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        .custom-paper-input, .custom-photo-input {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            padding: 16px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-md);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .input-group label {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-dark);
        }

        .input-group input {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            transition: border-color 0.2s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .orientation-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .orientation-options {
            display: flex;
            gap: 8px;
        }

        .orientation-btn {
            flex: 1;
            padding: 10px 16px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .orientation-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .orientation-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        /* Photo Size Styles */
        .photo-size-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .preset-photo-sizes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .photo-preset {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px 12px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .photo-preset:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .photo-preset.active {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }

        .photo-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-dark);
            margin-bottom: 4px;
        }

        .photo-desc {
            font-size: 0.8rem;
            color: var(--text-light);
        }

        /* Margin Configuration */
        .margin-config {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .margin-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
        }

        .gutter-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
        }

        /* Quality Configuration */
        .quality-config {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .dpi-selection {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .dpi-options {
            display: flex;
            gap: 8px;
        }

        .dpi-btn {
            flex: 1;
            padding: 10px 16px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .dpi-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .dpi-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        .fit-mode-selection {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .fit-options {
            display: flex;
            gap: 12px;
        }

        .fit-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 14px 12px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .fit-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .fit-btn.active {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }

        .fit-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-dark);
            margin-bottom: 4px;
        }

        .fit-desc {
            font-size: 0.8rem;
            color: var(--text-light);
            text-align: center;
        }

        /* Layout Information */
        .layout-info {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
            border-radius: var(--radius-lg);
            padding: 20px;
            margin-bottom: 24px;
        }

        .layout-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary-blue);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-light);
            font-weight: 500;
        }

        /* Upload Section */
        .print-upload-section {
            margin-bottom: 32px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 16px;
            padding: 28px;
            border: 2px dashed #e2e8f0;
            transition: all 0.3s ease;
        }
        
        .print-upload-section:hover {
            border-color: var(--primary-blue);
            background: rgba(248, 250, 252, 0.8);
        }

        .upload-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .btn-secondary {
            padding: 14px 28px;
            border: 2px solid var(--primary-blue);
            border-radius: 12px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            color: var(--primary-blue);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            align-self: flex-start;
            position: relative;
            overflow: hidden;
        }
        
        .btn-secondary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
            transition: left 0.5s ease;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }
        
        .btn-secondary:hover::before {
            left: 100%;
        }

        /* Selected Images */
        .selected-images {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-lg);
            padding: 20px;
            margin-bottom: 24px;
        }

        .images-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .images-header h3 {
            margin: 0;
            color: var(--text-dark);
        }

        .btn-clear {
            padding: 8px 16px;
            border: 1px solid #ef4444;
            border-radius: var(--radius-sm);
            background: white;
            color: #ef4444;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-clear:hover {
            background: #ef4444;
            color: white;
        }

        .images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
        }
        
        /* Override for compact version - use smaller thumbnails */
        .selected-images-compact .images-grid {
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Preview Canvas */
        .print-preview {
            background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 28px;
            margin-bottom: 32px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            position: relative;
            overflow: hidden;
        }
        
        .print-preview::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #06b6d4, #3b82f6, #8b5cf6);
            border-radius: 16px 16px 0 0;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .preview-header h3 {
            margin: 0;
            color: var(--text-dark);
        }

        .preview-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .btn-preview {
            padding: 8px 16px;
            border: 1px solid var(--primary-blue);
            border-radius: var(--radius-sm);
            background: white;
            color: var(--primary-blue);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-preview:hover:not(:disabled) {
            background: var(--primary-blue);
            color: white;
        }

        .btn-preview:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .page-indicator {
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-dark);
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: var(--radius-md);
            padding: 20px;
            min-height: 400px;
        }

        .print-canvas {
            max-width: 100%;
            max-height: 600px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Export Section */
        .export-section {
            background: linear-gradient(135deg, #f0fdf4 0%, #f8fafc 100%);
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            padding: 28px;
            box-shadow: 0 4px 20px rgba(16, 185, 129, 0.1);
            position: relative;
        }
        
        .export-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #10b981, #059669);
            border-radius: 16px 16px 0 0;
        }

        .export-header h3 {
            margin: 0 0 16px 0;
            color: var(--text-dark);
        }

        .export-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .export-format {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .format-option {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 16px;
            border: 2px solid #e2e8f0;
            border-radius: var(--radius-md);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .format-option:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .format-option input[type="radio"] {
            margin-top: 2px;
        }

        .format-option label {
            flex: 1;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .format-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-dark);
        }

        .format-desc {
            font-size: 0.85rem;
            color: var(--text-light);
        }

        .export-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn-primary {
            padding: 16px 32px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--primary-blue) 0%, var(--dark-blue) 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .btn-primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-4px);
            box-shadow: 0 12px 35px rgba(59, 130, 246, 0.4);
        }
        
        .btn-primary:hover:not(:disabled)::before {
            left: 100%;
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Cutting Guides Styles */
        .cutting-guides-config {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .cutting-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .cutting-option {
            display: flex;
            align-items: center;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-dark);
        }

        .checkbox-label input[type="checkbox"] {
            display: none;
        }

        .checkbox-custom {
            width: 18px;
            height: 18px;
            border: 2px solid #e2e8f0;
            border-radius: 3px;
            background: white;
            position: relative;
            transition: all 0.2s ease;
        }

        .checkbox-label input[type="checkbox"]:checked + .checkbox-custom {
            background: var(--primary-blue);
            border-color: var(--primary-blue);
        }

        .checkbox-label input[type="checkbox"]:checked + .checkbox-custom::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .option-text {
            flex: 1;
        }

        .cutting-style-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .style-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .style-group label {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-dark);
        }

        .color-options {
            display: flex;
            gap: 6px;
        }

        .color-btn {
            width: 28px;
            height: 28px;
            border: 2px solid #e2e8f0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .thickness-options, .line-style-options {
            display: flex;
            gap: 4px;
        }

        .thickness-btn, .line-style-btn {
            padding: 6px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .thickness-btn:hover, .line-style-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .thickness-btn.active, .line-style-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        /* Enhanced Preview Styles */
        .preview-header {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 16px;
        }

        .preview-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .preview-stat {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-dark);
        }

        .stat-icon {
            font-size: 0.9rem;
        }

        .preview-tools {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .view-controls, .guide-toggles {
            display: flex;
            gap: 8px;
        }

        .view-btn, .toggle-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .view-btn:hover, .toggle-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .view-btn.active, .toggle-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        .btn-icon {
            font-size: 0.9rem;
        }

        .btn-text {
            font-weight: 500;
        }

        .canvas-viewport {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
            overflow: auto;
            max-height: 80vh;
        }

        .canvas-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: white;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin: 0 auto;
            width: fit-content;
        }

        .canvas-ruler-h, .canvas-ruler-v {
            position: absolute;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            font-size: 10px;
            color: #6b7280;
            z-index: 10;
        }

        .canvas-ruler-h {
            top: -25px;
            left: 0;
            right: 0;
            height: 24px;
        }

        .canvas-ruler-v {
            left: -25px;
            top: 0;
            bottom: 0;
            width: 24px;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 5;
        }

        .print-canvas {
            display: block;
            border: 1px solid #e2e8f0;
            background: white;
        }

        /* Dual Canvas Layout for Duplex Mode */
        .dual-canvas-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
            padding: 20px 0;
        }

        .canvas-side {
            flex: 1;
            max-width: 45%;
            text-align: center;
        }

        .side-header {
            margin-bottom: 10px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .front-side .side-header {
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            border-color: #86efac;
            color: #166534;
        }

        .back-side .side-header {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-color: #facc15;
            color: #92400e;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        .duplex-canvas {
            display: block;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 4px;
            max-width: 100%;
            max-height: 500px;
        }

        .front-side .duplex-canvas {
            border-color: #86efac;
        }

        .back-side .duplex-canvas {
            border-color: #facc15;
        }

        /* Responsive behavior for dual canvas */
        @media (max-width: 1200px) {
            .dual-canvas-container {
                flex-direction: column;
                align-items: center;
                gap: 30px;
            }
            
            .canvas-side {
                max-width: 80%;
            }
        }

        /* Gallery Grid for Duplex Mode */
        .gallery-section-duplex {
            margin: 20px 0;
            padding: 15px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }

        .gallery-grid-duplex {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 10px;
        }

        .gallery-item-duplex {
            position: relative;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            overflow: hidden;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .gallery-item-duplex:hover {
            border-color: #3b82f6;
            transform: scale(1.02);
        }

        .gallery-item-duplex.selection-mode {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .gallery-item-duplex img {
            width: 100%;
            height: 80px;
            object-fit: cover;
        }

        .gallery-item-duplex .image-name {
            padding: 4px 6px;
            font-size: 0.7rem;
            background: rgba(0,0,0,0.7);
            color: white;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }

        .preview-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
            border-radius: 8px;
            font-size: 0.85rem;
        }

        .wysiwyg-indicator, .quality-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .wysiwyg-icon {
            font-size: 1rem;
        }

        .wysiwyg-text {
            font-weight: 600;
            color: #059669;
        }

        .quality-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
        }

        .quality-text {
            color: var(--text-dark);
            font-weight: 500;
        }

        /* Print Mode Styles */
        .print-mode-selection {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .print-mode-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .mode-option {
            position: relative;
        }

        .mode-option input[type="radio"] {
            display: none;
        }

        .mode-label {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mode-label:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .mode-option input[type="radio"]:checked + .mode-label {
            border-color: var(--primary-blue);
            background: var(--light-yellow);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }

        .mode-icon {
            font-size: 1.5rem;
            width: 32px;
            text-align: center;
        }

        .mode-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .mode-name {
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-dark);
        }

        .mode-desc {
            font-size: 0.85rem;
            color: var(--text-light);
        }

        .duplex-options {
            padding: 16px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin-top: 8px;
        }

        .duplex-config {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .config-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-item label {
            font-weight: 500;
            font-size: 0.9rem;
            color: var(--text-dark);
        }

        .flip-direction {
            display: flex;
            gap: 8px;
        }

        .flip-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 12px 8px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .flip-btn:hover {
            border-color: var(--primary-blue);
            background: #f0f9ff;
        }

        .flip-btn.active {
            border-color: var(--primary-blue);
            background: var(--primary-blue);
            color: white;
        }

        .flip-icon {
            font-size: 1.2rem;
        }

        .flip-text {
            font-size: 0.8rem;
            font-weight: 500;
        }

        .duplex-preview-mini {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
        }

        /* Back Side Bleed Controls */
        .duplex-bleed-control {
            margin-top: 16px;
            padding: 16px;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border: 2px solid #fbbf24;
            border-radius: 10px;
        }

        .bleed-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .bleed-toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            user-select: none;
        }

        .bleed-toggle-label input[type="checkbox"] {
            display: none;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: #cbd5e1;
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .bleed-toggle-label input:checked + .toggle-switch {
            background: #22c55e;
        }

        .bleed-toggle-label input:checked + .toggle-switch::after {
            left: 22px;
        }

        .toggle-text {
            font-weight: 600;
            color: #78350f;
            font-size: 0.95em;
        }

        .bleed-info-icon {
            font-size: 1.2em;
            cursor: help;
            color: #f59e0b;
            transition: transform 0.2s ease;
        }

        .bleed-info-icon:hover {
            transform: scale(1.2);
        }

        .bleed-slider-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px;
            background: white;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .bleed-slider-container.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .bleed-slider-container label {
            font-weight: 600;
            color: #92400e;
            font-size: 0.9em;
        }

        .slider-with-value {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slider-with-value input[type="range"] {
            flex: 1;
            height: 6px;
            background: linear-gradient(to right, #fbbf24 0%, #f59e0b 100%);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider-with-value input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border: 3px solid #f59e0b;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(245, 158, 11, 0.3);
            transition: all 0.2s ease;
        }

        .slider-with-value input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.5);
        }

        .slider-with-value input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: white;
            border: 3px solid #f59e0b;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(245, 158, 11, 0.3);
            transition: all 0.2s ease;
        }

        .slider-with-value input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.5);
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: 700;
            color: #92400e;
            font-size: 0.95em;
            background: #fef3c7;
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid #fbbf24;
        }

        .bleed-hint {
            color: #a16207;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .bleed-hint small {
            display: block;
        }

        /* Duplex Config Inline - Compact Layout */
        .duplex-config-inline {
            margin-top: 12px;
            padding: 16px;
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
            border: 2px solid #38bdf8;
            border-radius: 10px;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
                padding-top: 0;
                padding-bottom: 0;
            }
            to {
                opacity: 1;
                max-height: 500px;
                padding-top: 16px;
                padding-bottom: 16px;
            }
        }

        .duplex-section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 14px;
            padding-bottom: 10px;
            border-bottom: 2px solid #7dd3fc;
        }

        .duplex-section-header .section-icon {
            font-size: 1.2em;
        }

        .duplex-section-header .section-title {
            font-weight: 700;
            color: #0c4a6e;
            font-size: 0.95em;
        }

        .duplex-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .duplex-flip-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .duplex-flip-row > label {
            font-weight: 600;
            color: #0c4a6e;
            font-size: 0.9em;
            min-width: 80px;
        }

        .flip-buttons-inline {
            display: flex;
            gap: 8px;
            flex: 1;
        }

        .flip-btn-inline {
            flex: 1;
            padding: 8px 12px;
            background: white;
            border: 2px solid #bae6fd;
            border-radius: 8px;
            font-size: 0.85em;
            font-weight: 600;
            color: #0369a1;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .flip-btn-inline:hover {
            background: #f0f9ff;
            border-color: #38bdf8;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(56, 189, 248, 0.2);
        }

        .flip-btn-inline.active {
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            border-color: #0284c7;
            color: white;
            box-shadow: 0 4px 12px rgba(2, 132, 199, 0.4);
        }

        .duplex-bleed-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 10px 12px;
            background: white;
            border-radius: 8px;
        }

        .bleed-toggle-inline {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }

        .bleed-toggle-inline input[type="checkbox"] {
            display: none;
        }

        .toggle-switch-mini {
            position: relative;
            width: 36px;
            height: 20px;
            background: #cbd5e1;
            border-radius: 10px;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .toggle-switch-mini::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .bleed-toggle-inline input:checked + .toggle-switch-mini {
            background: #22c55e;
        }

        .bleed-toggle-inline input:checked + .toggle-switch-mini::after {
            left: 18px;
        }

        .bleed-toggle-inline .toggle-label {
            font-weight: 600;
            color: #0c4a6e;
            font-size: 0.9em;
        }

        .bleed-value-inline {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            max-width: 200px;
            transition: opacity 0.3s ease;
        }

        .bleed-value-inline.disabled {
            opacity: 0.4;
            pointer-events: none;
        }

        .slider-mini {
            flex: 1;
            height: 4px;
            background: linear-gradient(to right, #bae6fd 0%, #38bdf8 100%);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .slider-mini::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: white;
            border: 2px solid #0ea5e9;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(14, 165, 233, 0.3);
            transition: all 0.2s ease;
        }

        .slider-mini::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 3px 8px rgba(14, 165, 233, 0.5);
        }

        .slider-mini::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: white;
            border: 2px solid #0ea5e9;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(14, 165, 233, 0.3);
            transition: all 0.2s ease;
        }

        .slider-mini::-moz-range-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 3px 8px rgba(14, 165, 233, 0.5);
        }

        .value-display {
            min-width: 50px;
            text-align: center;
            font-weight: 700;
            color: #0c4a6e;
            font-size: 0.85em;
            background: #f0f9ff;
            padding: 3px 8px;
            border-radius: 6px;
            border: 1px solid #bae6fd;
        }

        .duplex-hint {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            border-left: 3px solid #f59e0b;
        }

        .duplex-hint .hint-icon {
            font-size: 1.1em;
            flex-shrink: 0;
        }

        .duplex-hint .hint-text {
            color: #0c4a6e;
            font-size: 0.85em;
            line-height: 1.4;
            font-weight: 500;
        }

        .offset-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .offset-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
        }

        .offset-input-group label {
            font-size: 0.8rem;
            font-weight: 500;
            color: #374151;
            min-width: 80px;
        }

        .offset-input {
            width: 70px;
            min-width: 70px;
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: center;
        }

        .offset-input:focus {
            border-color: var(--primary-blue);
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .offset-unit {
            font-size: 0.8rem;
            color: #6b7280;
            font-weight: 500;
        }

        .offset-help {
            margin-top: 8px;
            padding: 8px 12px;
            background: #fef3cd;
            border: 1px solid #fde047;
            border-radius: 6px;
        }

        .offset-help small {
            color: #92400e;
            font-size: 0.75rem;
        }

        .preview-instruction {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        .instruction-icon {
            font-size: 1.1rem;
            margin-top: 2px;
        }

        .instruction-text {
            flex: 1;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .instruction-text strong {
            color: var(--text-dark);
        }

        /* Responsive Design for Print Section */
        @media (max-width: 768px) {
            .preset-sizes {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            }

            .preset-photo-sizes {
                grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            }

            .margin-inputs {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }

            .gutter-inputs {
                grid-template-columns: 1fr;
            }

            .print-config-panel {
                grid-template-columns: 1fr;
                gap: 24px;
                padding: 24px 20px;
            }

            .config-column {
                gap: 24px;
            }
            
            .config-group {
                padding: 20px 16px;
            }
            
            .section-header h2 {
                font-size: 1.8rem;
            }
            
            .upload-zone {
                padding: 36px 20px;
            }

            .custom-paper-input, .custom-photo-input {
                grid-template-columns: 1fr;
            }

            .fit-options {
                flex-direction: column;
            }

            .layout-stats {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }

            .export-actions {
                flex-direction: column;
            }

            .btn-primary, .btn-secondary {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .print-config-panel {
                padding: 20px 16px;
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .config-column {
                gap: 20px;
            }
            
            .config-group {
                padding: 18px 14px;
            }
            
            .section-header h2 {
                font-size: 1.6rem;
            }
            
            .section-header h2::before {
                font-size: 1.4rem;
            }
            
            .upload-zone {
                padding: 32px 16px;
            }
            
            .print-preview {
                padding: 20px 16px;
            }
            
            .export-section {
                padding: 20px 16px;
            }
            
            .btn-primary, .btn-secondary {
                padding: 14px 24px;
                font-size: 0.9rem;
            }

            .dpi-options {
                flex-direction: column;
            }

            .orientation-options {
                flex-direction: column;
            }

            .preset-sizes {
                grid-template-columns: 1fr;
            }

            .preset-photo-sizes {
                grid-template-columns: 1fr;
            }
        }

        /* Convert Tab Styles */
        .convert-upload-zone {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 3px dashed var(--primary-blue);
            border-radius: 20px;
            padding: 40px 30px;
            text-align: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .convert-upload-zone:hover {
            border-color: var(--primary-yellow);
            background: linear-gradient(135deg, #fefce8 0%, #fef3c7 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.15);
        }

        .convert-upload-zone:active {
            transform: scale(0.98);
        }

        .convert-upload-zone.dragover {
            border-color: var(--primary-yellow);
            background: linear-gradient(135deg, #fefce8 0%, #fef3c7 100%);
            transform: scale(1.02);
            box-shadow: 0 10px 30px rgba(245, 158, 11, 0.2);
        }

        .convert-upload-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .convert-upload-icon {
            font-size: 4rem;
            color: var(--primary-blue);
            margin-bottom: 10px;
            transition: transform 0.3s ease;
        }

        .convert-upload-zone:hover .convert-upload-icon {
            transform: scale(1.1) rotate(360deg);
            color: var(--primary-yellow);
        }

        .convert-upload-text {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 8px;
        }

        .convert-upload-hint {
            font-size: 1rem;
            color: var(--text-light);
            font-weight: 500;
        }

        .convert-upload-formats {
            font-size: 0.9rem;
            color: var(--primary-blue);
            font-weight: 600;
            background: rgba(59, 130, 246, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            margin-top: 10px;
        }

        /* Convert Stats */
        .convert-stats {
            background: var(--white);
            border-radius: 16px;
            padding: 25px;
            border: 2px solid var(--light-yellow);
            margin-bottom: 25px;
        }

        .convert-stats h3 {
            color: var(--text-dark);
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .stat-item {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 1px solid #cbd5e1;
            border-radius: 10px;
            padding: 12px 8px;
            text-align: center;
            transition: all 0.3s ease;
            min-height: auto;
        }

        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
            border-color: var(--primary-blue);
        }

        .stat-icon {
            font-size: 1.4rem;
            color: var(--primary-blue);
            margin-bottom: 6px;
            display: block;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 3px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-light);
            font-weight: 500;
            line-height: 1.2;
        }

        /* Convert Controls */
        .convert-controls {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 16px;
            padding: 30px;
            border: 2px solid var(--primary-blue);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .convert-controls h3 {
            color: var(--primary-blue);
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
        }

        .control-group {
            background: var(--white);
            border: 2px solid #cbd5e1;
            border-radius: 12px;
            padding: 25px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .control-group:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            border-color: var(--primary-blue);
        }

        .control-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .control-icon {
            font-size: 1.5rem;
            color: var(--primary-blue);
        }

        .control-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #111827;
        }

        .control-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            padding: 12px 0;
            border-bottom: 1px solid #f3f4f6;
        }

        .control-row:last-child {
            border-bottom: none;
        }

        .control-label {
            font-size: 1rem;
            color: #1f2937;
            font-weight: 600;
            flex: 1;
            line-height: 1.4;
        }

        .control-input {
            flex: 1;
            max-width: 160px;
            padding: 12px 16px;
            border: 2px solid #d1d5db;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 500;
            color: #111827;
            transition: all 0.3s ease;
            background: var(--white);
        }

        .control-input:focus {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
            outline: none;
        }

        .control-select {
            flex: 1;
            max-width: 160px;
            padding: 12px 16px;
            border: 2px solid #d1d5db;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 500;
            color: #111827;
            background: var(--white);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-select:focus {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
            outline: none;
        }

        /* Convert Action Buttons */
        .convert-actions {
            margin-top: 30px;
            text-align: center;
        }

        .convert-btn {
            background: linear-gradient(135deg, var(--primary-blue) 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            margin: 0 10px;
        }

        .convert-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
            background: linear-gradient(135deg, #1d4ed8 0%, #1e40af 100%);
        }

        .convert-btn:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.2);
        }

        .convert-btn.secondary {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
        }

        .convert-btn.secondary:hover {
            background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
            box-shadow: 0 8px 25px rgba(75, 85, 99, 0.3);
        }

        /* Convert Action Button - High Contrast */
        .convert-action-btn {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            color: white;
            border: none;
            padding: 18px 45px;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            width: 100%;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 6px 20px rgba(5, 150, 105, 0.3);
            border: 2px solid #047857;
        }

        .convert-action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(5, 150, 105, 0.4);
            background: linear-gradient(135deg, #047857 0%, #065f46 100%);
            border-color: #065f46;
        }

        .convert-action-btn:active {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(5, 150, 105, 0.3);
        }

        .convert-action-btn:disabled {
            background: linear-gradient(135deg, #9ca3af 0%, #6b7280 100%);
            color: #d1d5db;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            border-color: #6b7280;
        }

        .convert-action-btn .btn-indicator {
            font-size: 1.4rem;
            font-weight: bold;
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .convert-action-btn:disabled .btn-indicator {
            animation: rotate 1.5s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Responsive Design for Convert Tab */
        @media (max-width: 768px) {
            .convert-upload-zone {
                padding: 30px 20px;
            }

            .convert-upload-icon {
                font-size: 3rem;
            }

            .convert-upload-text {
                font-size: 1.1rem;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .controls-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .control-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .control-input, .control-select {
                max-width: 100%;
                width: 100%;
            }

            .convert-btn {
                padding: 12px 30px;
                font-size: 1rem;
                margin: 5px;
            }
        }

        /* File System Section Styles */
        .file-system-section {
            padding: var(--space-8);
            background: var(--surface);
            border-radius: var(--radius-2xl);
            border: 2px solid var(--border);
            margin: var(--space-6) 0;
        }

        .file-system-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-6);
            padding-bottom: var(--space-4);
            border-bottom: 2px solid var(--border);
        }

        .file-system-title {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .file-system-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-4);
            margin-bottom: var(--space-6);
        }

        .status-card {
            background: var(--surface-elevated);
            border: 2px solid var(--border);
            border-radius: var(--radius-xl);
            padding: var(--space-4);
            text-align: center;
            transition: var(--transition-base);
        }

        .status-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .status-card-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: var(--space-2);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .status-card-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .file-system-controls {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-4);
            margin-bottom: var(--space-6);
            padding: var(--space-4);
            background: var(--background);
            border-radius: var(--radius-xl);
            border: 2px solid var(--border);
        }

        .control-group {
            display: flex;
            gap: var(--space-2);
            align-items: center;
        }

        .file-system-search {
            flex: 1;
            min-width: 200px;
            padding: var(--space-3) var(--space-4);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            background: var(--surface);
            font-size: 1rem;
            transition: var(--transition-base);
        }

        .file-system-search:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-alpha);
        }

        .view-toggle {
            display: flex;
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            overflow: hidden;
            background: var(--surface);
        }

        .view-toggle button {
            padding: var(--space-3) var(--space-4);
            border: none;
            background: transparent;
            cursor: pointer;
            font-weight: 600;
            transition: var(--transition-base);
            color: var(--text-secondary);
        }

        .view-toggle button.active,
        .view-toggle button:hover {
            background: var(--primary);
            color: white;
        }

        .file-system-images {
            margin-bottom: var(--space-6);
        }

        .images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--space-4);
            padding: var(--space-4);
            background: var(--background);
            border-radius: var(--radius-xl);
            border: 2px solid var(--border);
            max-height: 600px;
            overflow-y: auto;
        }

        .image-item {
            position: relative;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            overflow: hidden;
            transition: var(--transition-base);
            cursor: pointer;
        }

        .image-item:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .image-item.selected {
            border-color: var(--primary);
            background: var(--primary-alpha);
        }

        .image-item img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            display: block;
        }

        .image-info {
            padding: var(--space-3);
        }

        .image-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-1);
            font-size: 0.875rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .image-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }

        .selection-checkbox {
            position: absolute;
            top: var(--space-2);
            right: var(--space-2);
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .file-system-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-4);
            background: var(--surface-elevated);
            border-radius: var(--radius-xl);
            border: 2px solid var(--border);
        }

        .selection-summary {
            font-weight: 600;
            color: var(--text-primary);
        }

        .action-buttons {
            display: flex;
            gap: var(--space-2);
        }

        .send-to-section {
            padding: var(--space-2) var(--space-4);
            border: 2px solid var(--border);
            border-radius: var(--radius-lg);
            background: var(--surface);
            cursor: pointer;
            font-weight: 600;
            transition: var(--transition-base);
            color: var(--text-primary);
        }

        .send-to-section:hover {
            border-color: var(--primary);
            background: var(--primary-alpha);
            color: var(--primary-dark);
        }

        .no-images-message {
            text-align: center;
            padding: var(--space-8);
            color: var(--text-secondary);
            font-style: italic;
        }

        .file-system-loading {
            text-align: center;
            padding: var(--space-8);
            color: var(--text-secondary);
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
            margin-right: var(--space-2);
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Smart Filters Styles */
        .smart-filters {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border: 2px solid #cbd5e1;
            border-radius: 12px;
            padding: 16px;
            margin: 12px 0;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .smart-filters select {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            color: #475569;
            min-width: 160px;
            transition: all 0.3s ease;
        }

        .smart-filters select:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
            outline: none;
        }

        .tree-toggle {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            font-weight: 500;
        }

        .tree-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        /* Folder Tree Styles */
        .filesystem-tree-container {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            margin: 16px 0;
            overflow: hidden;
        }

        .tree-header {
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            padding: 16px;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tree-header h3 {
            margin: 0;
            color: #1e293b;
            font-size: 18px;
            font-weight: 600;
        }

        .tree-stats {
            color: #64748b;
            font-size: 14px;
        }

        .tree-content {
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
        }

        .tree-folder {
            margin: 8px 0;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
        }

        .folder-header {
            background: #f8fafc;
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s ease;
        }

        .folder-header:hover {
            background: #f1f5f9;
        }

        .folder-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .folder-name {
            font-weight: 500;
            color: #1e293b;
        }

        .folder-count {
            background: #3b82f6;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .folder-toggle {
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .folder-toggle.expanded {
            transform: rotate(90deg);
        }

        .folder-content {
            padding: 12px 16px;
            background: white;
            border-top: 1px solid #e2e8f0;
            display: none;
        }

        .folder-content.expanded {
            display: block;
        }

        .folder-image-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
        }

        .folder-image-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .folder-image-item:hover {
            transform: scale(1.05);
        }

        .folder-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .folder-image-category {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }

        /* Image Tags Styles */
        .image-tags {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .folder-tag, .category-tag {
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            color: #475569;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            border: 1px solid #cbd5e1;
            transition: all 0.2s ease;
        }

        .folder-tag:hover, .category-tag:hover {
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
            transform: scale(1.05);
        }

        .folder-tag {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            color: #1e40af;
            border-color: #93c5fd;
        }

        .category-tag {
            background: linear-gradient(135deg, #fef3c7 0%, #fed7aa 100%);
            color: #d97706;
            border-color: #fbbf24;
        }

        /* Responsive adjustments for File System */
        @media (max-width: 768px) {
            .file-system-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                justify-content: center;
            }

            .file-system-search {
                width: 100%;
            }

            .images-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }

            .file-system-actions {
                flex-direction: column;
                gap: var(--space-4);
                align-items: stretch;
            }
        }

        /* ==== NEW FILE SYSTEM REDESIGN STYLES ==== */
        .fs-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 24px;
            max-width: 100%;
            min-height: calc(100vh - 200px);
        }

        /* Header */
        .fs-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e5e7eb;
        }

        .fs-title h2 {
            font-size: 24px;
            font-weight: 700;
            color: #1f2937;
            margin: 0 0 4px 0;
            line-height: 1.2;
        }

        .fs-subtitle {
            font-size: 14px;
            color: #6b7280;
            margin: 0;
        }

        .fs-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .status-indicator {
            font-size: 12px;
            transition: color 0.3s ease;
        }

        .fs-status.disconnected .status-indicator { color: #ef4444; }
        .fs-status.connected .status-indicator { color: #10b981; }
        .fs-status.scanning .status-indicator { color: #f59e0b; }

        /* Directory Card */
        .fs-directory-card {
            background: #ffffff;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 24px;
            transition: all 0.3s ease;
        }

        .fs-directory-card:hover {
            border-color: #d1d5db;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .dir-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            margin-bottom: 16px;
        }

        .dir-info {
            flex: 1;
            min-width: 0;
        }

        .dir-name {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 4px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dir-path {
            font-size: 14px;
            color: #6b7280;
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dir-actions {
            display: flex;
            gap: 12px;
            flex-shrink: 0;
        }

        .fs-btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            text-align: center;
            white-space: nowrap;
        }

        .fs-btn.primary {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .fs-btn.primary:hover:not(:disabled) {
            background: #2563eb;
            border-color: #2563eb;
            transform: translateY(-1px);
        }

        .fs-btn.secondary {
            background: #f3f4f6;
            color: #374151;
            border-color: #d1d5db;
        }

        .fs-btn.secondary:hover:not(:disabled) {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        .fs-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .dir-stats {
            display: flex;
            gap: 24px;
            padding-top: 16px;
            border-top: 1px solid #e5e7eb;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            flex: 1;
        }

        .stat-number {
            font-size: 20px;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Toolbar */
        .fs-toolbar {
            display: flex;
            gap: 20px;
            align-items: center;
            padding: 16px 20px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
        }

        .toolbar-left, .toolbar-center, .toolbar-right {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .toolbar-left { flex: 1; }
        .toolbar-center { flex: 1; justify-content: center; }
        .toolbar-right { flex: 1; justify-content: flex-end; }

        .search-container {
            position: relative;
            flex: 1;
            max-width: 300px;
        }

        .fs-search {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            transition: border-color 0.2s ease;
        }

        .fs-search:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .fs-search:disabled {
            background: #f3f4f6;
            color: #9ca3af;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            margin-top: 2px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }

        .fs-select {
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s ease;
        }

        .fs-select:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .fs-select:disabled {
            background: #f3f4f6;
            color: #9ca3af;
            cursor: not-allowed;
        }

        .view-controls {
            display: flex;
            background: white;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            overflow: hidden;
        }

        .view-btn {
            padding: 8px 12px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            border-right: 1px solid #e5e7eb;
        }

        .view-btn:last-child {
            border-right: none;
        }

        .view-btn:hover {
            background: #f3f4f6;
        }

        .view-btn.active {
            background: #3b82f6;
            color: white;
        }

        .size-control {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #6b7280;
        }

        .size-control input[type="range"] {
            width: 80px;
        }

        /* Content Area */
        .fs-content {
            flex: 1;
            display: flex;
            gap: 20px;
            min-height: 400px;
        }

        .fs-tree-view {
            width: 300px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            flex-shrink: 0;
        }

        .tree-header h4 {
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 8px 0;
        }

        .tree-stats {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 16px;
        }

        .tree-content {
            max-height: 500px;
            overflow-y: auto;
        }

        .fs-images-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .fs-images-grid {
            flex: 1;
            padding: 20px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            min-height: 400px;
            overflow-y: auto;
        }

        /* Override for organized view - remove grid from main container */
        .fs-images-grid:has(.fs-organized-view) {
            display: block !important;
            grid-template-columns: none !important;
        }

        .fs-images-grid .fs-organized-view {
            display: flex !important;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        .fs-empty-state {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
            color: #6b7280;
        }

        .empty-visual {
            font-size: 48px;
            color: #d1d5db;
            margin-bottom: 16px;
        }

        .fs-empty-state h3 {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
            margin: 0 0 8px 0;
        }

        .fs-empty-state p {
            font-size: 14px;
            margin: 0 0 24px 0;
            max-width: 300px;
        }

        /* Selection Bar */
        .fs-selection-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            border-radius: 8px;
            gap: 20px;
        }

        .selection-info {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .selection-text {
            font-size: 14px;
            color: #0c4a6e;
            font-weight: 500;
        }

        .selection-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 6px 12px;
            background: #0ea5e9;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .action-btn:hover {
            background: #0284c7;
            transform: translateY(-1px);
        }

        .action-btn.secondary {
            background: #64748b;
        }

        .action-btn.secondary:hover {
            background: #475569;
        }

        /* File System Responsive */
        @media (max-width: 1024px) {
            .fs-toolbar {
                flex-direction: column;
                gap: 12px;
            }

            .toolbar-left, .toolbar-center, .toolbar-right {
                width: 100%;
                justify-content: center;
            }

            .fs-content {
                flex-direction: column;
            }

            .fs-tree-view {
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .fs-container {
                padding: 16px;
                gap: 16px;
            }

            .fs-header {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }

            .dir-main {
                flex-direction: column;
                gap: 16px;
                align-items: stretch;
            }

            .dir-actions {
                width: 100%;
                justify-content: center;
            }

            .dir-stats {
                gap: 16px;
            }

            .fs-images-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 12px;
                padding: 16px;
            }

            .selection-actions {
                width: 100%;
                justify-content: center;
            }
        }

        /* File System Image Items */
        .fs-image-item {
            position: relative;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .fs-image-item:hover {
            border-color: #3b82f6;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .fs-image-item.selected {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .fs-image-preview {
            position: relative;
            aspect-ratio: 1;
            overflow: hidden;
        }

        .fs-image-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.2s ease;
        }

        .fs-image-item:hover .fs-image-preview img {
            transform: scale(1.05);
        }

        .fs-checkbox {
            position: absolute;
            top: 8px;
            left: 8px;
            z-index: 2;
            width: 18px;
            height: 18px;
            accent-color: #3b82f6;
        }

        .fs-image-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .fs-image-item:hover .fs-image-overlay {
            opacity: 1;
        }

        .fs-image-actions {
            display: flex;
            gap: 8px;
        }

        .fs-action-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .fs-action-btn:hover {
            background: white;
        }

        .fs-image-info {
            padding: 8px;
        }

        .fs-image-name {
            font-size: 12px;
            font-weight: 500;
            color: #1f2937;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .fs-image-meta {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #6b7280;
        }

        .fs-size {
            font-weight: 500;
        }

        .fs-category {
            text-transform: capitalize;
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* File System Folder Organization Styles */
        .fs-organized-view {
            display: flex !important;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 100%;
        }

        .fs-folder-section {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .fs-folder-section:hover {
            border-color: #d1d5db;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .fs-folder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }

        .fs-folder-info {
            flex: 1;
        }

        .fs-folder-name {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0 0 4px 0;
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
        }

        .fs-folder-icon {
            font-size: 16px;
            color: #3b82f6;
            font-weight: 600;
            margin-right: 4px;
        }

        .fs-folder-stats {
            display: flex;
            gap: 16px;
            font-size: 12px;
            color: #6b7280;
        }

        .fs-folder-count {
            font-weight: 500;
        }

        .fs-folder-size {
            color: #9ca3af;
        }

        .fs-folder-actions {
            display: flex;
            gap: 8px;
        }

        .fs-folder-btn {
            padding: 6px 12px;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .fs-folder-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        .fs-folder-btn.collapse {
            min-width: 28px;
            padding: 6px;
            text-align: center;
            font-weight: 700;
        }

        .fs-folder-content {
            padding: 20px;
        }

        .fs-folder-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 16px;
            align-content: start;
        }

        /* Responsive adjustments for folder view */
        @media (max-width: 768px) {
            .fs-folder-header {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start;
            }

            .fs-folder-actions {
                width: 100%;
                justify-content: flex-end;
            }

            .fs-folder-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 12px;
            }

            .fs-folder-content {
                padding: 16px;
            }
        }

        /* ============================================
           SK316 CALIBRATION SYSTEM STYLES
           ============================================ */

        .sk316-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px;
        }

        .sk316-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #f59e0b;
        }

        .sk316-title h2 {
            margin: 0 0 8px 0;
            color: #0c4a6e;
            font-size: 1.8em;
        }

        .sk316-subtitle {
            color: #64748b;
            font-size: 0.95em;
        }

        .status-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .status-badge.active {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }

        .status-badge.inactive {
            background: #e2e8f0;
            color: #64748b;
        }

        /* Profile Selector */
        .sk316-profile-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-radius: 12px;
            border: 2px solid #f59e0b;
        }

        .sk316-profile-selector label {
            font-weight: 700;
            color: #92400e;
            min-width: 100px;
        }

        .sk316-select {
            flex: 1;
            padding: 10px 14px;
            border: 2px solid #f59e0b;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .sk316-select:hover {
            border-color: #d97706;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.2);
        }

        .sk316-select:focus {
            outline: none;
            border-color: #d97706;
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.1);
        }

        /* Cards */
        .sk316-card {
            margin-bottom: 30px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        .sk316-card:hover {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .sk316-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            color: white;
        }

        .sk316-card-header h3 {
            margin: 0;
            font-size: 1.3em;
        }

        .step-badge {
            padding: 6px 14px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.85em;
        }

        .step-badge.optional {
            background: rgba(251, 191, 36, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .sk316-card-content {
            padding: 24px;
        }

        /* Gutter Test Specific Styles */
        .gutter-test-card .sk316-card-header {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .gutter-test-config {
            margin-top: 20px;
        }

        .gutter-test-config .config-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .gutter-range-config {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border: 2px solid #fbbf24;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .gutter-range-config h4 {
            margin: 0 0 16px 0;
            color: #92400e;
            font-size: 1.05em;
        }

        .range-inputs {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 12px;
        }

        .range-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .range-item label {
            font-weight: 600;
            color: #92400e;
            font-size: 0.9em;
            min-width: 40px;
        }

        .sk316-input.small {
            width: 70px;
            padding: 8px 10px;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 600;
            text-align: center;
        }

        .range-item .unit {
            color: #92400e;
            font-size: 0.85em;
            font-weight: 600;
        }

        .test-preview {
            padding: 12px 16px;
            background: white;
            border-radius: 8px;
            border: 2px dashed #fbbf24;
            color: #92400e;
            font-size: 0.95em;
            text-align: center;
        }

        .test-preview strong {
            color: #b45309;
        }

        /* Gutter Selection */
        .gutter-selection {
            margin-top: 24px;
        }

        .selection-divider {
            height: 2px;
            background: linear-gradient(to right, transparent, #e2e8f0, transparent);
            margin: 24px 0;
        }

        .gutter-selection h4 {
            color: #0c4a6e;
            margin-bottom: 16px;
            font-size: 1.05em;
        }

        .gutter-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .gutter-option {
            padding: 16px 12px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .gutter-option:hover {
            border-color: #0ea5e9;
            background: #f0f9ff;
            transform: translateY(-2px);
        }

        .gutter-option.selected {
            border-color: #22c55e;
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.2);
        }

        .gutter-option .value {
            font-size: 1.4em;
            font-weight: 700;
            color: #0c4a6e;
            margin-bottom: 4px;
        }

        .gutter-option.selected .value {
            color: #16a34a;
        }

        .gutter-option .label {
            font-size: 0.8em;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .gutter-option.selected .label {
            color: #15803d;
            font-weight: 600;
        }

        .selected-gutter-display {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border: 2px solid #22c55e;
            border-radius: 10px;
        }

        .selected-gutter-display .selected-label {
            font-weight: 600;
            color: #15803d;
            font-size: 0.95em;
        }

        .selected-gutter-display .selected-value {
            font-size: 1.3em;
            font-weight: 700;
            color: #16a34a;
        }

        .sk316-btn.small {
            padding: 6px 14px;
            font-size: 0.85em;
        }

        /* Config Row */
        .sk316-config-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .config-item label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #0c4a6e;
            font-size: 0.9em;
        }

        /* Instructions */
        .sk316-instructions {
            display: flex;
            gap: 12px;
            padding: 16px;
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border-left: 4px solid #0ea5e9;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .instruction-icon {
            font-size: 1.5em;
            flex-shrink: 0;
        }

        .instruction-text {
            color: #0c4a6e;
            font-size: 0.9em;
            line-height: 1.6;
        }

        /* Buttons */
        .sk316-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .sk316-btn.primary {
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
        }

        .sk316-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(14, 165, 233, 0.4);
        }

        .sk316-btn.secondary {
            background: white;
            color: #0284c7;
            border: 2px solid #0ea5e9;
        }

        .sk316-btn.secondary:hover {
            background: #f0f9ff;
            border-color: #0284c7;
        }

        .sk316-btn.large {
            padding: 14px 28px;
            font-size: 1.05em;
        }

        .sk316-btn .svg-icon {
            width: 20px;
            height: 20px;
        }

        /* Table */
        .sk316-table-container {
            max-height: 500px;
            overflow-y: auto;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            margin-bottom: 16px;
        }

        .sk316-table {
            width: 100%;
            border-collapse: collapse;
        }

        .sk316-table thead {
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            color: white;
            z-index: 1;
        }

        .sk316-table th {
            padding: 14px;
            text-align: left;
            font-weight: 700;
            font-size: 0.9em;
        }

        .sk316-table tbody tr {
            border-bottom: 1px solid #e2e8f0;
            transition: background 0.2s ease;
        }

        .sk316-table tbody tr:hover {
            background: #f0f9ff;
        }

        .sk316-table td {
            padding: 12px 14px;
        }

        .sk316-table td:first-child {
            font-weight: 700;
            color: #0c4a6e;
        }

        .sk316-table input {
            width: 100%;
            padding: 8px;
            border: 2px solid #cbd5e1;
            border-radius: 6px;
            font-size: 0.9em;
            text-align: center;
            font-weight: 600;
        }

        .sk316-table input:focus {
            outline: none;
            border-color: #0ea5e9;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
        }

        .sk316-table-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        /* Heatmap */
        .sk316-heatmap-container {
            margin-bottom: 24px;
        }

        .sk316-heatmap-container h4 {
            margin: 0 0 16px 0;
            color: #0c4a6e;
        }

        .sk316-heatmap {
            display: grid;
            gap: 8px;
            margin-bottom: 16px;
        }

        .sk316-heatmap.grid-5x5 {
            grid-template-columns: repeat(5, 1fr);
        }

        .sk316-heatmap.grid-4x4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .sk316-heatmap.grid-3x3 {
            grid-template-columns: repeat(3, 1fr);
        }

        .heatmap-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-weight: 700;
            font-size: 0.85em;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease;
        }

        .heatmap-cell:hover {
            transform: scale(1.05);
            z-index: 1;
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.85em;
            color: #64748b;
        }

        .legend-gradient {
            flex: 1;
            height: 20px;
            background: linear-gradient(to right, #22c55e, #f59e0b, #ef4444);
            border-radius: 4px;
        }

        /* Statistics */
        .sk316-statistics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            padding: 20px;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            display: block;
            font-size: 0.85em;
            color: #92400e;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .stat-value {
            display: block;
            font-size: 1.4em;
            font-weight: 700;
            color: #78350f;
        }

        /* Save Section */
        .sk316-save-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .save-input-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .save-input-group label {
            font-weight: 600;
            color: #0c4a6e;
            min-width: 100px;
        }

        .sk316-input {
            flex: 1;
            padding: 12px;
            border: 2px solid #cbd5e1;
            border-radius: 8px;
            font-size: 0.95em;
        }

        .sk316-input:focus {
            outline: none;
            border-color: #0ea5e9;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
        }

        .save-actions {
            display: flex;
            justify-content: center;
            gap: 16px;
        }

        /* Profiles List */
        .sk316-profiles-list {
            margin-top: 40px;
            padding: 24px;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border-radius: 16px;
            border: 2px solid #22c55e;
        }

        .sk316-profiles-list h3 {
            margin: 0 0 20px 0;
            color: #14532d;
        }

        .profiles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
        }

        .profile-card {
            padding: 16px;
            background: white;
            border: 2px solid #86efac;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .profile-card:hover {
            border-color: #22c55e;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.2);
            transform: translateY(-2px);
        }

        .profile-card.active {
            border-color: #16a34a;
            box-shadow: 0 4px 16px rgba(22, 163, 74, 0.3);
        }

        .profile-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .profile-name {
            font-weight: 700;
            color: #14532d;
            font-size: 1.1em;
        }

        .profile-meta {
            font-size: 0.85em;
            color: #64748b;
            margin-bottom: 8px;
        }

        .profile-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .profile-action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.8em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .profile-action-btn.use {
            background: #22c55e;
            color: white;
        }

        .profile-action-btn.delete {
            background: #ef4444;
            color: white;
        }

        .profile-action-btn.export {
            background: #0ea5e9;
            color: white;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sk316-config-row {
                grid-template-columns: 1fr;
            }

            .sk316-statistics {
                grid-template-columns: 1fr;
            }

            .save-input-group {
                flex-direction: column;
                align-items: stretch;
            }

            .save-input-group label {
                min-width: auto;
            }

            .save-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- SVG Icons Sprite -->
    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
        <defs>
            <!-- Camera Icon -->
            <symbol id="icon-camera" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                <circle cx="12" cy="13" r="4"></circle>
            </symbol>

            <!-- ID Card Icon -->
            <symbol id="icon-id-card" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="2" y="4" width="20" height="16" rx="2"></rect>
                <circle cx="8" cy="11" r="2"></circle>
                <path d="M14 10h4M14 14h4M8 15c-1 0-2-1-2-2"></path>
            </symbol>

            <!-- Photo Icon -->
            <symbol id="icon-photo" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
            </symbol>

            <!-- Square Icon -->
            <symbol id="icon-square" viewBox="0 0 24 24" fill="currentColor">
                <rect x="4" y="4" width="16" height="16" rx="2"></rect>
            </symbol>

            <!-- Settings Icon -->
            <symbol id="icon-settings" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M12 1v6m0 6v10M1 12h6m6 0h10"></path>
            </symbol>

            <!-- Folder Icon -->
            <symbol id="icon-folder" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
            </symbol>

            <!-- Target Icon -->
            <symbol id="icon-target" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <circle cx="12" cy="12" r="6"></circle>
                <circle cx="12" cy="12" r="2"></circle>
            </symbol>

            <!-- Ruler Icon -->
            <symbol id="icon-ruler" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 3l18 18M3 3v18M21 3v18M3 21h18M7 3v4M11 3v4M15 3v4M19 3v4"></path>
            </symbol>

            <!-- Scissors Icon -->
            <symbol id="icon-scissors" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="6" cy="6" r="3"></circle>
                <circle cx="6" cy="18" r="3"></circle>
                <line x1="20" y1="4" x2="8.12" y2="15.88"></line>
                <line x1="14.47" y1="14.48" x2="20" y2="20"></line>
                <line x1="8.12" y1="8.12" x2="12" y2="12"></line>
            </symbol>

            <!-- Reset Icon -->
            <symbol id="icon-reset" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path>
                <path d="M21 3v5h-5"></path>
                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path>
                <path d="M3 21v-5h5"></path>
            </symbol>

            <!-- Eye Icon -->
            <symbol id="icon-eye" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </symbol>

            <!-- Printer Icon -->
            <symbol id="icon-printer" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="6 9 6 2 18 2 18 9"></polyline>
                <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path>
                <rect x="6" y="14" width="12" height="8"></rect>
            </symbol>

            <!-- Document Duplex Icon -->
            <symbol id="icon-document-duplex" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="9" y1="15" x2="15" y2="15"></line>
                <line x1="9" y1="12" x2="15" y2="12"></line>
            </symbol>

            <!-- Robot Icon -->
            <symbol id="icon-robot" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="11" width="18" height="10" rx="2"></rect>
                <circle cx="12" cy="5" r="2"></circle>
                <path d="M12 7v4"></path>
                <line x1="8" y1="16" x2="8" y2="16"></line>
                <line x1="16" y1="16" x2="16" y2="16"></line>
            </symbol>

            <!-- Swap Icon -->
            <symbol id="icon-swap" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="17 1 21 5 17 9"></polyline>
                <path d="M3 11V9a4 4 0 0 1 4-4h14"></path>
                <polyline points="7 23 3 19 7 15"></polyline>
                <path d="M21 13v2a4 4 0 0 1-4 4H3"></path>
            </symbol>

            <!-- Trash Icon -->
            <symbol id="icon-trash" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </symbol>

            <!-- Undo Icon -->
            <symbol id="icon-undo" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 7v6h6"></path>
                <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path>
            </symbol>

            <!-- Redo Icon -->
            <symbol id="icon-redo" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 7v6h-6"></path>
                <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"></path>
            </symbol>

            <!-- Balance Icon -->
            <symbol id="icon-balance" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="3" x2="12" y2="21"></line>
                <path d="M8 9l-5 7h10L8 9zM16 9l-5 7h10l-5-7z"></path>
            </symbol>

            <!-- Clean/Broom Icon -->
            <symbol id="icon-clean" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 3v18"></path>
                <path d="M7 5v14a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V5"></path>
                <path d="M16 3H8"></path>
            </symbol>

            <!-- Upload Icon -->
            <symbol id="icon-upload" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </symbol>

            <!-- Document Icon -->
            <symbol id="icon-document" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </symbol>

            <!-- Rotate/Refresh Icon -->
            <symbol id="icon-rotate" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </symbol>

            <!-- Book Open Icon (for duplex) -->
            <symbol id="icon-book-open" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
            </symbol>

            <!-- Files Icon (for file folder) -->
            <symbol id="icon-files" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path>
                <polyline points="13 2 13 9 20 9"></polyline>
            </symbol>

            <!-- Light Bulb Icon -->
            <symbol id="icon-lightbulb" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 18h6"></path>
                <path d="M10 22h4"></path>
                <path d="M15.09 14c.18-.98.65-1.74 1.41-2.5A4.65 4.65 0 0 0 18 8 6 6 0 0 0 6 8c0 1 .23 2.23 1.5 3.5A4.61 4.61 0 0 1 8.91 14"></path>
            </symbol>

            <!-- Zap/Lightning Icon -->
            <symbol id="icon-zap" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
            </symbol>

            <!-- Box Icon (for contain/fit) -->
            <symbol id="icon-box" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                <line x1="12" y1="22.08" x2="12" y2="12"></line>
            </symbol>

            <!-- Plus Icon -->
            <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </symbol>

            <!-- Download Icon -->
            <symbol id="icon-download" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </symbol>

            <!-- Inbox Icon -->
            <symbol id="icon-inbox" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline>
                <path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>
            </symbol>

            <!-- Copy Icon -->
            <symbol id="icon-copy" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </symbol>

            <!-- Edit Icon -->
            <symbol id="icon-edit" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </symbol>

            <!-- Save Icon -->
            <symbol id="icon-save" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                <polyline points="7 3 7 8 15 8"></polyline>
            </symbol>

            <!-- Image Icon -->
            <symbol id="icon-image" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
            </symbol>

            <!-- File Icon (alternative document) -->
            <symbol id="icon-file" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path>
                <polyline points="13 2 13 9 20 9"></polyline>
            </symbol>

            <!-- Pages/Layers Icon -->
            <symbol id="icon-layers" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="12 2 2 7 12 12 22 7 12 2"></polygon>
                <polyline points="2 17 12 22 22 17"></polyline>
                <polyline points="2 12 12 17 22 12"></polyline>
            </symbol>

            <!-- Arrow Right Icon -->
            <symbol id="icon-arrow-right" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="5" y1="12" x2="19" y2="12"></line>
                <polyline points="12 5 19 12 12 19"></polyline>
            </symbol>

            <!-- Refresh/Repeat Icon -->
            <symbol id="icon-refresh" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </symbol>

        </defs>
    </svg>

    <div class="container">
        <div class="header">
            <div class="header-content">
                <div class="header-branding">
                    <h1>MEU Layout</h1>
                    <p class="header-subtitle">Image Processing Tool</p>
                </div>
                <div class="filesystem-permission-area">
                    <button id="filesystemPermissionBtn" class="filesystem-permission-btn" title="C·∫•p quy·ªÅn l∆∞u tr·ªØ file system">
                        <span class="permission-icon">üìÅ</span>
                        <span class="permission-text">File System</span>
                        <span class="permission-status" id="permissionStatus">‚ùå</span>
                    </button>
                    <button id="clearAllDataBtn" class="filesystem-permission-btn" title="X√≥a to√†n b·ªô d·ªØ li·ªáu trong LocalStorage">
                        <span class="permission-icon">üóëÔ∏è</span>
                        <span class="permission-text">X√≥a D·ªØ Li·ªáu</span>
                    </button>
                    <div class="permission-info" id="permissionInfo">
                        <div class="info-content">
                            <div class="info-icon">‚ÑπÔ∏è</div>
                            <div class="info-text">
                                <strong>Ch∆∞a c·∫•p quy·ªÅn</strong><br>
                                Nh·∫•n ƒë·ªÉ ch·ªçn th∆∞ m·ª•c l∆∞u d·ªØ li·ªáu
                            </div>
                            <div class="custom-presets-block">
                                <div class="custom-presets-header">
                                    <span>Preset tuy chinh</span>
                                    <button class="save-custom-btn" id="saveCustomPresetBtn" type="button">+ Luu preset</button>
                                </div>
                                <div class="preset-pills-row custom-presets-list" id="customPresetsList">
                                    <span class="custom-presets-empty" id="customPresetsEmpty">Chua co preset</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <!-- Function Tabs -->
            <div class="function-tabs">
                <button class="tab-button active animate-slideUp" id="convertTab">
                    <span class="tab-icon">üîÑ</span>
                    <span class="tab-text">Convert Files</span>
                </button>
                <button class="tab-button animate-slideUp animate-delay-75" id="cropTab">
                    <span class="tab-icon">‚úÇ</span>
                    <span class="tab-text">Template Crop</span>
                </button>
                <button class="tab-button animate-slideUp animate-delay-150" id="templatesTab">
                    <span class="tab-icon">‚óà</span>
                    <span class="tab-text">Templates</span>
                </button>
                <button class="tab-button animate-slideUp animate-delay-200" id="galleryTab">
                    <span class="tab-icon">üñºÔ∏è</span>
                    <span class="tab-text">Kho ·∫¢nh</span>
                </button>
                <button class="tab-button animate-slideUp animate-delay-300" id="printTab">
                    <span class="tab-icon">üñ®Ô∏è</span>
                    <span class="tab-text">File in</span>
                </button>
                <button class="tab-button animate-slideUp animate-delay-400" id="filesystemTab">
                    <span class="tab-icon">üìÅ</span>
                    <span class="tab-text">File System</span>
                </button>
                <button class="tab-button animate-slideUp animate-delay-500" id="sk316Tab">
                    <span class="tab-icon">üéØ</span>
                    <span class="tab-text">SK316</span>
                </button>
            </div>

            <!-- Convert Section -->
            <div class="function-section active" id="convertSection">
                <!-- Header -->
                <div class="section-header">
                    <h2>Chuy·ªÉn ƒë·ªïi ƒë·ªãnh d·∫°ng ·∫£nh</h2>
                    <p>Chuy·ªÉn ƒë·ªïi ƒë·ªãnh d·∫°ng ·∫£nh</p>
                </div>

                <!-- Convert Content -->
                <div class="convert-content">
                    <!-- Enhanced Upload Zone for Convert -->
                    <div class="convert-upload-zone" id="convertUploadZone">
                        <div class="upload-content">
                            <div class="upload-visual">
                                <div class="upload-indicator">‚áÑ</div>
                                <div class="upload-title">Chuy·ªÉn ƒë·ªïi ƒë·ªãnh d·∫°ng ·∫£nh</div>
                            </div>
                            <div class="upload-details">
                                <div class="supported-formats">
                                    <span class="format-label">‚ñ∏ H·ªó tr·ª£:</span>
                                    <div class="format-list">
                                        <span class="format-item">PDF</span>
                                        <span class="format-item">PNG</span>
                                        <span class="format-item">JPG</span>
                                        <span class="format-item">WEBP</span>
                                        <span class="format-item">BMP</span>
                                        <span class="format-item">HEIC</span>
                                    </div>
                                </div>
                                <div class="upload-instruction">K√©o th·∫£ file ho·∫∑c nh·∫•n ƒë·ªÉ ch·ªçn</div>
                            </div>
                        </div>
                    </div>
                    <input type="file" id="convertFileInput" class="file-input" multiple>

                    <!-- üìÇ File System Button for Convert -->
                    <div class="filesystem-section">
                        <button class="filesystem-action-btn" id="convertFromFileSystemBtn" onclick="loadImagesFromFileSystem('convert')">
                            <span class="filesystem-icon">üìÅ</span>
                            <span class="filesystem-text">T·ª´ File System</span>
                            <span class="filesystem-subtitle">Ch·ªçn ·∫£nh t·ª´ th∆∞ m·ª•c ƒë√£ c·∫•p quy·ªÅn</span>
                        </button>
                    </div>

                    <!-- Legacy file input for backward compatibility -->
                    <input type="file" id="fileInput" class="file-input" multiple style="display: none;">

                    <!-- Enhanced Stats -->
                    <div class="convert-stats">
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="stat-indicator">‚â°</div>
                                <div class="stat-content">
                                    <div class="stat-number" id="totalFiles">0</div>
                                    <div class="stat-label">T·ªïng file</div>
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-indicator">‚úì</div>
                                <div class="stat-content">
                                    <div class="stat-number" id="convertedFiles">0</div>
                                    <div class="stat-label">ƒê√£ chuy·ªÉn ƒë·ªïi</div>
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-indicator">‚ñ§</div>
                                <div class="stat-content">
                                    <div class="stat-number" id="totalSize">0 MB</div>
                                    <div class="stat-label">Dung l∆∞·ª£ng</div>
                                </div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-indicator">%</div>
                                <div class="stat-content">
                                    <div class="stat-number" id="successRate">0%</div>
                                    <div class="stat-label">Th√†nh c√¥ng</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Enhanced Controls -->
                    <div class="convert-controls">
                        <div class="controls-section">
                            <div class="section-header">
                                <h3>‚öô C√†i ƒë·∫∑t chuy·ªÉn ƒë·ªïi</h3>
                            </div>
                            
                            <div class="controls-grid">
                                <div class="control-item">
                                    <label class="control-label">
                                        <span class="label-indicator">‚ñ∏</span>
                                        ƒê·ªãnh d·∫°ng xu·∫•t
                                    </label>
                                    <select id="outputFormat" class="control-select">
                                        <option value="auto">‚óØ T·ª± ƒë·ªông (Khuy·∫øn ngh·ªã)</option>
                                        <option value="png" selected>‚óØ PNG (Lossless - Kh√¥ng m·∫•t ch·∫•t l∆∞·ª£ng)</option>
                                        <option value="jpeg">‚óØ JPG (C√≥ n√©n nh·∫π - File nh·ªè h∆°n)</option>
                                        <option value="webp">‚óØ WebP (Hi·ªán ƒë·∫°i)</option>
                                        <option value="bmp">‚óØ BMP (Kh√¥ng n√©n - File r·∫•t l·ªõn)</option>
                                    </select>
                                </div>

                                <!-- Ch·∫•t l∆∞·ª£ng ƒë∆∞·ª£c set m·∫∑c ƒë·ªãnh 100% t·ªëi ƒëa, kh√¥ng th·ªÉ thay ƒë·ªïi ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng cao tuy·ªát ƒë·ªëi t·ª´ file g·ªëc -->
                                <!-- Quality control hidden - always set to maximum for perfect quality preservation -->
                                <input type="hidden" id="quality" value="100">

                                <!-- PDF Conversion Settings - Hi·ªÉn th·ªã khi c√≥ file PDF -->
                                <div class="control-item" id="pdfSettingsContainer" style="display: none;">
                                    <label class="control-label">
                                        <span class="label-indicator">‚ñ∏</span>
                                        C√†i ƒë·∫∑t PDF
                                    </label>
                                    <div style="display: flex; flex-direction: column; gap: 10px;">
                                        <select id="pdfPageSelection" class="control-select">
                                            <option value="all" selected>‚óØ T·∫•t c·∫£ trang</option>
                                            <option value="first">‚óØ Ch·ªâ trang ƒë·∫ßu</option>
                                            <option value="range">‚óØ Kho·∫£ng trang</option>
                                        </select>
                                        <input type="text" id="pdfPageRange" class="prefix-input" placeholder="VD: 1-5, 7, 9-12" style="display: none;">
                                        <select id="pdfDPI" class="control-select">
                                            <option value="300" selected>‚óØ 300 DPI - Ch·∫•t l∆∞·ª£ng in ·∫•n (Khuy·∫øn ngh·ªã)</option>
                                            <option value="600">‚óØ 600 DPI - Ch·∫•t l∆∞·ª£ng cao</option>
                                            <option value="150">‚óØ 150 DPI - Web/M√†n h√¨nh</option>
                                            <option value="72">‚óØ 72 DPI - Xem nhanh (Nh·ªè nh·∫•t)</option>
                                        </select>
                                        <div style="margin-top: 8px; padding: 8px; background: #f0f9ff; border-left: 3px solid #0284c7; font-size: 12px; line-height: 1.5;">
                                            <strong>üíé H∆∞·ªõng d·∫´n ch·ªçn DPI:</strong><br>
                                            ‚Ä¢ <strong>300 DPI</strong>: ƒê·ªß cho in ·∫•n vƒÉn ph√≤ng, file ~15-30MB<br>
                                            ‚Ä¢ <strong>600 DPI</strong>: Ch·∫•t l∆∞·ª£ng cao, file ~60-120MB<br>
                                            ‚Ä¢ <strong>150 DPI</strong>: Xem tr√™n m√†n h√¨nh, file ~5-10MB<br>
                                            ‚Ä¢ <strong>Lu√¥n ch·ªçn PNG</strong> ƒë·ªÉ kh√¥ng m·∫•t ch·∫•t l∆∞·ª£ng!
                                        </div>
                                    </div>
                                </div>

                                <div class="control-item">
                                    <label class="control-label">
                                        <span class="label-indicator">‚ñ∏</span>
                                        ƒê·∫∑t t√™n file
                                    </label>
                                    <div class="naming-control">
                                        <select id="namingOption" class="control-select">
                                            <option value="keep" selected>‚óØ Gi·ªØ t√™n g·ªëc</option>
                                            <option value="add_converted">‚óØ Th√™m "_converted"</option>
                                            <option value="add_timestamp">‚óØ Th√™m timestamp</option>
                                            <option value="custom">‚óØ T√πy ch·ªânh</option>
                                        </select>
                                        <input type="text" id="customPrefix" class="prefix-input" placeholder="Nh·∫≠p ti·ªÅn t·ªë..." style="display: none;">
                                    </div>
                                </div>

                                <div class="control-item action-item">
                                    <button class="convert-action-btn" id="convertAllBtn" disabled>
                                        <span class="btn-indicator">‚ñ∂</span>
                                        B·∫Øt ƒë·∫ßu chuy·ªÉn ƒë·ªïi
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Actions -->
                    <div class="actions" id="bulkActions" style="display: none;">
                        <div class="actions-container">
                            <div class="actions-group primary-actions">
                                <button class="action-btn download" id="downloadAllBtn">üì• T·∫£i t·ª´ng file g·ªëc</button>
                                <button class="action-btn download" id="downloadZipBtn">üì¶ T·∫£i ZIP file g·ªëc</button>
                                <button class="action-btn filesystem" id="saveToFileSystemBtn">üíæ L∆∞u v√†o File System</button>
                            </div>
                            
                            <div class="actions-group tools-actions">
                                <button class="action-btn tool" id="createPdfBtn">T·∫°o PDF</button>
                                <button class="action-btn tool" id="cropImagesBtn">C·∫Øt ·∫£nh</button>
                            </div>
                            
                            <div class="actions-group utility-actions">
                                <button class="action-btn utility" id="retryFailedBtn">Th·ª≠ l·∫°i l·ªói</button>
                                <button class="action-btn utility" id="showCropResultsBtn">üìä Xem k·∫øt qu·∫£ c·∫Øt ·∫£nh</button>
                                <button class="action-btn utility clear" id="clearAllBtn">X√≥a t·∫•t c·∫£</button>
                            </div>
                        </div>
                    </div>

                    <!-- File List -->
                    <div class="file-list" id="fileList"></div>

                    <!-- Progress -->
                    <div class="progress-bar" id="progressContainer" style="display: none;">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
            </div>

            <!-- NEW Crop Tab Section - FULL cropPage -->
            <div class="function-section" id="cropTabSection">
                <!-- Full Crop Page Content -->
                <div class="crop-page" id="cropPage">
                    <div class="crop-header">
                        <div class="crop-nav">
                            <h1>C·∫Øt ·∫£nh theo k√≠ch th∆∞·ªõc</h1>
                            <div class="crop-progress">
                                <span id="cropProgressText">B∆∞·ªõc 1/3: Ch·ªçn k√≠ch th∆∞·ªõc</span>
                            </div>
                        </div>
                    </div>

                    <!-- NEW 3-COLUMN LAYOUT -->
                    <div class="crop-workspace">
                        <!-- LEFT SIDEBAR: Upload & File Management -->
                        <div class="crop-sidebar-left">
                            <div class="sidebar-section upload-section">
                                <h3>T·∫£i ·∫£nh l√™n</h3>
                                <div class="upload-area-crop" id="cropUploadZone">
                                    <div class="upload-icon-crop">‚Üë</div>
                                    <p>K√©o th·∫£ ·∫£nh v√†o ƒë√¢y ho·∫∑c nh·∫•n ƒë·ªÉ ch·ªçn</p>
                                    <input type="file" id="cropFileInput" multiple accept="image/*" style="display: none;">
                                    <button type="button" id="cropSelectFilesBtn" class="select-files-btn-crop">
                                        <span class="btn-indicator"></span>Ch·ªçn ·∫£nh
                                    </button>
                                </div>

                                <!-- üìÇ File System Button for Crop -->
                                <div class="filesystem-section">
                                    <button class="filesystem-action-btn" id="cropFromFileSystemBtn" onclick="loadImagesFromFileSystem('crop')">
                                        <span class="filesystem-icon">üìÅ</span>
                                        <span class="filesystem-text">T·ª´ File System</span>
                                        <span class="filesystem-subtitle">Ch·ªçn ·∫£nh t·ª´ th∆∞ m·ª•c ƒë√£ c·∫•p quy·ªÅn</span>
                                    </button>
                                </div>
                            </div>

                            <div class="sidebar-section files-section">
                                <div class="files-header-crop">
                                    <h3>·∫¢nh ƒë√£ t·∫£i l√™n (<span id="cropFileCount">0</span>)</h3>
                                    <button id="cropClearAllBtn" class="action-btn-crop">
                                        <span class="btn-indicator">√ó</span>X√≥a t·∫•t c·∫£
                                    </button>
                                </div>
                                <div class="files-list-crop" id="cropFilesList"></div>
                            </div>
                        </div>

                        <!-- CENTER WORKSPACE: Main Content -->
                        <div class="crop-workspace-center">
                            <!-- Size Selection - Redesigned Clean Layout -->
                            <div class="size-selection-modern">
                                <div class="size-header">
                                    <h2>Ch·ªçn k√≠ch th∆∞·ªõc c·∫Øt</h2>
                                    <p>Ch·ªçn k√≠ch th∆∞·ªõc ph√π h·ª£p cho ·∫£nh c·ªßa b·∫°n</p>
                                </div>
                                
                                <!-- Popular Sizes - Large Cards -->
                                <div class="size-categories">
                                    <!-- All Sizes in One Compact Section -->
                                    <div class="category-section all-sizes">
                                        <div class="category-header">
                                            <span class="category-indicator">üìê</span>
                                            <h3>T·∫•t c·∫£ k√≠ch th∆∞·ªõc</h3>
                                            <span class="category-count">14</span>
                                        </div>
                                        
                                        <!-- Quick Access Row -->
                                        <div class="size-row">
                                            <div class="size-option-minimal active" data-size="5.5x8.5">
                                                <span class="size-label">5.5√ó8.5</span>
                                                <span class="size-badge-minimal">Ph·ªï bi·∫øn</span>
                                            </div>
                                            <div class="size-option-minimal" data-size="4.74x6.6">
                                                <span class="size-label">4.74√ó6.6</span>
                                                <span class="size-badge-minimal">Retro</span>
                                            </div>
                                        </div>
                                        
                                        <!-- Main Grid -->
                                        <div class="size-grid-compact">
                                            <div class="size-card-minimal" data-size="5x15">
                                                <div class="size-preview-minimal" style="aspect-ratio: 1/3;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">5√ó15</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal" data-size="6.3x8.8">
                                                <div class="size-preview-minimal" style="aspect-ratio: 6.3/8.8;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">6.3√ó8.8</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal" data-size="7x10">
                                                <div class="size-preview-minimal" style="aspect-ratio: 7/10;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">7√ó10</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal" data-size="10.5x14.8">
                                                <div class="size-preview-minimal" style="aspect-ratio: 10.5/14.8;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">10.5√ó14.8</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal" data-size="10x15">
                                                <div class="size-preview-minimal" style="aspect-ratio: 2/3;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">10√ó15</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal" data-size="13x18">
                                                <div class="size-preview-minimal" style="aspect-ratio: 13/18;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">13√ó18</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal" data-size="14.8x21">
                                                <div class="size-preview-minimal" style="aspect-ratio: 14.8/21;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">14.8√ó21</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal" data-size="20x25">
                                                <div class="size-preview-minimal" style="aspect-ratio: 4/5;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">20√ó25</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal" data-size="21x29.7">
                                                <div class="size-preview-minimal" style="aspect-ratio: 21/29.7;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">21√ó29.7</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal" data-size="5.4x9">
                                                <div class="size-preview-minimal" style="aspect-ratio: 5.4/9;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">5.4√ó9</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal" data-size="6x9">
                                                <div class="size-preview-minimal" style="aspect-ratio: 2/3;"></div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">6√ó9</div>
                                                </div>
                                            </div>
                                            <div class="size-card-minimal custom-card-minimal" data-size="custom">
                                                <div class="size-preview-minimal custom-preview" style="aspect-ratio: 1/1;">
                                                    <span class="custom-icon">‚öô</span>
                                                </div>
                                                <div class="size-info-minimal">
                                                    <div class="size-dimensions">Custom</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Current Selection Summary -->
                                <div class="selection-summary" id="selectionSummary">
                                    <div class="summary-content">
                                        <div class="summary-icon"></div>
                                        <div class="summary-info">
                                            <div class="summary-title">ƒê√£ ch·ªçn: <span id="currentSizePage">5.5√ó8.5 cm</span></div>
                                            <div class="summary-details">
                                                <span id="currentPixelsPage">650√ó1000px</span> ‚Ä¢ 
                                                <span id="currentRatioPage">11:17</span> ‚Ä¢ 
                                                <span>300 DPI</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- RIGHT SIDEBAR: Settings & Download -->
                        <div class="crop-sidebar-right">
                            <div class="sidebar-section size-settings">
                                <div class="selection-summary" id="selectionSummary">
                                    <div class="summary-content">
                                        <div class="summary-icon"></div>
                                        <div class="summary-info">
                                            <div class="summary-title">ƒê√£ ch·ªçn: <span id="currentSizePage">5.5√ó8.5 cm</span></div>
                                            <div class="summary-details">
                                                <span id="currentPixelsPage">650√ó1000px</span> ‚Ä¢
                                                <span id="currentRatioPage">3:5</span> ‚Ä¢
                                                <span id="currentDPIPage">300 DPI</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Custom Size Section -->
                                <div class="setting-section" id="customSizeSectionPage" style="display: none;">
                                    <h4 id="customSizeTitle">K√≠ch th∆∞·ªõc t√πy ch·ªânh</h4>
                                    <div class="custom-inputs-modern">
                                        <div class="input-row">
                                            <div class="input-field">
                                                <label>R·ªông</label>
                                                <div class="input-with-unit">
                                                    <input type="number" id="cropWidthPage" value="6" min="0.5" max="50" step="0.1">
                                                    <span class="unit">cm</span>
                                                </div>
                                            </div>
                                            <div class="input-field">
                                                <label>Cao</label>
                                                <div class="input-with-unit">
                                                    <input type="number" id="cropHeightPage" value="9" min="0.5" max="50" step="0.1">
                                                    <span class="unit">cm</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <button class="action-btn-modern primary" id="startCroppingPage">
                                    <div class="btn-icon"></div>
                                    <div class="btn-content">
                                        <div class="btn-title">B·∫Øt ƒë·∫ßu c·∫Øt</div>
                                        <div class="btn-subtitle">Ti·∫øn h√†nh c·∫Øt ·∫£nh</div>
                                    </div>
                                </button>
                            </div>

                            <div class="sidebar-section process-settings">
                                <h3>Ch·∫ø ƒë·ªô x·ª≠ l√Ω</h3>
                                <div class="mode-tabs">
                                    <label class="mode-tab">
                                        <input type="radio" name="cropProcessModePage" value="preview">
                                        <span class="tab-content">
                                            <span class="tab-icon"></span>
                                            <span class="tab-text">Xem tr∆∞·ªõc</span>
                                        </span>
                                    </label>
                                    <label class="mode-tab">
                                        <input type="radio" name="cropProcessModePage" value="batch">
                                        <span class="tab-content">
                                            <span class="tab-icon"></span>
                                            <span class="tab-text">H√†ng lo·∫°t</span>
                                        </span>
                                    </label>
                                    <label class="mode-tab active">
                                        <input type="radio" name="cropProcessModePage" value="individual" checked>
                                        <span class="tab-content">
                                            <span class="tab-icon"></span>
                                            <span class="tab-text">T·ª´ng ·∫£nh</span>
                                        </span>
                                    </label>
                                </div>
                            </div>

                            <div class="sidebar-section download-settings">
                                <h3>T·∫£i ·∫£nh ƒë√£ c·∫Øt</h3>
                                <p>T·∫£i xu·ªëng ·∫£nh ƒë√£ ƒë∆∞·ª£c c·∫Øt t·ª´ c√°c l·∫ßn x·ª≠ l√Ω tr∆∞·ªõc</p>

                                <div class="download-grid">
                                    <button class="download-card primary" id="downloadCroppedAllBtnPage">
                                        <div class="download-icon"></div>
                                        <div class="download-content">
                                            <div class="download-title">T·∫£i t·ª´ng file</div>
                                            <div class="download-subtitle">T·∫£i xu·ªëng ri√™ng l·∫ª</div>
                                        </div>
                                    </button>

                                    <button class="download-card secondary" id="downloadCroppedZipBtnPage">
                                        <div class="download-icon"></div>
                                        <div class="download-content">
                                            <div class="download-title">T·∫£i file ZIP</div>
                                            <div class="download-subtitle">N√©n t·∫•t c·∫£ th√†nh 1 file</div>
                                        </div>
                                    </button>

                                    <button class="download-card tertiary" id="cropResultsBtnPage">
                                        <div class="download-icon"></div>
                                        <div class="download-content">
                                            <div class="download-title">Xem k·∫øt qu·∫£</div>
                                            <div class="download-subtitle">Danh s√°ch ·∫£nh ƒë√£ c·∫Øt</div>
                                        </div>
                                    </button>
                                </div>

                                <div class="download-status" id="cropDownloadStatus">
                                    <span id="cropedFilesCount">0 ·∫£nh ƒë√£ c·∫Øt</span> ‚Ä¢
                                    <span id="cropedTotalSize">0 MB</span>
                                </div>
                            </div>

                            <div class="sidebar-section advanced-settings">
                                <details class="settings-toggle">
                                    <summary>
                                        <span class="settings-icon"></span>
                                        <span class="settings-title">C√†i ƒë·∫∑t n√¢ng cao</span>
                                        <span class="toggle-icon">‚ñº</span>
                                    </summary>

                                    <div class="settings-content">
                                        <!-- Crop Settings -->
                                        <div class="setting-section">
                                            <h4>C√†i ƒë·∫∑t c·∫Øt</h4>
                                            <div class="setting-field">
                                                <label>Ch·∫ø ƒë·ªô</label>
                                                <select id="cropModePage" class="modern-select">
                                                    <option value="auto">T·ª± ƒë·ªông - Trung t√¢m</option>
                                                    <option value="smart">Th√¥ng minh - AI</option>
                                                    <option value="manual" selected>Th·ªß c√¥ng</option>
                                                </select>
                                            </div>
                                            <div class="setting-field">
                                                <label>X·ª≠ l√Ω vi·ªÅn</label>
                                                <select id="cropBackgroundPage" class="modern-select">
                                                    <option value="fill" selected>ƒê·∫ßy khung</option>
                                                    <option value="fit">V·ª´a kh√≠t</option>
                                                    <option value="stretch">K√©o gi√£n</option>
                                                </select>
                                            </div>
                                        </div>

                                        <!-- Quality Settings -->
                                        <div class="setting-section">
                                            <h4>Ch·∫•t l∆∞·ª£ng</h4>
                                            <div class="setting-field">
                                                <label>DPI</label>
                                                <select id="cropDPIPage" class="modern-select" disabled>
                                                    <option value="300" selected>300 DPI - Ch·∫•t l∆∞·ª£ng t·ªëi ƒëa (C·ªê ƒê·ªäNH)</option>
                                                </select>
                                            </div>
                                            <div class="setting-field">
                                                <label>ƒê·∫∑t t√™n</label>
                                                <select id="cropNamingPage" class="modern-select">
                                                    <option value="append">Th√™m k√≠ch th∆∞·ªõc</option>
                                                    <option value="replace">Thay th·∫ø t√™n</option>
                                                    <option value="keep" selected>Gi·ªØ nguy√™n</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                </details>
                            </div>
                        </div>
                    </div>
                    </div>
                </div>
            </div>

            <!-- Template Crop Section - Enhanced UI (HIDDEN - Replaced by cropTab) -->
            <div class="function-section" id="cropSection" style="display: none;">
                <div class="crop-container-enhanced">
                    <!-- Modern Header with Progress -->
                    <div class="section-header-modern">
                        <div class="header-content">
                            <div class="header-icon">‚öô</div>
                            <div class="header-text">
                                <h2>C·∫Øt ·∫¢nh</h2>
                                <p>T·∫°o ·∫£nh chu·∫©n v·ªõi k√≠ch th∆∞·ªõc ho√†n h·∫£o cho m·ªçi nhu c·∫ßu</p>
                            </div>
                        </div>
                        <div class="progress-steps" id="cropProgressSteps">
                            <div class="step active">
                                <div class="step-number">1</div>
                                <span>Ch·ªçn k√≠ch th∆∞·ªõc</span>
                            </div>
                            <div class="step">
                                <div class="step-number">2</div>
                                <span>T·∫£i ·∫£nh</span>
                            </div>
                            <div class="step">
                                <div class="step-number">3</div>
                                <span>Ho√†n th√†nh</span>
                            </div>
                        </div>
                    </div>

                    <!-- Modern Size Selection with Preview -->
                    <div class="size-selection-modern">
                        <div class="selection-header">
                            <h3>üéØ Ch·ªçn k√≠ch th∆∞·ªõc mong mu·ªën</h3>
                            <div class="selection-hint">Ch·ªçn m·ªôt trong c√°c k√≠ch th∆∞·ªõc ph·ªï bi·∫øn ho·∫∑c t√πy ch·ªânh</div>
                        </div>
                        
                        <div class="size-grid">
                            <div class="size-card active" data-size="5.5x8.5">
                                <div class="size-preview">
                                    <div class="ratio-box" style="aspect-ratio: 5.5/8.5;"></div>
                                </div>
                                <div class="size-info">
                                    <div class="size-title">CƒÉn c∆∞·ªõc c√¥ng d√¢n</div>
                                    <div class="size-dimensions">5.5 √ó 8.5 cm</div>
                                    <div class="size-pixels">650 √ó 1000px @ 300 DPI</div>
                                    <div class="size-usage">CCCD, Th·∫ª cƒÉn c∆∞·ªõc</div>
                                </div>
                                <div class="size-badge">Ph·ªï bi·∫øn nh·∫•t</div>
                            </div>
                            
                            <div class="size-card" data-size="3x4">
                                <div class="size-preview">
                                    <div class="ratio-box" style="aspect-ratio: 3/4;"></div>
                                </div>
                                <div class="size-info">
                                    <div class="size-title">·∫¢nh th·∫ª chu·∫©n</div>
                                    <div class="size-dimensions">3 √ó 4 cm</div>
                                    <div class="size-pixels">354 √ó 472px @ 300 DPI</div>
                                    <div class="size-usage">Th·∫ª sinh vi√™n, h·ªì s∆°</div>
                                </div>
                            </div>
                            
                            <div class="size-card" data-size="4x6">
                                <div class="size-preview">
                                    <div class="ratio-box" style="aspect-ratio: 4/6;"></div>
                                </div>
                                <div class="size-info">
                                    <div class="size-title">·∫¢nh h·ªô chi·∫øu</div>
                                    <div class="size-dimensions">4 √ó 6 cm</div>
                                    <div class="size-pixels">472 √ó 708px @ 300 DPI</div>
                                    <div class="size-usage">H·ªô chi·∫øu, visa</div>
                                </div>
                            </div>
                            
                            <div class="size-card custom-card" data-size="custom">
                                <div class="size-preview">
                                    <div class="ratio-box custom-ratio">
                                        <div class="custom-icon">‚öôÔ∏è</div>
                                    </div>
                                </div>
                                <div class="size-info">
                                    <div class="size-title">üéØ T√πy ch·ªânh</div>
                                    <div class="size-dimensions">Nh·∫≠p k√≠ch th∆∞·ªõc ri√™ng</div>
                                    <div class="size-pixels">T·ª± ƒë·ªãnh nghƒ©a theo cm</div>
                                    <div class="size-usage">Cho m·ªçi nhu c·∫ßu ƒë·∫∑c bi·ªát</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced Custom Size Input -->
                        <div class="custom-dimensions-modern" id="customSizeInput" style="display: none;">
                            <div class="custom-header">
                                <h4>‚öô K√≠ch th∆∞·ªõc t√πy ch·ªânh</h4>
                                <p>Nh·∫≠p k√≠ch th∆∞·ªõc ch√≠nh x√°c theo nhu c·∫ßu c·ªßa b·∫°n</p>
                            </div>
                            <div class="dimension-inputs-grid">
                                <div class="input-group">
                                    <label for="customWidth">
                                        <span class="label-icon">üìè</span>
                                        Chi·ªÅu r·ªông
                                    </label>
                                    <div class="input-with-unit">
                                        <input type="number" id="customWidth" value="5.5" min="1" max="50" step="0.1" placeholder="5.5">
                                        <span class="unit">cm</span>
                                    </div>
                                </div>
                                <div class="input-group">
                                    <label for="customHeight">
                                        <span class="label-icon">‚ñ¶</span>
                                        Chi·ªÅu cao
                                    </label>
                                    <div class="input-with-unit">
                                        <input type="number" id="customHeight" value="8.5" min="1" max="50" step="0.1" placeholder="8.5">
                                        <span class="unit">cm</span>
                                    </div>
                                </div>
                                <div class="input-group">
                                    <label>
                                        <span class="label-icon">üéØ</span>
                                        ƒê·ªô ph√¢n gi·∫£i
                                    </label>
                                    <select class="dpi-select" id="customDPI">
                                        <option value="300" selected>300 DPI (In ·∫•n)</option>
                                        <option value="150">150 DPI (Web)</option>
                                        <option value="72">72 DPI (M√†n h√¨nh)</option>
                                    </select>
                                </div>
                                <div class="input-group">
                                    <label for="autoRotateToggle">
                                        <span class="label-icon">üîÑ</span>
                                        T·ª± ƒë·ªông xoay
                                    </label>
                                    <div class="toggle-switch-container">
                                        <label class="toggle-switch">
                                            <input type="checkbox" id="autoRotateToggle" checked>
                                            <span class="toggle-slider"></span>
                                        </label>
                                        <span class="toggle-label" id="autoRotateLabel">B·∫≠t</span>
                                    </div>
                                </div>
                            </div>
                            <div class="dimension-preview" id="dimensionPreview">
                                <div class="preview-info">
                                    <span class="preview-size">K√≠ch th∆∞·ªõc: <strong id="previewDimensions">5.5 √ó 8.5 cm</strong></span>
                                    <span class="preview-pixels">Pixels: <strong id="previewPixels">650 √ó 1000px</strong></span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Enhanced Upload Area with Better Visual Feedback -->
                    <div class="upload-area-modern" id="cropUploadArea">
                        <div class="upload-zone" onclick="document.getElementById('cropFileInput').click()">
                            <div class="upload-visual">
                                <div class="upload-icon">üì§</div>
                                <div class="upload-animation"></div>
                            </div>
                            <div class="upload-content">
                                <h3 class="upload-title">T·∫£i l√™n ·∫£nh c·ªßa b·∫°n</h3>
                                <p class="upload-subtitle">K√©o th·∫£ file v√†o ƒë√¢y ho·∫∑c nh·∫•p ƒë·ªÉ ch·ªçn</p>
                                <div class="upload-formats">
                                    <span class="format-badge">JPG</span>
                                    <span class="format-badge">PNG</span>
                                    <span class="format-badge">WEBP</span>
                                    <span class="format-badge">BMP</span>
                                </div>
                                <div class="upload-limit">T·ªëi ƒëa 20MB m·ªói file</div>
                            </div>
                        </div>
                        <input type="file" id="cropFileInput" class="file-input" multiple accept="image/*">
                    </div>

                    <!-- Modern Progress & Processing -->
                    <div class="processing-area" id="cropProcessingArea" style="display: none;">
                        <div class="processing-header">
                            <h3>üîÑ ƒêang x·ª≠ l√Ω ·∫£nh...</h3>
                            <div class="processing-count">
                                <span id="processedCount">0</span> / <span id="totalCount">0</span> ·∫£nh
                            </div>
                        </div>
                        <div class="processing-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" id="cropProgressFill"></div>
                            </div>
                            <div class="progress-text" id="cropProgressText">Kh·ªüi t·∫°o...</div>
                        </div>
                        <div class="processing-preview" id="cropProcessingPreview">
                            <!-- Dynamic preview thumbnails will be inserted here -->
                        </div>
                    </div>

                    <!-- Enhanced Results & Actions -->
                    <div class="crop-results" id="cropResults" style="display: none;">
                        <div class="results-header">
                            <div class="results-summary">
                                <h3>‚úÖ Ho√†n th√†nh c·∫Øt ·∫£nh!</h3>
                                <p>ƒê√£ x·ª≠ l√Ω <span id="successCount">0</span> ·∫£nh th√†nh c√¥ng</p>
                            </div>
                            <div class="results-stats">
                                <div class="stat-item">
                                    <div class="stat-number" id="totalSize">0 MB</div>
                                    <div class="stat-label">T·ªïng dung l∆∞·ª£ng</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-number" id="avgTime">0s</div>
                                    <div class="stat-label">Th·ªùi gian trung b√¨nh</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="action-grid">
                            <button class="action-card primary" id="downloadCroppedAllBtn">
                                <div class="action-icon">üìÅ</div>
                                <div class="action-content">
                                    <div class="action-title">T·∫£i t·ª´ng file</div>
                                    <div class="action-subtitle">T·∫£i xu·ªëng ri√™ng l·∫ª</div>
                                </div>
                            </button>
                            
                            <button class="action-card secondary" id="downloadCroppedZipBtn">
                                <div class="action-icon">üì¶</div>
                                <div class="action-content">
                                    <div class="action-title">T·∫£i file ZIP</div>
                                    <div class="action-subtitle">N√©n t·∫•t c·∫£ th√†nh 1 file</div>
                                </div>
                            </button>
                            
                            <button class="action-card tertiary" id="cropResultsBtn">
                                <div class="action-icon">üëÅÔ∏è</div>
                                <div class="action-content">
                                    <div class="action-title">Xem chi ti·∫øt</div>
                                    <div class="action-subtitle">Preview k·∫øt qu·∫£</div>
                                </div>
                            </button>
                            
                            <button class="action-card quaternary" id="cropNewBatchBtn">
                                <div class="action-icon">üîÑ</div>
                                <div class="action-content">
                                    <div class="action-title">C·∫Øt batch m·ªõi</div>
                                    <div class="action-subtitle">B·∫Øt ƒë·∫ßu l·∫°i</div>
                                </div>
                            </button>
                        </div>
                        
                        <div class="results-gallery" id="cropResultsGallery">
                            <!-- Cropped images preview will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Gallery Section -->
            <div class="function-section" id="gallerySection">
                <div class="gallery-container">
                    <!-- Header -->
                    <div class="section-header">
                        <h2>Kho ·∫¢nh</h2>
                        <p>Upload, qu·∫£n l√Ω v√† ph√¢n lo·∫°i ·∫£nh</p>
                    </div>

                    <!-- Gallery Controls -->
                    <div class="gallery-controls">
                        <div class="control-group">
                            <div class="gallery-status">
                                <span class="gallery-count" id="galleryCount">0 ·∫£nh</span>
                                <span class="gallery-info">JPG, PNG, GIF, WebP</span>
                            </div>
                        </div>
                        
                        <div class="control-group search-section">
                            <div class="search-box">
                                <input type="text" id="gallerySearchInput" placeholder="T√¨m ki·∫øm ·∫£nh..." class="search-input">
                                <span class="search-icon">üîç</span>
                            </div>
                            <select id="galleryFilterSelect" class="filter-select">
                                <option value="all">T·∫•t c·∫£</option>
                                <option value="uploaded">·∫¢nh t·∫£i l√™n</option>
                                <option value="cropped">·∫¢nh ƒë√£ c·∫Øt</option>
                            </select>
                        </div>
                        
                        <div class="control-group upload-section">
                            <button class="control-btn upload-btn" id="uploadBtn">
                                <span class="btn-icon">üì§</span>
                                <span class="btn-text">T·∫£i ·∫£nh l√™n</span>
                                <span class="btn-desc">Ch·ªçn nhi·ªÅu file</span>
                            </button>
                            <input type="file" id="galleryFileInput" class="file-input" multiple accept="image/*,image/jpeg,image/jpg,image/png,image/gif,image/webp">

                            <!-- üìÇ File System Button for Gallery -->
                            <button class="control-btn filesystem-btn" id="galleryFromFileSystemBtn" onclick="loadImagesFromFileSystem('gallery')">
                                <span class="btn-icon">üìÅ</span>
                                <span class="btn-text">T·ª´ File System</span>
                                <span class="btn-desc">T·ª´ th∆∞ m·ª•c ƒë√£ c·∫•p quy·ªÅn</span>
                            </button>
                        </div>
                        
                        <div class="control-group management">
                            <button class="control-btn classify" id="classifyBtn" disabled>
                                <span class="btn-icon">üîÑ</span>
                                <span class="btn-text">Ph√¢n lo·∫°i</span>
                            </button>
                            <button class="control-btn auto-classify" id="autoClassifyBtn" disabled>
                                <span class="btn-icon">ü§ñ</span>
                                <span class="btn-text">T·ª± ƒë·ªông ph√¢n lo·∫°i</span>
                                <span class="btn-desc">Theo t√™n file</span>
                            </button>
                            <button class="control-btn clear" id="clearGalleryBtn" disabled>
                                <span class="btn-icon">üóëÔ∏è</span>
                                <span class="btn-text">X√≥a t·∫•t c·∫£</span>
                            </button>
                        </div>

                    </div>

                    <!-- Upload Progress -->
                    <div class="upload-progress" id="uploadProgress" style="display: none;">
                        <div class="progress-header">
                            <span class="progress-text">ƒêang t·∫£i l√™n...</span>
                            <span class="progress-count" id="progressCount">0/0</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="progress-details" id="progressDetails">Chu·∫©n b·ªã...</div>
                    </div>

                    <!-- Main Gallery Grid -->
                    <div class="gallery-grid" id="galleryGrid">
                        <div class="empty-gallery">
                            <div class="empty-icon">Kh√¥ng c√≥ ·∫£nh</div>
                            <div class="empty-text">C√°c ·∫£nh ƒë√£ crop s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y</div>
                            <div class="empty-hint">S·ª≠ d·ª•ng ch·ª©c nƒÉng Template Crop ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
                        </div>
                    </div>

                    <!-- Classification Mode -->
                    <div class="classification-mode" id="classificationMode" style="display: none;">
                        <!-- Source Grid -->
                        <div class="section-title">üéØ T·∫•t c·∫£ ·∫£nh ƒë√£ crop 
                            <span class="instruction-hint" id="sourceGridHint">Click ·∫£nh ƒë·ªÉ ch·ªçn cho duplex</span>
                        </div>
                        <div class="source-grid" id="sourceGrid" style="border: 2px dashed #3b82f6; padding: 10px; border-radius: 8px;"></div>
                        
                        <!-- Quick Selection Controls -->
                        <div class="quick-selection-section">
                            <div class="section-title">
                                <span>‚ö° Ch·ªçn nhanh</span>
                                <div class="selection-status" id="selectionStatus" style="display: none;">
                                    <span class="selection-text">Ch·∫ø ƒë·ªô ch·ªçn: </span>
                                    <span class="selection-type" id="selectionType">Kh√¥ng ho·∫°t ƒë·ªông</span>
                                    <span class="selection-counter" id="selectionCounter">(0 ·∫£nh ƒë√£ ch·ªçn)</span>
                                </div>
                            </div>
                            
                            <div class="quick-select-controls">
                                <button class="quick-select-btn front-type" id="quickSelectFrontBtn">
                                    <span class="btn-icon">üÜî</span>
                                    <span class="btn-text">üìÇ Kho: Ch·ªçn Tr∆∞·ªõc</span>
                                </button>
                                <button class="quick-select-btn back-type" id="quickSelectBackBtn">
                                    <span class="btn-icon">üìÉ</span>
                                    <span class="btn-text">üìÇ Kho: Ch·ªçn Sau</span>
                                </button>
                                <button class="quick-select-btn" id="selectAllFrontBtn">
                                    <span class="btn-icon">‚úÖ</span>
                                    <span class="btn-text">üìÇ Kho: T·∫•t C·∫£ ‚Üí Tr∆∞·ªõc</span>
                                </button>
                                <button class="quick-select-btn" id="selectAllBackBtn">
                                    <span class="btn-icon">‚ùå</span>
                                    <span class="btn-text">üìÇ Kho: T·∫•t C·∫£ ‚Üí Sau</span>
                                </button>
                                <button class="quick-select-btn apply-btn" id="applySelectionBtn" style="display: none;">
                                    <span class="btn-icon">‚úÖ</span>
                                    <span class="btn-text">üìÇ Kho: √Åp d·ª•ng</span>
                                </button>
                                <button class="quick-select-btn cancel-btn" id="cancelSelectionBtn" style="display: none;">
                                    <span class="btn-icon">üö´</span>
                                    <span class="btn-text">üìÇ Kho: H·ªßy</span>
                                </button>
                            </div>
                        </div>

                        <!-- Classification Areas -->
                        <div class="classification-areas">
                            <div class="classification-panel">
                                <div class="panel-header">
                                    <h3>M·∫∑t tr∆∞·ªõc</h3>
                                    <div class="panel-controls">
                                        <input type="text" id="frontPrefix" placeholder="Ti·ªÅn t·ªë..." value="">
                                        <span class="rename-pattern">1a, 2a, 3a...</span>
                                    </div>
                                </div>
                                <div class="drop-zone" id="frontDropZone" data-type="front">
                                    <div class="drop-hint">K√©o ·∫£nh v√†o ƒë√¢y</div>
                                </div>
                            </div>

                            <div class="classification-panel">
                                <div class="panel-header">
                                    <h3>M·∫∑t sau</h3>
                                    <div class="panel-controls">
                                        <input type="text" id="backPrefix" placeholder="Ti·ªÅn t·ªë..." value="">
                                        <span class="rename-pattern">1b, 2b, 3b...</span>
                                    </div>
                                </div>
                                <div class="drop-zone" id="backDropZone" data-type="back">
                                    <div class="drop-hint">K√©o ·∫£nh v√†o ƒë√¢y</div>
                                </div>
                            </div>
                        </div>

                        <!-- Classification Controls -->
                        <div class="classification-controls">
                            <button class="control-btn" id="previewDownloadBtn" disabled>Xem tr∆∞·ªõc</button>
                            <button class="control-btn secondary" id="exitClassifyBtn">Tho√°t ph√¢n lo·∫°i</button>
                        </div>
                    </div>

                    <!-- Download Options -->
                    <div class="download-options" id="downloadOptions" style="display: none;">
                        <div class="section-header download-header">
                            <h3>T·∫£i xu·ªëng ·∫£nh ƒë√£ ph√¢n lo·∫°i</h3>
                            <p>Ch·ªçn ph∆∞∆°ng th·ª©c t·∫£i xu·ªëng cho ·∫£nh m·∫∑t tr∆∞·ªõc/sau</p>
                        </div>
                        
                        <div class="download-methods-grid">
                            <!-- Individual Download Method -->
                            <div class="download-method-card">
                                <div class="method-header">
                                    <span class="method-icon">üìÑ</span>
                                    <div class="method-info">
                                        <h4>T·ª´ng file</h4>
                                        <p>JPG, K√≠ch th∆∞·ªõc g·ªëc, Ch·∫•t l∆∞·ª£ng max</p>
                                    </div>
                                </div>
                                <div class="method-buttons">
                                    <button class="method-btn individual-btn" id="downloadFrontIndividualBtn" disabled>
                                        <span class="btn-label">M·∫∑t tr∆∞·ªõc</span>
                                        <span class="btn-count" id="frontCount">0 file</span>
                                    </button>
                                    <button class="method-btn individual-btn" id="downloadBackIndividualBtn" disabled>
                                        <span class="btn-label">M·∫∑t sau</span>
                                        <span class="btn-count" id="backCount">0 file</span>
                                    </button>
                                    <button class="method-btn individual-btn all" id="downloadAllIndividualBtn" disabled>
                                        <span class="btn-label">T·∫•t c·∫£</span>
                                        <span class="btn-count" id="allCount">0 file</span>
                                    </button>
                                </div>
                            </div>
                            
                            <!-- ZIP Download Method -->
                            <div class="download-method-card">
                                <div class="method-header">
                                    <span class="method-icon">üì¶</span>
                                    <div class="method-info">
                                        <h4>ZIP File</h4>
                                        <p>N√©n t·∫•t c·∫£</p>
                                    </div>
                                </div>
                                <div class="method-buttons">
                                    <button class="method-btn zip-btn" id="downloadZipFrontBtn" disabled>
                                        <span class="btn-label">ZIP m·∫∑t tr∆∞·ªõc</span>
                                        <span class="btn-count" id="frontZipCount">0 file</span>
                                    </button>
                                    <button class="method-btn zip-btn" id="downloadZipBackBtn" disabled>
                                        <span class="btn-label">ZIP m·∫∑t sau</span>
                                        <span class="btn-count" id="backZipCount">0 file</span>
                                    </button>
                                    <button class="method-btn zip-btn all" id="downloadZipAllBtn" disabled>
                                        <span class="btn-label">ZIP t·∫•t c·∫£</span>
                                        <span class="btn-count" id="allZipCount">0 file</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Templates Section -->
            <div class="function-section" id="templatesSection">
                <div class="templates-container">
                    <!-- Header -->
                    <div class="section-header">
                        <h2>‚óà Templates</h2>
                        <p>C√°c m·∫´u thi·∫øt k·∫ø cho ·∫£nh</p>
                    </div>
                    
                    <!-- Sub-tabs for Templates -->
                    <div class="template-sub-tabs">
                        <button class="sub-tab-button active" id="polaroidSubTab">
                            <span class="sub-tab-icon">‚óà</span>
                            <span class="sub-tab-text">Polaroid</span>
                        </button>
                        <button class="sub-tab-button" id="borderSubTab">
                            <span class="sub-tab-icon">‚ñ¶</span>
                            <span class="sub-tab-text">Vi·ªÅn Th∆∞·ªùng</span>
                        </button>
                        <button class="sub-tab-button" id="stripSubTab">
                            <span class="sub-tab-icon">‚ùô</span>
                            <span class="sub-tab-text">Strip Layout</span>
                        </button>
                    </div>
                    
                    <!-- Polaroid Template Content - Optimized Compact Design -->
                    <div class="template-content active" id="polaroidTemplateContent">
                        <div class="polaroid-compact-container">
                            <!-- Top Section: Header + Quick Actions -->
                            <div class="polaroid-top-section">
                                <div class="polaroid-header">
                                    <div class="header-info">
                                        <h3>‚óà Polaroid Template</h3>
                                        <div class="template-quick-specs" id="quickSpecs">5.5√ó8.5cm ‚Ä¢ 300 DPI ‚Ä¢ 1:1.55</div>
                                    </div>
                                    <div class="header-actions">
                                        <button class="compact-btn secondary" id="resetTemplateDefaults">‚Ü∫ Reset</button>
                                        <button class="compact-btn primary" id="templateCropEdit">‚úÇÔ∏è Crop ·∫£nh</button>
                                    </div>
                                </div>
                            </div>

                            <!-- Main Section: Preview + Controls Side by Side -->
                            <div class="polaroid-main-section">
                                <!-- Left: Preview -->
                                <div class="polaroid-preview-section">
                                    <div class="preview-header">
                                        <span class="preview-title">üëÅÔ∏è Preview</span>
                                        <div class="preview-controls">
                                            <button class="mini-btn" id="templateCropReset" title="Reset crop">‚ü≤</button>
                                            <button class="mini-btn" id="templateCropCenter" title="Center crop">‚äö</button>
                                            <button class="mini-btn" id="templateCropFit" title="Fit crop">‚óà</button>
                                        </div>
                                    </div>
                                    <div class="polaroid-preview-container">
                                        <div class="polaroid-frame">
                                            <div class="polaroid-image-area" id="polaroidImageArea">
                                                <div class="template-frame-preview" id="templateFramePreview" style="display: none;">
                                                    <img id="templateFrameImg" src="" alt="Template preview" style="width: 100%; height: 100%; object-fit: contain;">
                                                </div>
                                                <div class="placeholder-text" id="placeholderText">Ch·ªçn khung v√† upload ·∫£nh...</div>
                                            </div>
                                            <div class="polaroid-caption-area">
                                                <div class="caption-placeholder">Vi·ªÅn Polaroid</div>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- Upload Zone under preview -->
                                    <div class="compact-upload-zone" onclick="document.getElementById('templateFileInput').click()">
                                        <div class="upload-content">
                                            <span class="upload-icon">‚¨ÜÔ∏è</span>
                                            <span class="upload-text">Ch·ªçn ·∫£nh</span>
                                        </div>
                                        <input type="file" id="templateFileInput" accept="image/*" multiple style="display: none;">
                                    </div>

                                    <!-- üìÇ File System Button for Templates -->
                                    <div class="filesystem-section">
                                        <button class="filesystem-action-btn" id="templatesFromFileSystemBtn" onclick="loadImagesFromFileSystem('templates')">
                                            <span class="filesystem-icon">üìÅ</span>
                                            <span class="filesystem-text">T·ª´ File System</span>
                                            <span class="filesystem-subtitle">Ch·ªçn ·∫£nh t·ª´ th∆∞ m·ª•c ƒë√£ c·∫•p quy·ªÅn</span>
                                        </button>
                                    </div>
                                </div>

                                <!-- Right: Controls -->
                                <div class="polaroid-controls-section">
                                    <!-- Streamlined Settings Tabs -->
                                    <div class="settings-tabs">
                                        <div class="tab-header">
                                            <button class="tab-btn active" data-tab="layout">‚ñ¶ K√≠ch th∆∞·ªõc & B·ªë c·ª•c</button>
                                            <button class="tab-btn" data-tab="style">‚óà M√†u s·∫Øc & VƒÉn b·∫£n</button>
                                            <button class="tab-btn" data-tab="export">‚§ì Xu·∫•t & Th√¥ng s·ªë</button>
                                        </div>
                                        
                                        <!-- Layout & Dimensions Tab - CH·ªà k√≠ch th∆∞·ªõc & b·ªë c·ª•c -->
                                        <div class="tab-content active" data-tab="layout">
                                            <div class="settings-section">
                                                <div class="section-title">üé® Lo·∫°i Template</div>

                                                <!-- Template Type Selection -->
                                                <div class="template-type-options">
                                                    <label class="template-type-card active">
                                                        <input type="radio" name="polaroidTemplateType" value="type1" checked>
                                                        <div class="type-icon">üìê</div>
                                                        <div class="type-info">
                                                            <div class="type-name">Polaroid 1</div>
                                                            <div class="type-desc">Chu·∫©n</div>
                                                        </div>
                                                    </label>
                                                    <label class="template-type-card">
                                                        <input type="radio" name="polaroidTemplateType" value="type2">
                                                        <div class="type-icon">üñºÔ∏è</div>
                                                        <div class="type-info">
                                                            <div class="type-name">Polaroid 2</div>
                                                            <div class="type-desc">M·ªõi</div>
                                                        </div>
                                                    </label>
                                                </div>
                                            </div>

                                            <!-- Art Template Selection (Only for Polaroid 2) -->
                                            <div class="settings-section polaroid2-only-section" style="display: none;">
                                                <div class="section-title">üé® Ch·ªçn Khung Art</div>
                                                <div class="art-template-grid">
                                                    <label class="art-template-card active">
                                                        <input type="radio" name="artTemplateType" value="default" checked>
                                                        <div class="art-preview">
                                                            <img src="TEMPLATE/TEMPLATE Polaroid 6 x 9 cm.png" alt="Tr∆°n">
                                                        </div>
                                                        <div class="art-name">Tr∆°n</div>
                                                    </label>
                                                    <label class="art-template-card">
                                                        <input type="radio" name="artTemplateType" value="6x9-art-music">
                                                        <div class="art-preview">
                                                            <img src="TEMPLATE/Polaroid_6x9cm_Cunamnhac.png" alt="C√∫n √¢m nh·∫°c">
                                                        </div>
                                                        <div class="art-name">C√∫n √¢m nh·∫°c</div>
                                                    </label>
                                                </div>
                                            </div>

                                            <div class="settings-section">
                                                <div class="section-title">‚ñ† K√≠ch th∆∞·ªõc Polaroid</div>

                                                <!-- Quick Size Selection Buttons -->
                                                <div class="quick-sizes-grid">
                                                    <button class="size-preset-btn active" data-width="5.5" data-height="8.5">
                                                        <span class="size-name">5.5√ó8.5</span>
                                                        <span class="size-desc">Chu·∫©n</span>
                                                    </button>
                                                    <button class="size-preset-btn" data-width="4" data-height="6">
                                                        <span class="size-name">4√ó6</span>
                                                        <span class="size-desc">4R</span>
                                                    </button>
                                                    <button class="size-preset-btn" data-width="5" data-height="7">
                                                        <span class="size-name">5√ó7</span>
                                                        <span class="size-desc">5R</span>
                                                    </button>
                                                    <button class="size-preset-btn" data-width="6" data-height="9">
                                                        <span class="size-name">6√ó9</span>
                                                        <span class="size-desc">6R</span>
                                                    </button>
                                                    <button class="size-preset-btn" data-width="7" data-height="10">
                                                        <span class="size-name">7√ó10</span>
                                                        <span class="size-desc">7R</span>
                                                    </button>
                                                    <button class="size-preset-btn" data-width="8" data-height="10">
                                                        <span class="size-name">8√ó10</span>
                                                        <span class="size-desc">8R</span>
                                                    </button>
                                                    <button class="size-preset-btn" data-width="8.5" data-height="11">
                                                        <span class="size-name">8.5√ó11</span>
                                                        <span class="size-desc">Letter</span>
                                                    </button>
                                                </div>

                                                <div class="setting-row">
                                                    <label>K√≠ch th∆∞·ªõc (cm)</label>
                                                    <div class="size-inputs">
                                                        <input type="number" id="templateWidth" min="3" max="20" step="0.1" value="5.5" class="compact-input">
                                                        <span class="multiplier">√ó</span>
                                                        <input type="number" id="templateHeight" min="3" max="30" step="0.1" value="8.5" class="compact-input">
                                                    </div>
                                                </div>
                                                <div class="setting-row">
                                                    <label>Fit Mode</label>
                                                    <select id="templateFitMode" class="compact-select">
                                                        <option value="contain">Contain (gi·ªØ t·ª∑ l·ªá)</option>
                                                        <option value="cover" selected>Cover (c·∫Øt ·∫£nh)</option>
                                                    </select>
                                                </div>
                                            </div>

                                            <div class="settings-section">
                                                <div class="section-title">‚ñ° Vi·ªÅn & Kho·∫£ng c√°ch</div>
                                                <div class="border-grid">
                                                    <div class="border-item">
                                                        <label>‚ñ≤ Tr√™n</label>
                                                        <div class="border-control">
                                                            <input type="range" id="borderTop" min="0" max="100" value="50" class="compact-slider">
                                                            <input type="number" id="borderTopValue" min="0" max="100" value="50" class="compact-number">
                                                        </div>
                                                    </div>
                                                    <div class="border-item">
                                                        <label>‚óÄ Tr√°i</label>
                                                        <div class="border-control">
                                                            <input type="range" id="borderLeft" min="0" max="100" value="45" class="compact-slider">
                                                            <input type="number" id="borderLeftValue" min="0" max="100" value="45" class="compact-number">
                                                        </div>
                                                    </div>
                                                    <div class="border-item">
                                                        <label>‚ñ∂ Ph·∫£i</label>
                                                        <div class="border-control">
                                                            <input type="range" id="borderRight" min="0" max="100" value="45" class="compact-slider">
                                                            <input type="number" id="borderRightValue" min="0" max="100" value="45" class="compact-number">
                                                        </div>
                                                    </div>
                                                    <div class="border-item">
                                                        <label>‚ñº Caption</label>
                                                        <div class="border-control">
                                                            <input type="range" id="borderBottom" min="50" max="300" value="175" class="compact-slider">
                                                            <input type="number" id="borderBottomValue" min="50" max="300" value="175" class="compact-number">
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Style & Text Tab - CH·ªà m√†u s·∫Øc & vƒÉn b·∫£n -->
                                        <div class="tab-content" data-tab="style">
                                            <div class="settings-section">
                                                <div class="section-title">‚óà M√†u s·∫Øc & Hi·ªáu ·ª©ng</div>
                                                <div class="setting-row">
                                                    <label>M√†u n·ªÅn</label>
                                                    <input type="color" id="templateBgColor" value="#FFFFFF" class="compact-color">
                                                </div>
                                                <div class="setting-row">
                                                    <label>Safe Area (px)</label>
                                                    <input type="number" id="templateSafeArea" min="0" max="50" value="0" class="compact-input">
                                                </div>
                                                <div class="setting-row">
                                                    <label>Overlay Frame</label>
                                                    <input type="checkbox" id="templateOverlay" class="compact-checkbox">
                                                </div>
                                            </div>

                                            <div class="settings-section">
                                                <div class="section-title">‚Äª VƒÉn b·∫£n Caption</div>
                                                <div class="setting-row">
                                                    <label>N·ªôi dung</label>
                                                    <input type="text" id="captionText" placeholder="ƒê·ªÉ tr·ªëng n·∫øu kh√¥ng c·∫ßn..." class="compact-input">
                                                </div>
                                                <div class="caption-controls">
                                                    <div class="setting-row">
                                                        <label>Font</label>
                                                        <select id="captionFont" class="compact-select">
                                                            <option value="Arial">Arial</option>
                                                            <option value="Georgia">Georgia</option>
                                                            <option value="Times">Times</option>
                                                            <option value="Courier">Courier</option>
                                                        </select>
                                                    </div>
                                                    <div class="setting-row">
                                                        <label>K√≠ch th∆∞·ªõc</label>
                                                        <input type="number" id="captionFontSize" min="8" max="48" value="16" class="compact-input">
                                                    </div>
                                                    <div class="setting-row">
                                                        <label>M√†u ch·ªØ</label>
                                                        <input type="color" id="captionColor" value="#000000" class="compact-color">
                                                    </div>
                                                    <div class="setting-row">
                                                        <label>CƒÉn ch·ªânh</label>
                                                        <select id="captionAlign" class="compact-select">
                                                            <option value="center" selected>Gi·ªØa</option>
                                                            <option value="left">Tr√°i</option>
                                                            <option value="right">Ph·∫£i</option>
                                                        </select>
                                                    </div>
                                                    <div class="setting-row">
                                                        <label>Kho·∫£ng c√°ch</label>
                                                        <input type="number" id="captionMarginTop" min="0" max="50" value="10" class="compact-input">
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Export & Specs Tab -->
                                        <div class="tab-content" data-tab="export">
                                            <div class="settings-section">
                                                <div class="section-title">‚â° Th√¥ng s·ªë hi·ªán t·∫°i</div>
                                                <div class="specs-display" id="currentSpecsDisplay">
                                                    <!-- Will be populated by JavaScript -->
                                                </div>
                                            </div>

                                            <div class="settings-section">
                                                <div class="section-title">‚ü≤ ƒêi·ªÅu h∆∞·ªõng</div>
                                                <div class="navigation-controls">
                                                    <button class="nav-btn" id="templatePrevBtn" disabled>‚óÄ Tr∆∞·ªõc</button>
                                                    <span class="nav-info" id="templateNavInfo">0/0</span>
                                                    <button class="nav-btn" id="templateNextBtn" disabled>Sau ‚ñ∂</button>
                                                </div>
                                            </div>

                                            <div class="settings-section">
                                                <div class="section-title">‚§ì T√πy ch·ªçn xu·∫•t file</div>
                                                <div class="setting-row">
                                                    <label>
                                                        <input type="checkbox" id="useSubfolders" class="compact-checkbox"> 
                                                        T·∫°o th∆∞ m·ª•c con
                                                    </label>
                                                    <input type="text" id="folderPrefix" placeholder="Ti·ªÅn t·ªë th∆∞ m·ª•c..." maxlength="20" class="compact-input">
                                                </div>
                                                <div class="export-actions">
                                                    <button class="filesystem-save-btn primary" id="savePolaroidToFileSystem">üíæ L∆∞u v√†o File System</button>
                                                    <button class="action-btn primary" id="exportCurrentPolaroid">‚§ì T·∫£i trang hi·ªán t·∫°i</button>
                                                    <button class="action-btn secondary" id="exportAllIndividual">‚â° T·∫£i t·ª´ng file</button>
                                                    <button class="action-btn tertiary" id="exportAllPolaroids">‚ñ¶ T·∫£i file ZIP</button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>

                    <!-- Template Gallery -->
                    <div class="template-gallery" id="templateGallery">
                        <div class="gallery-header">
                            <h3>‚óä Danh s√°ch Polaroid</h3>
                            <div class="gallery-stats">
                                <span class="stat-value" id="templateImageCount">0</span>
                                <span class="stat-label">·∫£nh ƒë√£ t·∫£i</span>
                            </div>
                            <button class="compact-btn primary" id="quickToPrintBtn" style="display: none;">
                                <span>üìã Chuy·ªÉn sang In</span>
                            </button>
                        </div>
                        <div class="template-grid" id="templateGrid">
                            <!-- Polaroid previews will be generated here -->
                        </div>
                    </div>
                </div>
            </div>

                    </div>
                    
                    <!-- Border Template Content -->
                    <div class="template-content" id="borderTemplateContent">
                <div class="template-container">
                    <!-- Header -->
                    <div class="template-content-header">
                        <h3>‚ñ¶ Vi·ªÅn Th∆∞·ªùng</h3>
                        <p>·∫¢nh v·ªõi vi·ªÅn m·ªèng ho·∫∑c tr√†n vi·ªÅn</p>
                    </div>

                    <!-- Template Configuration -->
                    <div class="template-config-panel">
                        <!-- Border Template Configuration -->
                        <div class="config-group">
                            <label class="config-label" data-icon="‚ñ¶">C·∫•u h√¨nh Vi·ªÅn Th∆∞·ªùng</label>
                            
                            <!-- Size & DPI Settings -->
                            <div class="polaroid-basic-settings">
                                <div class="setting-row">
                                    <div class="setting-item">
                                        <label>DPI</label>
                                        <select id="borderTemplateDPI" class="template-select">
                                            <option value="150">150 DPI</option>
                                            <option value="200">200 DPI</option>
                                            <option value="300" selected>300 DPI</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <label>K√≠ch th∆∞·ªõc (cm)</label>
                                        <div class="size-inputs">
                                            <input type="number" id="borderTemplateWidth" min="3" max="20" step="0.1" value="10" class="size-input">
                                            <span>√ó</span>
                                            <input type="number" id="borderTemplateHeight" min="3" max="30" step="0.1" value="15" class="size-input">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Border Settings -->
                            <div class="border-settings">
                                <label class="subsection-label">‚ñ¶ Vi·ªÅn (mm)</label>
                                <div class="border-controls">
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>K√≠ch ho·∫°t vi·ªÅn</label>
                                            <input type="checkbox" id="borderTemplateEnabled" checked class="checkbox-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>ƒê·ªô d√†y vi·ªÅn</label>
                                            <input type="range" id="borderThickness" min="0" max="20" value="5" class="slider-input">
                                            <input type="number" id="borderThicknessValue" min="0" max="20" value="5" class="template-input">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>M√†u vi·ªÅn</label>
                                            <input type="color" id="borderTemplateColor" value="#FFFFFF" class="color-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>G√≥c bo tr√≤n (px)</label>
                                            <input type="range" id="borderCornerRadius" min="0" max="50" value="0" class="slider-input">
                                            <input type="number" id="borderCornerRadiusValue" min="0" max="50" value="0" class="template-input">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Advanced Settings -->
                            <div class="advanced-settings">
                                <label class="subsection-label">‚öô T√πy ch·ªçn n√¢ng cao</label>
                                <div class="advanced-controls">
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Fit Mode</label>
                                            <select id="borderTemplateFitMode" class="template-select">
                                                <option value="contain">Contain (gi·ªØ vi·ªÅn)</option>
                                                <option value="cover" selected>Cover (ƒë·ªï k√≠n, crop)</option>
                                            </select>
                                        </div>
                                        <div class="setting-item">
                                            <label>Safe Area (px)</label>
                                            <input type="number" id="borderTemplateSafeArea" min="0" max="50" value="0" class="template-input">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>M√†u n·ªÅn</label>
                                            <input type="color" id="borderTemplateBgColor" value="#FFFFFF" class="color-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>Drop Shadow</label>
                                            <input type="checkbox" id="borderTemplateDropShadow" class="checkbox-input">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Real-time Specs Display -->
                            <div class="current-specs">
                                <label class="subsection-label">‚óØ Th√¥ng s·ªë hi·ªán t·∫°i</label>
                                <div class="specs-display" id="borderTemplateSpecsDisplay">
                                    <!-- Will be populated by JavaScript -->
                                </div>
                            </div>

                            <!-- Reset Controls -->
                            <div class="reset-controls">
                                <button class="reset-btn" id="resetBorderTemplateDefaults">‚Ü∫ Kh√¥i ph·ª•c m·∫∑c ƒë·ªãnh</button>
                            </div>
                        </div>

                        <!-- Upload Area -->
                        <div class="config-group">
                            <label class="config-label" data-icon="‚¨Ü">·∫¢nh upload</label>
                            <div class="template-upload-zone" onclick="document.getElementById('borderTemplateFileInput').click()">
                                <div class="upload-icon">üñºÔ∏è</div>
                                <div class="upload-text">Ch·ªçn ·∫£nh ƒë·ªÉ t·∫°o vi·ªÅn th∆∞·ªùng</div>
                                <div class="upload-subtext">H·ªó tr·ª£ nhi·ªÅu ·∫£nh c√πng l√∫c - Auto crop center</div>
                                <input type="file" id="borderTemplateFileInput" accept="image/*" multiple style="display: none;">
                            </div>
                        </div>

                        <!-- Template Preview & Controls -->
                        <div class="config-group">
                            <label class="config-label" data-icon="‚óá">Preview & ƒêi·ªÅu ch·ªânh</label>
                            <div class="template-preview-area">
                                <div class="border-template-preview-container">
                                    <div class="border-template-frame">
                                        <div class="border-template-image-area" id="borderTemplateImageArea">
                                            <div class="placeholder-text">Ch·ªù ·∫£nh...</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Crop Controls -->
                                <div class="crop-controls" id="borderTemplateCropControls" style="display: none;">
                                    <div class="control-group">
                                        <button class="control-btn" id="borderTemplateCropReset">‚ü≤ Reset</button>
                                        <button class="control-btn" id="borderTemplateCropCenter">‚äö Center</button>
                                        <button class="control-btn" id="borderTemplateCropFit">‚óà Fit</button>
                                        <button class="control-btn primary" id="borderTemplateCropEdit">‚úÇÔ∏è Ch·ªânh crop</button>
                                    </div>
                                    <div class="crop-info" id="borderTemplateCropInfo">
                                        <span>K√©o ƒë·ªÉ ƒëi·ªÅu ch·ªânh v√πng crop</span>
                                    </div>
                                </div>
                                
                                <!-- Navigation Controls -->
                                <div class="navigation-controls" id="borderTemplateNavControls" style="display: none;">
                                    <button class="nav-btn" id="borderTemplatePrevBtn" disabled>‚óÄ Tr∆∞·ªõc</button>
                                    <span class="nav-info" id="borderTemplateNavInfo">0 / 0</span>
                                    <button class="nav-btn" id="borderTemplateNextBtn" disabled>Sau ‚ñ∂</button>
                                </div>
                                
                                <div class="export-controls">
                                    <button class="export-btn primary" id="exportCurrentBorderTemplate">üñºÔ∏è Xu·∫•t ·∫£nh hi·ªán t·∫°i</button>
                                    <button class="export-btn secondary" id="exportAllBorderTemplates">‚óá Xu·∫•t t·∫•t c·∫£ ZIP</button>
                                    <button class="export-btn individual" id="exportAllBorderIndividual">üìÅ Xu·∫•t t·ª´ng file ri√™ng</button>
                                </div>

                                <!-- File System Save Controls -->
                                <div class="filesystem-save-controls">
                                    <button class="filesystem-save-btn primary" id="saveBorderToFileSystem">üíæ L∆∞u v√†o File System</button>

                                    <div class="export-options-dropdown" id="borderExportOptions">
                                        <button class="dropdown-toggle" id="borderExportOptionsToggle">
                                            ‚§ì T√πy ch·ªçn xu·∫•t file
                                            <span class="dropdown-arrow">‚ñº</span>
                                        </button>
                                        <div class="dropdown-content" id="borderExportOptionsContent">
                                            <div class="option-group">
                                                <label class="option-label">
                                                    <input type="checkbox" id="borderCreateSubfolder" checked>
                                                    üìÅ T·∫°o th∆∞ m·ª•c con
                                                </label>
                                                <input type="text" id="borderSubfolderName" placeholder="Ti·ªÅn t·ªë th∆∞ m·ª•c..." value="Border_Templates" class="subfolder-input">
                                            </div>
                                        </div>
                                    </div>

                                    <div class="download-options">
                                        <button class="download-option-btn" id="borderDownloadCurrent">‚§ì T·∫£i trang hi·ªán t·∫°i</button>
                                        <button class="download-option-btn" id="borderDownloadIndividual">üìÅ Xu·∫•t t·ª´ng file ri√™ng</button>
                                        <button class="download-option-btn" id="borderDownloadZIP">‚ñ¶ T·∫£i file ZIP</button>
                                    </div>
                                </div>
                                
                                <div class="export-info">
                                    <div class="info-item">
                                        <span class="info-label">T√™n file:</span>
                                        <span class="info-value">Border_001.jpg, Border_002.jpg...</span>
                                    </div>
                                    <div class="info-item">
                                        <span class="info-label">ƒê·ªãnh d·∫°ng:</span>
                                        <span class="info-value">JPG - 300 DPI</span>
                                    </div>
                                    <div class="info-item">
                                        <span class="info-label">Xu·∫•t ri√™ng:</span>
                                        <span class="info-value">M·ªói ·∫£nh th√†nh 1 file ri√™ng bi·ªát</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Template Gallery -->
                    <div class="template-gallery" id="borderTemplateGallery">
                        <div class="gallery-header">
                            <h3>üñºÔ∏è Danh s√°ch ·∫£nh vi·ªÅn th∆∞·ªùng</h3>
                            <div class="gallery-stats">
                                <span class="stat-value" id="borderTemplateImageCount">0</span>
                                <span class="stat-label">·∫£nh ƒë√£ t·∫£i</span>
                            </div>
                        </div>
                        <div class="template-grid" id="borderTemplateGrid">
                            <!-- Border template previews will be generated here -->
                        </div>
                    </div>
                </div>
            </div>

                    </div>
                    
                    <!-- Strip Template Content -->
                    <div class="template-content" id="stripTemplateContent">
                <div class="template-container">
                    <!-- Header -->
                    <div class="template-content-header">
                        <h3>‚ùô Strip Layout</h3>
                        <p>D·∫£i ·∫£nh d·ªçc 4 khung phong c√°ch retro c·ªï ƒëi·ªÉn</p>
                    </div>

                    <!-- Template Configuration -->
                    <div class="template-config-panel">
                        <!-- Strip Configuration -->
                        <div class="config-group">
                            <label class="config-label" data-icon="‚ùô">C·∫•u h√¨nh Strip Layout</label>
                            
                            <!-- Size & DPI Settings -->
                            <div class="polaroid-basic-settings">
                                <div class="setting-row">
                                    <div class="setting-item">
                                        <label>DPI</label>
                                        <select id="stripTemplateDPI" class="template-select">
                                            <option value="150">150 DPI</option>
                                            <option value="200">200 DPI</option>
                                            <option value="300" selected>300 DPI</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <label>K√≠ch th∆∞·ªõc Strip (cm)</label>
                                        <div class="size-inputs">
                                            <input type="number" id="stripTemplateWidth" min="3" max="10" step="0.1" value="5" class="size-input">
                                            <span>√ó</span>
                                            <input type="number" id="stripTemplateHeight" min="10" max="25" step="0.1" value="15" class="size-input">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Frame Layout Settings -->
                            <div class="border-settings">
                                <label class="subsection-label">üñºÔ∏è C·∫•u h√¨nh khung ·∫£nh</label>
                                <div class="border-controls">
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>S·ªë khung ·∫£nh</label>
                                            <select id="stripFrameCount" class="template-select">
                                                <option value="3">3 khung</option>
                                                <option value="4" selected>4 khung</option>
                                                <option value="5">5 khung</option>
                                                <option value="6">6 khung</option>
                                            </select>
                                        </div>
                                        <div class="setting-item">
                                            <label>T·ª∑ l·ªá khung</label>
                                            <select id="stripFrameRatio" class="template-select">
                                                <option value="3:2">3:2 (Landscape)</option>
                                                <option value="4:3" selected>4:3 (Landscape)</option>
                                                <option value="16:9">16:9 (Wide)</option>
                                                <option value="1:1">1:1 (Vu√¥ng)</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Border & Spacing Settings -->
                            <div class="advanced-settings">
                                <label class="subsection-label">‚öô Vi·ªÅn & Kho·∫£ng c√°ch</label>
                                <div class="advanced-controls">
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Vi·ªÅn ngo√†i (mm)</label>
                                            <input type="range" id="stripOuterBorder" min="0" max="15" value="5" class="slider-input">
                                            <input type="number" id="stripOuterBorderValue" min="0" max="15" value="5" class="template-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>Kho·∫£ng c√°ch gi·ªØa khung (mm)</label>
                                            <input type="range" id="stripFrameSpacing" min="0" max="10" value="2" class="slider-input">
                                            <input type="number" id="stripFrameSpacingValue" min="0" max="10" value="2" class="template-input">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>Vi·ªÅn t·ª´ng ·∫£nh (mm)</label>
                                            <input type="range" id="stripFrameBorder" min="0" max="8" value="1" class="slider-input">
                                            <input type="number" id="stripFrameBorderValue" min="0" max="8" value="1" class="template-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>M√†u vi·ªÅn Strip</label>
                                            <input type="color" id="stripBorderColor" value="#FFFFFF" class="color-input">
                                        </div>
                                    </div>
                                    <div class="setting-row">
                                        <div class="setting-item">
                                            <label>M√†u vi·ªÅn khung</label>
                                            <input type="color" id="stripFrameColor" value="#FFFFFF" class="color-input">
                                        </div>
                                        <div class="setting-item">
                                            <label>M√†u n·ªÅn</label>
                                            <input type="color" id="stripTemplateBgColor" value="#000000" class="color-input">
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Real-time Specs Display -->
                            <div class="current-specs">
                                <label class="subsection-label">‚óØ Th√¥ng s·ªë hi·ªán t·∫°i</label>
                                <div class="specs-display" id="stripTemplateSpecsDisplay">
                                    <!-- Will be populated by JavaScript -->
                                </div>
                            </div>

                            <!-- Reset Controls -->
                            <div class="reset-controls">
                                <button class="reset-btn" id="resetStripTemplateDefaults">‚Ü∫ Kh√¥i ph·ª•c m·∫∑c ƒë·ªãnh</button>
                            </div>
                        </div>

                        <!-- Upload Area -->
                        <div class="config-group">
                            <label class="config-label" data-icon="‚¨Ü">Upload ·∫£nh cho Strip</label>
                            <div class="template-upload-zone" onclick="document.getElementById('stripTemplateFileInput').click()">
                                <div class="upload-icon">üì∏</div>
                                <div class="upload-text">Ch·ªçn 4 ·∫£nh ƒë·ªÉ t·∫°o Strip Layout</div>
                                <div class="upload-subtext">H·ªó tr·ª£ nhi·ªÅu ·∫£nh - T·ª∑ l·ªá landscape khuy·∫øn ngh·ªã</div>
                                <input type="file" id="stripTemplateFileInput" accept="image/*" multiple style="display: none;">
                            </div>
                        </div>

                        <!-- Template Preview & Controls -->
                        <div class="config-group">
                            <label class="config-label" data-icon="‚óá">Preview Strip Layout</label>
                            <div class="template-preview-area">
                                <div class="strip-template-preview-container">
                                    <div class="strip-template-frame" id="stripTemplateFrame">
                                        <!-- 4 frame areas will be generated here -->
                                        <div class="strip-frame" id="stripFrame1">
                                            <div class="strip-placeholder">
                                                <div class="placeholder-landscape"></div>
                                                <div class="placeholder-text">·∫¢nh 1</div>
                                            </div>
                                        </div>
                                        <div class="strip-frame" id="stripFrame2">
                                            <div class="strip-placeholder">
                                                <div class="placeholder-landscape"></div>
                                                <div class="placeholder-text">·∫¢nh 2</div>
                                            </div>
                                        </div>
                                        <div class="strip-frame" id="stripFrame3">
                                            <div class="strip-placeholder">
                                                <div class="placeholder-landscape"></div>
                                                <div class="placeholder-text">·∫¢nh 3</div>
                                            </div>
                                        </div>
                                        <div class="strip-frame" id="stripFrame4">
                                            <div class="strip-placeholder">
                                                <div class="placeholder-landscape"></div>
                                                <div class="placeholder-text">·∫¢nh 4</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Crop Controls -->
                                <div class="crop-controls" id="stripTemplateCropControls" style="display: none;">
                                    <div class="control-group">
                                        <button class="control-btn" id="stripTemplateCropReset">‚ü≤ Reset T·∫•t c·∫£</button>
                                        <button class="control-btn" id="stripTemplateCropCenter">‚äö Center T·∫•t c·∫£</button>
                                        <button class="control-btn primary" id="stripTemplateCropEdit">‚úÇÔ∏è Ch·ªânh t·ª´ng ·∫£nh</button>
                                    </div>
                                    <div class="crop-info" id="stripTemplateCropInfo">
                                        <span>S·ª≠ d·ª•ng navigation ƒë·ªÉ xem t·ª´ng ·∫£nh trong strip</span>
                                    </div>
                                </div>
                                
                                <!-- Navigation Controls -->
                                <div class="navigation-controls" id="stripTemplateNavControls" style="display: none;">
                                    <button class="nav-btn" id="stripTemplatePrevBtn" disabled>‚óÄ ·∫¢nh tr∆∞·ªõc</button>
                                    <span class="nav-info" id="stripTemplateNavInfo">0 / 0</span>
                                    <button class="nav-btn" id="stripTemplateNextBtn" disabled>·∫¢nh sau ‚ñ∂</button>
                                </div>
                                
                                <div class="export-controls">
                                    <button class="export-btn primary" id="exportCurrentStripTemplate">üì∏ Xu·∫•t Strip hi·ªán t·∫°i</button>
                                    <button class="export-btn secondary" id="exportAllStripTemplates">‚óá Xu·∫•t t·∫•t c·∫£ ZIP</button>
                                    <button class="export-btn individual" id="exportAllStripIndividual">üìÅ Xu·∫•t t·ª´ng strip ri√™ng</button>
                                </div>

                                <!-- File System Save Controls -->
                                <div class="filesystem-save-controls">
                                    <button class="filesystem-save-btn primary" id="saveStripToFileSystem">üíæ L∆∞u v√†o File System</button>

                                    <div class="export-options-dropdown" id="stripExportOptions">
                                        <button class="dropdown-toggle" id="stripExportOptionsToggle">
                                            ‚§ì T√πy ch·ªçn xu·∫•t file
                                            <span class="dropdown-arrow">‚ñº</span>
                                        </button>
                                        <div class="dropdown-content" id="stripExportOptionsContent">
                                            <div class="option-group">
                                                <label class="option-label">
                                                    <input type="checkbox" id="stripCreateSubfolder" checked>
                                                    üìÅ T·∫°o th∆∞ m·ª•c con
                                                </label>
                                                <input type="text" id="stripSubfolderName" placeholder="Ti·ªÅn t·ªë th∆∞ m·ª•c..." value="Strip_Templates" class="subfolder-input">
                                            </div>
                                        </div>
                                    </div>

                                    <div class="download-options">
                                        <button class="download-option-btn" id="stripDownloadCurrent">‚§ì T·∫£i trang hi·ªán t·∫°i</button>
                                        <button class="download-option-btn" id="stripDownloadIndividual">üìÅ Xu·∫•t t·ª´ng file ri√™ng</button>
                                        <button class="download-option-btn" id="stripDownloadZIP">‚ñ¶ T·∫£i file ZIP</button>
                                    </div>
                                </div>
                                
                                <div class="export-info">
                                    <div class="info-item">
                                        <span class="info-label">T√™n file:</span>
                                        <span class="info-value">PhotoStrip_001.jpg, PhotoStrip_002.jpg...</span>
                                    </div>
                                    <div class="info-item">
                                        <span class="info-label">ƒê·ªãnh d·∫°ng:</span>
                                        <span class="info-value">JPG - 300 DPI - 5√ó15cm</span>
                                    </div>
                                    <div class="info-item">
                                        <span class="info-label">Xu·∫•t:</span>
                                        <span class="info-value">M·ªói strip ch·ª©a 4 ·∫£nh th√†nh 1 file</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Template Gallery -->
                    <div class="template-gallery" id="stripTemplateGallery">
                        <div class="gallery-header">
                            <h3>üì∏ Danh s√°ch Strip Layout</h3>
                            <div class="gallery-stats">
                                <span class="stat-value" id="stripTemplateImageCount">0</span>
                                <span class="stat-label">strip ƒë√£ t·∫°o</span>
                            </div>
                        </div>
                        <div class="template-grid" id="stripTemplateGrid">
                            <!-- Strip template previews will be generated here -->
                        </div>
                    </div>
                    </div>
                </div>
            </div>

            <!-- Print Section -->
            <div class="function-section" id="printSection">
                <div class="print-container">
                    <!-- Header -->
                    <div class="section-header">
                        <h2>File in</h2>
                        <p>D√†n ·∫£nh t·ªëi ∆∞u cho in ·∫•n v·ªõi ƒë·ªô ch√≠nh x√°c cao</p>
                    </div>

                    <!-- 2-Column Layout -->
                    <div class="print-layout-2col">
                        <!-- LEFT COLUMN: Controls -->
                        <div class="print-left-column">

                    <!-- Quick Setup Presets - Pills Version -->
                    <div class="quick-presets-v2">
                        <div class="presets-header">
                            <h3>C√†i ƒë·∫∑t nhanh</h3>
                            <button class="expand-presets-btn" id="expandPresetsBtn" title="Xem th√™m">
                                <span class="expand-icon">‚ñº</span>
                            </button>
                        </div>
                        <div class="preset-pills-container">
                            <div class="preset-pills-row">
                                <button class="preset-pill active" data-preset="standard-5.5x8.5" title="A4 d·ªçc, ·∫£nh 5.5√ó8.5cm, l·ªÅ 5mm">
                                    <span class="pill-icon"><svg class="svg-icon"><use href="#icon-camera"></use></svg></span>
                                    <span class="pill-text">5.5√ó8.5</span>
                                </button>
                                <button class="preset-pill" data-preset="standard-6x9" title="A4 d·ªçc, ·∫£nh 6√ó9cm, l·ªÅ 5mm">
                                    <span class="pill-icon"><svg class="svg-icon"><use href="#icon-id-card"></use></svg></span>
                                    <span class="pill-text">6√ó9</span>
                                </button>
                                <button class="preset-pill" data-preset="standard-7x10" title="A4 d·ªçc, ·∫£nh 7√ó10cm, l·ªÅ 5mm">
                                    <span class="pill-icon"><svg class="svg-icon"><use href="#icon-photo"></use></svg></span>
                                    <span class="pill-text">7√ó10</span>
                                </button>
                                <button class="preset-pill" data-preset="standard-9.5x9.5" title="A4 ngang, ·∫£nh 9.5√ó9.5cm vu√¥ng, l·ªÅ 5mm">
                                    <span class="pill-icon"><svg class="svg-icon"><use href="#icon-square"></use></svg></span>
                                    <span class="pill-text">9.5¬≤</span>
                                </button>
                                <button class="preset-pill more-pill" id="morePresetsBtn">
                                    <span class="pill-icon">¬∑¬∑¬∑</span>
                                    <span class="pill-text">Th√™m</span>
                                </button>
                                <button class="preset-pill custom-pill" data-preset="custom">
                                    <span class="pill-icon"><svg class="svg-icon"><use href="#icon-settings"></use></svg></span>
                                    <span class="pill-text">T√πy ch·ªânh</span>
                                </button>
                            </div>
                            <div class="preset-pills-expanded" id="expandedPresets" style="display: none;">
                                <button class="preset-pill" data-preset="paper-10x15" title="Gi·∫•y 10√ó15cm, ·∫£nh 10√ó15cm, l·ªÅ 5mm">
                                    <span class="pill-icon"><svg class="svg-icon"><use href="#icon-photo"></use></svg></span>
                                    <span class="pill-text">10√ó15</span>
                                </button>
                                <button class="preset-pill" data-preset="paper-a6" title="Gi·∫•y A6 (10.5√ó14.8cm), l·ªÅ 5mm">
                                    <span class="pill-icon"><svg class="svg-icon"><use href="#icon-photo"></use></svg></span>
                                    <span class="pill-text">A6</span>
                                </button>
                                <button class="preset-pill" data-preset="paper-a5" title="Gi·∫•y A5 (14.8√ó21cm), l·ªÅ 5mm">
                                    <span class="pill-icon"><svg class="svg-icon"><use href="#icon-photo"></use></svg></span>
                                    <span class="pill-text">A5</span>
                                </button>
                                <button class="preset-pill" data-preset="sk316-namecard" title="SK316 namecard: A4 d·ªçc, card 90√ó54mm ngang, gutter 3mm c·ªë ƒë·ªãnh, grid 2√ó5 = 10 cards">
                                    <span class="pill-icon"><svg class="svg-icon"><use href="#icon-scissors"></use></svg></span>
                                    <span class="pill-text">SK316</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Custom Saved Presets Section -->
                    <div class="saved-presets-section" id="savedPresetsSection">
                        <div class="saved-presets-header">
                            <h3><svg class="svg-icon"><use href="#icon-folder"></use></svg> Preset ƒë√£ l∆∞u</h3>
                            <div class="preset-actions">
                                <button class="preset-action-btn" id="saveNewPresetBtn" title="L∆∞u c·∫•u h√¨nh hi·ªán t·∫°i">
                                    <span class="action-icon"><svg class="svg-icon"><use href="#icon-plus"></use></svg></span>
                                    <span class="action-text">L∆∞u m·ªõi</span>
                                </button>
                                <button class="preset-action-btn" id="importPresetBtn" title="Import preset">
                                    <span class="action-icon"><svg class="svg-icon"><use href="#icon-upload"></use></svg></span>
                                    <span class="action-text">Import</span>
                                </button>
                                <button class="preset-action-btn" id="exportAllPresetsBtn" title="Export t·∫•t c·∫£ preset">
                                    <span class="action-icon"><svg class="svg-icon"><use href="#icon-download"></use></svg></span>
                                    <span class="action-text">Export</span>
                                </button>
                            </div>
                        </div>
                        <div class="saved-presets-grid" id="savedPresetsGrid">
                            <div class="no-presets-message">
                                <span class="no-preset-icon"><svg class="svg-icon"><use href="#icon-inbox"></use></svg></span>
                                <p>Ch∆∞a c√≥ preset n√†o ƒë∆∞·ª£c l∆∞u</p>
                                <small>Nh·∫•n "L∆∞u m·ªõi" ƒë·ªÉ l∆∞u c·∫•u h√¨nh hi·ªán t·∫°i</small>
                            </div>
                        </div>
                    </div>

                    <!-- Compact Configuration Panel -->
                    <div class="print-config-compact" id="printConfigCompact">
                        <!-- Essential Settings Card -->
                        <div class="config-card essential-card">
                            <div class="card-header">
                                <h4><svg class="svg-icon"><use href="#icon-target"></use></svg> C√†i ƒë·∫∑t c∆° b·∫£n</h4>
                                <button class="card-toggle" data-target="essential-settings">‚ñ≤</button>
                            </div>
                            <div class="card-content" id="essential-settings">
                                <div class="settings-row">
                                    <div class="setting-group">
                                        <label><svg class="svg-icon"><use href="#icon-document"></use></svg> Kh·ªï gi·∫•y</label>
                                        <select id="paperSizeSelect" class="compact-select">
                                            <option value="a4">A4 (210√ó297mm)</option>
                                            <option value="a3">A3 (297√ó420mm)</option>
                                            <option value="letter">Letter (216√ó279mm)</option>
                                            <option value="custom">T√πy ch·ªânh</option>
                                        </select>
                                    </div>
                                    <div class="setting-group">
                                        <label><svg class="svg-icon"><use href="#icon-rotate"></use></svg> H∆∞·ªõng</label>
                                        <div class="orientation-buttons">
                                            <button class="orient-btn active" data-orientation="portrait" title="D·ªçc">‚ñØ</button>
                                            <button class="orient-btn" data-orientation="landscape" title="Ngang">‚ñ≠</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="settings-row">
                                    <div class="setting-group full-width">
                                        <label><svg class="svg-icon"><use href="#icon-photo"></use></svg> K√≠ch th∆∞·ªõc ·∫£nh</label>
                                        <select id="photoSizeSelect" class="compact-select">
                                            <option value="4x6">4√ó6 cm</option>
                                            <option value="5x7">5√ó7 cm</option>
                                            <option value="5.5x8.5">5.5√ó8.5 cm (Ti√™u chu·∫©n)</option>
                                            <option value="4.74x6.6">Polaroid 5.5√ó8.5</option>
                                            <option value="5x15">5√ó15 cm (Bookmark)</option>
                                            <option value="6x9">6√ó9 cm (H·ªô chi·∫øu)</option>
                                            <option value="9.5x9.5">9.5√ó9.5 cm (Vu√¥ng)</option>
                                            <option value="polaroid">54√ó67 mm (Mini Polaroid)</option>
                                            <option value="custom">T√πy ch·ªânh</option>
                                        </select>
                                    </div>
                                </div>

                                <div class="settings-row">
                                    <div class="setting-group full-width">
                                        <label><svg class="svg-icon"><use href="#icon-printer"></use></svg> Ch·∫ø ƒë·ªô in</label>
                                        <select id="printModeSelect" class="compact-select">
                                            <option value="single">In 1 m·∫∑t</option>
                                            <option value="duplex">In 2 m·∫∑t th·ªß c√¥ng</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- Duplex Configuration (hi·ªán khi ch·ªçn In 2 m·∫∑t) -->
                                <div class="duplex-config-inline" id="duplexConfigInline" style="display: none;">
                                    <div class="duplex-section-header">
                                        <svg class="svg-icon section-icon"><use href="#icon-book-open"></use></svg>
                                        <span class="section-title">C·∫•u h√¨nh in 2 m·∫∑t</span>
                                    </div>

                                    <div class="duplex-content">
                                        <div class="duplex-flip-row">
                                            <label>H∆∞·ªõng l·∫≠t:</label>
                                            <div class="flip-buttons-inline">
                                                <button class="flip-btn-inline active" data-flip="long-edge" title="L·∫≠t theo c·∫°nh d√†i (tr√°i-ph·∫£i)">
                                                    <svg class="svg-icon"><use href="#icon-book-open"></use></svg> C·∫°nh d√†i
                                                </button>
                                                <button class="flip-btn-inline" data-flip="short-edge" title="L·∫≠t theo c·∫°nh ng·∫Øn (tr√™n-d∆∞·ªõi)">
                                                    <svg class="svg-icon"><use href="#icon-files"></use></svg> C·∫°nh ng·∫Øn
                                                </button>
                                            </div>
                                        </div>

                                        <div class="duplex-bleed-row">
                                            <label class="bleed-toggle-inline">
                                                <input type="checkbox" id="backSideBleedToggleInline" checked>
                                                <span class="toggle-switch-mini"></span>
                                                <span class="toggle-label">Bleed m·∫∑t sau</span>
                                            </label>
                                            <div class="bleed-value-inline" id="bleedValueInline">
                                                <input type="range" id="backSideBleedSliderInline" min="0" max="1" step="0.05" value="0.3" class="slider-mini">
                                                <span class="value-display" id="backSideBleedValueInline">0.3mm</span>
                                            </div>
                                        </div>

                                        <div class="duplex-hint">
                                            <svg class="svg-icon hint-icon"><use href="#icon-lightbulb"></use></svg>
                                            <span class="hint-text" id="duplexInstructionsInline">In trang l·∫ª ‚Üí L·∫≠t theo c·∫°nh d√†i ‚Üí In trang ch·∫µn</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Custom Size Inputs (Hidden by default) -->
                                <div class="custom-inputs" id="customInputsSection" style="display: none;">
                                    <div class="custom-paper" id="customPaperInputs" style="display: none;">
                                        <h5><svg class="svg-icon"><use href="#icon-document"></use></svg> K√≠ch th∆∞·ªõc gi·∫•y t√πy ch·ªânh</h5>
                                        <div class="input-row">
                                            <input type="number" id="paperWidth" min="50" max="1000" value="210" placeholder="R·ªông (mm)">
                                            <input type="number" id="paperHeight" min="50" max="1500" value="297" placeholder="Cao (mm)">
                                        </div>
                                    </div>
                                    <div class="custom-photo" id="customPhotoInputs" style="display: none;">
                                        <h5><svg class="svg-icon"><use href="#icon-photo"></use></svg> K√≠ch th∆∞·ªõc ·∫£nh t√πy ch·ªânh</h5>
                                        <div class="input-row">
                                            <input type="number" id="photoWidth" min="1" max="50" step="0.1" value="5.5" placeholder="R·ªông (cm)">
                                            <input type="number" id="photoHeight" min="1" max="50" step="0.1" value="8.5" placeholder="Cao (cm)">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Layout Settings Card -->
                        <div class="config-card layout-card">
                            <div class="card-header">
                                <h4><svg class="svg-icon"><use href="#icon-ruler"></use></svg> B·ªë c·ª•c & Kho·∫£ng c√°ch</h4>
                                <button class="card-toggle" data-target="layout-settings">‚ñº</button>
                            </div>
                            <div class="card-content collapsed" id="layout-settings">
                                <div class="settings-row">
                                    <div class="setting-group">
                                        <label><svg class="svg-icon"><use href="#icon-ruler"></use></svg> L·ªÅ (mm)</label>
                                        <div class="margin-inputs-compact">
                                            <input type="number" id="marginAll" min="0" max="50" value="10" placeholder="T·∫•t c·∫£">
                                            <button class="margin-expand" id="marginExpandBtn" title="T√πy ch·ªânh t·ª´ng c·∫°nh"><svg class="svg-icon"><use href="#icon-settings"></use></svg></button>
                                        </div>
                                        <div class="margin-detailed" id="marginDetailed" style="display: none;">
                                            <div class="margin-grid">
                                                <input type="number" id="marginTop" min="0" max="50" value="10" placeholder="Tr√™n">
                                                <input type="number" id="marginRight" min="0" max="50" value="10" placeholder="Ph·∫£i">
                                                <input type="number" id="marginBottom" min="0" max="50" value="10" placeholder="D∆∞·ªõi">
                                                <input type="number" id="marginLeft" min="0" max="50" value="10" placeholder="Tr√°i">
                                            </div>
                                        </div>
                                    </div>
                                    <div class="setting-group">
                                        <label><svg class="svg-icon"><use href="#icon-ruler"></use></svg> Kho·∫£ng c√°ch (mm)</label>
                                        <div class="gutter-inputs-compact">
                                            <input type="number" id="gutterX" min="0" max="20" value="5" placeholder="Ngang">
                                            <input type="number" id="gutterY" min="0" max="20" value="5" placeholder="D·ªçc">
                                        </div>
                                        <div class="gutter-hint">
                                            <svg class="svg-icon"><use href="#icon-lightbulb"></use></svg>
                                            <small>SK316: C·ªë ƒë·ªãnh 3mm (blade spacing)</small>
                                        </div>
                                    </div>
                                </div>
                                <div class="settings-row">
                                    <div class="setting-group">
                                        <label><svg class="svg-icon"><use href="#icon-zap"></use></svg> Fit ·∫£nh</label>
                                        <div class="fit-buttons">
                                            <button class="fit-btn active" data-fit="fill" title="L·∫•p ƒë·∫ßy, crop n·∫øu c·∫ßn"><svg class="svg-icon"><use href="#icon-scissors"></use></svg> Fill</button>
                                            <button class="fit-btn" data-fit="contain" title="Kh√¥ng crop, th√™m vi·ªÅn"><svg class="svg-icon"><use href="#icon-box"></use></svg> Fit</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Advanced Settings Card -->
                        <div class="config-card advanced-card">
                            <div class="card-header">
                                <h4><svg class="svg-icon"><use href="#icon-scissors"></use></svg> ƒê∆∞·ªùng c·∫Øt</h4>
                                <button class="card-toggle" data-target="advanced-settings">‚ñº</button>
                            </div>
                            <div class="card-content collapsed" id="advanced-settings">
                                <div class="settings-row">
                                    <div class="setting-group full-width">
                                        <label><svg class="svg-icon"><use href="#icon-scissors"></use></svg> ƒê∆∞·ªùng c·∫Øt</label>
                                        <div class="cutting-presets">
                                            <button class="cutting-preset active" data-cutting="standard">
                                                <span class="preset-icon"><svg class="svg-icon"><use href="#icon-ruler"></use></svg></span>
                                                <div class="preset-info">
                                                    <div class="preset-name">Ti√™u chu·∫©n</div>
                                                    <div class="preset-desc">ƒê∆∞·ªùng c·∫Øt ngo√†i + gi·ªØa ·∫£nh</div>
                                                </div>
                                            </button>
                                            <button class="cutting-preset" data-cutting="minimal">
                                                <span class="preset-icon"><svg class="svg-icon"><use href="#icon-clean"></use></svg></span>
                                                <div class="preset-info">
                                                    <div class="preset-name">T·ªëi gi·∫£n</div>
                                                    <div class="preset-desc">Ch·ªâ ƒë∆∞·ªùng c·∫Øt c·∫ßn thi·∫øt</div>
                                                </div>
                                            </button>
                                            <button class="cutting-preset" data-cutting="detailed">
                                                <span class="preset-icon"><svg class="svg-icon"><use href="#icon-target"></use></svg></span>
                                                <div class="preset-info">
                                                    <div class="preset-name">Chi ti·∫øt</div>
                                                    <div class="preset-desc">ƒê·∫ßy ƒë·ªß ƒë√°nh d·∫•u + l∆∞·ªõi</div>
                                                </div>
                                            </button>
                                            <button class="cutting-preset" data-cutting="custom">
                                                <span class="preset-icon"><svg class="svg-icon"><use href="#icon-settings"></use></svg></span>
                                                <div class="preset-info">
                                                    <div class="preset-name">T√πy ch·ªânh</div>
                                                    <div class="preset-desc">Thi·∫øt l·∫≠p ri√™ng</div>
                                                </div>
                                            </button>
                                        </div>
                                        
                                        <!-- Custom Cutting Options -->
                                        <div class="cutting-custom-options" id="cuttingCustomOptions" style="display: none;">
                                            <div class="cutting-checkboxes">
                                                <label class="cutting-check">
                                                    <input type="checkbox" id="outerCuttingLines" checked>
                                                    <span class="check-icon">‚ñ†</span>
                                                    <span class="check-text">ƒê∆∞·ªùng c·∫Øt ngo√†i</span>
                                                </label>
                                                <label class="cutting-check">
                                                    <input type="checkbox" id="betweenImages" checked>
                                                    <span class="check-icon">‚îÜ</span>
                                                    <span class="check-text">ƒê∆∞·ªùng c·∫Øt gi·ªØa ·∫£nh</span>
                                                </label>
                                                <label class="cutting-check">
                                                    <input type="checkbox" id="cornerMarks">
                                                    <span class="check-icon">‚îº</span>
                                                    <span class="check-text">ƒê√°nh d·∫•u g√≥c</span>
                                                </label>
                                                <label class="cutting-check">
                                                    <input type="checkbox" id="gridHelperLines">
                                                    <span class="check-icon">‚ñí</span>
                                                    <span class="check-text">L∆∞·ªõi h·ªó tr·ª£</span>
                                                </label>
                                            </div>
                                            <div class="cutting-style-compact">
                                                <div class="style-row">
                                                    <label>M√†u:</label>
                                                    <div class="color-dots">
                                                        <button class="color-dot active" data-color="#000000" style="background: #000000;" title="ƒêen"></button>
                                                        <button class="color-dot" data-color="#3B82F6" style="background: #3B82F6;" title="Xanh"></button>
                                                        <button class="color-dot" data-color="#EF4444" style="background: #EF4444;" title="ƒê·ªè"></button>
                                                    </div>
                                                </div>
                                                <div class="style-row">
                                                    <label>ƒê·ªô d√†y:</label>
                                                    <select id="lineThickness" class="mini-select">
                                                        <option value="0.1">0.1px</option>
                                                        <option value="0.25" selected>0.25px</option>
                                                        <option value="0.5">0.5px</option>
                                                        <option value="1.0">1.0px</option>
                                                    </select>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Duplex Configuration -->
                                <div class="duplex-config-compact" id="duplexConfigCompact" style="display: none;">
                                    <div class="duplex-flip-options">
                                        <label><svg class="svg-icon"><use href="#icon-book-open"></use></svg> H∆∞·ªõng l·∫≠t gi·∫•y:</label>
                                        <div class="flip-buttons">
                                            <button class="flip-btn active" data-flip="long-edge">
                                                <span class="flip-icon"><svg class="svg-icon"><use href="#icon-book-open"></use></svg></span>
                                                <span class="flip-text">C·∫°nh d√†i</span>
                                            </button>
                                            <button class="flip-btn" data-flip="short-edge">
                                                <span class="flip-icon"><svg class="svg-icon"><use href="#icon-files"></use></svg></span>
                                                <span class="flip-text">C·∫°nh ng·∫Øn</span>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="duplex-instruction-mini">
                                        <span class="instruction-icon"><svg class="svg-icon"><use href="#icon-lightbulb"></use></svg></span>
                                        <span id="duplexInstructions">1. In trang l·∫ª ‚Üí 2. L·∫≠t theo c·∫°nh d√†i ‚Üí 3. In trang ch·∫µn</span>
                                    </div>

                                    <!-- Back Side Bleed Control -->
                                    <div class="duplex-bleed-control">
                                        <div class="bleed-header">
                                            <label class="bleed-toggle-label">
                                                <input type="checkbox" id="backSideBleedToggle" checked>
                                                <span class="toggle-switch"></span>
                                                <span class="toggle-text"><svg class="svg-icon"><use href="#icon-eye"></use></svg> T·ª± ƒë·ªông bleed m·∫∑t sau</span>
                                            </label>
                                            <span class="bleed-info-icon" title="Ph√≥ng to ·∫£nh m·∫∑t sau 0.1-1mm ƒë·ªÉ tr√°nh l·ªô vi·ªÅn tr·∫Øng khi in l·ªách"><svg class="svg-icon"><use href="#icon-eye"></use></svg></span>
                                        </div>
                                        <div class="bleed-slider-container" id="bleedSliderContainer">
                                            <label>ƒê·ªô tr√†n l·ªÅ (Bleed):</label>
                                            <div class="slider-with-value">
                                                <input type="range" id="backSideBleedSlider" min="0" max="1" step="0.05" value="0.3">
                                                <span class="slider-value" id="backSideBleedValue">0.3mm</span>
                                            </div>
                                            <div class="bleed-hint">
                                                <small><svg class="svg-icon"><use href="#icon-lightbulb"></use></svg> Khuy·∫øn ngh·ªã: 0.3mm cho m√°y in th√¥ng th∆∞·ªùng, 0.5mm cho m√°y c≈©</small>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- SK316 Offset rNcM Card -->
                        <div class="config-card offset-card">
                            <div class="card-header">
                                <h4><svg class="svg-icon"><use href="#icon-target"></use></svg> Offset rNcM (SK316)</h4>
                                <button class="card-toggle" data-target="offset-settings">‚ñº</button>
                            </div>
                            <div class="card-content collapsed" id="offset-settings">
                                <div class="offset-instructions">
                                    <svg class="svg-icon"><use href="#icon-lightbulb"></use></svg>
                                    <span>B√π l·ªách X/Y theo t·ª´ng √¥ trong layout 2√ó5 ƒë·ªÉ s·ª≠a l·ªói m√°y c·∫Øt SK316</span>
                                </div>

                                <!-- Toggle Enable Offset -->
                                <div class="offset-toggle-section">
                                    <label class="offset-enable-toggle">
                                        <input type="checkbox" id="enableOffsetRncm">
                                        <span class="toggle-switch"></span>
                                        <span class="toggle-text">B·∫≠t hi·ªáu ch·ªânh offset</span>
                                    </label>
                                </div>

                                <!-- Offset Table Container -->
                                <div class="offset-table-container" id="offsetTableContainer" style="display: none;">
                                    <div class="offset-table-header">
                                        <span>SK316 Grid: 2 c·ªôt √ó 5 h√†ng (10 √¥)</span>
                                        <div class="offset-table-actions">
                                            <button class="offset-btn-mini" id="offsetResetBtn" title="Reset t·∫•t c·∫£ v·ªÅ 0">‚Ü∫</button>
                                            <button class="offset-btn-mini" id="offsetFillZeroBtn" title="ƒêi·ªÅn 0 t·∫•t c·∫£">0</button>
                                        </div>
                                    </div>

                                    <table class="offset-table-rncm">
                                        <thead>
                                            <tr>
                                                <th>√î</th>
                                                <th>X (mm)</th>
                                                <th>Y (mm)</th>
                                            </tr>
                                        </thead>
                                        <tbody id="offsetRncmTableBody">
                                            <tr>
                                                <td>r1c1</td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r1c1" data-axis="x" class="offset-input-rncm"></td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r1c1" data-axis="y" class="offset-input-rncm"></td>
                                            </tr>
                                            <tr>
                                                <td>r1c2</td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r1c2" data-axis="x" class="offset-input-rncm"></td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r1c2" data-axis="y" class="offset-input-rncm"></td>
                                            </tr>
                                            <tr>
                                                <td>r2c1</td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r2c1" data-axis="x" class="offset-input-rncm"></td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r2c1" data-axis="y" class="offset-input-rncm"></td>
                                            </tr>
                                            <tr>
                                                <td>r2c2</td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r2c2" data-axis="x" class="offset-input-rncm"></td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r2c2" data-axis="y" class="offset-input-rncm"></td>
                                            </tr>
                                            <tr>
                                                <td>r3c1</td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r3c1" data-axis="x" class="offset-input-rncm"></td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r3c1" data-axis="y" class="offset-input-rncm"></td>
                                            </tr>
                                            <tr>
                                                <td>r3c2</td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r3c2" data-axis="x" class="offset-input-rncm"></td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r3c2" data-axis="y" class="offset-input-rncm"></td>
                                            </tr>
                                            <tr>
                                                <td>r4c1</td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r4c1" data-axis="x" class="offset-input-rncm"></td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r4c1" data-axis="y" class="offset-input-rncm"></td>
                                            </tr>
                                            <tr>
                                                <td>r4c2</td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r4c2" data-axis="x" class="offset-input-rncm"></td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r4c2" data-axis="y" class="offset-input-rncm"></td>
                                            </tr>
                                            <tr>
                                                <td>r5c1</td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r5c1" data-axis="x" class="offset-input-rncm"></td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r5c1" data-axis="y" class="offset-input-rncm"></td>
                                            </tr>
                                            <tr>
                                                <td>r5c2</td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r5c2" data-axis="x" class="offset-input-rncm"></td>
                                                <td><input type="number" step="0.1" min="-1" max="1" value="0" data-cell="r5c2" data-axis="y" class="offset-input-rncm"></td>
                                            </tr>
                                        </tbody>
                                    </table>

                                    <div class="offset-hint">
                                        <svg class="svg-icon"><use href="#icon-lightbulb"></use></svg>
                                        <small>D∆∞∆°ng (+): l·ªách ph·∫£i/l√™n | √Çm (‚àí): l·ªách tr√°i/xu·ªëng. Map ch√≠nh x√°c v·ªõi layout 2√ó5 c·ªßa SK316.</small>
                                    </div>
                                    <div class="offset-warning" style="display:flex; align-items:center; gap:8px; margin-top:8px; padding:8px; background:#fef2f2; border:1px solid #fecaca; border-radius:6px;">
                                        <svg class="svg-icon" style="width:16px; height:16px; color:#dc2626; flex-shrink:0;"><use href="#icon-alert"></use></svg>
                                        <small style="color:#991b1b; font-size:0.8em;">‚ö†Ô∏è SK316 gi·ªõi h·∫°n: Offset ch·ªâ cho ph√©p [-1.0mm, +1.0mm]. Kho·∫£ng c√°ch 3mm blade gap kh√¥ng ƒë∆∞·ª£c x√¢m ph·∫°m!</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Layout Preview V2 - Enhanced -->
                    <div class="layout-preview-v2">
                        <div class="preview-container">
                            <!-- Visual Paper Preview -->
                            <div class="paper-visualization">
                                <div class="paper-label">B·ªë c·ª•c trang in</div>
                                <div class="paper-frame" id="paperFrame">
                                    <div class="paper-grid" id="paperGrid">
                                        <!-- Grid cells will be generated here -->
                                    </div>
                                    <div class="paper-dimensions" id="paperDimensions">A4 d·ªçc</div>
                                </div>
                            </div>

                            <!-- Stats Panel -->
                            <div class="stats-panel">
                                <div class="stats-grid">
                                    <div class="stat-card">
                                        <div class="stat-icon">üìè</div>
                                        <div class="stat-content">
                                            <span class="stat-value" id="maxPhotosCount">0</span>
                                            <span class="stat-label">·∫£nh/trang</span>
                                        </div>
                                    </div>
                                    <div class="stat-card">
                                        <div class="stat-icon">‚äû</div>
                                        <div class="stat-content">
                                            <span class="stat-value" id="gridLayout">0√ó0</span>
                                            <span class="stat-label">l∆∞·ªõi</span>
                                        </div>
                                    </div>
                                    <div class="stat-card">
                                        <div class="stat-icon">üìÑ</div>
                                        <div class="stat-content">
                                            <span class="stat-value" id="totalPages">0</span>
                                            <span class="stat-label">trang</span>
                                        </div>
                                    </div>
                                    <div class="stat-card efficiency">
                                        <div class="stat-icon">üìä</div>
                                        <div class="stat-content">
                                            <span class="stat-value" id="efficiencyRate">0%</span>
                                            <span class="stat-label">hi·ªáu su·∫•t</span>
                                            <div class="efficiency-bar">
                                                <div class="efficiency-fill" id="efficiencyFill" style="width: 0%"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="layout-suggestion" id="layoutSuggestion">
                                    <span class="suggestion-icon">üí°</span>
                                    <span class="suggestion-text">Ch·ªù c·∫•u h√¨nh...</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Drag & Drop Zone V2 - Enhanced -->
                    <div class="drag-drop-zone-v2" id="dragDropZone">
                        <!-- Main Drop Area -->
                        <div class="drop-area-main" id="dropAreaMain">
                            <div class="drop-content" id="dropContent">
                                <div class="drop-icon">üéØ</div>
                                <div class="drop-title">K√©o & Th·∫£ ·∫£nh v√†o ƒë√¢y</div>
                                <div class="drop-subtitle">ho·∫∑c ch·ªçn t·ª´:</div>
                                <div class="drop-actions">
                                    <button class="drop-action-btn primary" onclick="document.getElementById('printFileInput').click()">
                                        <span class="action-icon">üìÅ</span>
                                        <span class="action-text">M√°y t√≠nh</span>
                                    </button>
                                    <button class="drop-action-btn secondary" id="useGalleryImagesBtn">
                                        <span class="action-icon">üñºÔ∏è</span>
                                        <span class="action-text">Kho ·∫£nh</span>
                                    </button>
                                    <button class="drop-action-btn tertiary" id="printFromFileSystemBtn" onclick="loadImagesFromFileSystem('print')">
                                        <span class="action-icon">üíæ</span>
                                        <span class="action-text">File System</span>
                                    </button>
                                </div>
                                <div class="drop-hint">H·ªó tr·ª£: JPG, PNG, WEBP (t·ªëi ƒëa 10MB/file)</div>
                            </div>

                            <!-- Upload Progress (Hidden by default) -->
                            <div class="upload-progress-container" id="uploadProgressContainer" style="display: none;">
                                <div class="progress-header">
                                    <span class="progress-icon">‚è≥</span>
                                    <span class="progress-title" id="progressTitle">ƒêang t·∫£i l√™n...</span>
                                </div>
                                <div class="progress-bar-wrapper">
                                    <div class="progress-bar" id="uploadProgressBar">
                                        <div class="progress-fill" id="uploadProgressFill" style="width: 0%"></div>
                                    </div>
                                    <div class="progress-text" id="progressText">0%</div>
                                </div>
                                <div class="upload-file-list" id="uploadFileList">
                                    <!-- File items will be added here -->
                                </div>
                            </div>

                            <!-- Success State (Hidden by default) -->
                            <div class="upload-success" id="uploadSuccess" style="display: none;">
                                <div class="success-icon">‚úÖ</div>
                                <div class="success-title" id="successTitle">ƒê√£ t·∫£i l√™n 0 ·∫£nh th√†nh c√¥ng</div>
                                <button class="success-action-btn" onclick="document.getElementById('selectedImagesContainer').scrollIntoView({behavior: 'smooth'})">
                                    <span>Xem ·∫£nh ƒë√£ ch·ªçn ‚Üì</span>
                                </button>
                            </div>
                        </div>

                        <input type="file" id="printFileInput" class="file-input" multiple accept="image/*">
                    </div>

                    <!-- Smart Grid V2 - Enhanced Selected Images -->
                    <div class="smart-grid-v2" id="selectedImagesContainer" style="display: none;">
                        <!-- Header with Controls -->
                        <div class="grid-header">
                            <div class="header-left">
                                <h4 class="grid-title">üñºÔ∏è <span id="selectedCount">0</span> ·∫£nh ƒë√£ ch·ªçn</h4>
                                <label class="select-all-checkbox">
                                    <input type="checkbox" id="selectAllCheckbox">
                                    <span>Ch·ªçn t·∫•t c·∫£</span>
                                </label>
                            </div>
                            <div class="header-right">
                                <select id="sortImagesSelect" class="grid-control-select">
                                    <option value="order">S·∫Øp x·∫øp: Th·ª© t·ª± th√™m</option>
                                    <option value="name-asc">T√™n (A‚ÜíZ)</option>
                                    <option value="name-desc">T√™n (Z‚ÜíA)</option>
                                    <option value="size-asc">K√≠ch th∆∞·ªõc (nh·ªè‚Üíl·ªõn)</option>
                                    <option value="size-desc">K√≠ch th∆∞·ªõc (l·ªõn‚Üính·ªè)</option>
                                </select>
                                <select id="gridSizeSelect" class="grid-control-select">
                                    <option value="small">Nh·ªè (6 ·∫£nh/h√†ng)</option>
                                    <option value="medium" selected>Trung b√¨nh (4 ·∫£nh/h√†ng)</option>
                                    <option value="large">L·ªõn (3 ·∫£nh/h√†ng)</option>
                                    <option value="xlarge">R·∫•t l·ªõn (2 ·∫£nh/h√†ng)</option>
                                </select>
                                <button class="grid-action-btn" id="toggleImagesView" title="Thu g·ªçn/M·ªü r·ªông">‚ñº</button>
                            </div>
                        </div>

                        <!-- Bulk Actions Toolbar (Hidden by default) -->
                        <div class="bulk-actions-toolbar" id="bulkActionsToolbar" style="display: none;">
                            <div class="toolbar-info">
                                <span class="selection-count" id="bulkSelectionCount">0 ·∫£nh ƒë√£ ch·ªçn</span>
                            </div>
                            <div class="toolbar-actions">
                                <button class="bulk-btn" id="bulkRotateBtn" title="Xoay 90¬∞">
                                    <span class="bulk-icon">üîÑ</span>
                                    <span class="bulk-text">Xoay</span>
                                </button>
                                <button class="bulk-btn" id="bulkDeleteBtn" title="X√≥a c√°c ·∫£nh ƒë√£ ch·ªçn">
                                    <span class="bulk-icon">üóëÔ∏è</span>
                                    <span class="bulk-text">X√≥a</span>
                                </button>
                                <button class="bulk-btn cancel" id="bulkCancelBtn" title="H·ªßy ch·ªçn">
                                    <span class="bulk-icon">‚úó</span>
                                    <span class="bulk-text">H·ªßy</span>
                                </button>
                            </div>
                        </div>

                        <!-- Images Grid -->
                        <div class="images-grid-smart" id="selectedImagesGrid" data-grid-size="medium"></div>
                    </div>

                    <!-- Image Distribution Controls - SINGLE MODE -->
                    <div class="image-distribution" id="imageDistributionSection" style="display: none;">
                        <div class="dist-header">
                            <span class="dist-title">Ph√¢n b·ªï ·∫£nh</span>
                            <span class="dist-info"><span id="distributionImageCount">0</span> ·∫£nh ‚Ä¢ <span id="distributionPageNeeds">0</span> v·ªã tr√≠</span>
                        </div>

                        <div class="dist-options">
                            <button class="dist-btn" id="fillAllPagesBtn" data-action="fill">
                                D√πng ·∫£nh ƒë·∫ßu
                            </button>
                            <button class="dist-btn" id="distributeEvenlyBtn" data-action="distribute">
                                Ph√¢n b·ªï ƒë·ªÅu
                            </button>
                            <button class="dist-btn" id="toggleCustomBtn" data-action="custom">
                                T√πy ch·ªânh
                            </button>
                        </div>

                        <div class="dist-custom" id="customDistributionSection" style="display: none;">
                            <div class="custom-header">
                                <span>Ch·ªâ ƒë·ªãnh s·ªë l∆∞·ª£ng</span>
                                <button class="apply-all" id="applyAllBtn">√Åp d·ª•ng t·∫•t c·∫£</button>
                            </div>
                            <div class="custom-grid" id="distributionGrid"></div>
                        </div>
                    </div>

                    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                    <!-- UNIFIED DUPLEX WORKSPACE - ALL-IN-ONE INTERFACE -->
                    <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                    <div class="duplex-unified-workspace" id="duplexUnifiedWorkspace" style="display: none;">

                        <!-- GLOBAL STATS BAR -->
                        <div class="duplex-global-stats">
                            <div class="stats-left">
                                <span class="stat-item stat-front">
                                    <svg class="svg-icon stat-icon"><use href="#icon-file"></use></svg>
                                    <span class="stat-value" id="unifiedFrontCount">0</span>
                                    <span class="stat-label">m·∫∑t tr∆∞·ªõc</span>
                                </span>
                                <span class="stat-separator">‚Ä¢</span>
                                <span class="stat-item stat-back">
                                    <svg class="svg-icon stat-icon"><use href="#icon-file"></use></svg>
                                    <span class="stat-value" id="unifiedBackCount">0</span>
                                    <span class="stat-label">m·∫∑t sau</span>
                                </span>
                                <span class="stat-separator">‚Ä¢</span>
                                <span class="stat-item stat-pages">
                                    <svg class="svg-icon stat-icon"><use href="#icon-layers"></use></svg>
                                    <span class="stat-value" id="unifiedTotalPages">0</span>
                                    <span class="stat-label">trang</span>
                                </span>
                                <span class="stat-separator">‚Ä¢</span>
                                <span class="stat-item stat-positions">
                                    <span class="stat-value" id="unifiedMaxPositions">0</span>
                                    <span class="stat-label">v·ªã tr√≠/trang</span>
                                </span>
                            </div>
                            <div class="stats-right">
                                <button class="stats-collapse-btn" id="statsCollapseBtn" title="Thu g·ªçn/M·ªü r·ªông">
                                    <span class="collapse-icon">‚óÄ</span>
                                </button>
                            </div>
                        </div>

                        <!-- 3-COLUMN LAYOUT -->
                        <div class="duplex-three-columns" id="duplexThreeColumns">

                            <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê COLUMN 1: SETUP & UPLOAD ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                            <div class="duplex-col duplex-col-setup">
                                <div class="col-header collapsible" data-target="setupContent">
                                    <span class="col-title">
                                        <span class="col-number">1</span>
                                        <span class="col-name">THI·∫æT L·∫¨P</span>
                                    </span>
                                    <span class="col-toggle">‚ñº</span>
                                </div>

                                <div class="col-content" id="setupContent">
                                    <!-- Upload Zone -->
                                    <div class="unified-upload-zone">
                                        <input type="file" id="unifiedDuplexFileInput" multiple accept="image/*" style="display: none;">
                                        <div class="upload-zone-inner">
                                            <svg class="svg-icon upload-icon-large"><use href="#icon-camera"></use></svg>
                                            <div class="upload-text-primary">K√©o th·∫£ ·∫£nh v√†o ƒë√¢y</div>
                                            <div class="upload-text-secondary">ho·∫∑c click ƒë·ªÉ ch·ªçn file</div>
                                            <div class="upload-count" id="uploadedCount" style="display: none;">
                                                <span class="count-badge">
                                                    <svg class="svg-icon"><use href="#icon-folder"></use></svg>
                                                    <span id="uploadedCountValue">0</span> ·∫£nh ƒë√£ t·∫£i
                                                </span>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Quick Presets -->
                                    <div class="quick-presets-section">
                                        <div class="section-label">
                                            <svg class="svg-icon"><use href="#icon-zap"></use></svg>
                                            M·∫´u nhanh (Quick Presets)
                                        </div>
                                        <div class="presets-grid">
                                            <button class="preset-btn" data-preset="1x1" title="1 ·∫£nh front + 1 ·∫£nh back">
                                                <span class="preset-icon">
                                                    <svg class="svg-icon"><use href="#icon-document-duplex"></use></svg>
                                                </span>
                                                <span class="preset-name">1√ó1</span>
                                                <span class="preset-desc">M·ªói m·∫∑t 1 ·∫£nh</span>
                                            </button>
                                            <button class="preset-btn" data-preset="nx1" title="N ·∫£nh front ph√¢n b·ªï ƒë·ªÅu + 1 ·∫£nh back">
                                                <span class="preset-icon">
                                                    <svg class="svg-icon"><use href="#icon-files"></use></svg>
                                                </span>
                                                <span class="preset-name">N√ó1</span>
                                                <span class="preset-desc">Nhi·ªÅu front, 1 back</span>
                                            </button>
                                            <button class="preset-btn" data-preset="1xn" title="1 ·∫£nh front + N ·∫£nh back ph√¢n b·ªï ƒë·ªÅu">
                                                <span class="preset-icon">
                                                    <svg class="svg-icon"><use href="#icon-files"></use></svg>
                                                </span>
                                                <span class="preset-name">1√óN</span>
                                                <span class="preset-desc">1 front, nhi·ªÅu back</span>
                                            </button>
                                            <button class="preset-btn" data-preset="nxn" title="C·∫£ 2 m·∫∑t ph√¢n b·ªï ƒë·ªÅu">
                                                <span class="preset-icon">
                                                    <svg class="svg-icon"><use href="#icon-layers"></use></svg>
                                                </span>
                                                <span class="preset-name">N√óN</span>
                                                <span class="preset-desc">C·∫£ 2 ƒë·ªÅu ph√¢n b·ªï</span>
                                            </button>
                                        </div>
                                    </div>

                                    <!-- Global Actions -->
                                    <div class="global-actions-section">
                                        <div class="section-label">
                                            <svg class="svg-icon"><use href="#icon-target"></use></svg>
                                            Thao t√°c to√†n c·ª•c
                                        </div>
                                        <div class="actions-list">
                                            <button class="action-btn action-auto" id="unifiedAutoClassifyBtn" title="Ctrl+A">
                                                <svg class="svg-icon action-icon"><use href="#icon-robot"></use></svg>
                                                <span class="action-text">T·ª± ƒë·ªông ph√¢n lo·∫°i</span>
                                            </button>
                                            <button class="action-btn action-swap" id="unifiedSwapBtn" title="Ctrl+S">
                                                <svg class="svg-icon action-icon"><use href="#icon-swap"></use></svg>
                                                <span class="action-text">Swap Front ‚Üî Back</span>
                                            </button>
                                            <button class="action-btn action-balance" id="unifiedBalanceBtn" title="Ctrl+B">
                                                <svg class="svg-icon action-icon"><use href="#icon-balance"></use></svg>
                                                <span class="action-text">C√¢n b·∫±ng s·ªë l∆∞·ª£ng</span>
                                            </button>
                                            <button class="action-btn action-clear" id="unifiedClearAllBtn" title="Delete">
                                                <svg class="svg-icon action-icon"><use href="#icon-trash"></use></svg>
                                                <span class="action-text">X√≥a t·∫•t c·∫£</span>
                                            </button>
                                            <div class="action-row">
                                                <button class="action-btn action-undo" id="unifiedUndoBtn" disabled title="Ctrl+Z">
                                                    <svg class="svg-icon action-icon"><use href="#icon-undo"></use></svg>
                                                    <span class="action-text">Undo</span>
                                                </button>
                                                <button class="action-btn action-redo" id="unifiedRedoBtn" disabled title="Ctrl+Y">
                                                    <svg class="svg-icon action-icon"><use href="#icon-redo"></use></svg>
                                                    <span class="action-text">Redo</span>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê COLUMN 2: CLASSIFICATION ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                            <div class="duplex-col duplex-col-classification">
                                <div class="col-header collapsible" data-target="classificationContent">
                                    <span class="col-title">
                                        <span class="col-number">2</span>
                                        <span class="col-name">PH√ÇN LO·∫†I ·∫¢NH</span>
                                    </span>
                                    <span class="col-toggle">‚ñº</span>
                                </div>

                                <div class="col-content" id="classificationContent">
                                    <!-- Gallery Section -->
                                    <div class="gallery-section">
                                        <div class="gallery-header">
                                            <span class="gallery-title">
                                                <svg class="svg-icon"><use href="#icon-image"></use></svg>
                                                Kho ·∫£nh (<span id="unifiedGalleryCount">0</span>)
                                            </span>
                                            <div class="gallery-mode-switch">
                                                <span class="mode-label">Ch·ªçn v√†o:</span>
                                                <button class="mode-btn mode-front active" data-mode="front">
                                                    <svg class="svg-icon mode-icon"><use href="#icon-file"></use></svg>
                                                    <span class="mode-text">Front</span>
                                                </button>
                                                <button class="mode-btn mode-back" data-mode="back">
                                                    <svg class="svg-icon mode-icon"><use href="#icon-file"></use></svg>
                                                    <span class="mode-text">Back</span>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="gallery-grid-unified" id="unifiedGalleryGrid">
                                            <div class="gallery-empty">Ch∆∞a c√≥ ·∫£nh n√†o</div>
                                        </div>
                                    </div>

                                    <!-- Classification Lists -->
                                    <div class="classification-section">
                                        <!-- Front List -->
                                        <div class="classified-list front-list">
                                            <div class="list-header">
                                                <span class="list-title">
                                                    <svg class="svg-icon list-icon"><use href="#icon-file"></use></svg>
                                                    <span class="list-name">M·∫∑t tr∆∞·ªõc</span>
                                                    <span class="list-count">(<span id="unifiedFrontListCount">0</span>)</span>
                                                </span>
                                                <button class="list-clear-btn" id="unifiedClearFrontBtn" title="X√≥a t·∫•t c·∫£ m·∫∑t tr∆∞·ªõc">
                                                    <svg class="svg-icon"><use href="#icon-trash"></use></svg>
                                                </button>
                                            </div>
                                            <div class="list-images droppable-zone" id="unifiedFrontList" data-side="front">
                                                <div class="list-empty">Ch∆∞a c√≥ ·∫£nh</div>
                                            </div>
                                            <div class="list-actions">
                                                <button class="list-action-btn" id="unifiedCustomFrontBtn">
                                                    <svg class="svg-icon btn-icon"><use href="#icon-settings"></use></svg>
                                                    <span class="btn-text">T√πy ch·ªânh</span>
                                                </button>
                                            </div>
                                        </div>

                                        <!-- Back List -->
                                        <div class="classified-list back-list">
                                            <div class="list-header">
                                                <span class="list-title">
                                                    <svg class="svg-icon list-icon"><use href="#icon-file"></use></svg>
                                                    <span class="list-name">M·∫∑t sau</span>
                                                    <span class="list-count">(<span id="unifiedBackListCount">0</span>)</span>
                                                </span>
                                                <button class="list-clear-btn" id="unifiedClearBackBtn" title="X√≥a t·∫•t c·∫£ m·∫∑t sau">
                                                    <svg class="svg-icon"><use href="#icon-trash"></use></svg>
                                                </button>
                                            </div>
                                            <div class="list-images droppable-zone" id="unifiedBackList" data-side="back">
                                                <div class="list-empty">Ch∆∞a c√≥ ·∫£nh</div>
                                            </div>
                                            <div class="list-actions">
                                                <button class="list-action-btn" id="unifiedCustomBackBtn">
                                                    <svg class="svg-icon btn-icon"><use href="#icon-settings"></use></svg>
                                                    <span class="btn-text">T√πy ch·ªânh</span>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê COLUMN 3: PREVIEW & EXPORT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                            <div class="duplex-col duplex-col-preview">
                                <div class="col-header collapsible" data-target="previewContent">
                                    <span class="col-title">
                                        <span class="col-number">3</span>
                                        <span class="col-name">XEM TR∆Ø·ªöC & XU·∫§T FILE</span>
                                    </span>
                                    <span class="col-toggle">‚ñº</span>
                                </div>

                                <div class="col-content" id="previewContent">
                                    <!-- Canvas Preview will be moved here dynamically -->
                                    <div class="preview-placeholder" id="unifiedPreviewPlaceholder">
                                        <!-- duplexCanvasContainer s·∫Ω ƒë∆∞·ª£c di chuy·ªÉn v√†o ƒë√¢y -->
                                    </div>

                                    <!-- Distribution Section -->
                                    <div class="distribution-unified">
                                        <div class="dist-header-unified">
                                            <svg class="svg-icon"><use href="#icon-zap"></use></svg>
                                            <span class="dist-title">Ph√¢n b·ªï ·∫£nh</span>
                                        </div>

                                        <!-- Front Distribution -->
                                        <div class="dist-side front-dist-unified">
                                            <div class="dist-side-header">
                                                <svg class="svg-icon dist-side-icon"><use href="#icon-file"></use></svg>
                                                <span class="dist-side-name">M·∫∑t tr∆∞·ªõc</span>
                                            </div>
                                            <div class="dist-progress">
                                                <div class="progress-info">
                                                    <span class="progress-text">
                                                        <span id="unifiedFrontFilled">0</span>/<span id="unifiedFrontTotal">0</span> v·ªã tr√≠
                                                    </span>
                                                    <span class="progress-percent" id="unifiedFrontPercent">0%</span>
                                                </div>
                                                <div class="progress-bar">
                                                    <div class="progress-fill front-fill" id="unifiedFrontProgressBar" style="width: 0%"></div>
                                                </div>
                                            </div>
                                            <div class="dist-side-actions">
                                                <button class="dist-btn dist-fill" data-action="fill-front">
                                                    <svg class="svg-icon btn-icon"><use href="#icon-refresh"></use></svg>
                                                    <span class="btn-text">Fill</span>
                                                </button>
                                                <button class="dist-btn dist-distribute" data-action="distribute-front">
                                                    <svg class="svg-icon btn-icon"><use href="#icon-balance"></use></svg>
                                                    <span class="btn-text">Ph√¢n b·ªï</span>
                                                </button>
                                                <button class="dist-btn dist-custom" data-action="custom-front">
                                                    <svg class="svg-icon btn-icon"><use href="#icon-settings"></use></svg>
                                                    <span class="btn-text">T√πy ch·ªânh</span>
                                                </button>
                                            </div>
                                        </div>

                                        <!-- Back Distribution -->
                                        <div class="dist-side back-dist-unified">
                                            <div class="dist-side-header">
                                                <svg class="svg-icon dist-side-icon"><use href="#icon-file"></use></svg>
                                                <span class="dist-side-name">M·∫∑t sau</span>
                                            </div>
                                            <div class="dist-progress">
                                                <div class="progress-info">
                                                    <span class="progress-text">
                                                        <span id="unifiedBackFilled">0</span>/<span id="unifiedBackTotal">0</span> v·ªã tr√≠
                                                    </span>
                                                    <span class="progress-percent" id="unifiedBackPercent">0%</span>
                                                </div>
                                                <div class="progress-bar">
                                                    <div class="progress-fill back-fill" id="unifiedBackProgressBar" style="width: 0%"></div>
                                                </div>
                                            </div>
                                            <div class="dist-side-actions">
                                                <button class="dist-btn dist-fill" data-action="fill-back">
                                                    <svg class="svg-icon btn-icon"><use href="#icon-refresh"></use></svg>
                                                    <span class="btn-text">Fill</span>
                                                </button>
                                                <button class="dist-btn dist-distribute" data-action="distribute-back">
                                                    <svg class="svg-icon btn-icon"><use href="#icon-balance"></use></svg>
                                                    <span class="btn-text">Ph√¢n b·ªï</span>
                                                </button>
                                                <button class="dist-btn dist-custom" data-action="custom-back">
                                                    <svg class="svg-icon btn-icon"><use href="#icon-settings"></use></svg>
                                                    <span class="btn-text">T√πy ch·ªânh</span>
                                                </button>
                                            </div>
                                        </div>

                                        <!-- Quick Actions -->
                                        <div class="dist-quick-actions-unified">
                                            <button class="dist-quick-btn" data-action="fill-all">
                                                <svg class="svg-icon btn-icon"><use href="#icon-document-duplex"></use></svg>
                                                <span class="btn-text">Fill c·∫£ 2 m·∫∑t</span>
                                            </button>
                                            <button class="dist-quick-btn" data-action="distribute-all">
                                                <svg class="svg-icon btn-icon"><use href="#icon-zap"></use></svg>
                                                <span class="btn-text">Ph√¢n b·ªï c·∫£ 2</span>
                                            </button>
                                            <button class="dist-quick-btn" data-action="copy-front-to-back">
                                                <svg class="svg-icon btn-icon"><use href="#icon-arrow-right"></use></svg>
                                                <span class="btn-text">Copy F‚ÜíB</span>
                                            </button>
                                            <button class="dist-quick-btn" data-action="copy-back-to-front">
                                                <svg class="svg-icon btn-icon"><use href="#icon-arrow-right"></use></svg>
                                                <span class="btn-text">Copy B‚ÜíF</span>
                                            </button>
                                        </div>
                                    </div>

                                    <!-- Export Section -->
                                    <div class="export-unified">
                                        <div class="export-header">
                                            <svg class="svg-icon"><use href="#icon-upload"></use></svg>
                                            <span class="export-title">Xu·∫•t file</span>
                                        </div>
                                        <div class="export-buttons">
                                            <button class="export-btn export-jpg" id="unifiedExportJPG">
                                                <svg class="svg-icon btn-icon"><use href="#icon-photo"></use></svg>
                                                <span class="btn-text">Xu·∫•t JPG</span>
                                            </button>
                                            <button class="export-btn export-pdf" id="unifiedExportPDF">
                                                <svg class="svg-icon btn-icon"><use href="#icon-document"></use></svg>
                                                <span class="btn-text">Xu·∫•t PDF</span>
                                            </button>
                                            <button class="export-btn export-folder" id="unifiedExportFolder">
                                                <svg class="svg-icon btn-icon"><use href="#icon-save"></use></svg>
                                                <span class="btn-text">L∆∞u th∆∞ m·ª•c</span>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div><!-- End 3-column layout -->

                        <!-- Context Menu -->
                        <div class="context-menu-unified" id="unifiedContextMenu" style="display: none;">
                            <div class="context-menu-item" data-action="cut">
                                <svg class="svg-icon menu-icon"><use href="#icon-scissors"></use></svg>
                                <span class="menu-text">C·∫Øt</span>
                            </div>
                            <div class="context-menu-item" data-action="copy">
                                <svg class="svg-icon menu-icon"><use href="#icon-copy"></use></svg>
                                <span class="menu-text">Copy</span>
                            </div>
                            <div class="context-menu-item" data-action="delete">
                                <svg class="svg-icon menu-icon"><use href="#icon-trash"></use></svg>
                                <span class="menu-text">X√≥a</span>
                                <span class="menu-shortcut">Del</span>
                            </div>
                            <div class="context-menu-divider"></div>
                            <div class="context-menu-item" data-action="move-to-front">
                                <svg class="svg-icon menu-icon"><use href="#icon-file"></use></svg>
                                <span class="menu-text">Chuy·ªÉn sang Front</span>
                            </div>
                            <div class="context-menu-item" data-action="move-to-back">
                                <svg class="svg-icon menu-icon"><use href="#icon-file"></use></svg>
                                <span class="menu-text">Chuy·ªÉn sang Back</span>
                            </div>
                            <div class="context-menu-divider"></div>
                            <div class="context-menu-item" data-action="duplicate-2">
                                <svg class="svg-icon menu-icon"><use href="#icon-copy"></use></svg>
                                <span class="menu-text">Nh√¢n b·∫£n √ó2</span>
                            </div>
                            <div class="context-menu-item" data-action="duplicate-5">
                                <svg class="svg-icon menu-icon"><use href="#icon-copy"></use></svg>
                                <span class="menu-text">Nh√¢n b·∫£n √ó5</span>
                            </div>
                            <div class="context-menu-item" data-action="duplicate-10">
                                <svg class="svg-icon menu-icon"><use href="#icon-copy"></use></svg>
                                <span class="menu-text">Nh√¢n b·∫£n √ó10</span>
                            </div>
                            <div class="context-menu-item" data-action="duplicate-custom">
                                <svg class="svg-icon menu-icon"><use href="#icon-edit"></use></svg>
                                <span class="menu-text">T√πy ch·ªânh s·ªë l∆∞·ª£ng...</span>
                            </div>
                        </div>

                    </div><!-- End duplex-unified-workspace -->

                    <!-- OLD SECTIONS - HIDDEN FOR BACKWARDS COMPATIBILITY -->
                    <div class="duplex-distribution" id="duplexDistributionSection" style="display: none;">
                        <div class="duplex-dist-header">
                            <span class="duplex-dist-title">‚ö° Ph√¢n b·ªï ·∫£nh Duplex</span>
                            <span class="duplex-dist-subtitle">T·ªëi ∆∞u s·ªë l∆∞·ª£ng ·∫£nh cho m·ªói m·∫∑t</span>
                        </div>

                        <!-- FRONT SIDE Distribution -->
                        <div class="duplex-side-dist front-dist">
                            <div class="side-dist-header">
                                <span class="side-icon">üìÑ</span>
                                <span class="side-title">M·∫∑t tr∆∞·ªõc</span>
                                <span class="side-stats">
                                    <span id="frontDistImageCount">0</span> ·∫£nh ‚Ä¢
                                    <span id="frontDistPageCount">0</span> trang ‚Ä¢
                                    <span id="frontDistPositions">0</span> v·ªã tr√≠
                                </span>
                            </div>

                            <div class="side-dist-actions">
                                <button class="duplex-dist-btn fill-btn" id="fillFrontPagesBtn" title="D√πng ·∫£nh ƒë·∫ßu ti√™n fill t·∫•t c·∫£ v·ªã tr√≠ m·∫∑t tr∆∞·ªõc">
                                    <span class="btn-icon">üîÑ</span>
                                    <span>D√πng 1 ·∫£nh</span>
                                </button>
                                <button class="duplex-dist-btn distribute-btn" id="distributeFrontEvenlyBtn" title="Ph√¢n b·ªï ƒë·ªÅu t·∫•t c·∫£ ·∫£nh front ra c√°c trang">
                                    <span class="btn-icon">‚öñÔ∏è</span>
                                    <span>Ph√¢n b·ªï ƒë·ªÅu</span>
                                </button>
                                <button class="duplex-dist-btn custom-btn" id="toggleCustomFrontBtn" title="T√πy ch·ªânh s·ªë l∆∞·ª£ng t·ª´ng ·∫£nh m·∫∑t tr∆∞·ªõc">
                                    <span class="btn-icon">üé®</span>
                                    <span>T√πy ch·ªânh</span>
                                </button>
                                <button class="duplex-dist-btn clear-btn" id="clearFrontBtn" title="X√≥a t·∫•t c·∫£ ·∫£nh m·∫∑t tr∆∞·ªõc">
                                    <span class="btn-icon">üóëÔ∏è</span>
                                    <span>X√≥a t·∫•t c·∫£</span>
                                </button>
                            </div>

                            <!-- Custom Distribution Section - FRONT -->
                            <div class="duplex-custom-dist" id="customDistFrontSection" style="display: none;">
                                <div class="custom-dist-header">
                                    <span class="custom-dist-title">üìã T√πy ch·ªânh s·ªë l∆∞·ª£ng t·ª´ng ·∫£nh</span>
                                    <div class="custom-dist-controls">
                                        <input type="number" class="apply-all-input" id="applyAllFrontInput" min="1" max="999" placeholder="S·ªë l∆∞·ª£ng" title="Nh·∫≠p s·ªë l∆∞·ª£ng √°p d·ª•ng cho t·∫•t c·∫£">
                                        <button class="apply-all-btn" id="applyAllFrontBtn" title="√Åp d·ª•ng s·ªë l∆∞·ª£ng cho t·∫•t c·∫£ ·∫£nh m·∫∑t tr∆∞·ªõc">
                                            <span>‚úì √Åp d·ª•ng t·∫•t c·∫£</span>
                                        </button>
                                    </div>
                                </div>
                                <div class="custom-dist-grid" id="frontDistributionGrid">
                                    <!-- Grid items will be populated by JavaScript -->
                                </div>
                            </div>
                        </div>

                        <!-- BACK SIDE Distribution -->
                        <div class="duplex-side-dist back-dist">
                            <div class="side-dist-header">
                                <span class="side-icon">üìÉ</span>
                                <span class="side-title">M·∫∑t sau</span>
                                <span class="side-stats">
                                    <span id="backDistImageCount">0</span> ·∫£nh ‚Ä¢
                                    <span id="backDistPageCount">0</span> trang ‚Ä¢
                                    <span id="backDistPositions">0</span> v·ªã tr√≠
                                </span>
                            </div>

                            <div class="side-dist-actions">
                                <button class="duplex-dist-btn fill-btn" id="fillBackPagesBtn" title="D√πng ·∫£nh ƒë·∫ßu ti√™n fill t·∫•t c·∫£ v·ªã tr√≠ m·∫∑t sau">
                                    <span class="btn-icon">üîÑ</span>
                                    <span>D√πng 1 ·∫£nh</span>
                                </button>
                                <button class="duplex-dist-btn distribute-btn" id="distributeBackEvenlyBtn" title="Ph√¢n b·ªï ƒë·ªÅu t·∫•t c·∫£ ·∫£nh back ra c√°c trang">
                                    <span class="btn-icon">‚öñÔ∏è</span>
                                    <span>Ph√¢n b·ªï ƒë·ªÅu</span>
                                </button>
                                <button class="duplex-dist-btn custom-btn" id="toggleCustomBackBtn" title="T√πy ch·ªânh s·ªë l∆∞·ª£ng t·ª´ng ·∫£nh m·∫∑t sau">
                                    <span class="btn-icon">üé®</span>
                                    <span>T√πy ch·ªânh</span>
                                </button>
                                <button class="duplex-dist-btn clear-btn" id="clearBackBtn" title="X√≥a t·∫•t c·∫£ ·∫£nh m·∫∑t sau">
                                    <span class="btn-icon">üóëÔ∏è</span>
                                    <span>X√≥a t·∫•t c·∫£</span>
                                </button>
                            </div>

                            <!-- Custom Distribution Section - BACK -->
                            <div class="duplex-custom-dist" id="customDistBackSection" style="display: none;">
                                <div class="custom-dist-header">
                                    <span class="custom-dist-title">üìã T√πy ch·ªânh s·ªë l∆∞·ª£ng t·ª´ng ·∫£nh</span>
                                    <div class="custom-dist-controls">
                                        <input type="number" class="apply-all-input" id="applyAllBackInput" min="1" max="999" placeholder="S·ªë l∆∞·ª£ng" title="Nh·∫≠p s·ªë l∆∞·ª£ng √°p d·ª•ng cho t·∫•t c·∫£">
                                        <button class="apply-all-btn" id="applyAllBackBtn" title="√Åp d·ª•ng s·ªë l∆∞·ª£ng cho t·∫•t c·∫£ ·∫£nh m·∫∑t sau">
                                            <span>‚úì √Åp d·ª•ng t·∫•t c·∫£</span>
                                        </button>
                                    </div>
                                </div>
                                <div class="custom-dist-grid" id="backDistributionGrid">
                                    <!-- Grid items will be populated by JavaScript -->
                                </div>
                            </div>
                        </div>

                        <!-- Quick Actions -->
                        <div class="duplex-dist-quick-actions">
                            <button class="duplex-quick-btn" id="fillAllDuplexBtn" title="D√πng ·∫£nh ƒë·∫ßu cho c·∫£ 2 m·∫∑t">
                                <span class="btn-icon">üìÑüìÉ</span>
                                <span>D√πng 1 ·∫£nh cho c·∫£ 2 m·∫∑t</span>
                            </button>
                            <button class="duplex-quick-btn" id="distributeAllDuplexBtn" title="Ph√¢n b·ªï ƒë·ªÅu ·∫£nh cho c·∫£ 2 m·∫∑t">
                                <span class="btn-icon">‚ö°</span>
                                <span>Ph√¢n b·ªï ƒë·ªÅu c·∫£ 2 m·∫∑t</span>
                            </button>
                            <button class="duplex-quick-btn copy-btn" id="copyFrontToBackBtn" title="Sao ch√©p t·∫•t c·∫£ ·∫£nh t·ª´ m·∫∑t tr∆∞·ªõc sang m·∫∑t sau">
                                <span class="btn-icon">üìÑ‚ÜíüìÉ</span>
                                <span>Copy Front ‚Üí Back</span>
                            </button>
                            <button class="duplex-quick-btn copy-btn" id="copyBackToFrontBtn" title="Sao ch√©p t·∫•t c·∫£ ·∫£nh t·ª´ m·∫∑t sau sang m·∫∑t tr∆∞·ªõc">
                                <span class="btn-icon">üìÉ‚ÜíüìÑ</span>
                                <span>Copy Back ‚Üí Front</span>
                            </button>
                        </div>
                    </div>

                    <!-- NEW Duplex Classification V2 - Phase 1 Enhanced -->
                    <div class="duplex-classification-v2" id="duplexClassificationSection" style="display: none;">
                        <!-- Header with Stats -->
                        <div class="duplex-v2-header">
                            <h4><svg class="svg-icon"><use href="#icon-document-duplex"></use></svg> Ch·∫ø ƒë·ªô in 2 m·∫∑t th·ªß c√¥ng</h4>
                            <div class="duplex-stats-inline">
                                <span class="stat-badge"><svg class="svg-icon"><use href="#icon-photo"></use></svg> <span id="frontImageCount">0</span> tr∆∞·ªõc</span>
                                <span class="stat-badge"><svg class="svg-icon"><use href="#icon-photo"></use></svg> <span id="backImageCount">0</span> sau</span>
                                <span class="stat-badge pages"><svg class="svg-icon"><use href="#icon-photo"></use></svg> <span id="maxDuplexPages">0</span> trang</span>
                            </div>
                        </div>

                        <!-- Upload Zone - Direct upload to duplex -->
                        <div class="duplex-upload-zone" id="duplexUploadZone" style="display: none;">
                            <input type="file" id="duplexFileInput" multiple accept="image/*" style="display: none;">
                            <div class="upload-zone-content">
                                <div class="upload-icon"><svg class="svg-icon" style="width: 3em; height: 3em;"><use href="#icon-upload"></use></svg></div>
                                <div class="upload-text">
                                    <strong>K√©o th·∫£ ·∫£nh v√†o ƒë√¢y</strong> ho·∫∑c <span class="upload-link">nh·∫•n ƒë·ªÉ ch·ªçn file</span>
                                </div>
                                <div class="upload-hint">H·ªó tr·ª£: JPG, PNG, WebP | T·∫£i l√™n tr·ª±c ti·∫øp kh√¥ng c·∫ßn qua Kho ·∫£nh</div>
                            </div>
                        </div>

                        <!-- Quick Actions Toolbar - NEW -->
                        <div class="duplex-quick-actions">
                            <button class="quick-action-btn auto-classify-action" id="autoClassifyBtnDuplex" title="T·ª± ƒë·ªông nh·∫≠n di·ªán m·∫∑t tr∆∞·ªõc/sau theo t√™n file">
                                <span class="qa-icon"><svg class="svg-icon"><use href="#icon-robot"></use></svg></span>
                                <span class="qa-text">T·ª± ƒë·ªông ph√¢n lo·∫°i</span>
                            </button>
                            <button class="quick-action-btn" id="undoDuplexBtn" disabled title="Ho√†n t√°c">
                                <span class="qa-icon"><svg class="svg-icon"><use href="#icon-undo"></use></svg></span>
                                <span class="qa-text">Ho√†n t√°c</span>
                            </button>
                            <button class="quick-action-btn" id="redoDuplexBtn" disabled title="L√†m l·∫°i">
                                <span class="qa-icon"><svg class="svg-icon"><use href="#icon-redo"></use></svg></span>
                                <span class="qa-text">L√†m l·∫°i</span>
                            </button>
                            <button class="quick-action-btn" id="swapDuplexBtn" title="ƒê·ªïi m·∫∑t tr∆∞·ªõc ‚Üî sau">
                                <span class="qa-icon"><svg class="svg-icon"><use href="#icon-swap"></use></svg></span>
                                <span class="qa-text">ƒê·ªïi ch·ªó</span>
                            </button>
                            <button class="quick-action-btn" id="clearAllDuplexBtn" title="X√≥a t·∫•t c·∫£">
                                <span class="qa-icon"><svg class="svg-icon"><use href="#icon-clean"></use></svg></span>
                                <span class="qa-text">X√≥a h·∫øt</span>
                            </button>
                            <button class="quick-action-btn" id="balanceDuplexBtn" title="C√¢n b·∫±ng s·ªë ·∫£nh">
                                <span class="qa-icon"><svg class="svg-icon"><use href="#icon-balance"></use></svg></span>
                                <span class="qa-text">C√¢n b·∫±ng</span>
                            </button>
                        </div>

                        <!-- 2-Column Layout - NEW -->
                        <div class="duplex-v2-layout">
                            <!-- LEFT: Gallery (Kho ·∫£nh) -->
                            <div class="duplex-v2-gallery-col">
                                <div class="gallery-col-header">
                                    <span class="col-title">üñºÔ∏è Kho ·∫£nh (<span id="galleryAvailableCount">0</span>)</span>
                                    <span class="col-hint">‚Üê K√©o th·∫£ sang ph√¢n lo·∫°i</span>
                                </div>
                                <div class="gallery-grid-v2" id="galleryGridDuplex">
                                    <!-- Gallery images will be populated here -->
                                </div>
                            </div>

                            <!-- RIGHT: Classification (Ph√¢n lo·∫°i) -->
                            <div class="duplex-v2-classify-col">
                                <!-- Toggle Mode Switch - NEW (replaces 3 buttons) -->
                                <div class="duplex-toggle-mode">
                                    <div class="toggle-label">Ch·∫ø ƒë·ªô ch·ªçn:</div>
                                    <div class="toggle-switch-wrapper">
                                        <button class="toggle-switch-btn front active" data-mode="front">
                                            <span class="toggle-icon">üìÑ</span>
                                            <span class="toggle-text">M·∫∑t tr∆∞·ªõc</span>
                                        </button>
                                        <button class="toggle-switch-btn back" data-mode="back">
                                            <span class="toggle-icon">üìÉ</span>
                                            <span class="toggle-text">M·∫∑t sau</span>
                                        </button>
                                    </div>
                                    <div class="toggle-hint" id="toggleHint">Click ·∫£nh b√™n tr√°i ƒë·ªÉ th√™m v√†o m·∫∑t tr∆∞·ªõc</div>
                                </div>

                                <!-- Classification Lists -->
                                <div class="classification-lists-v2">
                                    <!-- Front Side -->
                                    <div class="classify-side-v2 front-side">
                                        <div class="side-header-v2">
                                            <div class="header-left">
                                                <span class="side-icon">üìÑ</span>
                                                <span class="side-title">M·∫∑t tr∆∞·ªõc</span>
                                                <span class="side-count" id="frontCount">0</span>
                                            </div>
                                            <button class="clear-btn-v2" id="clearFrontBtn" title="X√≥a t·∫•t c·∫£ m·∫∑t tr∆∞·ªõc">
                                                <span>üóëÔ∏è</span>
                                            </button>
                                        </div>
                                        <div class="classification-thumbnails-v2 droppable-zone" id="frontImagesList" data-side="front">
                                            <div class="empty-state">Ch∆∞a c√≥ ·∫£nh n√†o</div>
                                        </div>
                                    </div>

                                    <!-- Back Side -->
                                    <div class="classify-side-v2 back-side">
                                        <div class="side-header-v2">
                                            <div class="header-left">
                                                <span class="side-icon">üìÉ</span>
                                                <span class="side-title">M·∫∑t sau</span>
                                                <span class="side-count" id="printBackCount">0</span>
                                            </div>
                                            <button class="clear-btn-v2" id="clearBackBtn" title="X√≥a t·∫•t c·∫£ m·∫∑t sau">
                                                <span>üóëÔ∏è</span>
                                            </button>
                                        </div>
                                        <div class="classification-thumbnails-v2 droppable-zone" id="backImagesList" data-side="back">
                                            <div class="empty-state">Ch∆∞a c√≥ ·∫£nh n√†o</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Validation Messages -->
                                <div class="duplex-validation" id="duplexValidation">
                                    <!-- Validation messages will appear here -->
                                </div>
                            </div>
                        </div>
                    </div>

                        </div>
                        <!-- END LEFT COLUMN -->

                        <!-- RIGHT COLUMN: Preview & Actions -->
                        <div class="print-right-column">

                    <!-- Action Buttons - Now in Right Column -->
                    <div class="print-actions-compact">
                        <div class="actions-info">
                            <span class="selection-indicator" id="selectionIndicator">
                                <span class="indicator-icon"><svg class="svg-icon"><use href="#icon-camera"></use></svg></span>
                                <span class="indicator-text" id="selectedImagesCount">0 ·∫£nh ƒë√£ ch·ªçn</span>
                            </span>
                        </div>
                        <div class="actions-buttons">
                            <button class="action-btn utility" id="resetConfigBtn">
                                <span class="btn-icon"><svg class="svg-icon"><use href="#icon-reset"></use></svg></span>
                                <span class="btn-text">ƒê·∫∑t l·∫°i</span>
                            </button>
                            <button class="action-btn primary" id="generatePreviewBtn" disabled>
                                <span class="btn-icon"><svg class="svg-icon"><use href="#icon-eye"></use></svg></span>
                                <span class="btn-text">Xem tr∆∞·ªõc</span>
                            </button>
                            <button class="action-btn secondary" id="generatePrintBtnNew" disabled>
                                <span class="btn-icon"><svg class="svg-icon"><use href="#icon-printer"></use></svg></span>
                                <span class="btn-text">T·∫°o file in</span>
                            </button>
                        </div>
                    </div>

                    <!-- Compact Print Preview -->
                    <div class="print-preview-elite" id="printPreviewContainer" style="display: block;">
                        <!-- Elite Header: Minimalist & Informative -->
                        <div class="preview-header-elite">
                            <div class="header-identity">
                                <div class="preview-brand">
                                    <div class="brand-icon">‚óä</div>
                                    <div class="brand-text">
                                        <h3 class="preview-title">Xem tr∆∞·ªõc</h3>
                                        <div class="status-indicator" id="previewStatus">
                                            <div class="status-dot"></div>
                                            <span class="status-text">S·∫µn s√†ng</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="header-metrics">
                                <div class="metric-card">
                                    <span class="metric-value" id="previewDimensions">210√ó297</span>
                                    <span class="metric-label">mm</span>
                                </div>
                                <div class="metric-card">
                                    <span class="metric-value" id="previewImageCount">0</span>
                                    <span class="metric-label">·∫£nh</span>
                                </div>
                                <div class="metric-card">
                                    <span class="metric-value" id="previewDPI">300</span>
                                    <span class="metric-label">DPI</span>
                                </div>
                                <div class="metric-card sk316-metric" id="sk316MetricCard" title="Tr·∫°ng th√°i hi·ªáu chu·∫©n SK316">
                                    <span class="metric-icon" id="sk316MetricIcon">‚óã</span>
                                    <span class="metric-value" id="sk316MetricValue">SK316</span>
                                    <span class="metric-label" id="sk316MetricLabel">T·∫ÆT</span>
                                </div>
                            </div>

                            <div class="header-actions-elite">
                                <button class="action-elite secondary" id="previewSettings">
                                    <span class="action-icon">‚öô</span>
                                    <span class="action-label">C√†i ƒë·∫∑t</span>
                                </button>
                                <button class="action-elite secondary" id="previewRefresh">
                                    <span class="action-icon">‚Üª</span>
                                    <span class="action-label">L√†m m·ªõi</span>
                                </button>
                                <button class="action-elite primary" id="quickExport">
                                    <span class="action-icon">‚ö°</span>
                                    <span class="action-label">Xu·∫•t JPG</span>
                                </button>
                            </div>
                        </div>

                        <!-- Elite Controls: Maximum Productivity -->
                        <div class="preview-controls-elite">
                            <!-- Control Strip 1: Navigation & Core -->
                            <div class="control-strip primary-strip">
                                <div class="control-section nav-section">
                                    <div class="section-label">ƒêi·ªÅu h∆∞·ªõng</div>
                                    <div class="nav-controls">
                                        <button class="nav-btn-elite" id="prevPageBtn" disabled>‚Äπ</button>
                                        <div class="page-display" id="pageIndicator">1/1</div>
                                        <button class="nav-btn-elite" id="nextPageBtn" disabled>‚Ä∫</button>
                                    </div>
                                    <div class="duplex-toggle-elite" id="duplexPreviewControls" style="display: none;">
                                        <button class="duplex-btn-elite active" id="frontSideBtn" data-side="front">Tr∆∞·ªõc</button>
                                        <button class="duplex-btn-elite" id="backSideBtn" data-side="back">Sau</button>
                                    </div>
                                </div>

                                <div class="control-section zoom-section">
                                    <div class="section-label">Thu ph√≥ng</div>
                                    <div class="zoom-controls-elite">
                                        <button class="zoom-btn-elite" id="zoom25" data-zoom="0.25">25</button>
                                        <button class="zoom-btn-elite" id="zoom50" data-zoom="0.5">50</button>
                                        <button class="zoom-btn-elite active" id="zoom100" data-zoom="1">100</button>
                                        <button class="zoom-btn-elite fit" id="zoomFit" data-zoom="fit">Fit</button>
                                    </div>
                                </div>

                                <div class="control-section orientation-section">
                                    <div class="section-label">H∆∞·ªõng</div>
                                    <div class="orientation-controls-elite">
                                        <button class="orient-btn-elite active" data-orientation="portrait" title="D·ªçc">‚¨ú</button>
                                        <button class="orient-btn-elite" data-orientation="landscape" title="Ngang">‚ñ¨</button>
                                    </div>
                                </div>

                                <!-- ‚öôÔ∏è Duplex Physical Offset Controls -->
                                <div class="control-section duplex-offset-section" id="duplexOffsetSection" style="display: none;">
                                    <div class="section-label" title="B√π l·ªách v·∫≠t l√Ω khi in 2 m·∫∑t th·ªß c√¥ng">
                                        <svg class="svg-icon"><use href="#icon-settings"></use></svg>
                                        B√π l·ªách
                                    </div>
                                    <div class="offset-controls-elite">
                                        <div class="offset-input-group">
                                            <label title="L·ªách tr√°i: +mm, L·ªách ph·∫£i: -mm">X:</label>
                                            <input type="number" id="duplexOffsetX" class="offset-input"
                                                   value="0" step="0.1" min="-5" max="5"
                                                   placeholder="0.0">
                                            <span class="offset-unit">mm</span>
                                        </div>
                                        <div class="offset-input-group">
                                            <label title="L·ªách tr√™n: +mm, L·ªách d∆∞·ªõi: -mm">Y:</label>
                                            <input type="number" id="duplexOffsetY" class="offset-input"
                                                   value="0" step="0.1" min="-5" max="5"
                                                   placeholder="0.0">
                                            <span class="offset-unit">mm</span>
                                        </div>
                                        <button class="calibration-btn-elite" id="calibrationTestBtn" title="T·∫°o trang test ƒë·ªÉ ƒëo l·ªách">
                                            <svg class="svg-icon"><use href="#icon-ruler"></use></svg>
                                            Test
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Control Strip 2: Advanced Features -->
                            <div class="control-strip secondary-strip">
                                <div class="control-section cutting-section">
                                    <div class="section-label">ƒê∆∞·ªùng c·∫Øt</div>
                                    <div class="cutting-controls-elite">
                                        <button class="cut-toggle-elite active" id="toggleGuides">ON</button>
                                        <div class="cut-types-elite" id="cuttingTypes">
                                            <button class="cut-type-elite active" id="outerLines" data-type="outer" title="Vi·ªÅn ngo√†i">‚¨õ</button>
                                            <button class="cut-type-elite active" id="betweenLines" data-type="between" title="Gi·ªØa ·∫£nh">‚∏¨</button>
                                            <button class="cut-type-elite active" id="previewCornerMarks" data-type="corner" title="G√≥c">‚ï¨</button>
                                            <button class="cut-type-elite" id="gridLines" data-type="grid" title="L∆∞·ªõi">‚ñ¶</button>
                                        </div>
                                        <select class="cut-thickness-elite" id="previewLineThickness">
                                            <option value="0.25">0.25pt</option>
                                            <option value="0.5" selected>0.5pt</option>
                                            <option value="1">1.0pt</option>
                                            <option value="2">2.0pt</option>
                                        </select>
                                    </div>
                                </div>

                                <div class="control-section size-section">
                                    <div class="section-label">K√≠ch th∆∞·ªõc</div>
                                    <div class="size-controls-elite">
                                        <select class="paper-size-elite" id="previewPaperSize">
                                            <option value="a4">A4</option>
                                            <option value="a3">A3</option>
                                            <option value="letter">Letter</option>
                                            <option value="5x7">5√ó7"</option>
                                            <option value="4x6">4√ó6"</option>
                                            <option value="custom">T√πy ch·ªânh</option>
                                        </select>
                                        <select class="photo-size-elite" id="previewPhotoSize">
                                            <option value="5.5x8.5">5.5√ó8.5cm</option>
                                            <option value="6x9">6√ó9cm</option>
                                            <option value="9.5x9.5">9.5√ó9.5cm</option>
                                            <option value="5x15">5√ó15cm</option>
                                            <option value="5x7.5">5√ó7.5cm</option>
                                            <option value="4x6">4√ó6cm</option>
                                            <option value="custom">T√πy ch·ªânh</option>
                                        </select>

                                        <!-- Custom Size Inputs -->
                                        <div class="custom-size-inputs" id="previewCustomSizeInputs" style="display: none;">
                                            <div class="custom-input-row">
                                                <input type="number" id="previewCustomWidth" placeholder="R·ªông" min="1" max="50" step="0.1" value="5">
                                                <span>√ó</span>
                                                <input type="number" id="previewCustomHeight" placeholder="Cao" min="1" max="50" step="0.1" value="15">
                                                <span class="unit">cm</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        </div>
                        
                        <div class="canvas-viewport">
                            <!-- Single Canvas for Single Mode -->
                            <div class="canvas-container single-mode" id="canvasContainer">
                                <div class="canvas-ruler-h" id="rulerHorizontal" style="display: none;"></div>
                                <div class="canvas-ruler-v" id="rulerVertical" style="display: none;"></div>
                                <canvas id="printCanvas" class="print-canvas"></canvas>
                                <div class="canvas-overlay" id="canvasOverlay"></div>
                            </div>
                            
                            <!-- Dual Canvas for Duplex Mode -->
                            <div class="dual-canvas-container duplex-mode" id="duplexCanvasContainer" style="display: none;">
                                <div class="canvas-side front-side">
                                    <div class="side-header">
                                        <h4>üìÑ M·∫∑t tr∆∞·ªõc</h4>
                                    </div>
                                    <div class="canvas-wrapper">
                                        <canvas id="frontCanvas" class="duplex-canvas"></canvas>
                                        <div class="canvas-overlay" id="frontCanvasOverlay"></div>
                                    </div>
                                </div>
                                
                                <div class="canvas-side back-side">
                                    <div class="side-header">
                                        <h4>üìÉ M·∫∑t sau</h4>
                                    </div>
                                    <div class="canvas-wrapper">
                                        <canvas id="backCanvas" class="duplex-canvas"></canvas>
                                        <div class="canvas-overlay" id="backCanvasOverlay"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="preview-footer-compact">
                            <div class="quality-badge">
                                <span class="badge-icon">‚úÖ</span>
                                <span class="badge-text">300 DPI</span>
                            </div>
                        </div>
                    </div>

                    <!-- Compact Export Options -->
                    <div class="export-section-compact" id="exportSection" style="display: none;">
                        <div class="export-options-compact">
                            <div class="export-format-tabs">
                                <!-- üö´ T·∫ÆT JPG ZIP -->
                                <button class="format-tab" data-format="jpg-zip" style="display: none;">
                                    <span class="tab-icon">üì¶</span>
                                    <span class="tab-text">JPG (ZIP)</span>
                                </button>
                                <button class="format-tab active" data-format="jpg-individual">
                                    <span class="tab-icon">üñºÔ∏è</span>
                                    <span class="tab-text">JPG ri√™ng (100% quality)</span>
                                </button>
                                <button class="format-tab" data-format="pdf">
                                    <span class="tab-icon">üìÑ</span>
                                    <span class="tab-text">PDF</span>
                                </button>
                                <button class="format-tab" data-format="filesystem">
                                    <span class="tab-icon">üíæ</span>
                                    <span class="tab-text">L∆∞u v√†o File System</span>
                                </button>
                            </div>

                            <!-- SK316 Export Status Badge -->
                            <div class="sk316-export-status" id="sk316ExportStatus">
                                <div class="sk316-status-badge" id="sk316ExportBadge">
                                    <span class="status-icon">‚óã</span>
                                    <span class="status-text">SK316: T·∫ÆT</span>
                                </div>
                                <div class="sk316-profile-info" id="sk316ProfileInfo" style="display: none;">
                                    <div class="profile-name" id="sk316ExportProfileName">-</div>
                                    <div class="profile-details" id="sk316ExportProfileDetails">-</div>
                                </div>
                            </div>

                            <button class="export-btn primary" id="generatePrintBtn" disabled>
                                <span class="btn-icon">üöÄ</span>
                                <span class="btn-text">T·∫°o v√† t·∫£i file in</span>
                            </button>
                        </div>
                    </div>

                        </div>
                        <!-- END RIGHT COLUMN -->

                    </div>
                    <!-- END 2-COLUMN LAYOUT -->

                </div>
            </div>

            <!-- Add CSS for new compact interface -->
            <style>
            /* 2-Column Layout for Print Section */
            .print-layout-2col {
                display: grid;
                grid-template-columns: minmax(360px, 1fr) minmax(520px, 1.3fr);
                gap: clamp(20px, 2vw, 36px);
                margin-top: 20px;
                align-items: start;
                width: 100%;
            }

            .print-left-column {
                display: flex;
                flex-direction: column;
                gap: 20px;
                height: fit-content;
                min-width: 0;
            }

            .print-right-column {
                position: sticky;
                top: 20px;
                display: flex;
                flex-direction: column;
                gap: 16px;
                height: fit-content;
                max-height: calc(100vh - 40px);
                overflow-y: auto;
                min-width: 0;
            }

            /* Compact Actions for Right Column */
            .print-actions-compact {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 16px;
                padding: 12px 16px;
                background: linear-gradient(135deg, #f8fafc 0%, #eef2ff 100%);
                border: 2px solid #e2e8f0;
                border-radius: 12px;
                flex-wrap: wrap;
            }

            /* Responsive: Stack on mobile */
            @media (max-width: 1366px) {
                .print-layout-2col {
                    grid-template-columns: minmax(320px, 1fr) minmax(460px, 1.15fr);
                    gap: clamp(18px, 2vw, 28px);
                }
            }

            @media (max-width: 1100px) {
                .print-layout-2col {
                    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
                    gap: 18px;
                }
            }

            @media (max-width: 820px) {
                .print-layout-2col {
                    grid-template-columns: 1fr;
                    gap: 20px;
                }

                .print-right-column {
                    position: static;
                    max-height: none;
                    overflow: visible;
                }
            }

            /* Quick Presets V2 - Pills Design */
            .quick-presets-v2 {
                margin: 0;
                padding: 16px 20px;
                background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                border-radius: 12px;
                border: 1px solid #e2e8f0;
            }

            .presets-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 12px;
            }

            .presets-header h3 {
                margin: 0;
                font-size: 1em;
                color: #1e293b;
                font-weight: 600;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .expand-presets-btn {
                background: none;
                border: none;
                cursor: pointer;
                padding: 4px 8px;
                color: #64748b;
                transition: all 0.2s ease;
                border-radius: 4px;
            }

            .expand-presets-btn:hover {
                background: rgba(99, 102, 241, 0.1);
                color: #6366f1;
            }

            .preset-pills-container {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .preset-pills-row {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }

            .preset-pills-expanded {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                padding-top: 8px;
                border-top: 1px dashed #e2e8f0;
                animation: slideDown 0.3s ease;
            }

            @keyframes slideDown {
                from {
                    opacity: 0;
                    transform: translateY(-10px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

              .preset-pill {
                  display: inline-flex;
                  align-items: center;
                  gap: 6px;
                  padding: 8px 16px;
                  background: white;
                  border: 2px solid #e2e8f0;
                  border-radius: 20px;
                  cursor: pointer;
                transition: all 0.2s ease;
                font-size: 0.9em;
                font-weight: 500;
                color: #475569;
                white-space: nowrap;
            }

            .preset-pill:hover {
                border-color: #6366f1;
                background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(99, 102, 241, 0.15);
            }

            .preset-pill.active {
                border-color: #6366f1;
                background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                color: white;
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
            }

            .preset-pill.more-pill {
                border-style: dashed;
                color: #64748b;
            }

              .preset-pill.custom-pill {
                  border-color: #f59e0b;
                  color: #f59e0b;
              }

              .preset-pill.custom-pill:hover,
              .preset-pill.custom-pill.active {
                  border-color: #f59e0b;
                  background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
                  color: #d97706;
              }

              .custom-presets-block {
                  margin-top: 10px;
                  padding-top: 10px;
                  border-top: 1px dashed #e2e8f0;
                  display: flex;
                  flex-direction: column;
                  gap: 8px;
              }

              .custom-presets-header {
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  color: #334155;
                  font-size: 0.95em;
                  font-weight: 600;
              }

              .save-custom-btn {
                  background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
                  color: #fff;
                  border: none;
                  border-radius: 12px;
                  padding: 6px 10px;
                  font-weight: 700;
                  cursor: pointer;
                  box-shadow: 0 4px 10px rgba(34, 197, 94, 0.25);
                  transition: all 0.2s ease;
              }

              .save-custom-btn:hover {
                  transform: translateY(-1px);
                  box-shadow: 0 6px 14px rgba(34, 197, 94, 0.3);
              }

              .custom-presets-list {
                  display: flex;
                  flex-wrap: wrap;
                  gap: 8px;
              }

              .custom-saved-pill {
                  position: relative;
                  padding-right: 28px;
              }

              .remove-preset-btn {
                  position: absolute;
                  right: 6px;
                  top: 50%;
                  transform: translateY(-50%);
                  color: #ef4444;
                  font-weight: 700;
                  cursor: pointer;
                  font-size: 14px;
              }

              .remove-preset-btn:hover {
                  color: #b91c1c;
              }

              .custom-presets-empty {
                  color: #94a3b8;
                  font-size: 0.9em;
              }

              .pill-icon {
                  font-size: 1.1em;
                  line-height: 1;
              }

            /* SVG Icon Styles */
            .svg-icon {
                width: 1em;
                height: 1em;
                display: inline-block;
                vertical-align: middle;
            }

            .pill-icon .svg-icon {
                width: 1.1em;
                height: 1.1em;
            }

            .btn-icon .svg-icon {
                width: 1.2em;
                height: 1.2em;
            }

            .qa-icon .svg-icon {
                width: 1.1em;
                height: 1.1em;
            }

            .pill-text {
                font-size: 0.95em;
                font-weight: 600;
            }

            /* Saved Presets Section */
            .saved-presets-section {
                margin: 20px 0;
                padding: 20px;
                background: linear-gradient(135deg, #fefce8 0%, #fef9c3 100%);
                border-radius: 16px;
                border: 2px solid #fbbf24;
                box-shadow: 0 4px 12px rgba(251, 191, 36, 0.15);
            }

            .saved-presets-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 16px;
                padding-bottom: 12px;
                border-bottom: 2px dashed #fbbf24;
            }

            .saved-presets-header h3 {
                margin: 0;
                font-size: 1.1em;
                color: #78350f;
                font-weight: 700;
            }

            .preset-actions {
                display: flex;
                gap: 8px;
            }

            .preset-action-btn {
                display: inline-flex;
                align-items: center;
                gap: 6px;
                padding: 8px 14px;
                background: white;
                border: 2px solid #fbbf24;
                border-radius: 12px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 0.85em;
                font-weight: 600;
                color: #b45309;
            }

            .preset-action-btn:hover {
                background: #fef3c7;
                border-color: #f59e0b;
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(245, 158, 11, 0.2);
            }

            .preset-action-btn .action-icon {
                font-size: 1.2em;
            }

            .saved-presets-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 12px;
            }

            .no-presets-message {
                grid-column: 1 / -1;
                text-align: center;
                padding: 40px 20px;
                color: #a16207;
            }

            .no-preset-icon {
                font-size: 3em;
                display: block;
                margin-bottom: 12px;
            }

            .no-presets-message p {
                margin: 8px 0;
                font-weight: 600;
                font-size: 1.05em;
            }

            .no-presets-message small {
                color: #ca8a04;
                font-size: 0.9em;
            }

            .preset-card {
                position: relative;
                background: white;
                border: 2px solid #fcd34d;
                border-radius: 12px;
                padding: 16px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .preset-card:hover {
                border-color: #f59e0b;
                background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(245, 158, 11, 0.2);
            }

            .preset-card.active {
                border-color: #6366f1;
                background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
                box-shadow: 0 6px 16px rgba(99, 102, 241, 0.3);
            }

            .preset-card-header {
                display: flex;
                align-items: flex-start;
                gap: 12px;
            }

            .preset-icon {
                font-size: 2em;
                line-height: 1;
            }

            .preset-info {
                flex: 1;
                min-width: 0;
            }

            .preset-name {
                font-weight: 700;
                color: #78350f;
                font-size: 1em;
                margin-bottom: 4px;
                word-wrap: break-word;
            }

            .preset-description {
                font-size: 0.85em;
                color: #92400e;
                line-height: 1.4;
            }

            .preset-details {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                padding-top: 12px;
                border-top: 1px dashed #fcd34d;
            }

            .preset-detail-item {
                font-size: 0.8em;
                color: #a16207;
            }

            .preset-detail-label {
                font-weight: 600;
                display: block;
                margin-bottom: 2px;
            }

            .preset-detail-value {
                color: #b45309;
            }

            .preset-card-actions {
                position: absolute;
                top: 12px;
                right: 12px;
                display: flex;
                gap: 4px;
                opacity: 0;
                transition: opacity 0.2s ease;
            }

            .preset-card:hover .preset-card-actions {
                opacity: 1;
            }

            .preset-card-action {
                width: 28px;
                height: 28px;
                border-radius: 6px;
                border: none;
                background: white;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1em;
                transition: all 0.2s ease;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }

            .preset-card-action:hover {
                transform: scale(1.1);
            }

            .preset-card-action.edit:hover {
                background: #dbeafe;
                color: #2563eb;
            }

            .preset-card-action.duplicate:hover {
                background: #dcfce7;
                color: #16a34a;
            }

            .preset-card-action.delete:hover {
                background: #fee2e2;
                color: #dc2626;
            }

            .preset-card-action.export:hover {
                background: #e0e7ff;
                color: #6366f1;
            }

            /* Preset Modal */
            .preset-modal-content {
                max-width: 600px;
                width: 90%;
            }

            .preset-form {
                display: flex;
                flex-direction: column;
                gap: 20px;
            }

            .form-group label {
                display: block;
                font-weight: 600;
                margin-bottom: 8px;
                color: #1e293b;
                font-size: 0.95em;
            }

            .form-group .required {
                color: #ef4444;
            }

            .form-group input[type="text"],
            .form-group textarea {
                width: 100%;
                padding: 10px 14px;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                font-size: 0.95em;
                transition: all 0.2s ease;
                font-family: inherit;
            }

            .form-group input[type="text"]:focus,
            .form-group textarea:focus {
                outline: none;
                border-color: #6366f1;
                box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
            }

            .form-hint {
                display: block;
                margin-top: 6px;
                font-size: 0.85em;
                color: #64748b;
            }

            .icon-picker {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
                gap: 8px;
            }

            .icon-option {
                width: 100%;
                aspect-ratio: 1;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                background: white;
                cursor: pointer;
                font-size: 1.5em;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .icon-option:hover {
                border-color: #6366f1;
                background: #eef2ff;
                transform: scale(1.1);
            }

            .icon-option.active {
                border-color: #6366f1;
                background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
                transform: scale(1.05);
            }

            .preset-config-preview {
                background: #f8fafc;
                border: 1px solid #e2e8f0;
                border-radius: 8px;
                padding: 16px;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 12px;
            }

            .config-item {
                display: flex;
                gap: 8px;
                align-items: center;
                font-size: 0.9em;
            }

            .config-label {
                font-weight: 600;
                color: #64748b;
            }

            .config-value {
                color: #1e293b;
                font-weight: 500;
            }

            .preset-pill.active .pill-text,
            .preset-pill.active .pill-icon {
                color: white;
            }
            
            /* Compact Configuration */
            .print-config-compact {
                display: flex;
                flex-direction: column;
                gap: 16px;
                margin: 0;
            }
            
            .config-card {
                background: white;
                border: 1px solid #e2e8f0;
                border-radius: 8px;
                overflow: hidden;
            }
            
            .card-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 16px;
                background: #f8fafc;
                border-bottom: 1px solid #e2e8f0;
                cursor: pointer;
                user-select: none;
            }
            
            .card-header h4 {
                margin: 0;
                font-size: 1em;
                color: #1e293b;
            }
            
            .card-toggle {
                background: none;
                border: none;
                font-size: 1.2em;
                color: #64748b;
                cursor: pointer;
                transition: transform 0.2s ease;
            }
            
            .card-toggle.expanded {
                transform: rotate(180deg);
            }
            
            .card-content {
                padding: 16px;
                transition: all 0.3s ease;
            }
            
            .card-content.collapsed {
                display: none;
            }
            
            .settings-row {
                display: flex;
                gap: 16px;
                margin-bottom: 16px;
                flex-wrap: wrap;
            }
            
            .setting-group {
                flex: 1;
                min-width: 200px;
            }
            
            .setting-group.full-width {
                flex: 1 1 100%;
            }
            
            .setting-group label {
                display: block;
                margin-bottom: 6px;
                font-weight: 500;
                color: #374151;
                font-size: 0.9em;
            }

            /* Input containers for margin and gutter */
            .margin-inputs-compact,
            .gutter-inputs-compact {
                display: flex;
                gap: 8px;
                align-items: center;
            }

            .margin-inputs-compact input,
            .gutter-inputs-compact input {
                flex: 1;
                min-width: 70px;
                padding: 8px 12px;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                font-size: 0.9em;
                text-align: center;
            }

            .margin-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
                margin-top: 8px;
            }

            .margin-grid input {
                min-width: 70px;
                padding: 8px 12px;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                font-size: 0.9em;
                text-align: center;
            }

            .compact-select, .mini-select {
                width: 100%;
                padding: 8px 12px;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                background: white;
                font-size: 0.9em;
            }
            
            .mini-select {
                width: auto;
                min-width: 80px;
            }
            
            .orientation-buttons, .fit-buttons {
                display: flex;
                gap: 4px;
            }
            
            .orient-btn, .fit-btn {
                flex: 1;
                padding: 8px 12px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 0.85em;
            }
            
            .orient-btn.active, .fit-btn.active {
                background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                color: white;
                border-color: #6366f1;
                box-shadow: 0 2px 4px rgba(99, 102, 241, 0.2);
            }

            /* Offset rNcM Card Styles */
            .offset-card {
                border-left: 3px solid #f59e0b;
            }

            .offset-instructions {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px;
                background: #fffbeb;
                border: 1px solid #fef3c7;
                border-radius: 6px;
                margin-bottom: 16px;
                font-size: 0.9em;
                color: #92400e;
            }

            .offset-instructions svg {
                width: 18px;
                height: 18px;
                color: #f59e0b;
                flex-shrink: 0;
            }

            .offset-toggle-section {
                padding: 16px 0;
                border-bottom: 1px solid #e5e7eb;
                margin-bottom: 16px;
            }

            .offset-enable-toggle {
                display: flex;
                align-items: center;
                gap: 12px;
                cursor: pointer;
                user-select: none;
            }

            .offset-enable-toggle .toggle-text {
                font-weight: 500;
                color: #374151;
                font-size: 0.95em;
            }

            .offset-table-container {
                margin-top: 16px;
            }

            .offset-table-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 12px;
                padding-bottom: 8px;
                border-bottom: 2px solid #f59e0b;
            }

            .offset-table-header span {
                font-weight: 600;
                color: #92400e;
                font-size: 0.9em;
            }

            .offset-table-actions {
                display: flex;
                gap: 6px;
            }

            .offset-btn-mini {
                padding: 4px 10px;
                background: #f3f4f6;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.85em;
                font-weight: 600;
                color: #6b7280;
                transition: all 0.2s ease;
            }

            .offset-btn-mini:hover {
                background: #e5e7eb;
                border-color: #9ca3af;
            }

            .offset-table-rncm {
                width: 100%;
                border-collapse: collapse;
                font-size: 0.9em;
            }

            .offset-table-rncm thead {
                background: #fef3c7;
            }

            .offset-table-rncm th {
                padding: 10px;
                text-align: center;
                font-weight: 600;
                color: #92400e;
                border: 1px solid #fde68a;
            }

            .offset-table-rncm td {
                padding: 6px;
                text-align: center;
                border: 1px solid #e5e7eb;
            }

            .offset-table-rncm td:first-child {
                font-weight: 600;
                color: #6b7280;
                background: #f9fafb;
            }

            .offset-table-rncm tbody tr:hover {
                background: #fffbeb;
            }

            .offset-input-rncm {
                width: 100%;
                padding: 6px 8px;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                text-align: center;
                font-size: 0.85em;
                transition: all 0.2s ease;
            }

            .offset-input-rncm:focus {
                outline: none;
                border-color: #f59e0b;
                box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.1);
            }

            .offset-hint {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-top: 12px;
                padding: 10px;
                background: #f3f4f6;
                border-radius: 6px;
            }

            .offset-hint svg {
                width: 16px;
                height: 16px;
                color: #6b7280;
                flex-shrink: 0;
            }

            .offset-hint small {
                color: #6b7280;
                font-size: 0.85em;
            }

            /* Gutter hint (SK316 reminder) */
            .gutter-hint {
                display: flex;
                align-items: center;
                gap: 6px;
                margin-top: 6px;
                padding: 6px 8px;
                background: #fffbeb;
                border-radius: 4px;
            }

            .gutter-hint svg {
                width: 14px;
                height: 14px;
                color: #f59e0b;
                flex-shrink: 0;
            }

            .gutter-hint small {
                color: #92400e;
                font-size: 0.8em;
            }

            /* Layout Preview V2 - Enhanced with Visualization */
            .layout-preview-v2 {
                margin: 0;
                border: 2px solid #e2e8f0;
                border-radius: 12px;
                background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
                overflow: hidden;
            }

            .preview-container {
                display: grid;
                grid-template-columns: 280px 1fr;
                gap: 20px;
                padding: 20px;
            }

            /* Paper Visualization */
            .paper-visualization {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .paper-label {
                font-size: 0.85em;
                font-weight: 600;
                color: #475569;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .paper-frame {
                position: relative;
                background: white;
                border: 2px solid #6366f1;
                border-radius: 8px;
                padding: 16px;
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
                aspect-ratio: 210/297;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .paper-grid {
                display: grid;
                gap: 4px;
                width: 100%;
                height: 100%;
            }

            .paper-grid-cell {
                background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
                border: 1px dashed #6366f1;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.5em;
                transition: all 0.2s ease;
            }

            .paper-grid-cell:hover {
                background: linear-gradient(135deg, #ddd6fe 0%, #c7d2fe 100%);
                transform: scale(1.05);
            }

            .paper-dimensions {
                position: absolute;
                bottom: 8px;
                right: 8px;
                background: rgba(99, 102, 241, 0.9);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.75em;
                font-weight: 600;
            }

            /* Stats Panel */
            .stats-panel {
                display: flex;
                flex-direction: column;
                gap: 16px;
            }

            .stats-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            .stat-card {
                background: white;
                border: 2px solid #e2e8f0;
                border-radius: 10px;
                padding: 16px;
                display: flex;
                align-items: center;
                gap: 12px;
                transition: all 0.2s ease;
            }

            .stat-card:hover {
                border-color: #6366f1;
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.1);
                transform: translateY(-2px);
            }

            .stat-card.efficiency {
                grid-column: 1 / -1;
                background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
                border-color: #6366f1;
            }

            .stat-icon {
                font-size: 2em;
                line-height: 1;
            }

            .stat-content {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .stat-value {
                font-size: 1.5em;
                font-weight: 700;
                color: #1e293b;
                line-height: 1;
            }

            .stat-label {
                font-size: 0.8em;
                color: #64748b;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .efficiency-bar {
                width: 100%;
                height: 6px;
                background: rgba(255, 255, 255, 0.5);
                border-radius: 3px;
                overflow: hidden;
                margin-top: 8px;
            }

            .efficiency-fill {
                height: 100%;
                background: linear-gradient(90deg, #10b981 0%, #059669 100%);
                transition: width 0.5s ease;
                border-radius: 3px;
            }

            .layout-suggestion {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 14px 16px;
                background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
                border: 2px solid #f59e0b;
                border-radius: 10px;
                font-size: 0.9em;
                color: #92400e;
                font-weight: 500;
            }

            .suggestion-icon {
                font-size: 1.3em;
            }

            .suggestion-text {
                flex: 1;
            }

            /* Responsive */
            @media (max-width: 768px) {
                .preview-container {
                    grid-template-columns: 1fr;
                }

                .stats-grid {
                    grid-template-columns: 1fr;
                }
            }
            
            /* Drag & Drop Zone V2 */
            .drag-drop-zone-v2 {
                margin: 0;
            }

            .drop-area-main {
                min-height: 240px;
                border: 3px dashed #cbd5e1;
                border-radius: 16px;
                background: linear-gradient(135deg, #f8fafc 0%, #eef2ff 100%);
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            }

            .drop-area-main.drag-over {
                border-color: #6366f1;
                border-width: 4px;
                background: linear-gradient(135deg, #eef2ff 0%, #ddd6fe 100%);
                transform: scale(1.02);
                box-shadow: 0 8px 24px rgba(99, 102, 241, 0.25);
                animation: pulse 1s infinite;
            }

            @keyframes pulse {
                0%, 100% { box-shadow: 0 8px 24px rgba(99, 102, 241, 0.25); }
                50% { box-shadow: 0 8px 32px rgba(99, 102, 241, 0.4); }
            }

            .drop-content {
                padding: 40px 20px;
                text-align: center;
            }

            .drop-icon {
                font-size: 4em;
                margin-bottom: 16px;
                animation: bounce 2s infinite;
            }

            @keyframes bounce {
                0%, 100% { transform: translateY(0); }
                50% { transform: translateY(-10px); }
            }

            .drop-area-main.drag-over .drop-icon {
                animation: rotate 1s linear infinite;
            }

            @keyframes rotate {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }

            .drop-title {
                font-size: 1.5em;
                font-weight: 700;
                color: #1e293b;
                margin-bottom: 8px;
            }

            .drop-area-main.drag-over .drop-title::after {
                content: " üéØ Th·∫£ ·∫£nh v√†o ƒë√¢y!";
                color: #6366f1;
            }

            .drop-subtitle {
                font-size: 1em;
                color: #64748b;
                margin-bottom: 20px;
            }

            .drop-actions {
                display: flex;
                gap: 12px;
                justify-content: center;
                flex-wrap: wrap;
                margin-bottom: 16px;
            }

            .drop-action-btn {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px 24px;
                border: 2px solid #e2e8f0;
                border-radius: 10px;
                background: white;
                cursor: pointer;
                transition: all 0.2s ease;
                font-weight: 600;
            }

            .drop-action-btn.primary {
                border-color: #6366f1;
                background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                color: white;
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
            }

            .drop-action-btn.secondary {
                border-color: #10b981;
                color: #10b981;
            }

            .drop-action-btn.tertiary {
                border-color: #f59e0b;
                color: #f59e0b;
            }

            .drop-action-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
            }

            .drop-action-btn.secondary:hover {
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                color: white;
                border-color: #10b981;
            }

            .drop-action-btn.tertiary:hover {
                background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
                color: white;
                border-color: #f59e0b;
            }

            .action-icon {
                font-size: 1.2em;
            }

            .drop-hint {
                font-size: 0.85em;
                color: #94a3b8;
                font-style: italic;
            }

            /* Upload Progress */
            .upload-progress-container {
                padding: 30px;
                text-align: center;
            }

            .progress-header {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 12px;
                margin-bottom: 20px;
            }

            .progress-icon {
                font-size: 2em;
                animation: spin 1s linear infinite;
            }

            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }

            .progress-title {
                font-size: 1.2em;
                font-weight: 600;
                color: #1e293b;
            }

            .progress-bar-wrapper {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 20px;
            }

            .progress-bar {
                flex: 1;
                height: 12px;
                background: #e2e8f0;
                border-radius: 6px;
                overflow: hidden;
            }

            .progress-fill {
                height: 100%;
                background: linear-gradient(90deg, #6366f1 0%, #8b5cf6 100%);
                transition: width 0.3s ease;
                border-radius: 6px;
            }

            .progress-text {
                font-weight: 700;
                color: #6366f1;
                min-width: 50px;
            }

            .upload-file-list {
                max-height: 200px;
                overflow-y: auto;
                text-align: left;
                margin-top: 20px;
            }

            .file-item {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 8px 12px;
                background: white;
                border: 1px solid #e2e8f0;
                border-radius: 8px;
                margin-bottom: 8px;
                transition: all 0.2s ease;
            }

            .file-item-icon {
                font-size: 1.2em;
            }

            .file-item-name {
                flex: 1;
                font-size: 0.9em;
                color: #475569;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .file-item-size {
                font-size: 0.8em;
                color: #94a3b8;
            }

            .file-item.success {
                border-color: #10b981;
                background: #f0fdf4;
            }

            .file-item.error {
                border-color: #ef4444;
                background: #fef2f2;
            }

            /* Upload Success */
            .upload-success {
                padding: 40px;
                text-align: center;
            }

            .success-icon {
                font-size: 4em;
                margin-bottom: 16px;
                animation: scaleIn 0.5s ease;
            }

            @keyframes scaleIn {
                from { transform: scale(0); }
                to { transform: scale(1); }
            }

            .success-title {
                font-size: 1.3em;
                font-weight: 600;
                color: #10b981;
                margin-bottom: 20px;
            }

            .success-action-btn {
                padding: 12px 24px;
                background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                color: white;
                border: none;
                border-radius: 10px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .success-action-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(99, 102, 241, 0.3);
            }

            /* Smart Grid V2 - Enhanced Selected Images */
            .smart-grid-v2 {
                margin: 0;
                border: 2px solid #e2e8f0;
                border-radius: 12px;
                background: white;
                overflow: hidden;
            }

            .grid-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 16px 20px;
                background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                border-bottom: 2px solid #e2e8f0;
                flex-wrap: wrap;
                gap: 12px;
            }

            .header-left {
                display: flex;
                align-items: center;
                gap: 16px;
                flex-wrap: wrap;
            }

            .grid-title {
                margin: 0;
                font-size: 1.1em;
                color: #1e293b;
                font-weight: 600;
            }

            .select-all-checkbox {
                display: flex;
                align-items: center;
                gap: 8px;
                cursor: pointer;
                font-size: 0.9em;
                color: #64748b;
                font-weight: 500;
            }

            .select-all-checkbox input[type="checkbox"] {
                width: 18px;
                height: 18px;
                cursor: pointer;
            }

            .header-right {
                display: flex;
                align-items: center;
                gap: 8px;
                flex-wrap: wrap;
            }

            .grid-control-select {
                padding: 6px 12px;
                border: 1px solid #cbd5e1;
                border-radius: 6px;
                background: white;
                font-size: 0.85em;
                color: #475569;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .grid-control-select:hover {
                border-color: #6366f1;
            }

            .grid-action-btn {
                padding: 6px 12px;
                background: white;
                border: 1px solid #cbd5e1;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 1.2em;
            }

            .grid-action-btn:hover {
                background: #f8fafc;
                border-color: #6366f1;
            }

            /* Bulk Actions Toolbar */
            .bulk-actions-toolbar {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 20px;
                background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
                border-bottom: 2px solid #6366f1;
                animation: slideDown 0.3s ease;
            }

            .toolbar-info {
                flex: 1;
            }

            .selection-count {
                font-weight: 600;
                color: #4f46e5;
                font-size: 0.95em;
            }

            .toolbar-actions {
                display: flex;
                gap: 8px;
            }

            .bulk-btn {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 8px 16px;
                background: white;
                border: 2px solid #6366f1;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-weight: 600;
                color: #4f46e5;
            }

            .bulk-btn:hover {
                background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                color: white;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
            }

            .bulk-btn.cancel {
                border-color: #ef4444;
                color: #ef4444;
            }

            .bulk-btn.cancel:hover {
                background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                color: white;
            }

            .bulk-icon {
                font-size: 1.1em;
            }

            /* Images Grid Smart */
            .images-grid-smart {
                display: grid;
                gap: 12px;
                padding: 20px;
                min-height: 200px;
            }

            .images-grid-smart[data-grid-size="small"] {
                grid-template-columns: repeat(6, 1fr);
            }

            .images-grid-smart[data-grid-size="medium"] {
                grid-template-columns: repeat(4, 1fr);
            }

            .images-grid-smart[data-grid-size="large"] {
                grid-template-columns: repeat(3, 1fr);
            }

            .images-grid-smart[data-grid-size="xlarge"] {
                grid-template-columns: repeat(2, 1fr);
            }

            .grid-image-item {
                position: relative;
                aspect-ratio: 1;
                border: 2px solid #e2e8f0;
                border-radius: 10px;
                overflow: hidden;
                cursor: pointer;
                transition: all 0.2s ease;
                background: #f8fafc;
            }

            .grid-image-item:hover {
                border-color: #6366f1;
                transform: translateY(-4px);
                box-shadow: 0 8px 16px rgba(99, 102, 241, 0.15);
            }

            .grid-image-item.selected {
                border-color: #6366f1;
                border-width: 3px;
                box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
            }

            .grid-image-number {
                position: absolute;
                top: 8px;
                left: 8px;
                background: rgba(99, 102, 241, 0.9);
                color: white;
                padding: 4px 8px;
                border-radius: 6px;
                font-weight: 700;
                font-size: 0.85em;
                z-index: 2;
            }

            .grid-image-checkbox {
                position: absolute;
                top: 8px;
                right: 8px;
                width: 24px;
                height: 24px;
                cursor: pointer;
                z-index: 2;
                background: white;
                border: 2px solid #cbd5e1;
                border-radius: 6px;
                transition: all 0.2s ease;
            }

            .grid-image-checkbox:checked {
                background: #6366f1;
                border-color: #6366f1;
            }

            .grid-image-img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .grid-image-actions {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
                padding: 30px 8px 8px 8px;
                display: flex;
                justify-content: center;
                gap: 4px;
                opacity: 0;
                transition: opacity 0.2s ease;
            }

            .grid-image-item:hover .grid-image-actions {
                opacity: 1;
            }

            .grid-action-icon {
                width: 32px;
                height: 32px;
                background: rgba(255, 255, 255, 0.9);
                border: none;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.1em;
            }

            .grid-action-icon:hover {
                background: white;
                transform: scale(1.1);
            }

            .grid-action-icon.delete:hover {
                background: #ef4444;
                color: white;
            }

            /* Responsive */
            @media (max-width: 768px) {
                .images-grid-smart[data-grid-size="small"],
                .images-grid-smart[data-grid-size="medium"] {
                    grid-template-columns: repeat(3, 1fr);
                }

                .images-grid-smart[data-grid-size="large"] {
                    grid-template-columns: repeat(2, 1fr);
                }

                .images-grid-smart[data-grid-size="xlarge"] {
                    grid-template-columns: 1fr;
                }
            }

            /* Print Actions - Sticky (Old - Hidden in 2col layout) */
            .print-actions-sticky {
                display: none;
            }

            .actions-info {
                flex: 1;
                min-width: 150px;
            }

            .selection-indicator {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 8px 16px;
                background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
                border: 2px solid #6366f1;
                border-radius: 20px;
                font-weight: 600;
                color: #4f46e5;
            }

            .indicator-icon {
                font-size: 1.2em;
            }

            .indicator-text {
                font-size: 0.9em;
            }

            .actions-buttons {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
            }

            .action-btn {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px 24px;
                border: 2px solid #d1d5db;
                border-radius: 8px;
                background: white;
                cursor: pointer;
                transition: all 0.2s ease;
                font-weight: 600;
                font-size: 0.95em;
                white-space: nowrap;
            }

            .action-btn.primary {
                background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                color: white;
                border-color: #6366f1;
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
            }

            .action-btn.secondary {
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                color: white;
                border-color: #10b981;
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
            }

            .action-btn.utility {
                background: white;
                color: #64748b;
                border-color: #e2e8f0;
            }

            .action-btn.utility:hover {
                background: #f8fafc;
                border-color: #cbd5e1;
                color: #475569;
            }

            .action-btn:hover:not(:disabled) {
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(0,0,0,0.12);
            }

            .action-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
            }

            .action-btn .btn-icon {
                font-size: 1.2em;
            }
            
            /* Preview Compact */
            .print-preview-compact {
                margin: 20px 0;
                border: 1px solid #e2e8f0;
                border-radius: 8px;
                overflow: hidden;
            }
            
            .preview-header-compact {
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
                padding: 16px 20px;
                background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
                border-bottom: 1px solid #d1d5db;
            }

            .header-left {
                flex: 1;
            }

            .preview-title {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 12px;
            }

            .title-text {
                font-size: 1.1em;
                font-weight: 600;
                color: #1f2937;
            }

            .status-badge {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 4px 8px;
                background: rgba(34, 197, 94, 0.1);
                border: 1px solid rgba(34, 197, 94, 0.2);
                border-radius: 12px;
            }

            .status-dot {
                width: 6px;
                height: 6px;
                background: #22c55e;
                border-radius: 50%;
                animation: pulse 2s infinite;
            }

            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.5; }
            }

            .status-text {
                font-size: 0.8em;
                color: #16a34a;
                font-weight: 500;
            }

            .preview-stats {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 16px;
                max-width: 600px;
            }

            .stat-group {
                display: flex;
                flex-direction: column;
                gap: 2px;
            }

            .stat-label {
                font-size: 0.75em;
                color: #6b7280;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            .stat-value {
                font-size: 0.9em;
                color: #1f2937;
                font-weight: 600;
            }

            .header-actions {
                display: flex;
                gap: 8px;
                align-items: center;
                flex-shrink: 0;
            }

            .action-btn {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 8px 16px;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                cursor: pointer;
                font-size: 0.85em;
                font-weight: 500;
                transition: all 0.15s ease;
                background: white;
                color: #374151;
            }

            .action-btn.secondary:hover {
                background: #f3f4f6;
                border-color: #9ca3af;
            }

            .action-btn.primary {
                background: #2563eb;
                border-color: #2563eb;
                color: white;
            }

            .action-btn.primary:hover {
                background: #1d4ed8;
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(37, 99, 235, 0.2);
            }
            
            .preview-controls-compact {
                display: flex;
                flex-direction: column;
                gap: 8px;
                padding: 12px 16px;
                background: #fafafa;
                border-bottom: 1px solid #e5e7eb;
            }

            .controls-row-1, .controls-row-2 {
                display: flex;
                align-items: center;
                gap: 16px;
                flex-wrap: wrap;
            }

            /* Zoom Controls */
            .zoom-controls {
                display: flex;
                gap: 1px;
                background: #e5e7eb;
                border-radius: 4px;
                padding: 1px;
            }

            .zoom-btn {
                padding: 4px 8px;
                border: none;
                background: white;
                color: #6b7280;
                font-size: 0.8em;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.15s ease;
                border-radius: 3px;
            }

            .zoom-btn.active {
                background: #2563eb;
                color: white;
            }

            .zoom-btn:hover:not(.active) {
                background: #f3f4f6;
            }

            /* Orientation Control */
            .orientation-control {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .orient-btn {
                width: 32px;
                height: 32px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.1em;
                transition: all 0.15s ease;
            }

            .orient-btn.active {
                background: #2563eb;
                border-color: #2563eb;
                color: white;
            }

            .orient-label {
                font-size: 0.8em;
                color: #6b7280;
                font-weight: 500;
            }

            /* Cutting Detailed Controls */
            .cutting-detailed {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .cut-toggle {
                padding: 6px 12px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 4px;
                font-size: 0.85em;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.15s ease;
                color: #6b7280;
            }

            .cut-toggle.active {
                background: #2563eb;
                border-color: #2563eb;
                color: white;
            }

            .cut-types {
                display: flex;
                gap: 2px;
                background: #f3f4f6;
                border-radius: 4px;
                padding: 2px;
            }

            .cut-type {
                width: 28px;
                height: 28px;
                border: none;
                background: white;
                border-radius: 2px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1em;
                color: #6b7280;
                transition: all 0.15s ease;
            }

            .cut-type.active {
                background: #2563eb;
                color: white;
            }

            .cut-type:hover:not(.active) {
                background: #e5e7eb;
            }

            .cut-thickness {
                padding: 4px 6px;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                font-size: 0.8em;
                background: white;
                color: #374151;
                cursor: pointer;
            }

            .cut-thickness:focus {
                outline: none;
                border-color: #2563eb;
            }

            /* Size Controls */
            .size-controls {
                display: flex;
                gap: 8px;
            }

            .paper-size, .photo-size {
                padding: 6px 8px;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                font-size: 0.85em;
                background: white;
                color: #374151;
                cursor: pointer;
                min-width: 120px;
                transition: border-color 0.15s ease;
            }

            .paper-size:focus, .photo-size:focus {
                outline: none;
                border-color: #2563eb;
            }

            /* ================================
               ELITE PREVIEW INTERFACE DESIGN
               ================================ */

            .print-preview-elite {
                margin: 0;
                background: linear-gradient(145deg, #ffffff, #f8fafc);
                border: 2px solid #e2e8f0;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
                overflow: hidden;
                transition: all 0.3s ease;
                flex: 1;
                display: flex;
                flex-direction: column;
            }

            .print-preview-elite:hover {
                box-shadow:
                    0 10px 15px -3px rgba(0, 0, 0, 0.08),
                    0 4px 6px -2px rgba(0, 0, 0, 0.05);
            }

            /* Elite Header Design */
            .preview-header-elite {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px 24px;
                background: linear-gradient(135deg, #fafbfc 0%, #f1f5f9 100%);
                border-bottom: 1px solid #e2e8f0;
                position: relative;
            }

            .preview-header-elite::before {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 1px;
                background: linear-gradient(90deg, transparent, #3b82f6, transparent);
                opacity: 0.3;
            }

            .header-identity {
                display: flex;
                align-items: center;
                gap: 16px;
            }

            .preview-brand {
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .brand-icon {
                width: 36px;
                height: 36px;
                background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                color: white;
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 18px;
                font-weight: bold;
                box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
            }

            .brand-text {
                display: flex;
                flex-direction: column;
                gap: 4px;
            }

            .preview-title {
                font-size: 16px;
                font-weight: 700;
                color: #1e293b;
                margin: 0;
                letter-spacing: -0.025em;
            }

            .status-indicator {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .status-dot {
                width: 8px;
                height: 8px;
                background: #10b981;
                border-radius: 50%;
                animation: pulse-elite 2s infinite;
            }

            @keyframes pulse-elite {
                0%, 100% { opacity: 1; transform: scale(1); }
                50% { opacity: 0.7; transform: scale(0.95); }
            }

            .status-text {
                font-size: 13px;
                color: #059669;
                font-weight: 500;
            }

            /* Elite Metrics */
            .header-metrics {
                display: flex;
                gap: 20px;
                align-items: center;
            }

            .metric-card {
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 8px 12px;
                background: rgba(255, 255, 255, 0.7);
                border: 1px solid rgba(59, 130, 246, 0.1);
                border-radius: 8px;
                backdrop-filter: blur(10px);
                transition: all 0.2s ease;
            }

            .metric-card:hover {
                background: rgba(255, 255, 255, 0.9);
                border-color: rgba(59, 130, 246, 0.2);
                transform: translateY(-1px);
            }

            .metric-value {
                font-size: 16px;
                font-weight: 700;
                color: #1e293b;
                line-height: 1;
            }

            .metric-label {
                font-size: 11px;
                color: #64748b;
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                margin-top: 2px;
            }

            /* SK316 Metric Card */
            .metric-card.sk316-metric {
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .metric-card.sk316-metric.active {
                background: linear-gradient(135deg, rgba(34, 197, 94, 0.1) 0%, rgba(22, 163, 74, 0.15) 100%);
                border-color: rgba(34, 197, 94, 0.3);
            }

            .metric-card.sk316-metric.active:hover {
                background: linear-gradient(135deg, rgba(34, 197, 94, 0.15) 0%, rgba(22, 163, 74, 0.2) 100%);
                border-color: rgba(34, 197, 94, 0.4);
            }

            .metric-card.sk316-metric.inactive {
                background: rgba(255, 255, 255, 0.5);
                border-color: rgba(148, 163, 184, 0.2);
            }

            .metric-icon {
                font-size: 18px;
                line-height: 1;
                margin-bottom: 2px;
            }

            .metric-card.sk316-metric.active .metric-icon {
                color: #22c55e;
            }

            .metric-card.sk316-metric.inactive .metric-icon {
                color: #94a3b8;
            }

            .metric-card.sk316-metric.active .metric-value {
                color: #16a34a;
            }

            .metric-card.sk316-metric.inactive .metric-value {
                color: #64748b;
            }

            .metric-card.sk316-metric.active .metric-label {
                color: #22c55e;
            }

            .metric-card.sk316-metric.inactive .metric-label {
                color: #94a3b8;
            }

            /* Elite Actions */
            .header-actions-elite {
                display: flex;
                gap: 8px;
                align-items: center;
            }

            .action-elite {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 10px 16px;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s ease;
                position: relative;
                overflow: hidden;
            }

            .action-elite.secondary {
                background: rgba(148, 163, 184, 0.1);
                color: #475569;
                border: 1px solid rgba(148, 163, 184, 0.2);
            }

            .action-elite.secondary:hover {
                background: rgba(148, 163, 184, 0.15);
                border-color: rgba(148, 163, 184, 0.3);
                transform: translateY(-1px);
            }

            .action-elite.primary {
                background: linear-gradient(135deg, #3b82f6, #2563eb);
                color: white;
                border: 1px solid transparent;
                box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
            }

            .action-elite.primary:hover {
                background: linear-gradient(135deg, #2563eb, #1d4ed8);
                transform: translateY(-1px);
                box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
            }

            .action-icon {
                font-size: 16px;
            }

            .action-label {
                font-weight: 500;
            }

            /* Elite Controls */
            .preview-controls-elite {
                padding: 16px 24px;
                background: #fafbfc;
                border-bottom: 1px solid #e2e8f0;
            }

            .control-strip {
                display: flex;
                gap: 24px;
                align-items: flex-start;
                margin-bottom: 12px;
            }

            .control-strip:last-child {
                margin-bottom: 0;
            }

            .control-section {
                display: flex;
                flex-direction: column;
                gap: 8px;
                min-width: 0;
            }

            .section-label {
                font-size: 11px;
                font-weight: 600;
                color: #64748b;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                margin-bottom: 4px;
            }

            /* Navigation Controls */
            .nav-section {
                flex: 0 0 auto;
            }

            .nav-controls {
                display: flex;
                align-items: center;
                gap: 4px;
                background: white;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                padding: 2px;
            }

            .nav-btn-elite {
                width: 28px;
                height: 28px;
                border: none;
                background: transparent;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 16px;
                color: #64748b;
                transition: all 0.15s ease;
            }

            .nav-btn-elite:not(:disabled):hover {
                background: #f1f5f9;
                color: #334155;
            }

            .nav-btn-elite:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }

            .page-display {
                padding: 0 12px;
                font-size: 13px;
                font-weight: 600;
                color: #334155;
                min-width: 40px;
                text-align: center;
            }

            .duplex-toggle-elite {
                display: flex;
                gap: 2px;
                background: white;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                padding: 2px;
                margin-top: 4px;
            }

            .duplex-btn-elite {
                padding: 6px 12px;
                border: none;
                background: transparent;
                border-radius: 4px;
                font-size: 12px;
                font-weight: 500;
                cursor: pointer;
                color: #64748b;
                transition: all 0.15s ease;
            }

            .duplex-btn-elite.active {
                background: #3b82f6;
                color: white;
            }

            /* Zoom Controls */
            .zoom-section {
                flex: 0 0 auto;
            }

            .zoom-controls-elite {
                display: flex;
                gap: 2px;
                background: white;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                padding: 2px;
            }

            .zoom-btn-elite {
                padding: 6px 10px;
                border: none;
                background: transparent;
                border-radius: 4px;
                font-size: 12px;
                font-weight: 600;
                cursor: pointer;
                color: #64748b;
                transition: all 0.15s ease;
                min-width: 36px;
            }

            .zoom-btn-elite.active {
                background: #3b82f6;
                color: white;
            }

            .zoom-btn-elite.fit {
                background: linear-gradient(135deg, #10b981, #059669);
                color: white;
                font-weight: 700;
            }

            .zoom-btn-elite:not(.active):not(.fit):hover {
                background: #f1f5f9;
                color: #334155;
            }

            /* Orientation Controls */
            .orientation-section {
                flex: 0 0 auto;
            }

            .orientation-controls-elite {
                display: flex;
                gap: 2px;
                background: white;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                padding: 2px;
            }

            .orient-btn-elite {
                width: 32px;
                height: 32px;
                border: none;
                background: transparent;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 14px;
                color: #64748b;
                transition: all 0.15s ease;
            }

            .orient-btn-elite.active {
                background: #3b82f6;
                color: white;
            }

            .orient-btn-elite:not(.active):hover {
                background: #f1f5f9;
                color: #334155;
            }

            /* Duplex Offset Controls */
            .duplex-offset-section {
                min-width: 280px;
            }

            .offset-controls-elite {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .offset-input-group {
                display: flex;
                align-items: center;
                gap: 4px;
                background: white;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                padding: 4px 8px;
            }

            .offset-input-group label {
                font-size: 11px;
                font-weight: 600;
                color: #64748b;
                min-width: 12px;
            }

            .offset-input {
                width: 70px;
                min-width: 70px;
                border: none;
                outline: none;
                font-size: 12px;
                font-weight: 500;
                text-align: center;
                padding: 2px;
            }

            .offset-unit {
                font-size: 10px;
                color: #94a3b8;
                font-weight: 500;
            }

            .calibration-btn-elite {
                padding: 6px 10px;
                border: 1px solid #3b82f6;
                background: white;
                color: #3b82f6;
                border-radius: 6px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.15s ease;
                white-space: nowrap;
            }

            .calibration-btn-elite:hover {
                background: #3b82f6;
                color: white;
            }

            /* Cutting Controls */
            .cutting-section {
                flex: 1;
                min-width: 200px;
            }

            .cutting-controls-elite {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .cut-toggle-elite {
                padding: 6px 12px;
                border: 1px solid #e2e8f0;
                background: white;
                border-radius: 6px;
                font-size: 12px;
                font-weight: 600;
                cursor: pointer;
                color: #64748b;
                transition: all 0.15s ease;
            }

            .cut-toggle-elite.active {
                background: #10b981;
                color: white;
                border-color: #059669;
            }

            .cut-types-elite {
                display: flex;
                gap: 2px;
                background: white;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                padding: 2px;
            }

            .cut-type-elite {
                width: 28px;
                height: 28px;
                border: none;
                background: transparent;
                border-radius: 4px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 12px;
                color: #64748b;
                transition: all 0.15s ease;
            }

            .cut-type-elite.active {
                background: #3b82f6;
                color: white;
            }

            .cut-type-elite:not(.active):hover {
                background: #f1f5f9;
                color: #334155;
            }

            .cut-thickness-elite {
                padding: 6px 8px;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                font-size: 12px;
                background: white;
                color: #334155;
                cursor: pointer;
                min-width: 70px;
            }

            .cut-thickness-elite:focus {
                outline: none;
                border-color: #3b82f6;
            }

            /* Size Controls */
            .size-section {
                flex: 1;
                min-width: 180px;
            }

            .size-controls-elite {
                display: flex;
                gap: 8px;
            }

            .paper-size-elite, .photo-size-elite {
                flex: 1;
                padding: 6px 8px;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                font-size: 12px;
                background: white;
                color: #334155;
                cursor: pointer;
                transition: border-color 0.15s ease;
            }

            .paper-size-elite:focus, .photo-size-elite:focus {
                outline: none;
                border-color: #3b82f6;
            }

            .custom-size-inputs {
                margin-top: 8px;
                padding: 8px;
                background: #f8fafc;
                border-radius: 6px;
                border: 1px solid #e2e8f0;
            }

            .custom-input-row {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .custom-input-row input[type="number"] {
                flex: 1;
                padding: 4px 6px;
                border: 1px solid #cbd5e1;
                border-radius: 4px;
                font-size: 11px;
                text-align: center;
                width: 70px;
                min-width: 70px;
            }

            .custom-input-row input[type="number"]:focus {
                outline: none;
                border-color: #3b82f6;
            }

            .custom-input-row span {
                font-size: 12px;
                color: #64748b;
                font-weight: 500;
            }

            .custom-input-row .unit {
                font-size: 11px;
                color: #94a3b8;
            }

            /* Responsive Design */
            @media (max-width: 1024px) {
                .control-strip {
                    flex-wrap: wrap;
                    gap: 16px;
                }

                .header-metrics {
                    gap: 12px;
                }

                .metric-card {
                    padding: 6px 8px;
                }
            }

            @media (max-width: 768px) {
                .preview-header-elite {
                    flex-direction: column;
                    gap: 16px;
                    align-items: stretch;
                }

                .header-identity, .header-metrics, .header-actions-elite {
                    justify-content: center;
                }

                .control-strip {
                    flex-direction: column;
                    gap: 12px;
                }

                .control-section {
                    align-items: center;
                }
            }

            .page-nav {
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .nav-btn {
                width: 32px;
                height: 32px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .nav-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }
            
            .duplex-toggle {
                display: flex;
                gap: 4px;
            }
            
            .duplex-btn {
                padding: 6px 12px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.8em;
            }
            
            .duplex-btn.active {
                background: #3b82f6;
                color: white;
                border-color: #3b82f6;
            }
            
            .view-tools {
                display: flex;
                gap: 4px;
            }
            
            .tool-btn {
                width: 32px;
                height: 32px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.9em;
            }
            
            .tool-btn.active {
                background: #3b82f6;
                color: white;
                border-color: #3b82f6;
            }
            
            /* Export Compact */
            .export-section-compact {
                margin: 0;
                padding: 16px;
                background: white;
                border-radius: 12px;
                border: 2px solid #e2e8f0;
            }
            
            .export-options-compact {
                display: flex;
                flex-direction: column;
                gap: 16px;
                align-items: center;
            }
            
            .export-format-tabs {
                display: flex;
                gap: 8px;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                overflow: hidden;
            }
            
            .format-tab {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
                padding: 12px 16px;
                background: white;
                border: none;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 0.85em;
            }
            
            .format-tab.active {
                background: #3b82f6;
                color: white;
            }
            
            .export-btn {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 16px 32px;
                background: #10b981;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 600;
                font-size: 1.1em;
                transition: all 0.2s ease;
            }
            
            .export-btn:hover {
                background: #059669;
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
            }
            
            .export-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none;
            }
            
            /* Images Compact */
            .selected-images-compact {
                margin: 16px 0;
                border: 1px solid #e2e8f0;
                border-radius: 8px;
                overflow: hidden;
                background: white;
            }
            
            .selected-images-compact .images-header-compact {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                background: #f8fafc;
                border-bottom: 1px solid #e2e8f0;
            }
            
            .selected-images-compact .header-actions {
                display: flex;
                gap: 8px;
            }
            
            .selected-images-compact .action-btn {
                width: 32px;
                height: 32px;
                border: 2px solid #d1d5db;
                background: #f1f5f9;
                border-radius: 4px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1em;
                transition: all 0.2s ease;
            }
            
            .selected-images-compact .action-btn:hover {
                background: #e2e8f0;
                border-color: #3b82f6;
                transform: translateY(-1px);
            }
            
            /* Optimized Images Grid */
            .images-grid-compact {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 8px;
                padding: 16px;
                max-height: 300px;
                overflow-y: auto;
            }
            
            .images-grid-compact .image-item {
                position: relative;
                aspect-ratio: 1;
                border-radius: 6px;
                overflow: hidden;
                border: 1px solid #e5e7eb;
                cursor: pointer;
                transition: all 0.2s ease;
                background: #f9fafb;
            }
            
            .images-grid-compact .image-item:hover {
                border-color: #3b82f6;
                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
                transform: translateY(-1px);
            }
            
            .images-grid-compact .image-item img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                display: block;
            }
            
            .images-grid-compact .image-item .remove-btn {
                position: absolute;
                top: 4px;
                right: 4px;
                width: 20px;
                height: 20px;
                background: rgba(239, 68, 68, 0.9);
                color: white;
                border: none;
                border-radius: 50%;
                font-size: 12px;
                line-height: 1;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 0;
                transition: opacity 0.2s ease;
            }
            
            .images-grid-compact .image-item:hover .remove-btn {
                opacity: 1;
            }
            
            .images-grid-compact .image-item .remove-btn:hover {
                background: #dc2626;
            }
            
            .images-grid-compact .image-item .image-info {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
                color: white;
                font-size: 10px;
                padding: 4px;
                opacity: 0;
                transition: opacity 0.2s ease;
            }
            
            .images-grid-compact .image-item:hover .image-info {
                opacity: 1;
            }

            /* Image Distribution - Minimal & Professional */
            .image-distribution {
                margin: 16px 0;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
                background: white;
            }

            .dist-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                border-bottom: 1px solid #f3f4f6;
                background: #fafafa;
            }

            .dist-title {
                font-weight: 600;
                color: #374151;
                font-size: 0.95em;
            }

            .dist-info {
                font-size: 0.85em;
                color: #6b7280;
            }

            .dist-options {
                display: flex;
                gap: 1px;
                background: #f3f4f6;
                padding: 1px;
                margin: 16px;
                border-radius: 4px;
            }

            .dist-btn {
                flex: 1;
                padding: 10px 16px;
                border: none;
                background: white;
                color: #374151;
                font-size: 0.9em;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.15s ease;
                border-radius: 3px;
            }

            .dist-btn:hover {
                background: #f8fafc;
                color: #1f2937;
            }

            .dist-btn.active {
                background: #2563eb;
                color: white;
            }

            .dist-custom {
                border-top: 1px solid #f3f4f6;
                background: #fafafa;
            }

            .custom-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 12px 16px;
                border-bottom: 1px solid #e5e7eb;
            }

            .custom-header span {
                font-weight: 500;
                color: #374151;
                font-size: 0.9em;
            }

            .apply-all {
                padding: 6px 12px;
                background: #2563eb;
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 0.85em;
                font-weight: 500;
                cursor: pointer;
                transition: background 0.15s ease;
            }

            .apply-all:hover {
                background: #1d4ed8;
            }

            .custom-grid {
                padding: 16px;
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 14px;
                max-height: 500px;
                overflow-y: auto;
            }

            /* Responsive grid */
            @media (max-width: 768px) {
                .custom-grid {
                    grid-template-columns: 1fr;
                    max-height: 400px;
                }
            }

            @media (min-width: 1400px) {
                .custom-grid {
                    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
                }
            }

            /* ========================================
               DUPLEX DISTRIBUTION STYLES
               ======================================== */
            .duplex-distribution {
                margin: 16px 0;
                border: 2px solid #e0e7ff;
                border-radius: 8px;
                background: linear-gradient(135deg, #fafbff 0%, #f3f4ff 100%);
                box-shadow: 0 2px 8px rgba(99, 102, 241, 0.08);
            }

            .duplex-dist-header {
                padding: 16px 20px;
                border-bottom: 2px solid #e0e7ff;
                background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                border-radius: 6px 6px 0 0;
            }

            .duplex-dist-title {
                display: block;
                font-size: 1.05em;
                font-weight: 700;
                color: white;
                margin-bottom: 4px;
            }

            .duplex-dist-subtitle {
                display: block;
                font-size: 0.85em;
                color: #e0e7ff;
                font-weight: 400;
            }

            /* Side Distribution */
            .duplex-side-dist {
                margin: 16px;
                padding: 16px;
                border: 1.5px solid #e5e7eb;
                border-radius: 8px;
                background: white;
                transition: all 0.2s ease;
            }

            .duplex-side-dist:hover {
                border-color: #6366f1;
                box-shadow: 0 4px 12px rgba(99, 102, 241, 0.12);
            }

            .front-dist {
                border-left: 4px solid #10b981;
            }

            .back-dist {
                border-left: 4px solid #f59e0b;
            }

            .side-dist-header {
                display: flex;
                align-items: center;
                gap: 12px;
                margin-bottom: 14px;
                padding-bottom: 12px;
                border-bottom: 1px solid #f3f4f6;
            }

            .side-icon {
                font-size: 1.4em;
            }

            .side-title {
                font-size: 1em;
                font-weight: 600;
                color: #1f2937;
                flex-shrink: 0;
            }

            .side-stats {
                font-size: 0.85em;
                color: #6b7280;
                margin-left: auto;
            }

            .side-stats span {
                font-weight: 500;
            }

            /* Distribution Action Buttons */
            .side-dist-actions {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }

            .duplex-dist-btn {
                flex: 1;
                min-width: 120px;
                padding: 10px 14px;
                border: 1.5px solid #e5e7eb;
                border-radius: 6px;
                background: white;
                color: #374151;
                font-size: 0.9em;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
            }

            .duplex-dist-btn .btn-icon {
                font-size: 1.1em;
            }

            .duplex-dist-btn.fill-btn:hover {
                background: #dbeafe;
                border-color: #3b82f6;
                color: #1e40af;
                transform: translateY(-1px);
            }

            .duplex-dist-btn.distribute-btn:hover {
                background: #dcfce7;
                border-color: #10b981;
                color: #065f46;
                transform: translateY(-1px);
            }

            .duplex-dist-btn.clear-btn:hover {
                background: #fee2e2;
                border-color: #ef4444;
                color: #991b1b;
                transform: translateY(-1px);
            }

            .duplex-dist-btn.custom-btn:hover {
                background: #f3e8ff;
                border-color: #a855f7;
                color: #6b21a8;
                transform: translateY(-1px);
            }

            .duplex-dist-btn.custom-btn.active {
                background: #e9d5ff;
                border-color: #9333ea;
                color: #581c87;
                font-weight: 600;
            }

            /* Quick Actions */
            .duplex-dist-quick-actions {
                margin: 0 16px 16px;
                padding: 16px;
                border-radius: 8px;
                background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
                border: 1.5px solid #fbbf24;
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
            }

            .duplex-quick-btn {
                flex: 1;
                min-width: 200px;
                padding: 12px 18px;
                border: none;
                border-radius: 6px;
                background: white;
                color: #92400e;
                font-size: 0.92em;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            }

            .duplex-quick-btn:hover {
                background: #fffbeb;
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.12);
            }

            .duplex-quick-btn .btn-icon {
                font-size: 1.3em;
            }

            .duplex-quick-btn.copy-btn {
                background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
                color: #075985;
                border: 1.5px solid #0ea5e9;
            }

            .duplex-quick-btn.copy-btn:hover {
                background: linear-gradient(135deg, #7dd3fc 0%, #38bdf8 100%);
                color: #0c4a6e;
            }

            /* Custom Distribution Sections */
            .duplex-custom-dist {
                margin-top: 12px;
                padding: 14px;
                background: linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%);
                border: 1.5px solid #d8b4fe;
                border-radius: 6px;
                animation: slideDown 0.3s ease;
            }

            @keyframes slideDown {
                from {
                    opacity: 0;
                    max-height: 0;
                    padding-top: 0;
                    padding-bottom: 0;
                }
                to {
                    opacity: 1;
                    max-height: 1000px;
                    padding-top: 14px;
                    padding-bottom: 14px;
                }
            }

            .custom-dist-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 12px;
                margin-bottom: 14px;
                padding-bottom: 10px;
                border-bottom: 1.5px solid #e9d5ff;
                flex-wrap: wrap;
            }

            .custom-dist-title {
                font-size: 0.95em;
                font-weight: 600;
                color: #6b21a8;
            }

            .custom-dist-controls {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .apply-all-input {
                width: 80px;
                padding: 6px 10px;
                border: 1.5px solid #c084fc;
                border-radius: 4px;
                font-size: 0.9em;
                text-align: center;
                transition: all 0.2s ease;
            }

            .apply-all-input:focus {
                outline: none;
                border-color: #9333ea;
                box-shadow: 0 0 0 3px rgba(147, 51, 234, 0.1);
            }

            .apply-all-btn {
                padding: 6px 14px;
                background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%);
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 0.88em;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
                white-space: nowrap;
            }

            .apply-all-btn:hover {
                background: linear-gradient(135deg, #9333ea 0%, #7e22ce 100%);
                transform: translateY(-1px);
                box-shadow: 0 4px 8px rgba(147, 51, 234, 0.3);
            }

            .apply-all-btn:active {
                transform: translateY(0);
            }

            /* Custom Distribution Grid */
            .custom-dist-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 12px;
                max-height: 500px;
                overflow-y: auto;
                padding: 4px;
            }

            .custom-dist-grid::-webkit-scrollbar {
                width: 8px;
            }

            .custom-dist-grid::-webkit-scrollbar-track {
                background: #f3e8ff;
                border-radius: 4px;
            }

            .custom-dist-grid::-webkit-scrollbar-thumb {
                background: #c084fc;
                border-radius: 4px;
            }

            .custom-dist-grid::-webkit-scrollbar-thumb:hover {
                background: #a855f7;
            }

            .dist-grid-item {
                background: white;
                border: 1.5px solid #e9d5ff;
                border-radius: 6px;
                padding: 12px;
                transition: all 0.2s ease;
            }

            .dist-grid-item:hover {
                border-color: #c084fc;
                box-shadow: 0 4px 12px rgba(168, 85, 247, 0.15);
                transform: translateY(-2px);
            }

            .dist-item-header {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 10px;
            }

            .dist-item-thumb {
                width: 50px;
                height: 50px;
                object-fit: cover;
                border-radius: 4px;
                border: 1.5px solid #e5e7eb;
                flex-shrink: 0;
            }

            .dist-item-info {
                flex: 1;
                min-width: 0;
            }

            .dist-item-name {
                font-size: 0.88em;
                font-weight: 600;
                color: #1f2937;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                margin-bottom: 3px;
            }

            .dist-item-meta {
                font-size: 0.78em;
                color: #6b7280;
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .dist-quantity-badge {
                display: inline-flex;
                align-items: center;
                padding: 2px 6px;
                background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%);
                color: white;
                border-radius: 10px;
                font-size: 0.75em;
                font-weight: 600;
            }

            .dist-item-controls {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .dist-quantity-label {
                font-size: 0.85em;
                color: #6b7280;
                font-weight: 500;
            }

            .dist-quantity-input {
                width: 70px;
                padding: 6px 8px;
                border: 1.5px solid #d1d5db;
                border-radius: 4px;
                font-size: 0.88em;
                text-align: center;
                transition: all 0.2s ease;
            }

            .dist-quantity-input:focus {
                outline: none;
                border-color: #a855f7;
                box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.1);
            }

            .dist-apply-btn {
                padding: 6px 12px;
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 0.85em;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .dist-apply-btn:hover {
                background: linear-gradient(135deg, #059669 0%, #047857 100%);
                transform: translateY(-1px);
                box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);
            }

            .dist-apply-btn:active {
                transform: translateY(0);
            }

            /* Responsive */
            @media (max-width: 768px) {
                .side-dist-actions {
                    flex-direction: column;
                }

                .duplex-dist-btn {
                    min-width: unset;
                    width: 100%;
                }

                .duplex-dist-quick-actions {
                    flex-direction: column;
                }

                .duplex-quick-btn {
                    min-width: unset;
                    width: 100%;
                }

                .custom-dist-header {
                    flex-direction: column;
                    align-items: flex-start;
                }

                .custom-dist-controls {
                    width: 100%;
                }

                .apply-all-input {
                    flex: 1;
                }

                .apply-all-btn {
                    flex: 1;
                }

                .custom-dist-grid {
                    grid-template-columns: 1fr;
                }

                .dist-item-controls {
                    flex-wrap: wrap;
                }

                .dist-quantity-input {
                    flex: 1;
                    min-width: 60px;
                }

                .dist-apply-btn {
                    flex: 1;
                }
            }

            @media (max-width: 480px) {
                .side-stats {
                    font-size: 0.75em;
                }

                .duplex-dist-btn {
                    font-size: 0.85em;
                    padding: 8px 10px;
                }

                .duplex-quick-btn {
                    font-size: 0.85em;
                }

                .dist-item-header {
                    flex-direction: column;
                    align-items: flex-start;
                }

                .dist-item-thumb {
                    width: 100%;
                    height: auto;
                    aspect-ratio: 16/9;
                }
            }

            /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
            /* UNIFIED DUPLEX WORKSPACE CSS */
            /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

            .duplex-unified-workspace {
                margin: 16px 0;
                background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                border-radius: 12px;
                overflow: hidden;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            }

            /* Global Stats Bar */
            .duplex-global-stats {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 16px 24px;
                background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
                border-bottom: 2px solid #1e3a8a;
            }

            .stats-left {
                display: flex;
                align-items: center;
                gap: 12px;
                flex-wrap: wrap;
            }

            .stat-item {
                display: flex;
                align-items: center;
                gap: 6px;
                color: white;
                font-size: 0.95em;
            }

            .stat-icon {
                font-size: 1.2em;
            }

            .stat-value {
                font-weight: 700;
                font-size: 1.1em;
            }

            .stat-label {
                font-weight: 400;
                opacity: 0.9;
            }

            .stat-separator {
                color: rgba(255, 255, 255, 0.5);
                font-weight: 300;
            }

            .stats-collapse-btn {
                padding: 8px 12px;
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 255, 255, 0.3);
                border-radius: 6px;
                color: white;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .stats-collapse-btn:hover {
                background: rgba(255, 255, 255, 0.25);
            }

            /* 3-Column Grid Layout */
            .duplex-three-columns {
                display: grid;
                grid-template-columns: 300px 1fr 400px;
                gap: 0;
                min-height: 600px;
            }

            /* Column General Styles */
            .duplex-col {
                background: white;
                border-right: 1px solid #e5e7eb;
                display: flex;
                flex-direction: column;
            }

            .duplex-col:last-child {
                border-right: none;
            }

            .col-header {
                padding: 14px 18px;
                background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
                border-bottom: 2px solid #cbd5e1;
                cursor: pointer;
                user-select: none;
                display: flex;
                align-items: center;
                justify-content: space-between;
                transition: all 0.2s ease;
            }

            .col-header:hover {
                background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
            }

            .col-title {
                display: flex;
                align-items: center;
                gap: 10px;
                font-weight: 600;
                color: #1e293b;
                font-size: 0.95em;
            }

            .col-number {
                font-size: 1.2em;
            }

            .col-name {
                letter-spacing: 0.5px;
            }

            .col-toggle {
                font-size: 0.9em;
                color: #64748b;
                transition: transform 0.3s ease;
            }

            .col-header.collapsed .col-toggle {
                transform: rotate(-90deg);
            }

            .col-content {
                flex: 1;
                overflow-y: auto;
                padding: 16px;
            }

            .col-content.collapsed {
                display: none;
            }

            /* Column 1: Setup & Upload */
            .duplex-col-setup {
                background: linear-gradient(135deg, #fefce8 0%, #fef3c7 100%);
            }

            .unified-upload-zone {
                margin-bottom: 16px;
                padding: 32px 20px;
                border: 2px dashed #fbbf24;
                border-radius: 8px;
                background: white;
                text-align: center;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .unified-upload-zone:hover {
                border-color: #f59e0b;
                background: #fffbeb;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(251, 191, 36, 0.2);
            }

            .upload-icon-large {
                font-size: 3.5em;
                margin-bottom: 12px;
                animation: float 3s ease-in-out infinite;
            }

            @keyframes float {
                0%, 100% { transform: translateY(0); }
                50% { transform: translateY(-10px); }
            }

            .upload-text-primary {
                font-size: 1.1em;
                font-weight: 600;
                color: #92400e;
                margin-bottom: 4px;
            }

            .upload-text-secondary {
                font-size: 0.9em;
                color: #b45309;
            }

            .upload-count {
                margin-top: 12px;
            }

            .count-badge {
                display: inline-block;
                padding: 6px 14px;
                background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
                color: white;
                border-radius: 20px;
                font-size: 0.9em;
                font-weight: 600;
            }

            /* Quick Presets */
            .quick-presets-section {
                margin-bottom: 16px;
            }

            .section-label {
                font-size: 0.9em;
                font-weight: 600;
                color: #78350f;
                margin-bottom: 10px;
                display: block;
            }

            .presets-grid {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .preset-btn {
                padding: 12px 8px;
                background: white;
                border: 1.5px solid #fbbf24;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 6px;
            }

            .preset-btn:hover {
                background: #fffbeb;
                border-color: #f59e0b;
                transform: translateY(-2px);
                box-shadow: 0 4px 10px rgba(251, 191, 36, 0.25);
            }

            .preset-icon {
                font-size: 1.5em;
            }

            .preset-name {
                font-weight: 700;
                color: #92400e;
                font-size: 1em;
            }

            .preset-desc {
                font-size: 0.75em;
                color: #b45309;
                text-align: center;
            }

            /* Global Actions */
            .global-actions-section {
                /* Inherits section styles */
            }

            .actions-list {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .action-btn {
                padding: 10px 14px;
                background: white;
                border: 1.5px solid #cbd5e1;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 10px;
                font-weight: 500;
                color: #334155;
            }

            .action-btn:hover:not(:disabled) {
                background: #f1f5f9;
                border-color: #94a3b8;
                transform: translateX(4px);
            }

            .action-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .action-icon {
                font-size: 1.3em;
            }

            .action-text {
                font-size: 0.9em;
            }

            .action-row {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }

            .action-auto:hover {
                background: #dbeafe;
                border-color: #3b82f6;
                color: #1e40af;
            }

            .action-swap:hover {
                background: #fef3c7;
                border-color: #fbbf24;
                color: #92400e;
            }

            .action-balance:hover {
                background: #dcfce7;
                border-color: #10b981;
                color: #065f46;
            }

            .action-clear:hover {
                background: #fee2e2;
                border-color: #ef4444;
                color: #991b1b;
            }

            .action-undo:hover, .action-redo:hover {
                background: #f3e8ff;
                border-color: #a855f7;
                color: #6b21a8;
            }

            /* Column 2: Classification */
            .duplex-col-classification {
                background: #ffffff;
            }

            .gallery-section {
                margin-bottom: 16px;
            }

            .gallery-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 12px;
                flex-wrap: wrap;
                gap: 10px;
            }

            .gallery-title {
                font-size: 1em;
                font-weight: 600;
                color: #1e293b;
            }

            .gallery-mode-switch {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mode-label {
                font-size: 0.85em;
                color: #64748b;
            }

            .mode-btn {
                padding: 6px 12px;
                background: white;
                border: 1.5px solid #e5e7eb;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 0.85em;
            }

            .mode-btn:hover {
                border-color: #cbd5e1;
                background: #f8fafc;
            }

            .mode-btn.active.mode-front {
                background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
                border-color: #3b82f6;
                color: #1e40af;
                font-weight: 600;
            }

            .mode-btn.active.mode-back {
                background: linear-gradient(135deg, #fed7aa 0%, #fdba74 100%);
                border-color: #f59e0b;
                color: #92400e;
                font-weight: 600;
            }

            .gallery-grid-unified {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 10px;
                max-height: 300px;
                overflow-y: auto;
                padding: 12px;
                background: #f8fafc;
                border: 1px solid #e5e7eb;
                border-radius: 6px;
            }

            .gallery-empty {
                grid-column: 1 / -1;
                text-align: center;
                padding: 40px 20px;
                color: #94a3b8;
                font-size: 0.9em;
            }

            /* Classification Section */
            .classification-section {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .classified-list {
                border: 1.5px solid #e5e7eb;
                border-radius: 8px;
                background: white;
            }

            .front-list {
                border-left: 4px solid #3b82f6;
            }

            .back-list {
                border-left: 4px solid #f59e0b;
            }

            .list-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 10px 14px;
                background: #f8fafc;
                border-bottom: 1px solid #e5e7eb;
            }

            .list-title {
                display: flex;
                align-items: center;
                gap: 8px;
                font-weight: 600;
                color: #1e293b;
                font-size: 0.9em;
            }

            .list-icon {
                font-size: 1.2em;
            }

            .list-count {
                font-weight: 400;
                color: #64748b;
            }

            .list-clear-btn {
                padding: 4px 8px;
                background: transparent;
                border: none;
                cursor: pointer;
                font-size: 1.2em;
                opacity: 0.6;
                transition: all 0.2s ease;
            }

            .list-clear-btn:hover {
                opacity: 1;
                transform: scale(1.1);
            }

            .list-images {
                min-height: 100px;
                padding: 12px;
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 8px;
            }

            .list-empty {
                grid-column: 1 / -1;
                text-align: center;
                padding: 30px 20px;
                color: #cbd5e1;
                font-size: 0.85em;
            }

            .list-actions {
                padding: 10px 14px;
                border-top: 1px solid #e5e7eb;
                background: #fafafa;
            }

            .list-action-btn {
                width: 100%;
                padding: 8px 12px;
                background: white;
                border: 1.5px solid #e5e7eb;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                font-size: 0.88em;
                font-weight: 500;
            }

            .list-action-btn:hover {
                background: #f3e8ff;
                border-color: #a855f7;
                color: #6b21a8;
            }

            /* Column 3: Preview & Export */
            .duplex-col-preview {
                background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            }

            .preview-placeholder {
                margin-bottom: 16px;
                min-height: 400px;
                background: white;
                border-radius: 8px;
                padding: 8px;
            }

            /* Distribution Unified */
            .distribution-unified {
                margin-bottom: 16px;
                padding: 14px;
                background: white;
                border-radius: 8px;
                border: 1.5px solid #d1fae5;
            }

            .dist-header-unified {
                margin-bottom: 12px;
                padding-bottom: 10px;
                border-bottom: 1.5px solid #a7f3d0;
            }

            .dist-title {
                font-weight: 600;
                color: #065f46;
                font-size: 0.95em;
            }

            .dist-side {
                margin-bottom: 14px;
                padding: 12px;
                background: #f8fafc;
                border-radius: 6px;
            }

            .front-dist-unified {
                border-left: 3px solid #3b82f6;
            }

            .back-dist-unified {
                border-left: 3px solid #f59e0b;
            }

            .dist-side-header {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 10px;
                font-weight: 600;
                color: #1e293b;
                font-size: 0.9em;
            }

            .dist-side-icon {
                font-size: 1.2em;
            }

            .dist-progress {
                margin-bottom: 10px;
            }

            .progress-info {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 6px;
                font-size: 0.85em;
            }

            .progress-text {
                color: #475569;
            }

            .progress-percent {
                font-weight: 600;
                color: #1e293b;
            }

            .progress-bar {
                height: 8px;
                background: #e2e8f0;
                border-radius: 10px;
                overflow: hidden;
            }

            .progress-fill {
                height: 100%;
                border-radius: 10px;
                transition: width 0.4s ease;
            }

            .front-fill {
                background: linear-gradient(90deg, #3b82f6 0%, #2563eb 100%);
            }

            .back-fill {
                background: linear-gradient(90deg, #f59e0b 0%, #d97706 100%);
            }

            .dist-side-actions {
                display: flex;
                gap: 6px;
            }

            .dist-btn {
                flex: 1;
                padding: 8px 10px;
                background: white;
                border: 1.5px solid #cbd5e1;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
                font-size: 0.8em;
            }

            .dist-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }

            .dist-fill:hover {
                background: #dbeafe;
                border-color: #3b82f6;
                color: #1e40af;
            }

            .dist-distribute:hover {
                background: #dcfce7;
                border-color: #10b981;
                color: #065f46;
            }

            .dist-custom:hover {
                background: #f3e8ff;
                border-color: #a855f7;
                color: #6b21a8;
            }

            .dist-quick-actions-unified {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
                margin-top: 12px;
                padding-top: 12px;
                border-top: 1.5px solid #e5e7eb;
            }

            .dist-quick-btn {
                padding: 10px 12px;
                background: white;
                border: 1.5px solid #cbd5e1;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 0.85em;
                font-weight: 500;
            }

            .dist-quick-btn:hover {
                background: #e0f2fe;
                border-color: #0ea5e9;
                color: #075985;
                transform: translateY(-1px);
            }

            /* Export Unified */
            .export-unified {
                padding: 14px;
                background: white;
                border-radius: 8px;
                border: 1.5px solid #d1fae5;
            }

            .export-header {
                margin-bottom: 12px;
                padding-bottom: 10px;
                border-bottom: 1.5px solid #a7f3d0;
            }

            .export-title {
                font-weight: 600;
                color: #065f46;
                font-size: 0.95em;
            }

            .export-buttons {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .export-btn {
                padding: 12px 16px;
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                font-weight: 600;
                font-size: 0.95em;
            }

            .export-btn:hover {
                background: linear-gradient(135deg, #059669 0%, #047857 100%);
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(16, 185, 129, 0.3);
            }

            .export-btn:active {
                transform: translateY(0);
            }

            /* Context Menu */
            .context-menu-unified {
                position: fixed;
                background: white;
                border: 1px solid #e5e7eb;
                border-radius: 8px;
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
                padding: 6px 0;
                min-width: 220px;
                z-index: 10000;
            }

            .context-menu-item {
                padding: 10px 16px;
                display: flex;
                align-items: center;
                gap: 12px;
                cursor: pointer;
                transition: background 0.2s ease;
                font-size: 0.9em;
            }

            .context-menu-item:hover {
                background: #f1f5f9;
            }

            .menu-icon {
                font-size: 1.2em;
                width: 20px;
                text-align: center;
            }

            .menu-text {
                flex: 1;
                color: #334155;
            }

            .menu-shortcut {
                font-size: 0.8em;
                color: #94a3b8;
            }

            .context-menu-divider {
                height: 1px;
                background: #e5e7eb;
                margin: 4px 0;
            }

            /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê RESPONSIVE BREAKPOINTS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

            /* Tablet: <= 1200px */
            @media (max-width: 1200px) {
                .duplex-three-columns {
                    grid-template-columns: 280px 1fr 350px;
                }

                .preset-desc {
                    font-size: 0.7em;
                }

                .action-text {
                    font-size: 0.85em;
                }
            }

            /* Tablet/Mobile: <= 992px */
            @media (max-width: 992px) {
                .duplex-three-columns {
                    grid-template-columns: 1fr;
                }

                .duplex-col {
                    border-right: none;
                    border-bottom: 1px solid #e5e7eb;
                }

                .duplex-col:last-child {
                    border-bottom: none;
                }

                .col-content {
                    max-height: none;
                }

                .stats-left {
                    gap: 8px;
                    font-size: 0.9em;
                }

                .stat-label {
                    display: none;
                }

                .presets-grid {
                    grid-template-columns: repeat(4, 1fr);
                }

                .action-row {
                    grid-template-columns: 1fr;
                }
            }

            /* Mobile: <= 768px */
            @media (max-width: 768px) {
                .duplex-global-stats {
                    padding: 12px 16px;
                }

                .col-header {
                    padding: 12px 16px;
                }

                .col-content {
                    padding: 12px;
                }

                .upload-icon-large {
                    font-size: 2.5em;
                }

                .upload-text-primary {
                    font-size: 1em;
                }

                .presets-grid {
                    grid-template-columns: repeat(2, 1fr);
                }

                .gallery-grid-unified {
                    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                }

                .dist-quick-actions-unified {
                    grid-template-columns: 1fr;
                }

                .export-buttons {
                    gap: 8px;
                }
            }

            /* Small Mobile: <= 480px */
            @media (max-width: 480px) {
                .duplex-global-stats {
                    flex-direction: column;
                    align-items: flex-start;
                    gap: 10px;
                }

                .stats-left {
                    flex-wrap: wrap;
                    gap: 6px;
                }

                .stat-item {
                    font-size: 0.85em;
                }

                .stats-collapse-btn {
                    align-self: flex-end;
                }

                .presets-grid {
                    gap: 8px;
                }

                .preset-btn {
                    padding: 10px 6px;
                }

                .preset-icon {
                    font-size: 1.3em;
                }

                .preset-name {
                    font-size: 0.9em;
                }

                .preset-desc {
                    font-size: 0.7em;
                }

                .action-btn {
                    padding: 8px 12px;
                    font-size: 0.85em;
                }

                .gallery-grid-unified {
                    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                    gap: 8px;
                }

                .list-images {
                    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                }

                .dist-side-actions {
                    flex-direction: column;
                }

                .dist-btn {
                    flex-direction: row;
                    justify-content: center;
                }
            }

            .distribution-item {
                background: white;
                border: 1.5px solid #e5e7eb;
                border-radius: 6px;
                padding: 14px;
                transition: all 0.2s ease;
            }

            .distribution-item:hover {
                border-color: #d1d5db;
            }

            .item-header {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 10px;
            }

            .image-thumb {
                width: 40px;
                height: 40px;
                border-radius: 3px;
                object-fit: cover;
                border: 1px solid #e5e7eb;
            }

            .image-info {
                flex: 1;
                min-width: 0;
            }

            .image-name {
                font-weight: 500;
                font-size: 0.9em;
                color: #374151;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                margin-bottom: 2px;
            }

            .image-size {
                font-size: 0.8em;
                color: #9ca3af;
            }

            .quantity-controls {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px;
                background: #f8fafc;
                border-radius: 3px;
                border: 1px solid #e5e7eb;
            }

            .quantity-label {
                font-size: 0.85em;
                color: #6b7280;
                font-weight: 500;
            }

            .quantity-input-group {
                display: flex;
                align-items: center;
                gap: 4px;
                flex: 1;
            }

            .quantity-btn {
                width: 24px;
                height: 24px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 2px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 0.8em;
                color: #6b7280;
                transition: all 0.15s ease;
            }

            .quantity-btn:hover {
                background: #f3f4f6;
                border-color: #9ca3af;
            }

            .quantity-input {
                width: 50px;
                padding: 4px 6px;
                border: 1px solid #d1d5db;
                border-radius: 2px;
                text-align: center;
                font-size: 0.85em;
                background: white;
                transition: border-color 0.15s ease;
            }

            .quantity-input:focus {
                outline: none;
                border-color: #2563eb;
            }

            .apply-btn {
                padding: 4px 8px;
                background: #2563eb;
                color: white;
                border: none;
                border-radius: 2px;
                cursor: pointer;
                font-size: 0.8em;
                font-weight: 500;
                transition: background 0.15s ease;
            }

            .apply-btn:hover {
                background: #1d4ed8;
            }

            /* Styles m·ªõi cho custom distribution c·∫£i ti·∫øn */
            .quantity-input-simple {
                width: 70px;
                padding: 6px 10px;
                border: 1.5px solid #d1d5db;
                border-radius: 4px;
                font-size: 0.9em;
                text-align: center;
                transition: all 0.2s ease;
            }

            .quantity-input-simple:focus {
                outline: none;
                border-color: #2563eb;
                box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
            }

            .quantity-input-simple:hover {
                border-color: #9ca3af;
            }

            .apply-btn-single {
                padding: 6px 12px;
                background: #10b981;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.85em;
                font-weight: 500;
                transition: all 0.2s ease;
                white-space: nowrap;
            }

            .apply-btn-single:hover {
                background: #059669;
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
            }

            .apply-btn-single:active {
                transform: translateY(0);
            }

            .quantity-badge {
                display: inline-block;
                margin-left: 6px;
                padding: 2px 6px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border-radius: 10px;
                font-size: 0.75em;
                font-weight: 600;
                vertical-align: middle;
            }

            /* C·∫£i ti·∫øn quantity-controls layout */
            .distribution-item .quantity-controls {
                display: flex;
                align-items: center;
                gap: 10px;
                padding: 8px 0;
            }

            .distribution-item .quantity-label {
                font-size: 0.85em;
                color: #6b7280;
                font-weight: 500;
                min-width: 70px;
            }

            /* C·∫£i ti·∫øn distribution-item */
            .distribution-item {
                transition: all 0.2s ease;
            }

            .distribution-item:hover {
                border-color: #2563eb;
                box-shadow: 0 2px 8px rgba(37, 99, 235, 0.1);
            }

            .distribution-item .image-name {
                font-size: 0.9em;
                color: #374151;
                font-weight: 500;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 180px;
            }

            .distribution-item .image-size {
                font-size: 0.8em;
                color: #9ca3af;
                display: flex;
                align-items: center;
                gap: 4px;
            }

            /* Duplex Compact */
            .duplex-classification-compact .duplex-header-compact {
                padding: 16px;
                background: #f8fafc;
                border-bottom: 1px solid #e2e8f0;
            }
            
            .duplex-classification-compact .duplex-quick-stats {
                display: flex;
                gap: 16px;
                margin-top: 8px;
                font-size: 0.9em;
            }
            
            .duplex-classification-compact .duplex-actions-compact {
                display: flex;
                gap: 12px;
                padding: 16px;
                flex-wrap: wrap;
            }
            
            .duplex-classification-compact .classify-action-btn {
                flex: 1;
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px 16px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                min-width: 150px;
            }
            
            .duplex-classification-compact .classify-action-btn.front {
                border-color: #3b82f6;
                background: #eff6ff;
            }
            
            .duplex-classification-compact .classify-action-btn.back {
                border-color: #10b981;
                background: #ecfdf5;
            }
            
            .duplex-classification-compact .classification-grid-compact {
                display: flex;
                gap: 16px;
                padding: 16px;
            }
            
            .duplex-classification-compact .classification-side {
                flex: 1;
                border: 1px solid #e2e8f0;
                border-radius: 6px;
                overflow: hidden;
            }
            
            .duplex-classification-compact .side-header {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 12px;
                background: #f8fafc;
                border-bottom: 1px solid #e2e8f0;
                font-size: 0.9em;
                font-weight: 600;
            }

            /* ===================================================
               DUPLEX V2 - PHASE 1 ENHANCED STYLES
               =================================================== */

            .duplex-classification-v2 {
                background: white;
                border-radius: 8px;
                border: 1px solid #e2e8f0;
                overflow: hidden;
                margin-bottom: 20px;
            }

            /* Header */
            .duplex-v2-header {
                padding: 16px 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 12px;
            }

            .duplex-v2-header h4 {
                margin: 0;
                font-size: 1.1em;
                font-weight: 600;
            }

            .duplex-stats-inline {
                display: flex;
                gap: 12px;
                flex-wrap: wrap;
            }

            .stat-badge {
                background: rgba(255, 255, 255, 0.2);
                padding: 6px 12px;
                border-radius: 20px;
                font-size: 0.85em;
                font-weight: 500;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.3);
            }

            .stat-badge.pages {
                background: rgba(255, 255, 255, 0.3);
                font-weight: 600;
            }

            /* Duplex Upload Zone */
            .duplex-upload-zone {
                margin: 16px 20px;
                padding: 32px 20px;
                border: 2px dashed #cbd5e1;
                border-radius: 12px;
                background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                cursor: pointer;
                transition: all 0.3s ease;
                text-align: center;
            }

            .duplex-upload-zone:hover {
                border-color: #667eea;
                background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
            }

            .duplex-upload-zone.drag-over {
                border-color: #667eea;
                background: linear-gradient(135deg, #ddd6fe 0%, #c7d2fe 100%);
                transform: scale(1.02);
            }

            .upload-zone-content {
                pointer-events: none;
            }

            .upload-icon {
                font-size: 3em;
                margin-bottom: 12px;
                opacity: 0.8;
            }

            .upload-text {
                font-size: 1em;
                color: #475569;
                margin-bottom: 8px;
            }

            .upload-text strong {
                color: #1e293b;
                font-weight: 600;
            }

            .upload-link {
                color: #667eea;
                font-weight: 600;
                text-decoration: underline;
                cursor: pointer;
            }

            .upload-hint {
                font-size: 0.85em;
                color: #64748b;
                margin-top: 8px;
            }

            /* Quick Actions Toolbar */
            .duplex-quick-actions {
                display: flex;
                gap: 8px;
                padding: 12px 20px;
                background: #f8fafc;
                border-bottom: 2px solid #e2e8f0;
                flex-wrap: wrap;
            }

            .quick-action-btn {
                display: flex;
                align-items: center;
                gap: 6px;
                padding: 8px 14px;
                border: 1px solid #d1d5db;
                background: white;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 0.9em;
                font-weight: 500;
            }

            .quick-action-btn:hover:not(:disabled) {
                background: #f3f4f6;
                border-color: #9ca3af;
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            .quick-action-btn:active:not(:disabled) {
                transform: translateY(0);
            }

            .quick-action-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .qa-icon {
                font-size: 1.1em;
            }

            .qa-text {
                font-size: 0.9em;
            }

            /* 2-Column Layout */
            .duplex-v2-layout {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                padding: 20px;
                min-height: 500px;
            }

            /* LEFT Column - Gallery */
            .duplex-v2-gallery-col {
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            .gallery-col-header {
                padding: 12px 16px;
                background: #f8fafc;
                border-bottom: 2px solid #e2e8f0;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .col-title {
                font-weight: 600;
                font-size: 0.95em;
                color: #374151;
            }

            .col-hint {
                font-size: 0.8em;
                color: #9ca3af;
                font-style: italic;
            }

            .gallery-grid-v2 {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 12px;
                padding: 16px;
                overflow-y: auto;
                max-height: 600px;
            }

            /* Gallery Items with States */
            .gallery-item-v2 {
                position: relative;
                aspect-ratio: 1;
                border-radius: 8px;
                overflow: hidden;
                cursor: pointer;
                transition: all 0.2s ease;
                border: 3px solid transparent;
            }

            .gallery-item-v2 img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            /* States */
            .gallery-item-v2.available {
                border-color: #e5e7eb;
                opacity: 1;
            }

            .gallery-item-v2.available:hover {
                border-color: #9ca3af;
                transform: scale(1.05);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }

            .gallery-item-v2.in-front {
                border-color: #3b82f6;
                opacity: 0.6;
            }

            .gallery-item-v2.in-back {
                border-color: #10b981;
                opacity: 0.6;
            }

            .gallery-item-v2.dragging {
                opacity: 0.5;
                cursor: grabbing;
                transform: rotate(5deg);
            }

            /* Badges on Gallery Items */
            .gallery-item-v2 .item-badge {
                position: absolute;
                top: 4px;
                right: 4px;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 0.7em;
                font-weight: 600;
                backdrop-filter: blur(4px);
            }

            .gallery-item-v2.in-front .item-badge {
                background: #3b82f6;
            }

            .gallery-item-v2.in-back .item-badge {
                background: #10b981;
            }

            /* RIGHT Column - Classification */
            .duplex-v2-classify-col {
                display: flex;
                flex-direction: column;
                gap: 16px;
            }

            /* Toggle Mode Switch */
            .duplex-toggle-mode {
                background: white;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                padding: 16px;
            }

            .toggle-label {
                font-size: 0.9em;
                font-weight: 600;
                color: #374151;
                margin-bottom: 12px;
            }

            .toggle-switch-wrapper {
                display: flex;
                gap: 8px;
                margin-bottom: 10px;
            }

            .toggle-switch-btn {
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                padding: 12px;
                border: 2px solid #d1d5db;
                background: white;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-weight: 500;
            }

            .toggle-switch-btn:hover {
                background: #f9fafb;
                border-color: #9ca3af;
            }

            .toggle-switch-btn.active.front {
                background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
                border-color: #2563eb;
                color: white;
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            }

            .toggle-switch-btn.active.back {
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                border-color: #059669;
                color: white;
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
            }

            .toggle-icon {
                font-size: 1.2em;
            }

            .toggle-hint {
                font-size: 0.8em;
                color: #6b7280;
                font-style: italic;
                text-align: center;
            }

            /* Classification Lists */
            .classification-lists-v2 {
                display: flex;
                gap: 12px;
                flex: 1;
            }

            .classify-side-v2 {
                flex: 1;
                background: white;
                border: 2px solid #e2e8f0;
                border-radius: 8px;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }

            .classify-side-v2.front-side {
                border-color: #3b82f6;
            }

            .classify-side-v2.back-side {
                border-color: #10b981;
            }

            .side-header-v2 {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px 12px;
                background: #f8fafc;
                border-bottom: 2px solid #e2e8f0;
            }

            .front-side .side-header-v2 {
                background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
                border-bottom-color: #3b82f6;
            }

            .back-side .side-header-v2 {
                background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
                border-bottom-color: #10b981;
            }

            .header-left {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .side-icon {
                font-size: 1.2em;
            }

            .side-title {
                font-weight: 600;
                font-size: 0.9em;
                color: #374151;
            }

            .side-count {
                background: rgba(0, 0, 0, 0.1);
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 0.85em;
                font-weight: 600;
            }

            .clear-btn-v2 {
                background: none;
                border: none;
                cursor: pointer;
                padding: 4px 8px;
                border-radius: 4px;
                transition: all 0.2s ease;
                font-size: 1.1em;
            }

            .clear-btn-v2:hover {
                background: rgba(239, 68, 68, 0.1);
                transform: scale(1.1);
            }

            /* Classification Thumbnails */
            .classification-thumbnails-v2 {
                padding: 12px;
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 10px;
                overflow-y: auto;
                max-height: 400px;
                min-height: 150px;
            }

            .classification-thumbnails-v2.droppable-zone.drag-over {
                background: rgba(59, 130, 246, 0.1);
                border: 2px dashed #3b82f6;
                border-radius: 8px;
            }

            .back-side .classification-thumbnails-v2.droppable-zone.drag-over {
                background: rgba(16, 185, 129, 0.1);
                border-color: #10b981;
            }

            .empty-state {
                grid-column: 1 / -1;
                text-align: center;
                padding: 40px 20px;
                color: #9ca3af;
                font-style: italic;
                font-size: 0.9em;
            }

            /* Classified Thumbnail Item */
            .classified-thumb {
                position: relative;
                aspect-ratio: 1;
                border-radius: 6px;
                overflow: hidden;
                border: 2px solid #e5e7eb;
                cursor: grab;
                transition: all 0.2s ease;
            }

            .classified-thumb:hover {
                transform: scale(1.05);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            }

            .classified-thumb img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .classified-thumb .thumb-order {
                position: absolute;
                top: 4px;
                left: 4px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 2px 6px;
                border-radius: 10px;
                font-size: 0.75em;
                font-weight: 700;
            }

            .classified-thumb .thumb-remove {
                position: absolute;
                top: 4px;
                right: 4px;
                background: #ef4444;
                color: white;
                border: none;
                border-radius: 50%;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 0.8em;
                opacity: 0;
                transition: opacity 0.2s ease;
            }

            .classified-thumb:hover .thumb-remove {
                opacity: 1;
            }

            .classified-thumb .thumb-remove:hover {
                background: #dc2626;
                transform: scale(1.1);
            }

            /* Validation Messages */
            .duplex-validation {
                padding: 12px;
                border-radius: 6px;
                font-size: 0.9em;
                display: none;
            }

            .duplex-validation.show {
                display: block;
            }

            .duplex-validation.warning {
                background: #fef3c7;
                border: 1px solid #fbbf24;
                color: #92400e;
            }

            .duplex-validation.error {
                background: #fee2e2;
                border: 1px solid #ef4444;
                color: #991b1b;
            }

            .duplex-validation.success {
                background: #d1fae5;
                border: 1px solid #10b981;
                color: #065f46;
            }

            /* Responsive */
            @media (max-width: 768px) {
                .preset-options {
                    grid-template-columns: 1fr;
                }
                
                .settings-row {
                    flex-direction: column;
                    gap: 12px;
                }
                
                .upload-actions {
                    flex-direction: column;
                }
                
                .upload-btn {
                    min-width: 100%;
                }
                
                .print-actions {
                    flex-direction: column;
                }
                
                .preview-header-compact {
                    flex-direction: column;
                    align-items: flex-start;
                }
                
                .preview-controls-compact {
                    width: 100%;
                    justify-content: space-between;
                }
                
                .export-format-tabs {
                    flex-direction: column;
                }
                
                .duplex-actions-compact {
                    flex-direction: column;
                }
                
                .classification-grid-compact {
                    flex-direction: column;
                }

                /* === Duplex V2 Responsive === */
                .duplex-v2-layout {
                    grid-template-columns: 1fr;
                    gap: 16px;
                    padding: 12px;
                }

                .duplex-quick-actions {
                    flex-wrap: wrap;
                    justify-content: center;
                    gap: 6px;
                    padding: 10px;
                }

                .quick-action-btn {
                    flex: 1 1 auto;
                    min-width: 80px;
                    padding: 6px 10px;
                    font-size: 0.85em;
                }

                .qa-text {
                    display: none;
                }

                .gallery-grid-v2 {
                    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                    gap: 8px;
                    padding: 12px;
                    max-height: 400px;
                }

                .classification-lists-v2 {
                    flex-direction: column;
                }

                .classification-thumbnails-v2 {
                    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                    gap: 8px;
                    max-height: 250px;
                }

                .toggle-switch-wrapper {
                    flex-direction: column;
                }

                .toggle-switch-btn {
                    width: 100%;
                }

                .duplex-stats-inline {
                    gap: 8px;
                }

                .stat-badge {
                    font-size: 0.75em;
                    padding: 4px 8px;
                }

                /* Responsive Images Grid */
                .images-grid-compact {
                    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                    gap: 6px;
                    padding: 12px;
                    max-height: 250px;
                }
                
                .images-grid-compact .image-item .remove-btn {
                    width: 18px;
                    height: 18px;
                    font-size: 10px;
                }
                
                .selected-images-compact .images-header-compact {
                    padding: 8px 12px;
                    flex-wrap: wrap;
                    gap: 8px;
                }
                
                .selected-images-compact .header-actions {
                    gap: 6px;
                }
                
                .selected-images-compact .action-btn {
                    width: 28px;
                    height: 28px;
                    font-size: 0.9em;
                }
            }
            
        /* ===========================================
           MODERN CROP PAGE REDESIGN - CLEAN & INTUITIVE
           =========================================== */
           
        /* Layout Updates */
        .crop-body {
            display: flex;
            flex-direction: row;
            gap: 30px;
            height: calc(100vh - 80px);
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .crop-main-content {
            flex: 1;
            background: var(--white);
            border-radius: 20px;
            border: 2px solid #e5e7eb;
            padding: 30px;
            overflow-y: auto;
        }
        
        .crop-sidebar-modern {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* Size Selection - Modern Design */
        .size-selection-modern {
            max-width: 100%;
        }
        
        .size-header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .size-header h2 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-dark);
            margin: 0 0 8px 0;
        }
        
        .size-header p {
            font-size: 1.1rem;
            color: var(--text-light);
            margin: 0;
        }
        
        .size-categories {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        /* Compact Category Header */
        .category-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding: 8px 0;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .category-indicator {
            font-size: 16px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f3f4f6;
            border-radius: 4px;
            color: #6b7280;
        }
        
        .category-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #374151;
            margin: 0;
            flex: 1;
        }
        
        .category-count {
            font-size: 0.75rem;
            color: #9ca3af;
            background: #f9fafb;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 500;
        }
        
        /* Quick Access Row */
        .size-row {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .size-option-minimal {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
        }

        .size-option-minimal:hover {
            border-color: #3b82f6;
            background: #f8fafc;
        }

        .size-option-minimal.active {
            border-color: #3b82f6;
            background: #eff6ff;
            box-shadow: 0 1px 3px rgba(59, 130, 246, 0.1);
        }

        /* M√†u s·∫Øc ph√¢n bi·ªát cho size-option-minimal */
        .size-option-minimal[data-size="5.5x8.5"] {
            border-left: 4px solid #ef4444;
            background: linear-gradient(to right, #fef2f2, #ffffff);
        }

        .size-option-minimal[data-size="8.5x11"] {
            border-left: 4px solid #f59e0b;
            background: linear-gradient(to right, #fffbeb, #ffffff);
        }

        .size-option-minimal[data-size="4x6"] {
            border-left: 4px solid #10b981;
            background: linear-gradient(to right, #f0fdf4, #ffffff);
        }

        .size-option-minimal[data-size="5x7"] {
            border-left: 4px solid #3b82f6;
            background: linear-gradient(to right, #eff6ff, #ffffff);
        }

        .size-option-minimal[data-size="6x9"] {
            border-left: 4px solid #8b5cf6;
            background: linear-gradient(to right, #f5f3ff, #ffffff);
        }

        .size-option-minimal[data-size="8x10"] {
            border-left: 4px solid #ec4899;
            background: linear-gradient(to right, #fdf2f8, #ffffff);
        }

        .size-option-minimal[data-size="custom"] {
            border-left: 4px solid #64748b;
            background: linear-gradient(to right, #f8fafc, #ffffff);
        }

        .size-option-minimal[data-size="5.5x8.5"]:hover,
        .size-option-minimal[data-size="5.5x8.5"].active {
            border-color: #ef4444;
            background: linear-gradient(to right, #fee2e2, #fef2f2);
        }

        .size-option-minimal[data-size="8.5x11"]:hover,
        .size-option-minimal[data-size="8.5x11"].active {
            border-color: #f59e0b;
            background: linear-gradient(to right, #fef3c7, #fffbeb);
        }

        .size-option-minimal[data-size="4x6"]:hover,
        .size-option-minimal[data-size="4x6"].active {
            border-color: #10b981;
            background: linear-gradient(to right, #d1fae5, #f0fdf4);
        }

        .size-option-minimal[data-size="5x7"]:hover,
        .size-option-minimal[data-size="5x7"].active {
            border-color: #3b82f6;
            background: linear-gradient(to right, #dbeafe, #eff6ff);
        }

        .size-option-minimal[data-size="6x9"]:hover,
        .size-option-minimal[data-size="6x9"].active {
            border-color: #8b5cf6;
            background: linear-gradient(to right, #ede9fe, #f5f3ff);
        }

        .size-option-minimal[data-size="8x10"]:hover,
        .size-option-minimal[data-size="8x10"].active {
            border-color: #ec4899;
            background: linear-gradient(to right, #fce7f3, #fdf2f8);
        }

        .size-option-minimal[data-size="custom"]:hover,
        .size-option-minimal[data-size="custom"].active {
            border-color: #64748b;
            background: linear-gradient(to right, #e2e8f0, #f8fafc);
        }
        
        .size-label {
            font-weight: 500;
            color: #374151;
            font-size: 0.9rem;
        }
        
        .size-badge-minimal {
            font-size: 0.7rem;
            color: #6b7280;
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        /* Compact Size Grid */
        .size-grid-compact {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 6px;
        }
        
        .size-card-minimal {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .size-card-minimal:hover {
            border-color: #3b82f6;
            background: #f8fafc;
            transform: translateY(-1px);
        }

        .size-card-minimal.active {
            border-color: #3b82f6;
            background: #eff6ff;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.1);
        }

        /* M√†u s·∫Øc ph√¢n bi·ªát cho t·ª´ng k√≠ch th∆∞·ªõc */
        .size-card-minimal[data-size="5.5x8.5"] {
            border-left: 4px solid #ef4444;
            background: linear-gradient(to right, #fef2f2, #ffffff);
        }

        .size-card-minimal[data-size="8.5x11"] {
            border-left: 4px solid #f59e0b;
            background: linear-gradient(to right, #fffbeb, #ffffff);
        }

        .size-card-minimal[data-size="4x6"] {
            border-left: 4px solid #10b981;
            background: linear-gradient(to right, #f0fdf4, #ffffff);
        }

        .size-card-minimal[data-size="5x7"] {
            border-left: 4px solid #3b82f6;
            background: linear-gradient(to right, #eff6ff, #ffffff);
        }

        .size-card-minimal[data-size="6x9"] {
            border-left: 4px solid #8b5cf6;
            background: linear-gradient(to right, #f5f3ff, #ffffff);
        }

        .size-card-minimal[data-size="8x10"] {
            border-left: 4px solid #ec4899;
            background: linear-gradient(to right, #fdf2f8, #ffffff);
        }

        .size-card-minimal[data-size="custom"] {
            border-left: 4px solid #64748b;
            background: linear-gradient(to right, #f8fafc, #ffffff);
        }

        .size-card-minimal[data-size="5.5x8.5"]:hover,
        .size-card-minimal[data-size="5.5x8.5"].active {
            border-color: #ef4444;
            background: linear-gradient(to right, #fee2e2, #fef2f2);
        }

        .size-card-minimal[data-size="8.5x11"]:hover,
        .size-card-minimal[data-size="8.5x11"].active {
            border-color: #f59e0b;
            background: linear-gradient(to right, #fef3c7, #fffbeb);
        }

        .size-card-minimal[data-size="4x6"]:hover,
        .size-card-minimal[data-size="4x6"].active {
            border-color: #10b981;
            background: linear-gradient(to right, #d1fae5, #f0fdf4);
        }

        .size-card-minimal[data-size="5x7"]:hover,
        .size-card-minimal[data-size="5x7"].active {
            border-color: #3b82f6;
            background: linear-gradient(to right, #dbeafe, #eff6ff);
        }

        .size-card-minimal[data-size="6x9"]:hover,
        .size-card-minimal[data-size="6x9"].active {
            border-color: #8b5cf6;
            background: linear-gradient(to right, #ede9fe, #f5f3ff);
        }

        .size-card-minimal[data-size="8x10"]:hover,
        .size-card-minimal[data-size="8x10"].active {
            border-color: #ec4899;
            background: linear-gradient(to right, #fce7f3, #fdf2f8);
        }

        .size-card-minimal[data-size="custom"]:hover,
        .size-card-minimal[data-size="custom"].active {
            border-color: #64748b;
            background: linear-gradient(to right, #e2e8f0, #f8fafc);
        }
        
        .size-preview-minimal {
            width: 100%;
            height: 35px;
            background: #f3f4f6;
            border-radius: 4px;
            margin-bottom: 6px;
            border: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .size-preview-minimal::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: #9ca3af;
            border-radius: 50%;
            opacity: 0.3;
        }
        
        .custom-preview {
            background: #fef3c7;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .custom-icon {
            font-size: 14px;
            color: #f59e0b;
        }
        
        .size-info-minimal {
            text-align: center;
        }
        
        .size-dimensions {
            font-weight: 600;
            color: #374151;
            font-size: 0.75rem;
            margin: 0;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .size-grid-compact {
                grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
                gap: 4px;
            }
            
            .size-card-minimal {
                padding: 6px;
            }
            
            .size-preview-minimal {
                height: 30px;
            }
            
            .size-row {
                flex-direction: column;
                gap: 6px;
            }
        }
        
        /* Simple Size List - Text Only (No Cards) */
        .size-list-simple {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }

        .size-option {
            padding: 10px 14px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            background: #ffffff;
        }

        .size-option:hover {
            background: #f8f9fa;
            border-color: #3b82f6;
        }

        .size-option.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        .size-label {
            font-weight: 500;
            font-size: 14px;
        }

        .size-option.active .size-label {
            color: white;
        }

        /* Legacy classes - hide if still referenced */
        .size-cards-large {
            display: none;
        }
        
        /* Compact Size Cards - More Options */
        .more-sizes-toggle {
            border: none;
            margin: 10px 0 0 0;
        }
        
        .more-sizes-toggle summary {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 12px 16px;
            background: #f8fafc;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
            transition: all 0.2s ease;
            list-style: none;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .more-sizes-toggle summary::-webkit-details-marker {
            display: none;
        }
        
        .more-sizes-toggle summary:hover {
            background: #f1f5f9;
            border-color: var(--primary-blue);
        }
        
        .more-sizes-toggle[open] summary {
            background: var(--primary-blue);
            color: white;
            border-color: var(--primary-blue);
        }
        
        .more-sizes-toggle[open] .toggle-icon {
            transform: rotate(180deg);
        }
        
        .toggle-icon {
            transition: transform 0.2s ease;
            font-size: 0.8rem;
        }
        
        .size-cards-compact {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 10px;
        }
        
        .size-card-compact {
            background: var(--white);
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            min-height: 75px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .size-card-compact:hover {
            border-color: var(--primary-blue);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .size-card-compact.active {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        /* M√†u s·∫Øc ph√¢n bi·ªát cho size-card-compact */
        .size-card-compact[data-size="5.5x8.5"] {
            border-top: 4px solid #ef4444;
            background: linear-gradient(to bottom, #fef2f2, #ffffff);
        }

        .size-card-compact[data-size="8.5x11"] {
            border-top: 4px solid #f59e0b;
            background: linear-gradient(to bottom, #fffbeb, #ffffff);
        }

        .size-card-compact[data-size="4x6"] {
            border-top: 4px solid #10b981;
            background: linear-gradient(to bottom, #f0fdf4, #ffffff);
        }

        .size-card-compact[data-size="5x7"] {
            border-top: 4px solid #3b82f6;
            background: linear-gradient(to bottom, #eff6ff, #ffffff);
        }

        .size-card-compact[data-size="6x9"] {
            border-top: 4px solid #8b5cf6;
            background: linear-gradient(to bottom, #f5f3ff, #ffffff);
        }

        .size-card-compact[data-size="8x10"] {
            border-top: 4px solid #ec4899;
            background: linear-gradient(to bottom, #fdf2f8, #ffffff);
        }

        .size-card-compact[data-size="custom"] {
            border-top: 4px solid #64748b;
            background: linear-gradient(to bottom, #f8fafc, #ffffff);
        }

        .size-card-compact[data-size="5.5x8.5"]:hover,
        .size-card-compact[data-size="5.5x8.5"].active {
            border-color: #ef4444;
            background: linear-gradient(to bottom, #fee2e2, #fef2f2);
        }

        .size-card-compact[data-size="8.5x11"]:hover,
        .size-card-compact[data-size="8.5x11"].active {
            border-color: #f59e0b;
            background: linear-gradient(to bottom, #fef3c7, #fffbeb);
        }

        .size-card-compact[data-size="4x6"]:hover,
        .size-card-compact[data-size="4x6"].active {
            border-color: #10b981;
            background: linear-gradient(to bottom, #d1fae5, #f0fdf4);
        }

        .size-card-compact[data-size="5x7"]:hover,
        .size-card-compact[data-size="5x7"].active {
            border-color: #3b82f6;
            background: linear-gradient(to bottom, #dbeafe, #eff6ff);
        }

        .size-card-compact[data-size="6x9"]:hover,
        .size-card-compact[data-size="6x9"].active {
            border-color: #8b5cf6;
            background: linear-gradient(to bottom, #ede9fe, #f5f3ff);
        }

        .size-card-compact[data-size="8x10"]:hover,
        .size-card-compact[data-size="8x10"].active {
            border-color: #ec4899;
            background: linear-gradient(to bottom, #fce7f3, #fdf2f8);
        }

        .size-card-compact[data-size="custom"]:hover,
        .size-card-compact[data-size="custom"].active {
            border-color: #64748b;
            background: linear-gradient(to bottom, #e2e8f0, #f8fafc);
        }
        
        .size-preview-compact {
            width: 28px;
            height: 28px;
            background: #f1f5f9;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 8px auto;
            border: 1px solid #e2e8f0;
        }
        
        .size-info-compact .size-name {
            font-size: 0.8rem;
            font-weight: 700;
            margin: 0 0 2px 0;
            color: var(--text-dark);
        }
        
        .size-info-compact .size-dimensions {
            font-size: 0.7rem;
            color: var(--primary-blue);
            margin: 0;
            font-weight: 600;
        }
        
        .custom-visual {
            background: linear-gradient(135deg, #64748b, #475569) !important;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 1.2rem;
        }
        
        /* Selection Summary */
        .selection-summary {
            margin-top: 30px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(16, 185, 129, 0.08));
            border: 2px solid rgba(59, 130, 246, 0.2);
            border-radius: 16px;
            padding: 20px;
        }
        
        .summary-content {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .summary-icon {
            font-size: 2rem;
            flex-shrink: 0;
        }
        
        .summary-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-dark);
            margin: 0 0 4px 0;
        }
        
        .summary-details {
            font-size: 0.9rem;
            color: var(--text-light);
            margin: 0;
        }
        
        /* Sidebar Modern Design */
        .quick-actions-modern {
            background: var(--white);
            border: 2px solid var(--primary-yellow);
            border-radius: 16px;
            padding: 20px;
        }
        
        .action-btn-modern {
            width: 100%;
            background: linear-gradient(135deg, var(--primary-blue), var(--dark-blue));
            color: white;
            border: none;
            border-radius: 12px;
            padding: 18px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .action-btn-modern:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }
        
        .btn-icon {
            font-size: 1.4rem;
            flex-shrink: 0;
        }
        
        .btn-content {
            flex: 1;
            text-align: left;
        }
        
        .btn-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin: 0 0 2px 0;
        }
        
        .btn-subtitle {
            font-size: 0.85rem;
            opacity: 0.9;
            margin: 0;
        }
        
        /* Advanced Settings */
        .advanced-settings-modern {
            background: var(--white);
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            overflow: hidden;
        }
        
        .settings-toggle summary {
            padding: 16px 20px;
            background: #f8fafc;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
            color: var(--text-dark);
            transition: all 0.2s ease;
            list-style: none;
        }
        
        .settings-toggle summary::-webkit-details-marker {
            display: none;
        }
        
        .settings-toggle summary:hover {
            background: #f1f5f9;
        }
        
        .settings-toggle[open] summary {
            background: var(--primary-blue);
            color: white;
        }
        
        .settings-toggle[open] .toggle-icon {
            transform: rotate(180deg);
        }
        
        .settings-content {
            padding: 20px;
            background: var(--white);
        }
        
        .setting-section {
            margin-bottom: 20px;
        }
        
        .setting-section:last-child {
            margin-bottom: 0;
        }
        
        .setting-section h4 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-dark);
            margin: 0 0 12px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .custom-inputs-modern .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .input-field label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-dark);
            margin: 0 0 4px 0;
        }
        
        .setting-field {
            margin-bottom: 12px;
        }
        
        .setting-field:last-child {
            margin-bottom: 0;
        }
        
        .setting-field label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-dark);
            margin: 0 0 6px 0;
        }
        
        .modern-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: white;
            font-size: 0.85rem;
            color: var(--text-dark);
            cursor: pointer;
        }
        
        .modern-select:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }
        
        /* Process Mode */
        .process-mode-modern {
            background: var(--white);
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            padding: 20px;
        }
        
        .process-mode-modern h4 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-dark);
            margin: 0 0 16px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .mode-tabs {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .mode-tab {
            display: block;
            cursor: pointer;
        }
        
        .mode-tab input[type="radio"] {
            display: none;
        }
        
        .tab-content {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            transition: all 0.2s ease;
            background: white;
        }
        
        .mode-tab:hover .tab-content {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.05);
        }
        
        .mode-tab input:checked + .tab-content,
        .mode-tab.active .tab-content {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
            color: var(--primary-blue);
            font-weight: 600;
        }
        
        .tab-icon {
            font-size: 1.1rem;
        }
        
        .tab-text {
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        /* Responsive Design */
        @media (max-width: 1024px) {
            .crop-body {
                flex-direction: column;
                height: auto;
                min-height: calc(100vh - 80px);
            }
            
            .crop-sidebar-modern {
                width: 100%;
                flex-direction: row;
                gap: 15px;
                overflow-x: auto;
                padding-bottom: 10px;
            }
            
            .crop-sidebar-modern > * {
                flex-shrink: 0;
                min-width: 250px;
            }
            
            .size-list-simple {
                gap: 6px;
            }
        }
        
        @media (max-width: 768px) {
            .crop-main-content {
                padding: 20px;
            }
            
            .size-header h2 {
                font-size: 1.6rem;
            }
            
            .size-card-large {
                flex-direction: column;
                text-align: center;
                gap: 12px;
                padding: 16px;
            }
            
            .size-cards-compact {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
            
            .crop-sidebar-modern {
                flex-direction: column;
            }
        }

        /* Layout 3 c·ªôt cho Crop Page */
        .crop-workspace {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 20px;
            height: calc(100vh - 100px);
            max-height: 800px;
            min-height: 600px;
        }

        .crop-sidebar-left,
        .crop-sidebar-right {
            background: var(--surface);
            border: 2px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            overflow-y: auto;
            box-shadow: var(--shadow-sm);
        }

        .crop-workspace-center {
            background: var(--surface);
            border: 2px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: var(--shadow-sm);
        }

        .crop-sidebar-left h3,
        .crop-sidebar-right h3,
        .crop-workspace-center h3 {
            font-size: var(--text-lg);
            font-weight: 600;
            margin-bottom: var(--space-4);
            color: var(--text-primary);
            border-bottom: 2px solid var(--border-light);
            padding-bottom: var(--space-2);
        }

        /* Responsive cho layout 3 c·ªôt */
        @media (max-width: 1200px) {
            .crop-workspace {
                grid-template-columns: 250px 1fr 250px;
                gap: 15px;
            }
        }

        @media (max-width: 768px) {
            .crop-workspace {
                grid-template-columns: 1fr;
                gap: 15px;
                height: auto;
                max-height: none;
            }

            .crop-sidebar-left,
            .crop-sidebar-right {
                max-height: 300px;
            }
        }

        /* Thanh b√™n tr√°i - Upload v√† qu·∫£n l√Ω file */
        .crop-sidebar-left .sidebar-section {
            margin-bottom: var(--space-6);
        }

        .crop-sidebar-left .upload-area-crop {
            border: 2px dashed var(--border);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            text-align: center;
            margin-bottom: var(--space-4);
            transition: var(--transition-base);
            background: var(--surface);
        }

        .crop-sidebar-left .upload-area-crop:hover {
            border-color: var(--primary);
            background: var(--gray-100);
        }

        .crop-sidebar-left .upload-icon-crop {
            font-size: 2rem;
            color: var(--text-secondary);
            margin-bottom: var(--space-2);
        }

        .crop-sidebar-left .select-files-btn-crop {
            background: var(--primary);
            color: white;
            border: none;
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition-base);
            margin-top: var(--space-3);
        }

        .crop-sidebar-left .select-files-btn-crop:hover {
            background: var(--primary-dark);
        }

        .crop-sidebar-left .files-header-crop {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-3);
        }

        .crop-sidebar-left .action-btn-crop {
            background: var(--error);
            color: white;
            border: none;
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: var(--text-sm);
            transition: var(--transition-base);
        }

        .crop-sidebar-left .action-btn-crop:hover {
            background: #991b1b;
        }

        .crop-sidebar-left .files-list-crop {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Thanh b√™n ph·∫£i - Thi·∫øt l·∫≠p v√† t·∫£i xu·ªëng */
        .crop-sidebar-right .sidebar-section {
            margin-bottom: var(--space-6);
        }

        /* Mode tabs */
        .crop-sidebar-right .mode-tabs {
            display: flex;
            flex-direction: column;
            gap: var(--space-2);
        }

        .crop-sidebar-right .mode-tab {
            display: block;
            cursor: pointer;
        }

        .crop-sidebar-right .mode-tab input[type="radio"] {
            display: none;
        }

        .crop-sidebar-right .tab-content {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-3);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            background: var(--surface);
            transition: var(--transition-base);
        }

        .crop-sidebar-right .mode-tab:hover .tab-content {
            border-color: var(--primary);
            background: var(--gray-100);
        }

        .crop-sidebar-right .mode-tab input[type="radio"]:checked + .tab-content {
            border-color: var(--primary);
            background: var(--primary-light);
            color: white;
        }

        /* Download grid */
        .crop-sidebar-right .download-grid {
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
            margin-bottom: var(--space-4);
        }

        .crop-sidebar-right .download-card {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-4);
            border: 2px solid var(--border-light);
            border-radius: var(--radius-md);
            background: var(--surface);
            cursor: pointer;
            transition: var(--transition-base);
            text-align: left;
        }

        .crop-sidebar-right .download-card:hover {
            border-color: var(--primary);
            background: var(--gray-100);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .crop-sidebar-right .download-card.primary {
            border-color: var(--primary);
            background: var(--primary-light);
            color: white;
        }

        .crop-sidebar-right .download-content {
            flex: 1;
        }

        .crop-sidebar-right .download-title {
            font-weight: 500;
            margin-bottom: var(--space-1);
        }

        .crop-sidebar-right .download-subtitle {
            font-size: var(--text-sm);
            opacity: 0.8;
        }

        /* Download status */
        .crop-sidebar-right .download-status {
            padding: var(--space-3);
            background: var(--gray-100);
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            text-align: center;
            color: var(--text-secondary);
        }

        /* Advanced settings */
        .crop-sidebar-right .settings-toggle {
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .crop-sidebar-right .settings-toggle summary {
            padding: var(--space-3);
            background: var(--gray-100);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--space-2);
            font-weight: 500;
        }

        .crop-sidebar-right .settings-content {
            padding: var(--space-4);
            background: var(--surface);
        }

        .crop-sidebar-right .setting-section {
            margin-bottom: var(--space-4);
        }

        .crop-sidebar-right .setting-section h4 {
            font-size: var(--text-base);
            font-weight: 500;
            margin-bottom: var(--space-3);
            color: var(--text-primary);
        }

        .crop-sidebar-right .setting-field {
            margin-bottom: var(--space-3);
        }

        .crop-sidebar-right .setting-field label {
            display: block;
            font-size: var(--text-sm);
            font-weight: 500;
            margin-bottom: var(--space-2);
            color: var(--text-secondary);
        }

        .crop-sidebar-right .modern-select {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            background: var(--surface);
            font-size: var(--text-sm);
        }

        /* Khu v·ª±c workspace ch√≠nh */
        .crop-workspace-center .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }

        .crop-workspace-center .size-selection-modern {
            width: 100%;
        }

        .crop-workspace-center .size-header {
            text-align: center;
            margin-bottom: var(--space-6);
        }

        .crop-workspace-center .size-header h2 {
            font-size: var(--text-2xl);
            font-weight: 600;
            margin-bottom: var(--space-2);
            color: var(--text-primary);
        }

        .crop-workspace-center .size-header p {
            color: var(--text-secondary);
            font-size: var(--text-base);
        }

        .crop-workspace-center .size-categories {
            margin-bottom: var(--space-6);
        }

        .crop-workspace-center .category-section {
            margin-bottom: var(--space-6);
        }

        .crop-workspace-center .category-section h3 {
            font-size: var(--text-lg);
            font-weight: 500;
            margin-bottom: var(--space-4);
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-light);
            padding-bottom: var(--space-2);
        }

        .crop-workspace-center .size-list-simple {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--space-3);
        }

        .crop-workspace-center .size-option {
            padding: var(--space-4);
            border: 2px solid var(--border-light);
            border-radius: var(--radius-md);
            background: var(--surface);
            cursor: pointer;
            transition: var(--transition-base);
            text-align: center;
        }

        .crop-workspace-center .size-option:hover {
            border-color: var(--primary);
            background: var(--gray-100);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .crop-workspace-center .size-option.active {
            border-color: var(--primary);
            background: var(--primary-light);
            color: white;
            box-shadow: var(--shadow-lg);
        }

        .crop-workspace-center .size-label {
            font-size: var(--text-base);
            font-weight: 500;
            display: block;
        }

        /* Custom size section */
        .crop-workspace-center .custom-size-section {
            background: var(--gray-100);
            padding: var(--space-4);
            border-radius: var(--radius-lg);
            margin-top: var(--space-4);
        }

        .crop-workspace-center .custom-inputs {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: var(--space-3);
            align-items: center;
        }
            </style>

        </div>
    </div>

    <!-- OLD Crop Page - REMOVED (Content moved to cropTabSection) -->

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- PDF Configuration Modal -->
    <div class="modal" id="pdfModal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>T·∫°o file PDF b·∫£n in</h2>
                <span class="close" id="closePdfModal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="pdf-config">
                    <div class="config-section">
                        <label>üìê K√≠ch th∆∞·ªõc gi·∫•y:</label>
                        <select id="pdfPageSize">
                            <option value="a4">A4 (210√ó297mm)</option>
                            <option value="a3">A3 (297√ó420mm)</option>
                            <option value="letter">Letter (216√ó279mm)</option>
                            <option value="legal">Legal (216√ó356mm)</option>
                        </select>
                    </div>

                    <div class="config-section">
                        <label>üì± H∆∞·ªõng gi·∫•y:</label>
                        <select id="pdfOrientation">
                            <option value="portrait">D·ªçc (Portrait)</option>
                            <option value="landscape">Ngang (Landscape)</option>
                        </select>
                    </div>

                    <div class="config-section">
                        <label>üñºÔ∏è Layout ·∫£nh:</label>
                        <select id="pdfLayout">
                            <option value="grid">L∆∞·ªõi (Grid)</option>
                            <option value="list">Danh s√°ch (List)</option>
                            <option value="single">T·ª´ng ·∫£nh m·ªôt trang</option>
                        </select>
                    </div>

                    <div class="config-section">
                        <label>üìè S·ªë ·∫£nh m·ªói trang:</label>
                        <input type="number" id="imagesPerPage" value="4" min="1" max="20">
                    </div>

                    <div class="config-section">
                        <label>üìù Ti√™u ƒë·ªÅ PDF:</label>
                        <input type="text" id="pdfTitle" value="B·ªô s∆∞u t·∫≠p ·∫£nh ƒë√£ chuy·ªÉn ƒë·ªïi" placeholder="Nh·∫≠p ti√™u ƒë·ªÅ...">
                    </div>

                    <div class="config-section">
                        <label>‚úèÔ∏è M√¥ t·∫£:</label>
                        <textarea id="pdfDescription" placeholder="Th√™m m√¥ t·∫£ cho PDF..." rows="3">Processed images.</textarea>
                    </div>

                    <div class="config-section">
                        <label>üè∑Ô∏è Hi·ªÉn th·ªã t√™n file:</label>
                        <input type="checkbox" id="showFilenames" checked>
                        <span>Hi·ªÉn th·ªã t√™n file d∆∞·ªõi m·ªói ·∫£nh</span>
                    </div>

                    <div class="config-section">
                        <label>üìä Hi·ªÉn th·ªã th√¥ng tin:</label>
                        <input type="checkbox" id="showImageInfo" checked>
                        <span>Hi·ªÉn th·ªã k√≠ch th∆∞·ªõc v√† format</span>
                    </div>

                    <div class="config-section">
                        <label>üìÖ Th√™m ng√†y th√°ng:</label>
                        <input type="checkbox" id="addTimestamp" checked>
                        <span>Th√™m timestamp v√†o PDF</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn cancel" id="cancelPdf">‚ùå H·ªßy</button>
                <button class="modal-btn primary" id="generatePdf">üìÑ T·∫°o PDF</button>
            </div>
        </div>
    </div>

    <!-- Crop Configuration Modal -->
    <div class="modal" id="cropModal" style="display: none;">
        <div class="modal-content crop-modal-content">
            <div class="modal-header">
                <h2>üî™ C·∫Øt ·∫£nh theo k√≠ch th∆∞·ªõc</h2>
                <span class="close" id="closeCropModal">&times;</span>
            </div>
            <div class="modal-body crop-modal-body">
                <div class="crop-config">
                    <!-- Template Section -->
                    <div class="crop-section template-section">
                        <h3>üìê K√≠ch th∆∞·ªõc</h3>
                        <div class="template-grid">
                            <div class="template-card" data-size="6x9">
                                <div class="template-preview">
                                    <div class="ratio-box ratio-6x9"></div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">·∫¢nh h·ªô chi·∫øu</div>
                                    <div class="template-size">6√ó9 cm</div>
                                </div>
                            </div>
                            <div class="template-card" data-size="5.5x8.5">
                                <div class="template-preview">
                                    <div class="ratio-box ratio-55x85"></div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">Th·∫ª visit</div>
                                    <div class="template-size">5.5√ó8.5 cm</div>
                                </div>
                            </div>
                            <div class="template-card active" data-size="10x15">
                                <div class="template-preview">
                                    <div class="ratio-box ratio-10x15"></div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">·∫¢nh 4√ó6</div>
                                    <div class="template-size">10√ó15 cm</div>
                                </div>
                            </div>
                            <div class="template-card" data-size="13x18">
                                <div class="template-preview">
                                    <div class="ratio-box ratio-13x18"></div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">·∫¢nh 5√ó7</div>
                                    <div class="template-size">13√ó18 cm</div>
                                </div>
                            </div>
                            <div class="template-card" data-size="20x25">
                                <div class="template-preview">
                                    <div class="ratio-box ratio-20x25"></div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">·∫¢nh 8√ó10</div>
                                    <div class="template-size">20√ó25 cm</div>
                                </div>
                            </div>
                            <div class="template-card custom" data-size="custom">
                                <div class="template-preview">
                                    <div class="ratio-box custom-box">
                                        <span>?</span>
                                    </div>
                                </div>
                                <div class="template-info">
                                    <div class="template-name">T√πy ch·ªânh</div>
                                    <div class="template-size">Custom</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="size-details" id="sizeDetails">
                            <div class="detail-item">
                                <span class="detail-label">K√≠ch th∆∞·ªõc:</span>
                                <span class="detail-value" id="currentSize">10√ó15 cm</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Pixel (300 DPI):</span>
                                <span class="detail-value" id="currentPixels">1181√ó1772px</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">T·ª∑ l·ªá:</span>
                                <span class="detail-value" id="currentRatio">2:3</span>
                            </div>
                        </div>
                    </div>

                    <!-- Custom Size Section -->
                    <div class="crop-section custom-section" id="customSizeSection" style="display: none;">
                        <h3>üìè K√≠ch th∆∞·ªõc t√πy ch·ªânh</h3>
                        <div class="custom-inputs">
                            <div class="input-group">
                                <label>Chi·ªÅu r·ªông</label>
                                <div class="input-with-unit">
                                    <input type="number" id="cropWidth" value="10" min="0.5" max="50" step="0.1">
                                    <span class="unit">cm</span>
                                </div>
                            </div>
                            <div class="input-group">
                                <label>Chi·ªÅu cao</label>
                                <div class="input-with-unit">
                                    <input type="number" id="cropHeight" value="15" min="0.5" max="50" step="0.1">
                                    <span class="unit">cm</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Settings Section -->
                    <div class="crop-section settings-section">
                        <h3>‚öôÔ∏è C√†i ƒë·∫∑t</h3>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <label>üéØ Ch·∫ø ƒë·ªô c·∫Øt</label>
                                <select id="cropMode" class="modern-select">
                                    <option value="auto">T·ª± ƒë·ªông - C·∫Øt trung t√¢m</option>
                                    <option value="smart">Th√¥ng minh - Ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng</option>
                                    <option value="manual">Th·ªß c√¥ng - ƒêi·ªÅu ch·ªânh t·ª´ng ·∫£nh</option>
                                </select>
                            </div>

                            <div class="setting-item">
                                <label>üìä Ch·∫•t l∆∞·ª£ng DPI</label>
                                <select id="cropDPI" class="modern-select" disabled>
                                    <option value="300" selected>300 DPI - Ch·∫•t l∆∞·ª£ng t·ªëi ƒëa (C·ªê ƒê·ªäNH)</option>
                                </select>
                            </div>

                            <div class="setting-item">
                                <label>‚öô X·ª≠ l√Ω vi·ªÅn</label>
                                <select id="cropBackground" class="modern-select">
                                    <option value="fill">ƒê·∫ßy khung - C·∫Øt ·∫£nh v·ª´a khung</option>
                                    <option value="fit">V·ª´a kh√≠t - Th√™m vi·ªÅn tr·∫Øng</option>
                                    <option value="stretch">K√©o gi√£n - Bi·∫øn d·∫°ng ·∫£nh</option>
                                </select>
                                <div class="setting-help" id="edgeModeHelp">
                                    <span id="edgeModeDetails">Ch·ªçn c√°ch x·ª≠ l√Ω khi ·∫£nh kh√¥ng v·ª´a t·ª∑ l·ªá khung c·∫Øt</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Process Mode Section -->
                    <div class="crop-section process-section">
                        <h3>‚ö° Ch·∫ø ƒë·ªô x·ª≠ l√Ω</h3>
                        <div class="process-modes">
                            <label class="mode-card">
                                <input type="radio" name="cropProcessMode" value="preview">
                                <div class="mode-icon">üëÅÔ∏è</div>
                                <div class="mode-info">
                                    <div class="mode-name">Xem tr∆∞·ªõc</div>
                                    <div class="mode-desc">Ki·ªÉm tra tr∆∞·ªõc khi c·∫Øt</div>
                                </div>
                            </label>
                            <label class="mode-card">
                                <input type="radio" name="cropProcessMode" value="batch">
                                <div class="mode-icon">üìã</div>
                                <div class="mode-info">
                                    <div class="mode-name">H√†ng lo·∫°t</div>
                                    <div class="mode-desc">C·∫Øt t·∫•t c·∫£ c√πng l√∫c</div>
                                </div>
                            </label>
                            <label class="mode-card active">
                                <input type="radio" name="cropProcessMode" value="individual" checked>
                                <div class="mode-icon">üéØ</div>
                                <div class="mode-info">
                                    <div class="mode-name">T·ª´ng ·∫£nh</div>
                                    <div class="mode-desc">ƒêi·ªÅu ch·ªânh ri√™ng bi·ªát</div>
                                </div>
                            </label>
                        </div>
                        
                        <div class="naming-section">
                            <label>üè∑Ô∏è ƒê·∫∑t t√™n file</label>
                            <select id="cropNaming" class="modern-select">
                                <option value="append">Th√™m k√≠ch th∆∞·ªõc v√†o t√™n</option>
                                <option value="replace">Thay th·∫ø: "cropped_[k√≠ch th∆∞·ªõc]"</option>
                                <option value="keep">Gi·ªØ nguy√™n t√™n g·ªëc</option>
                            </select>
                        </div>
                    </div>

                    <div class="preview-info">
                        <h3>Th√¥ng tin chi ti·∫øt:</h3>
                        <div class="info-grid">
                            <div class="info-item">
                                <strong>K√≠ch th∆∞·ªõc:</strong> <span id="cropSizeInfo">6√ó9 cm</span>
                            </div>
                            <div class="info-item">
                                <strong>Pixels (300 DPI):</strong> <span id="cropPixelInfo">708√ó1063 px</span>
                            </div>
                            <div class="info-item">
                                <strong>T·ª∑ l·ªá:</strong> <span id="cropRatioInfo">2:3</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn cancel" id="cancelCrop">‚ùå H·ªßy</button>
                <button class="modal-btn secondary" id="downloadCropConfigZip">üì¶ T·∫£i ZIP</button>
                <button class="modal-btn primary" id="startCropping">‚úÇÔ∏è B·∫Øt ƒë·∫ßu c·∫Øt</button>
            </div>
        </div>
    </div>

    <!-- Crop Preview Gallery Modal -->
    <div class="modal" id="cropPreviewModal" style="display: none;">
        <div class="modal-content crop-preview-content">
            <div class="modal-header">
                <h2>Xem tr∆∞·ªõc c·∫Øt ·∫£nh - <span id="previewModeTitle">Ch·∫ø ƒë·ªô m·∫´u</span></h2>
                <div class="preview-stats">
                    <span id="previewCount">0/0</span>
                </div>
                <span class="close" id="closePreviewModal">&times;</span>
            </div>
            <div class="modal-body preview-gallery-body">
                <div class="preview-controls-top">
                    <div class="template-info">
                        <span>üìê K√≠ch th∆∞·ªõc: <span id="previewTemplateSize">6√ó9 cm</span></span>
                        <span>üìè Pixel: <span id="previewPixelSize">709√ó1063px</span></span>
                        <span>üéØ Ch·∫ø ƒë·ªô: <span id="previewCropMode">Smart</span></span>
                    </div>
                    <div class="batch-controls">
                        <button class="preview-btn" id="acceptAllPreviews">‚úÖ Ch·∫•p nh·∫≠n t·∫•t c·∫£</button>
                        <button class="preview-btn secondary" id="selectAllPreviews">‚òëÔ∏è Ch·ªçn t·∫•t c·∫£</button>
                        <button class="preview-btn secondary" id="clearAllPreviews">‚ùå B·ªè ch·ªçn t·∫•t c·∫£</button>
                    </div>
                </div>
                
                <div class="preview-gallery" id="previewGallery">
                    <!-- Preview items will be generated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn cancel" id="cancelPreview">‚ùå H·ªßy</button>
                <button class="modal-btn secondary" id="downloadCropPreviewZip">üì¶ T·∫£i ZIP</button>
                <button class="modal-btn" id="cropSelectedPreviews">‚úÇÔ∏è C·∫Øt ƒë√£ ch·ªçn (<span id="selectedCount">0</span>)</button>
                <button class="modal-btn primary" id="cropAllPreviews">üöÄ C·∫Øt t·∫•t c·∫£</button>
            </div>
        </div>
    </div>

    <!-- Multi-Image Crop Editor Modal -->
    <div class="modal" id="cropEditorModal" style="display: none;">
        <div class="modal-content multi-crop-editor-content">
            <div class="modal-header">
                <h2>Ch·ªânh s·ª≠a c·∫Øt ·∫£nh h√†ng lo·∫°t</h2>
                <div class="crop-progress">
                    <span id="multiCropProgress">5 ·∫£nh</span>
                </div>
                <span class="close" id="closeCropEditor">&times;</span>
            </div>
            <div class="modal-body multi-crop-editor-body">
                <!-- Global Controls -->
                <div class="global-crop-controls">
                    <div class="global-info">
                        <div class="target-size-display">
                            <span class="info-label">K√≠ch th∆∞·ªõc m·ª•c ti√™u:</span>
                            <span id="globalTargetSize">6√ó9 cm</span>
                        </div>
                        <div class="aspect-ratio-display">
                            <span class="info-label">T·ª∑ l·ªá:</span>
                            <span id="globalAspectRatio">2:3</span>
                        </div>
                    </div>
                    <div class="global-actions">
                        <button class="global-btn" id="resetAllCrops">ƒê·∫∑t l·∫°i t·∫•t c·∫£</button>
                        <button class="global-btn" id="centerAllCrops">CƒÉn gi·ªØa t·∫•t c·∫£</button>
                        <button class="global-btn" id="fitAllCrops">T·ªëi ƒëa t·∫•t c·∫£</button>
                        <button class="global-btn toggle" id="globalAspectLock">Kh√≥a t·ª∑ l·ªá</button>
                        <button class="global-btn toggle" id="globalSizeLock">Kh√≥a k√≠ch th∆∞·ªõc</button>
                    </div>
                </div>

                <!-- Multi-Image Grid -->
                <div class="multi-crop-container" id="multiCropContainer">
                    <!-- Dynamic crop cards will be inserted here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn cancel" id="cancelMultiCrop">
                    <span>‚ùå</span> H·ªßy b·ªè
                </button>
                <div style="display: flex; gap: 12px; align-items: center;">
                    <button class="modal-btn secondary" id="selectAllCrops">
                        <span>‚òëÔ∏è</span> Ch·ªçn t·∫•t c·∫£
                    </button>
                    <button class="modal-btn primary" id="acceptAllCrops">
                        <span>‚úÇÔ∏è</span> C·∫Øt t·∫•t c·∫£ ·∫£nh ƒë√£ ch·ªçn
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Template Crop Editor Modal (Fixed Aspect Ratio) -->
    <!-- Polaroid Template Crop Modal - Enhanced cropPage-style Interface -->
    <div class="modal" id="templateCropModal" style="display: none;">
        <div class="modal-content template-crop-page-content">
            <div class="modal-header template-crop-header">
                <div class="template-header-left">
                    <h2>‚úÇÔ∏è C·∫Øt ·∫£nh Polaroid Template</h2>
                    <div class="template-progress-info">
                        <span id="templateCropProgress">1/5 ·∫£nh</span>
                        <span class="template-size-info" id="templateSizeDisplay">5.5√ó8.5 cm</span>
                    </div>
                </div>
                <span class="close" id="closeTemplateCrop">&times;</span>
            </div>
            
            <div class="modal-body template-crop-page-body">
                <div class="template-crop-sidebar">
                    <!-- Template Configuration Section -->
                    <div class="template-section template-config-section">
                        <h3>üìê C·∫•u h√¨nh Template</h3>

                        <!-- Template Type Selection -->
                        <div class="template-type-selection">
                            <label class="template-type-label">üé® Lo·∫°i Template:</label>
                            <div class="template-type-options">
                                <label class="template-type-card active">
                                    <input type="radio" name="polaroidTemplateType" value="type1" checked>
                                    <div class="type-icon">üìê</div>
                                    <div class="type-info">
                                        <div class="type-name">Polaroid 1</div>
                                        <div class="type-desc">Chu·∫©n</div>
                                    </div>
                                </label>
                                <label class="template-type-card">
                                    <input type="radio" name="polaroidTemplateType" value="type2">
                                    <div class="type-icon">üñºÔ∏è</div>
                                    <div class="type-info">
                                        <div class="type-name">Polaroid 2</div>
                                        <div class="type-desc">M·ªõi</div>
                                    </div>
                                </label>
                            </div>
                        </div>

                        <div class="template-size-details">
                            <div class="detail-item">
                                <span class="detail-label">K√≠ch th∆∞·ªõc:</span>
                                <span class="detail-value" id="templateCurrentSizeDetail">5.5√ó8.5 cm</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Pixel (300 DPI):</span>
                                <span class="detail-value" id="templateCurrentPixels">650√ó1000px</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">T·ª∑ l·ªá ·∫£nh chu·∫©n:</span>
                                <span class="detail-value highlight" id="templateAspectRatio">1:1.55</span>
                            </div>
                        </div>
                        
                        <div class="template-border-info">
                            <h4>üñºÔ∏è Vi·ªÅn Polaroid</h4>
                            <div class="border-details">
                                <div class="border-item">
                                    <span class="border-label">Tr√™n/Tr√°i/Ph·∫£i:</span>
                                    <span class="border-value" id="templateBorderTLR">50-45-45px</span>
                                </div>
                                <div class="border-item">
                                    <span class="border-label">Caption (d∆∞·ªõi):</span>
                                    <span class="border-value" id="templateBorderBottom">175px</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Crop Settings Section -->
                    <div class="template-section template-settings-section">
                        <h3>‚öôÔ∏è C√†i ƒë·∫∑t Crop</h3>
                        <div class="template-settings-grid">
                            <div class="setting-item">
                                <label>üéØ Ch·∫ø ƒë·ªô c·∫Øt</label>
                                <select id="templateCropMode" class="modern-select">
                                    <option value="manual" selected>Th·ªß c√¥ng - ƒêi·ªÅu ch·ªânh t·ª´ng ·∫£nh</option>
                                    <option value="auto">T·ª± ƒë·ªông - C·∫Øt trung t√¢m</option>
                                    <option value="smart">Th√¥ng minh - Ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng</option>
                                </select>
                            </div>

                            <div class="setting-item">
                                <label>üìä Ch·∫•t l∆∞·ª£ng DPI</label>
                                <select id="templateCropDPI" class="modern-select" disabled>
                                    <option value="300" selected>300 DPI - Ch·∫•t l∆∞·ª£ng t·ªëi ƒëa (C·ªê ƒê·ªäNH)</option>
                                </select>
                            </div>

                            <div class="setting-item">
                                <label>‚öô X·ª≠ l√Ω vi·ªÅn</label>
                                <select id="templateCropBackground" class="modern-select">
                                    <option value="fill" selected>ƒê·∫ßy khung - C·∫Øt ·∫£nh v·ª´a khung</option>
                                    <option value="fit">V·ª´a kh√≠t - Th√™m vi·ªÅn tr·∫Øng</option>
                                    <option value="stretch">K√©o gi√£n - Bi·∫øn d·∫°ng ·∫£nh</option>
                                </select>
                                <div class="setting-help">
                                    <span>X·ª≠ l√Ω khi ·∫£nh kh√¥ng v·ª´a t·ª∑ l·ªá 1:1.55</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Crop Controls Section -->
                    <div class="template-section template-controls-section">
                        <h3>üéõÔ∏è ƒêi·ªÅu khi·ªÉn</h3>
                        <div class="template-position-controls">
                            <button class="control-btn" id="templateCenter">üìç CƒÉn gi·ªØa</button>
                            <button class="control-btn" id="templateReset">üîÑ ƒê·∫∑t l·∫°i</button>
                        </div>
                        
                        <div class="template-display-controls">
                            <button class="toggle-btn" id="templateGrid">üìè L∆∞·ªõi</button>
                            <button class="toggle-btn" id="templateGuides">üìê H∆∞·ªõng d·∫´n</button>
                            <button class="toggle-btn" id="templateBorderPreview">üñºÔ∏è Preview vi·ªÅn</button>
                        </div>
                    </div>

                    <!-- Process Mode Section -->
                    <div class="template-section template-process-section">
                        <h3>‚ö° Ch·∫ø ƒë·ªô x·ª≠ l√Ω</h3>
                        <div class="template-process-modes">
                            <label class="mode-card active">
                                <input type="radio" name="templateProcessMode" value="individual" checked>
                                <div class="mode-icon">üéØ</div>
                                <div class="mode-info">
                                    <div class="mode-name">T·ª´ng ·∫£nh</div>
                                    <div class="mode-desc">ƒêi·ªÅu ch·ªânh ri√™ng bi·ªát</div>
                                </div>
                            </label>
                            <label class="mode-card">
                                <input type="radio" name="templateProcessMode" value="batch">
                                <div class="mode-icon">üìã</div>
                                <div class="mode-info">
                                    <div class="mode-name">H√†ng lo·∫°t</div>
                                    <div class="mode-desc">C·∫Øt t·∫•t c·∫£ c√πng l√∫c</div>
                                </div>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="template-crop-main">
                    <div class="template-crop-workspace">
                        <div class="template-workspace-header">
                            <div class="current-image-info">
                                <h4 id="templateImageName">image1.jpg</h4>
                                <span class="image-dimensions" id="templateImageDimensions">1920√ó1280px</span>
                            </div>
                            <div class="workspace-controls">
                                <button class="workspace-btn" id="templateFitToScreen">üîç Fit m√†n h√¨nh</button>
                                <button class="workspace-btn" id="templateActualSize">üìè K√≠ch th∆∞·ªõc th·ª±c</button>
                            </div>
                        </div>
                        
                        <div class="template-image-container">
                            <div id="templateCropContainer" class="template-crop-container">
                                <canvas id="templateCropCanvas" class="template-crop-canvas"></canvas>
                                <div id="templateCropOverlay" class="template-crop-overlay">
                                    <div id="templateCropSelection" class="template-crop-selection">
                                        <!-- Move handle -->
                                        <div class="template-move-handle">‚ú•</div>
                                        
                                        <!-- Resize handles with aspect ratio lock -->
                                        <div class="template-resize-handle nw" data-direction="nw"></div>
                                        <div class="template-resize-handle ne" data-direction="ne"></div>
                                        <div class="template-resize-handle sw" data-direction="sw"></div>
                                        <div class="template-resize-handle se" data-direction="se"></div>
                                        
                                        <div class="template-selection-info">
                                            <span id="templateSelectionSize">650√ó1000px</span>
                                            <span class="selection-status" id="templateSelectionStatus">‚úÖ T·ª∑ l·ªá chu·∫©n</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="template-workspace-footer">
                            <div class="crop-preview-mini">
                                <h5>üëÅÔ∏è Preview k·∫øt qu·∫£</h5>
                                <div class="mini-preview-container">
                                    <canvas id="templateMiniPreview" class="template-mini-preview"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="modal-footer template-crop-footer">
                <div class="template-nav-controls">
                    <button class="nav-btn" id="prevTemplateImage" disabled>‚óÄ Tr∆∞·ªõc</button>
                    <span class="nav-status" id="templateNavStatus">1 / 5</span>
                    <button class="nav-btn" id="nextTemplateImage">Sau ‚ñ∂</button>
                </div>
                <div class="template-action-controls">
                    <button class="modal-btn cancel" id="cancelTemplateCrop">‚ùå H·ªßy</button>
                    <button class="modal-btn secondary" id="skipTemplateImage">‚è≠Ô∏è B·ªè qua</button>
                    <button class="modal-btn secondary" id="downloadCropZip">üì¶ T·∫£i t·∫•t c·∫£</button>
                    <button class="modal-btn primary" id="cropTemplateImage">‚úÇÔ∏è C·∫Øt ·∫£nh n√†y</button>
                </div>
            </div>
        </div>
    </div>


    <!-- Preview Before Download Modal -->
    <div class="modal" id="previewModal" style="display: none;" onclick="converter.handleModalClick(event)">
        <div class="modal-content preview-modal-content" onclick="event.stopPropagation()">
            <div class="modal-header preview-modal-header">
                <h2>
                    <span>üëÅÔ∏è</span>
                    <span id="previewModalTitle">Preview File</span>
                </h2>
                <button class="close" onclick="converter.hidePreviewModal()">&times;</button>
            </div>
            <div class="modal-body preview-modal-body">
                <div id="previewLoadingContainer" class="preview-loading">
                    <div class="preview-loading-spinner"></div>
                    <p>ƒêang t·∫£i preview...</p>
                </div>
                
                <div id="previewContentContainer" class="preview-container" style="display: none;">
                    <div class="preview-image-container">
                        <img id="previewImage" class="preview-image" alt="Preview">
                        <div class="preview-image-info">
                            <div id="previewImageDimensions">ƒêang t·∫£i k√≠ch th∆∞·ªõc...</div>
                        </div>
                    </div>
                    
                    <div class="preview-details">
                        <h3>üìã Th√¥ng tin chi ti·∫øt</h3>
                        <div class="detail-grid">
                            <div class="detail-item">
                                <span class="detail-label">T√™n file</span>
                                <span class="detail-value" id="previewFileName">...</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">ƒê·ªãnh d·∫°ng</span>
                                <span class="detail-value" id="previewFormat">...</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">K√≠ch th∆∞·ªõc file</span>
                                <span class="detail-value" id="previewFileSize">...</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Ch·∫•t l∆∞·ª£ng</span>
                                <span class="detail-value" id="previewQuality">...</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">K√≠ch th∆∞·ªõc ·∫£nh</span>
                                <span class="detail-value" id="previewDimensions">...</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">DPI/ƒê·ªô ph√¢n gi·∫£i</span>
                                <span class="detail-value" id="previewDPI">300 DPI</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer preview-modal-footer">
                <button class="preview-btn cancel" onclick="converter.hidePreviewModal()">
                    <span>‚ùå</span>
                    <span>Cancel</span>
                </button>
                <button class="preview-btn download" id="previewDownloadBtn" onclick="converter.confirmDownload()">
                    <span>üíæ</span>
                    <span>Download</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Save/Edit Preset Modal -->
    <div class="modal" id="presetModal" style="display: none;">
        <div class="modal-content preset-modal-content">
            <div class="modal-header">
                <h2 id="presetModalTitle">üíæ L∆∞u preset m·ªõi</h2>
                <span class="close" id="closePresetModal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="preset-form">
                    <!-- T√™n preset -->
                    <div class="form-group">
                        <label for="presetName">T√™n preset <span class="required">*</span></label>
                        <input type="text" id="presetName" placeholder="VD: A4 d·ªçc - ·∫£nh 5.5√ó8.5cm" maxlength="50">
                        <small class="form-hint">T·ªëi ƒëa 50 k√Ω t·ª±</small>
                    </div>

                    <!-- Icon preset -->
                    <div class="form-group">
                        <label>Icon (t√πy ch·ªçn)</label>
                        <div class="icon-picker">
                            <button class="icon-option active" data-icon="üìÑ">üìÑ</button>
                            <button class="icon-option" data-icon="üñºÔ∏è">üñºÔ∏è</button>
                            <button class="icon-option" data-icon="üì∏">üì∏</button>
                            <button class="icon-option" data-icon="üé®">üé®</button>
                            <button class="icon-option" data-icon="üìê">üìê</button>
                            <button class="icon-option" data-icon="‚úÇÔ∏è">‚úÇÔ∏è</button>
                            <button class="icon-option" data-icon="‚≠ê">‚≠ê</button>
                            <button class="icon-option" data-icon="üíé">üíé</button>
                            <button class="icon-option" data-icon="üî•">üî•</button>
                            <button class="icon-option" data-icon="‚ö°">‚ö°</button>
                        </div>
                    </div>

                    <!-- M√¥ t·∫£ ng·∫Øn -->
                    <div class="form-group">
                        <label for="presetDescription">M√¥ t·∫£ (t√πy ch·ªçn)</label>
                        <textarea id="presetDescription" rows="2" placeholder="VD: D√πng cho in ·∫£nh th·∫ª CCCD, h·ªô chi·∫øu" maxlength="100"></textarea>
                        <small class="form-hint">T·ªëi ƒëa 100 k√Ω t·ª±</small>
                    </div>

                    <!-- Preview c·∫•u h√¨nh -->
                    <div class="form-group">
                        <label>Preview c·∫•u h√¨nh</label>
                        <div class="preset-config-preview" id="presetConfigPreview">
                            <div class="config-item">
                                <span class="config-label">üìÑ Gi·∫•y:</span>
                                <span class="config-value" id="previewPaperSize">-</span>
                            </div>
                            <div class="config-item">
                                <span class="config-label">üñºÔ∏è ·∫¢nh:</span>
                                <span class="config-value" id="previewPhotoSize">-</span>
                            </div>
                            <div class="config-item">
                                <span class="config-label">üìè L·ªÅ:</span>
                                <span class="config-value" id="previewMargins">-</span>
                            </div>
                            <div class="config-item">
                                <span class="config-label">‚äû L∆∞·ªõi:</span>
                                <span class="config-value" id="previewGrid">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn cancel" id="cancelPresetSave">‚ùå H·ªßy</button>
                <button class="modal-btn primary" id="confirmPresetSave">üíæ L∆∞u preset</button>
            </div>
        </div>
    </div>

    <script>
        // üöÄ T·ª∞ ƒê·ªòNG CHO PH√âP MULTIPLE DOWNLOADS - Bypass browser restrictions
        (() => {
            // Override browser download policy
            if (typeof window !== 'undefined') {
                // Auto-allow multiple downloads for this domain - DISABLED
                // Commented out to prevent automatic file downloads
                /*
                const autoAllowDownloads = () => {
                    try {
                        // Create invisible element to trigger user gesture
                        const trigger = document.createElement('div');
                        trigger.style.position = 'absolute';
                        trigger.style.left = '-9999px';
                        trigger.style.width = '1px';
                        trigger.style.height = '1px';
                        document.body.appendChild(trigger);

                        // Simulate user interaction to enable downloads
                        const clickEvent = new MouseEvent('click', {
                            bubbles: true,
                            cancelable: true,
                            view: window
                        });
                        trigger.dispatchEvent(clickEvent);

                        // Cleanup
                        setTimeout(() => {
                            if (trigger.parentNode) {
                                trigger.parentNode.removeChild(trigger);
                            }
                        }, 100);

                        console.log('‚úÖ Auto-allow multiple downloads enabled');
                    } catch (e) {
                        console.warn('Could not auto-enable downloads:', e);
                    }
                };

                // Enable on page load - DISABLED
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', autoAllowDownloads);
                } else {
                    autoAllowDownloads();
                }
                */
                console.log('üö´ Auto-download permissions disabled to prevent temp file downloads');

                // Re-enable on any user interaction - DISABLED
                /*
                ['click', 'keydown', 'touchstart'].forEach(event => {
                    document.addEventListener(event, autoAllowDownloads, { once: true, passive: true });
                });
                */
            }
        })();

        // üìÅ Global Directory Handle - Shared across all instances
        window.globalDirectoryHandle = null;

        // üìÅ File System Storage Class - Qu·∫£n l√Ω l∆∞u tr·ªØ file thay v√¨ localStorage
        window.FileSystemStorage = class FileSystemStorage {
            constructor() {
                // S·ª≠ d·ª•ng global handle v√† ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
                this.directoryHandle = window.globalDirectoryHandle;
                this.dataFileName = 'meu-layout-data.json';
                this.isSupported = 'showDirectoryPicker' in window;

                // Theo d√µi global handle thay ƒë·ªïi
                this.syncWithGlobalHandle();
            }

            // ƒê·ªìng b·ªô v·ªõi global handle
            syncWithGlobalHandle() {
                // Ki·ªÉm tra v√† c·∫≠p nh·∫≠t handle ƒë·ªãnh k·ª≥
                setInterval(() => {
                    if (window.globalDirectoryHandle && this.directoryHandle !== window.globalDirectoryHandle) {
                        this.directoryHandle = window.globalDirectoryHandle;
                        console.log('üîÑ ƒê√£ ƒë·ªìng b·ªô directoryHandle v·ªõi global');
                    }
                }, 1000); // Ki·ªÉm tra m·ªói gi√¢y
            }

            // Kh·ªüi t·∫°o v√† y√™u c·∫ßu quy·ªÅn truy c·∫≠p th∆∞ m·ª•c
            async init() {
                if (!this.isSupported) {
                    throw new Error('File System Access API kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ trong tr√¨nh duy·ªát n√†y');
                }

                // Ki·ªÉm tra global handle tr∆∞·ªõc
                if (window.globalDirectoryHandle && await this.verifyPermission(window.globalDirectoryHandle)) {
                    this.directoryHandle = window.globalDirectoryHandle;
                    return;
                }

                try {
                    // Y√™u c·∫ßu ng∆∞·ªùi d√πng ch·ªçn th∆∞ m·ª•c ƒë·ªÉ l∆∞u tr·ªØ
                    const handle = await window.showDirectoryPicker({
                        mode: 'readwrite',
                        startIn: 'documents'
                    });

                    // L∆∞u v√†o global v√† instance
                    window.globalDirectoryHandle = handle;
                    this.directoryHandle = handle;

                    // C·∫≠p nh·∫≠t t·∫•t c·∫£ instances hi·ªán c√≥
                    this.updateAllInstances(handle);

                    // üßπ Cleanup localStorage khi ƒë√£ c√≥ File System
                    this.cleanupLocalStorageAfterFileSystem();

                    console.log('‚úÖ ƒê√£ c·∫•p quy·ªÅn truy c·∫≠p file system:', handle.name);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Ng∆∞·ªùi d√πng ƒë√£ h·ªßy vi·ªác c·∫•p quy·ªÅn file system');
                    }
                    throw error;
                }
            }

            // C·∫≠p nh·∫≠t t·∫•t c·∫£ instances v·ªõi handle m·ªõi
            updateAllInstances(handle) {
                // C·∫≠p nh·∫≠t converter instance
                if (window.converter && window.converter.fileSystemStorage) {
                    window.converter.fileSystemStorage.directoryHandle = handle;
                }

                // C·∫≠p nh·∫≠t cropper instance
                if (window.cropper && window.cropper.fileSystemStorage) {
                    window.cropper.fileSystemStorage.directoryHandle = handle;
                }

                // C·∫≠p nh·∫≠t gallery instance
                if (window.galleryManager && window.galleryManager.fileSystemStorage) {
                    window.galleryManager.fileSystemStorage.directoryHandle = handle;
                }

                // C·∫≠p nh·∫≠t print instance
                if (window.printManager && window.printManager.fileSystemStorage) {
                    window.printManager.fileSystemStorage.directoryHandle = handle;
                }

                console.log('üîÑ ƒê√£ c·∫≠p nh·∫≠t directoryHandle cho t·∫•t c·∫£ instances');
            }

            // üßπ Cleanup localStorage khi ƒë√£ c√≥ File System
            cleanupLocalStorageAfterFileSystem() {
                try {
                    console.log('üßπ B·∫Øt ƒë·∫ßu cleanup localStorage sau khi c√≥ File System...');

                    // X√≥a gallery data t·ª´ localStorage
                    if (localStorage.getItem('meu-layout-gallery')) {
                        localStorage.removeItem('meu-layout-gallery');
                        console.log('‚úÖ ƒê√£ x√≥a meu-layout-gallery t·ª´ localStorage');
                    }

                    // X√≥a c√°c data c≈© kh√°c n·∫øu c√≥
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && (key.includes('meu-layout') || key.includes('gallery') || key.includes('converted'))) {
                            keysToRemove.push(key);
                        }
                    }

                    keysToRemove.forEach(key => {
                        localStorage.removeItem(key);
                        console.log(`‚úÖ ƒê√£ x√≥a ${key} t·ª´ localStorage`);
                    });

                    console.log(`üßπ Cleanup ho√†n th√†nh! ƒê√£ x√≥a ${keysToRemove.length + 1} items t·ª´ localStorage`);

                    // Th√¥ng b√°o cho user
                    if (window.converter && typeof window.converter.showToast === 'function') {
                        window.converter.showToast('üßπ ƒê√£ d·ªçn d·∫πp b·ªô nh·ªõ tr√¨nh duy·ªát c≈©!', 'success');
                    }
                } catch (error) {
                    console.error('‚ùå L·ªói cleanup localStorage:', error);
                }
            }

            // Ki·ªÉm tra quy·ªÅn truy c·∫≠p
            async verifyPermission(handle = null) {
                const targetHandle = handle || this.directoryHandle;
                if (!targetHandle) return false;

                try {
                    const permission = await targetHandle.queryPermission({ mode: 'readwrite' });
                    if (permission === 'granted') return true;

                    // Y√™u c·∫ßu quy·ªÅn n·∫øu ch∆∞a c√≥
                    const newPermission = await targetHandle.requestPermission({ mode: 'readwrite' });
                    return newPermission === 'granted';
                } catch (error) {
                    console.error('L·ªói ki·ªÉm tra quy·ªÅn:', error);
                    return false;
                }
            }

            // ƒê·ªçc d·ªØ li·ªáu t·ª´ file
            async getItem(key) {
                try {
                    const fileHandle = await this.directoryHandle.getFileHandle(this.dataFileName);
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    const data = JSON.parse(text);
                    return data[key];
                } catch (error) {
                    if (error.name === 'NotFoundError') {
                        // File ch∆∞a t·ªìn t·∫°i
                        return null;
                    }
                    throw error;
                }
            }

            // L∆∞u d·ªØ li·ªáu v√†o file
            async setItem(key, value) {
                try {
                    // ƒê·ªçc d·ªØ li·ªáu hi·ªán t·∫°i
                    let currentData = {};
                    try {
                        const fileHandle = await this.directoryHandle.getFileHandle(this.dataFileName);
                        const file = await fileHandle.getFile();
                        const text = await file.text();
                        currentData = JSON.parse(text);
                    } catch (error) {
                        if (error.name !== 'NotFoundError') {
                            throw error;
                        }
                    }

                    // C·∫≠p nh·∫≠t d·ªØ li·ªáu
                    currentData[key] = value;

                    // L∆∞u file m·ªõi
                    const fileHandle = await this.directoryHandle.getFileHandle(this.dataFileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(currentData, null, 2));
                    await writable.close();

                    console.log(`‚úÖ ƒê√£ l∆∞u ${key} v√†o file system`);
                } catch (error) {
                    console.error(`‚ùå L·ªói l∆∞u ${key}:`, error);
                    throw error;
                }
            }

            // X√≥a d·ªØ li·ªáu
            async removeItem(key) {
                try {
                    const fileHandle = await this.directoryHandle.getFileHandle(this.dataFileName);
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    const data = JSON.parse(text);

                    delete data[key];

                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(data, null, 2));
                    await writable.close();

                    console.log(`‚úÖ ƒê√£ x√≥a ${key} kh·ªèi file system`);
                } catch (error) {
                    if (error.name !== 'NotFoundError') {
                        throw error;
                    }
                }
            }

            // X√≥a to√†n b·ªô d·ªØ li·ªáu
            async clear() {
                try {
                    const fileHandle = await this.directoryHandle.getFileHandle(this.dataFileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write('{}');
                    await writable.close();

                    console.log('‚úÖ ƒê√£ x√≥a to√†n b·ªô d·ªØ li·ªáu file system');
                } catch (error) {
                    console.error('‚ùå L·ªói x√≥a d·ªØ li·ªáu:', error);
                    throw error;
                }
            }

            // üé® Ph∆∞∆°ng th·ª©c qu·∫£n l√Ω giao di·ªán
            updatePermissionUI() {
                const btn = document.getElementById('filesystemPermissionBtn');
                const status = document.getElementById('permissionStatus');
                const info = document.getElementById('permissionInfo');
                const infoText = info?.querySelector('.info-text');

                if (!btn || !status || !info || !infoText) return;

                if (this.directoryHandle) {
                    // ƒê√£ c·∫•p quy·ªÅn
                    btn.classList.add('granted');
                    btn.querySelector('.permission-text').textContent = 'File System ƒê√£ C·∫•p Quy·ªÅn';
                    status.textContent = '‚úÖ';

                    infoText.innerHTML =
                        '<strong>ƒê√£ c·∫•p quy·ªÅn l∆∞u tr·ªØ</strong><br>' +
                        'Th∆∞ m·ª•c: ' + this.directoryHandle.name + '<br>' +
                        'D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c l∆∞u t·ª± ƒë·ªông';
                } else {
                    // Ch∆∞a c·∫•p quy·ªÅn
                    btn.classList.remove('granted');
                    btn.querySelector('.permission-text').textContent = 'C·∫•p quy·ªÅn File System';
                    status.textContent = '‚ùå';

                    infoText.innerHTML =
                        '<strong>Ch∆∞a c·∫•p quy·ªÅn l∆∞u tr·ªØ</strong><br>' +
                        'Nh·∫•n ƒë·ªÉ ch·ªçn th∆∞ m·ª•c l∆∞u d·ªØ li·ªáu ·ª©ng d·ª•ng';
                }
            }

            // Y√™u c·∫ßu quy·ªÅn th√¥ng qua UI
            async requestPermissionFromUI() {
                console.log('üîç requestPermissionFromUI called');

                // Prevent multiple simultaneous calls
                if (this._requesting) {
                    console.log('ƒê√£ c√≥ request permission ƒëang ch·∫°y');
                    return;
                }

                // Enhanced user activation check
                if (!navigator.userActivation) {
                    console.warn('üö´ UserActivation API not supported');
                    // Continue anyway for older browsers
                } else if (!navigator.userActivation.isActive) {
                    console.warn('üö´ User activation required for showDirectoryPicker');
                    console.log('UserActivation state:', {
                        isActive: navigator.userActivation.isActive,
                        hasBeenActive: navigator.userActivation.hasBeenActive
                    });

                    if (window.converter && typeof window.converter.showToast === 'function') {
                        window.converter.showToast('‚ùå Vui l√≤ng nh·∫•n tr·ª±c ti·∫øp v√†o n√∫t ƒë·ªÉ c·∫•p quy·ªÅn', 'warning');
                    }
                    return;
                }

                this._requesting = true;
                const btn = document.getElementById('filesystemPermissionBtn');
                const info = document.getElementById('permissionInfo');

                try {
                    // Hi·ªÉn th·ªã tr·∫°ng th√°i ƒëang x·ª≠ l√Ω
                    if (btn) {
                        btn.disabled = true;
                        btn.querySelector('.permission-text').textContent = 'ƒêang ch·ªù c·∫•p quy·ªÅn...';
                    }

                    // Y√™u c·∫ßu quy·ªÅn
                    await this.init();

                    // C·∫≠p nh·∫≠t UI th√†nh c√¥ng
                    this.updatePermissionUI();

                    // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
                    if (window.converter && window.converter.showToast) {
                        window.converter.showToast('‚úÖ ƒê√£ c·∫•p quy·ªÅn File System th√†nh c√¥ng!', 'success');
                    }

                    // ·∫®n info panel sau 3 gi√¢y
                    setTimeout(() => {
                        if (info) info.classList.remove('visible');
                    }, 3000);

                } catch (error) {
                    console.error('L·ªói c·∫•p quy·ªÅn t·ª´ UI:', error);

                    // Hi·ªÉn th·ªã l·ªói
                    if (window.converter && window.converter.showToast) {
                        if (error.message.includes('h·ªßy')) {
                            window.converter.showToast('‚ö†Ô∏è ƒê√£ h·ªßy vi·ªác c·∫•p quy·ªÅn', 'warning');
                        } else {
                            window.converter.showToast('‚ùå L·ªói c·∫•p quy·ªÅn: ' + error.message, 'error');
                        }
                    }
                } finally {
                    // Reset requesting flag
                    this._requesting = false;

                    // Kh√¥i ph·ª•c n√∫t
                    if (btn) {
                        btn.disabled = false;
                        this.updatePermissionUI();
                    }
                }
            }

            // Kh·ªüi t·∫°o event listeners cho UI
            initPermissionUI() {
                const btn = document.getElementById('filesystemPermissionBtn');
                const info = document.getElementById('permissionInfo');

                if (btn) {
                    btn.addEventListener('click', () => {
                        this.requestPermissionFromUI();
                    });

                    // Hi·ªÉn th·ªã/·∫©n info khi hover
                    btn.addEventListener('mouseenter', () => {
                        if (info) info.classList.add('visible');
                    });

                    btn.addEventListener('mouseleave', () => {
                        if (info) {
                            setTimeout(() => {
                                if (!info.matches(':hover')) {
                                    info.classList.remove('visible');
                                }
                            }, 200);
                        }
                    });
                }

                // Gi·ªØ info hi·ªÉn th·ªã khi hover v√†o ch√≠nh n√≥
                if (info) {
                    info.addEventListener('mouseenter', () => {
                        info.classList.add('visible');
                    });

                    info.addEventListener('mouseleave', () => {
                        info.classList.remove('visible');
                    });
                }

                // C·∫≠p nh·∫≠t UI ban ƒë·∫ßu
                this.updatePermissionUI();
            }

            // üîç T√≠nh nƒÉng qu√©t ·∫£nh t·ª´ th∆∞ m·ª•c
            async scanImagesFromDirectory() {
                if (!this.directoryHandle) {
                    throw new Error('Ch∆∞a c·∫•p quy·ªÅn truy c·∫≠p th∆∞ m·ª•c');
                }

                const imageFiles = [];
                const supportedTypes = ['jpg', 'jpeg', 'png', 'webp', 'gif', 'heic'];

                try {
                    // ƒê·ªçc t·∫•t c·∫£ file trong th∆∞ m·ª•c
                    for await (const [name, handle] of this.directoryHandle.entries()) {
                        if (handle.kind === 'file') {
                            const extension = name.split('.').pop()?.toLowerCase();

                            if (extension && supportedTypes.includes(extension)) {
                                const file = await handle.getFile();
                                imageFiles.push({
                                    name: name,
                                    file: file,
                                    size: file.size,
                                    type: file.type,
                                    lastModified: file.lastModified,
                                    extension: extension
                                });
                            }
                        }
                    }

                    console.log(`‚úÖ ƒê√£ qu√©t ƒë∆∞·ª£c ${imageFiles.length} ·∫£nh t·ª´ th∆∞ m·ª•c:`, this.directoryHandle.name);
                    return imageFiles;

                } catch (error) {
                    console.error('‚ùå L·ªói qu√©t ·∫£nh t·ª´ th∆∞ m·ª•c:', error);
                    throw error;
                }
            }

            // üóÇÔ∏è Enhanced: Recursive folder scanning v·ªõi folder structure
            async scanImagesRecursive(currentHandle = null, currentPath = '', maxDepth = 3, currentDepth = 0) {
                if (currentDepth > maxDepth) return [];

                const handle = currentHandle || this.directoryHandle;
                if (!handle) throw new Error('Ch∆∞a c·∫•p quy·ªÅn truy c·∫≠p th∆∞ m·ª•c');

                const imageFiles = [];
                const supportedTypes = ['jpg', 'jpeg', 'png', 'webp', 'gif', 'heic'];

                try {
                    for await (const [name, entryHandle] of handle.entries()) {
                        const fullPath = currentPath ? `${currentPath}/${name}` : name;

                        if (entryHandle.kind === 'file') {
                            const extension = name.split('.').pop()?.toLowerCase();
                            if (extension && supportedTypes.includes(extension)) {
                                const file = await entryHandle.getFile();
                                imageFiles.push({
                                    name: name,
                                    file: file,
                                    size: file.size,
                                    lastModified: file.lastModified,
                                    type: file.type,
                                    url: URL.createObjectURL(file),
                                    path: fullPath,
                                    folder: currentPath || 'Root',
                                    category: this.categorizeByPath(fullPath)
                                });
                            }
                        } else if (entryHandle.kind === 'directory') {
                            // Recursive scan subfolders
                            const subImages = await this.scanImagesRecursive(
                                entryHandle,
                                fullPath,
                                maxDepth,
                                currentDepth + 1
                            );
                            imageFiles.push(...subImages);
                        }
                    }

                    return imageFiles;
                } catch (error) {
                    console.error('‚ùå L·ªói qu√©t ·∫£nh recursive:', error);
                    throw error;
                }
            }

            // üè∑Ô∏è Smart categorization d·ª±a v√†o path
            categorizeByPath(filePath) {
                const path = filePath.toLowerCase();
                const pathParts = path.split('/');

                // Category mapping
                const categories = {
                    'convert': ['convert', 'raw', 'input', 'source'],
                    'crop': ['crop', 'cut', 'trim'],
                    'template': ['template', 'frame', 'border'],
                    'gallery': ['gallery', 'kho', 'output', 'final'],
                    'print': ['print', 'in', 'ready'],
                    'archive': ['archive', 'backup', 'old'],
                    'work': ['work', 'working', 'temp', 'draft']
                };

                for (const [category, keywords] of Object.entries(categories)) {
                    if (keywords.some(keyword =>
                        pathParts.some(part => part.includes(keyword))
                    )) {
                        return category;
                    }
                }

                return 'uncategorized';
            }

            // Alias method cho t∆∞∆°ng th√≠ch (s·ª≠ d·ª•ng recursive scan)
            async scanImages() {
                return await this.scanImagesRecursive();
            }

            // L·∫•y file ·∫£nh theo t√™n (h·ªó tr·ª£ t√¨m trong th∆∞ m·ª•c con)
            async getImageFile(fileName) {
                if (!this.directoryHandle) {
                    throw new Error('Ch∆∞a c·∫•p quy·ªÅn truy c·∫≠p th∆∞ m·ª•c');
                }

                // Tr∆∞·ªõc ti√™n t√¨m trong th∆∞ m·ª•c root
                try {
                    const fileHandle = await this.directoryHandle.getFileHandle(fileName);
                    return await fileHandle.getFile();
                } catch (rootError) {
                    // N·∫øu kh√¥ng t√¨m th·∫•y trong root, t√¨m trong c√°c th∆∞ m·ª•c con
                    try {
                        const file = await this.findFileRecursive(fileName, this.directoryHandle);
                        if (file) {
                            return file;
                        }
                    } catch (searchError) {
                        console.error('Error searching for file:', searchError);
                    }

                    // N·∫øu v·∫´n kh√¥ng t√¨m th·∫•y, tr·∫£ v·ªÅ l·ªói
                    throw new Error(`Kh√¥ng t√¨m th·∫•y file: ${fileName}`);
                }
            }

            // Helper method ƒë·ªÉ t√¨m file recursively
            async findFileRecursive(fileName, directoryHandle, maxDepth = 3, currentDepth = 0) {
                if (currentDepth > maxDepth) return null;

                try {
                    for await (const [name, entryHandle] of directoryHandle.entries()) {
                        if (entryHandle.kind === 'file' && name === fileName) {
                            return await entryHandle.getFile();
                        } else if (entryHandle.kind === 'directory') {
                            const foundFile = await this.findFileRecursive(fileName, entryHandle, maxDepth, currentDepth + 1);
                            if (foundFile) {
                                return foundFile;
                            }
                        }
                    }
                } catch (error) {
                    console.error(`L·ªói t√¨m file trong th∆∞ m·ª•c:`, error);
                }

                return null;
            }

            // L·∫•y danh s√°ch ·∫£nh c√≥ metadata (bao g·ªìm th∆∞ m·ª•c con)
            async getImagesList() {
                const images = await this.scanImagesRecursive();

                return images.map(img => ({
                    ...img,
                    url: img.url || URL.createObjectURL(img.file),
                    sizeFormatted: this.formatFileSize(img.size),
                    dateFormatted: new Date(img.lastModified).toLocaleDateString('vi-VN')
                }));
            }

            // Format file size
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            // Ki·ªÉm tra th∆∞ m·ª•c c√≥ ·∫£nh kh√¥ng
            async hasImages() {
                try {
                    const images = await this.scanImagesFromDirectory();
                    return images.length > 0;
                } catch (error) {
                    return false;
                }
            }

            // üíæ L∆ØU ·∫¢NH V√ÄO FILE SYSTEM - T√çNH NƒÇNG CH√çNH

            // L∆∞u ·∫£nh v√†o file system t·ª´ File/Blob
            async saveImageToFileSystem(imageData, fileName, subfolder = null) {
                if (!this.directoryHandle) {
                    throw new Error('‚ùå Ch∆∞a c·∫•p quy·ªÅn File System!');
                }

                try {
                    let targetDirectory = this.directoryHandle;

                    // T·∫°o subfolder n·∫øu c·∫ßn
                    if (subfolder) {
                        try {
                            targetDirectory = await this.directoryHandle.getDirectoryHandle(subfolder, { create: true });
                        } catch (error) {
                            console.error('L·ªói t·∫°o subfolder:', error);
                            throw new Error('Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c: ' + subfolder);
                        }
                    }

                    // T·∫°o file handle
                    const fileHandle = await targetDirectory.getFileHandle(fileName, { create: true });
                    const writable = await fileHandle.createWritable();

                    // Convert imageData to appropriate format
                    let dataToWrite;
                    if (imageData instanceof Blob) {
                        dataToWrite = imageData;
                    } else if (imageData instanceof File) {
                        dataToWrite = imageData;
                    } else if (typeof imageData === 'string' && imageData.startsWith('data:')) {
                        // Base64 data URL
                        const response = await fetch(imageData);
                        dataToWrite = await response.blob();
                    } else {
                        throw new Error('‚ùå ƒê·ªãnh d·∫°ng ·∫£nh kh√¥ng h·ªó tr·ª£');
                    }

                    // Ghi file
                    await writable.write(dataToWrite);
                    await writable.close();

                    const filePath = subfolder ? `${subfolder}/${fileName}` : fileName;
                    console.log(`‚úÖ ƒê√£ l∆∞u ·∫£nh v√†o File System: ${filePath}`);

                    return {
                        success: true,
                        filePath: filePath,
                        size: dataToWrite.size
                    };
                } catch (error) {
                    console.error('‚ùå L·ªói l∆∞u ·∫£nh v√†o File System:', error);
                    throw error;
                }
            }

            // L∆∞u nhi·ªÅu ·∫£nh batch v·ªõi progress callback
            async saveMultipleImages(images, subfolder = null, progressCallback = null) {
                if (!Array.isArray(images) || images.length === 0) {
                    throw new Error('‚ùå Danh s√°ch ·∫£nh tr·ªëng!');
                }

                const results = [];
                const total = images.length;

                for (let i = 0; i < total; i++) {
                    const { imageData, fileName } = images[i];

                    try {
                        const result = await this.saveImageToFileSystem(imageData, fileName, subfolder);
                        results.push({ ...result, fileName, index: i });

                        // Progress callback
                        if (progressCallback) {
                            progressCallback({
                                current: i + 1,
                                total: total,
                                fileName: fileName,
                                success: true
                            });
                        }
                    } catch (error) {
                        results.push({
                            success: false,
                            fileName,
                            index: i,
                            error: error.message
                        });

                        if (progressCallback) {
                            progressCallback({
                                current: i + 1,
                                total: total,
                                fileName: fileName,
                                success: false,
                                error: error.message
                            });
                        }
                    }

                    // Small delay to prevent overwhelming the system
                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                return results;
            }

            // L∆∞u canvas as image - LU√îN ch·∫•t l∆∞·ª£ng 100%
            async saveCanvasToFileSystem(canvas, fileName, format = 'image/png', quality = 1.0, subfolder = null) {
                return new Promise((resolve, reject) => {
                    canvas.toBlob(async (blob) => {
                        try {
                            const result = await this.saveImageToFileSystem(blob, fileName, subfolder);
                            resolve(result);
                        } catch (error) {
                            reject(error);
                        }
                    }, format, quality);
                });
            }

            // L∆∞u t·ª´ URL (fetch and save)
            async saveImageFromUrl(imageUrl, fileName, subfolder = null) {
                try {
                    const response = await fetch(imageUrl);
                    if (!response.ok) {
                        throw new Error('‚ùå Kh√¥ng th·ªÉ t·∫£i ·∫£nh t·ª´ URL');
                    }

                    const blob = await response.blob();
                    return await this.saveImageToFileSystem(blob, fileName, subfolder);
                } catch (error) {
                    console.error('‚ùå L·ªói l∆∞u ·∫£nh t·ª´ URL:', error);
                    throw error;
                }
            }

            // üì§ AUTO-SAVE UPLOADED FILES - L∆∞u ·∫£nh t·∫£i l√™n v√†o th∆∞ m·ª•c Uploaded
            async saveUploadedFile(file) {
                if (!this.directoryHandle) {
                    console.warn('‚ö†Ô∏è File System ch∆∞a ƒë∆∞·ª£c c·∫•p quy·ªÅn, kh√¥ng th·ªÉ auto-save upload');
                    return false;
                }

                try {
                    const subfolderName = 'Uploaded';
                    const result = await this.saveImageToFileSystem(file, file.name, subfolderName);
                    console.log(`‚úÖ ƒê√£ auto-save uploaded file: ${subfolderName}/${file.name}`);
                    return result;
                } catch (error) {
                    console.error('‚ùå L·ªói auto-save uploaded file:', error);
                    return false;
                }
            }
        }

        // üõ°Ô∏è Helper function ƒë·ªÉ t·∫°o FileSystemStorage an to√†n
        window.createFileSystemStorage = function() {
            try {
                if (typeof window.FileSystemStorage === 'function') {
                    const instance = new window.FileSystemStorage();
                    // ƒê·∫£m b·∫£o instance s·ª≠ d·ª•ng global handle n·∫øu c√≥
                    if (window.globalDirectoryHandle) {
                        instance.directoryHandle = window.globalDirectoryHandle;
                    }
                    return instance;
                } else {
                    console.error('‚ùå FileSystemStorage class kh√¥ng s·∫µn s√†ng');
                    return null;
                }
            } catch (error) {
                console.error('‚ùå L·ªói t·∫°o FileSystemStorage:', error);
                return null;
            }
        };

        class BatchImageConverter {
            constructor() {
                this.files = [];
                this.convertedFiles = [];
                this.currentConversion = 0;
                this.totalConversions = 0;
                this.currentCropSize = { width: 5.5, height: 8.5 };
                this.cropProcessedFiles = [];
                this.isDownloading = false;
                this.isDownloadingCropped = false;

                // Resource management for memory leaks prevention
                this.objectURLs = new Set(); // Track all created object URLs
                this.canvasElements = new Set(); // Track all canvas elements
                this.eventListeners = new Map(); // Track all event listeners for cleanup
                this.intervals = new Set(); // Track all intervals
                this.timeouts = new Set(); // Track all timeouts
                this.abortControllers = new Map(); // Track abort controllers for async operations

                // üéØ AUTO DOWNLOAD PERMISSION SETUP
                this.setupAutoDownloadPermission();

                // File System Storage - kh·ªüi t·∫°o nh∆∞ng kh√¥ng init() ƒë·ªÉ tr√°nh SecurityError
                try {
                    if (typeof window.FileSystemStorage === 'function') {
                        this.fileSystemStorage = new window.FileSystemStorage();
                    } else {
                        console.warn('‚ö†Ô∏è FileSystemStorage class ch∆∞a s·∫µn s√†ng');
                        this.fileSystemStorage = null;
                    }
                } catch (error) {
                    console.error('‚ùå L·ªói kh·ªüi t·∫°o FileSystemStorage:', error);
                    this.fileSystemStorage = null;
                }

                // Gallery management
                this.galleryImages = [];
                this.loadGalleryFromStorage().then(data => {
                    this.galleryImages = data;
                    this.updateGalleryDisplay();
                }).catch(error => {
                    console.error('L·ªói t·∫£i gallery:', error);
                    this.galleryImages = [];
                });
                this.classificationMode = false;
                this.frontImages = [];
                this.backImages = [];
                this.selectedImageForAction = null;
                
                // Quick selection mode
                this.selectionMode = false;
                this.selectionType = null; // 'front', 'back', or null
                this.selectedImages = [];

                // Duplex V2 - Undo/Redo History
                this.duplexHistory = [];
                this.duplexHistoryIndex = -1;
                this.maxHistorySize = 50;
                this.duplexCurrentMode = 'front'; // 'front' or 'back'

                // Performance optimization
                this.galleryCache = new Map();
                this.thumbnailCache = new Map();
                this.lazyLoadObserver = null;
                this.batchSize = 20;
                this.currentBatchIndex = 0;
                
                // Download folder preferences
                this.downloadSettings = {
                    folderPrefix: '',
                    useSubfolders: false,
                    subfolderNames: {
                        front: 'Mat_truoc',
                        back: 'Mat_sau', 
                        cropped: 'Da_cat',
                        original: 'Goc',
                        gallery: 'Kho_anh'
                    }
                };

                this.initializeEventListeners();

                // Load download settings t·ª´ file system (sau khi kh·ªüi t·∫°o FileSystemStorage)
                this.loadDownloadSettings().catch(error => {
                    console.error('L·ªói t·∫£i settings:', error);
                });
                this.initKeyboardShortcuts();
                this.updateStats();
                this.updateGalleryDisplay();

                // üìÅ Kh·ªüi t·∫°o giao di·ªán File System Permission
                setTimeout(() => {
                    if (this.fileSystemStorage) {
                        this.fileSystemStorage.initPermissionUI();
                    }
                }, 500);

                // Initialize template preview after DOM is ready
                setTimeout(() => this.updateTemplatePreview(), 100);
                
                // Setup auto cleanup for memory management
                this.setupAutoCleanup();
                
                // Initialize performance monitoring
                this.initPerformanceMonitoring();
            }

            // ============= CENTRALIZED ERROR HANDLING & RESOURCE MANAGEMENT =============
            
            // Centralized error handler with context
            handleError(error, context = 'Unknown', showToast = true) {
                const errorMessage = `Error in ${context}: ${error?.message || error}`;
                console.error(errorMessage, error);
                
                if (showToast) {
                    const userMessage = this.getUserFriendlyErrorMessage(error, context);
                    this.showToast(`‚ùå ${userMessage}`, 'error');
                }
                
                // Log to external service if needed (can be extended)
                this.logError(error, context);
                
                return false; // Return false to indicate error handled
            }
            
            // Convert technical errors to user-friendly messages
            getUserFriendlyErrorMessage(error, context) {
                const message = error?.message?.toLowerCase() || '';
                
                if (context.includes('convert') || context.includes('file')) {
                    if (message.includes('memory') || message.includes('size')) {
                        return 'File qu√° l·ªõn, vui l√≤ng th·ª≠ file nh·ªè h∆°n';
                    }
                    if (message.includes('format') || message.includes('type')) {
                        return 'ƒê·ªãnh d·∫°ng file kh√¥ng h·ªó tr·ª£';
                    }
                    if (message.includes('load') || message.includes('url')) {
                        return 'Kh√¥ng th·ªÉ t·∫£i file, vui l√≤ng th·ª≠ l·∫°i';
                    }
                    return 'L·ªói x·ª≠ l√Ω file, vui l√≤ng th·ª≠ l·∫°i';
                }
                
                if (context.includes('crop')) {
                    return 'L·ªói c·∫Øt ·∫£nh, vui l√≤ng ki·ªÉm tra k√≠ch th∆∞·ªõc';
                }
                
                if (context.includes('download')) {
                    return 'L·ªói t·∫£i xu·ªëng, vui l√≤ng th·ª≠ l·∫°i';
                }
                
                return 'C√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i';
            }
            
            // Log error to external service (placeholder)
            logError(error, context) {
                // Can be extended to send to analytics service
                if (window.gtag) {
                    gtag('event', 'exception', {
                        description: `${context}: ${error?.message}`,
                        fatal: false
                    });
                }
            }
            
            // Safe object URL creation with tracking
            safeCreateObjectURL(blob) {
                try {
                    if (!blob) {
                        throw new Error('Blob is null or undefined');
                    }
                    
                    const url = URL.createObjectURL(blob);
                    this.objectURLs.add(url);
                    
                    // Auto-cleanup after 10 minutes to prevent memory leaks
                    const timeoutId = setTimeout(() => {
                        this.safeRevokeObjectURL(url);
                    }, 10 * 60 * 1000);
                    this.timeouts.add(timeoutId);
                    
                    return url;
                } catch (error) {
                    this.handleError(error, 'safeCreateObjectURL');
                    return null;
                }
            }
            
            // Safe object URL cleanup
            safeRevokeObjectURL(url) {
                try {
                    if (url && this.objectURLs.has(url)) {
                        URL.revokeObjectURL(url);
                        this.objectURLs.delete(url);
                    }
                } catch (error) {
                    console.warn('Error revoking object URL:', error);
                }
            }
            
            // Safe canvas creation with tracking
            safeCreateCanvas(width, height) {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    this.canvasElements.add(canvas);
                    
                    // Add cleanup method to canvas
                    canvas._cleanup = () => {
                        const ctx = canvas.getContext('2d');
                        if (ctx) {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                        canvas.width = 1;
                        canvas.height = 1;
                        this.canvasElements.delete(canvas);
                    };
                    
                    return canvas;
                } catch (error) {
                    this.handleError(error, 'safeCreateCanvas');
                    return null;
                }
            }
            
            // Safe event listener addition with tracking
            safeAddEventListener(element, event, handler, options = {}) {
                try {
                    if (!element) {
                        console.warn(`‚ö†Ô∏è Element b·ªã null/undefined cho s·ª± ki·ªán '${event}'`);
                        return;
                    }
                    
                    if (typeof handler !== 'function') {
                        console.warn(`‚ö†Ô∏è Handler kh√¥ng ph·∫£i l√† function cho s·ª± ki·ªán '${event}' tr√™n element:`, element);
                        return;
                    }
                    
                    element.addEventListener(event, handler, options);
                    
                    // Track for cleanup - use element tag name or ID for better tracking
                    const elementId = element.id || element.tagName || 'unknown';
                    const key = `${elementId}-${event}`;
                    if (!this.eventListeners.has(key)) {
                        this.eventListeners.set(key, []);
                    }
                    this.eventListeners.get(key).push({ element, event, handler, options });
                    
                } catch (error) {
                    console.error(`‚ùå L·ªói khi th√™m event listener cho '${event}':`, error);
                    // Don't use this.handleError here to avoid recursion
                }
            }
            
            // Safe interval creation with tracking  
            safeSetInterval(callback, delay) {
                try {
                    const intervalId = setInterval(() => {
                        try {
                            callback();
                        } catch (error) {
                            this.handleError(error, 'interval callback');
                        }
                    }, delay);
                    
                    this.intervals.add(intervalId);
                    return intervalId;
                } catch (error) {
                    this.handleError(error, 'safeSetInterval');
                    return null;
                }
            }
            
            // Safe timeout creation with tracking
            safeSetTimeout(callback, delay) {
                try {
                    const timeoutId = setTimeout(() => {
                        try {
                            callback();
                        } catch (error) {
                            this.handleError(error, 'timeout callback');
                        }
                        this.timeouts.delete(timeoutId);
                    }, delay);
                    
                    this.timeouts.add(timeoutId);
                    return timeoutId;
                } catch (error) {
                    this.handleError(error, 'safeSetTimeout');
                    return null;
                }
            }
            
            // Create abort controller for async operations
            createAbortController(operationId) {
                const controller = new AbortController();
                this.abortControllers.set(operationId, controller);
                return controller;
            }
            
            // Cleanup all resources
            cleanup() {
                try {
                    // Cleanup object URLs
                    for (const url of this.objectURLs) {
                        URL.revokeObjectURL(url);
                    }
                    this.objectURLs.clear();
                    
                    // Cleanup canvas elements
                    for (const canvas of this.canvasElements) {
                        if (canvas._cleanup) {
                            canvas._cleanup();
                        }
                    }
                    this.canvasElements.clear();
                    
                    // Cleanup event listeners
                    for (const [key, listeners] of this.eventListeners) {
                        for (const { element, event, handler, options } of listeners) {
                            element.removeEventListener(event, handler, options);
                        }
                    }
                    this.eventListeners.clear();
                    
                    // Cleanup intervals
                    for (const intervalId of this.intervals) {
                        clearInterval(intervalId);
                    }
                    this.intervals.clear();
                    
                    // Cleanup timeouts
                    for (const timeoutId of this.timeouts) {
                        clearTimeout(timeoutId);
                    }
                    this.timeouts.clear();
                    
                    // Abort ongoing operations
                    for (const [operationId, controller] of this.abortControllers) {
                        controller.abort();
                    }
                    this.abortControllers.clear();
                    
                } catch (error) {
                    console.error('Error during cleanup:', error);
                }
            }
            
            // Auto cleanup on page unload
            setupAutoCleanup() {
                window.addEventListener('beforeunload', () => {
                    this.cleanup();
                });
                
                // Cleanup every 5 minutes to prevent accumulation
                this.safeSetInterval(() => {
                    this.performMaintenanceCleanup();
                }, 5 * 60 * 1000);
            }
            
            // Periodic maintenance cleanup
            performMaintenanceCleanup() {
                try {
                    // Cleanup expired cache entries
                    const now = Date.now();
                    for (const [key, entry] of this.galleryCache) {
                        if (entry.timestamp && (now - entry.timestamp) > 30 * 60 * 1000) { // 30 minutes
                            this.galleryCache.delete(key);
                        }
                    }
                    
                    // Cleanup orphaned object URLs
                    const urlsToCleanup = [];
                    for (const url of this.objectURLs) {
                        // If URL is not being used anywhere, mark for cleanup
                        if (!document.querySelector(`[src="${url}"]`) && 
                            !document.querySelector(`[href="${url}"]`)) {
                            urlsToCleanup.push(url);
                        }
                    }
                    
                    for (const url of urlsToCleanup) {
                        this.safeRevokeObjectURL(url);
                    }
                    
                } catch (error) {
                    console.warn('Error during maintenance cleanup:', error);
                }
            }
            
            // Performance monitoring to ensure memory leak fixes don't impact performance
            initPerformanceMonitoring() {
                this.performanceStats = {
                    startTime: Date.now(),
                    memoryUsage: 0,
                    operationTimes: new Map(),
                    resourceCounts: {
                        objectURLs: 0,
                        canvases: 0,
                        eventListeners: 0
                    }
                };
                
                // Monitor memory usage periodically
                this.safeSetInterval(() => {
                    this.updatePerformanceStats();
                }, 30000); // Every 30 seconds
                
                // Log performance stats when user leaves
                window.addEventListener('beforeunload', () => {
                    this.logFinalPerformanceStats();
                });
            }
            
            // Update performance statistics
            updatePerformanceStats() {
                try {
                    const stats = this.performanceStats;
                    
                    // Update resource counts
                    stats.resourceCounts.objectURLs = this.objectURLs.size;
                    stats.resourceCounts.canvases = this.canvasElements.size;
                    stats.resourceCounts.eventListeners = this.eventListeners.size;
                    
                    // Check memory usage if available
                    if (performance.memory) {
                        stats.memoryUsage = performance.memory.usedJSHeapSize;
                    }
                    
                    // Log warning if resource counts are too high
                    if (stats.resourceCounts.objectURLs > 50) {
                        console.warn('High object URL count:', stats.resourceCounts.objectURLs);
                    }
                    if (stats.resourceCounts.canvases > 10) {
                        console.warn('High canvas count:', stats.resourceCounts.canvases);
                    }
                    
                } catch (error) {
                    console.warn('Error updating performance stats:', error);
                }
            }
            
            // Log final performance statistics
            logFinalPerformanceStats() {
                try {
                    const stats = this.performanceStats;
                    const totalTime = (Date.now() - stats.startTime) / 1000;
                    
                    console.log('=== PERFORMANCE STATS ===');
                    console.log(`Session duration: ${totalTime.toFixed(1)}s`);
                    console.log(`Final resource counts:`, stats.resourceCounts);
                    
                    if (performance.memory) {
                        console.log(`Memory usage: ${(stats.memoryUsage / 1024 / 1024).toFixed(1)} MB`);
                    }
                    
                    // Log operation times if any were tracked
                    if (stats.operationTimes.size > 0) {
                        console.log('Operation times:');
                        for (const [operation, times] of stats.operationTimes) {
                            const avg = times.reduce((a, b) => a + b, 0) / times.length;
                            console.log(`  ${operation}: ${avg.toFixed(1)}ms avg (${times.length} ops)`);
                        }
                    }
                    
                } catch (error) {
                    console.warn('Error logging performance stats:', error);
                }
            }
            
            // Track operation time for performance monitoring
            trackOperationTime(operation, startTime) {
                try {
                    const duration = Date.now() - startTime;
                    
                    if (!this.performanceStats.operationTimes.has(operation)) {
                        this.performanceStats.operationTimes.set(operation, []);
                    }
                    
                    const times = this.performanceStats.operationTimes.get(operation);
                    times.push(duration);
                    
                    // Keep only last 100 measurements
                    if (times.length > 100) {
                        times.shift();
                    }
                    
                } catch (error) {
                    console.warn('Error tracking operation time:', error);
                }
            }

            // L∆∞u tr·ªØ file system
            async initFileSystemStorage() {
                if (!this.fileSystemStorage) {
                    try {
                        if (typeof window.FileSystemStorage === 'function') {
                            this.fileSystemStorage = new window.FileSystemStorage();
                        } else {
                            console.warn('‚ö†Ô∏è FileSystemStorage class ch∆∞a s·∫µn s√†ng');
                            return false;
                        }
                    } catch (error) {
                        console.error('‚ùå L·ªói kh·ªüi t·∫°o FileSystemStorage:', error);
                        return false;
                    }
                    // Kh√¥ng t·ª± ƒë·ªông g·ªçi init(), ch·ªâ kh·ªüi t·∫°o object
                    // init() s·∫Ω ƒë∆∞·ª£c g·ªçi khi user click c·∫•p quy·ªÅn
                }
                return true;
            }

            // Load download settings t·ª´ file system
            async loadDownloadSettings() {
                try {
                    // Ch·ªâ s·ª≠ d·ª•ng File System n·∫øu ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o v√† c√≥ quy·ªÅn
                    if (this.fileSystemStorage && this.fileSystemStorage.directoryHandle) {
                        const saved = await this.fileSystemStorage.getItem('downloadSettings');
                        if (saved) {
                            this.downloadSettings = { ...this.downloadSettings, ...saved };
                            this.updateDownloadSettingsUI();
                            return;
                        }
                    }

                    // M·∫∑c ƒë·ªãnh s·ª≠ d·ª•ng localStorage
                    const savedLocal = localStorage.getItem('downloadSettings');
                    if (savedLocal) {
                        this.downloadSettings = { ...this.downloadSettings, ...JSON.parse(savedLocal) };
                        this.updateDownloadSettingsUI();
                    }
                } catch (error) {
                    console.error('Error loading download settings:', error);
                }
            }

            // Update UI with loaded settings
            updateDownloadSettingsUI() {
                document.getElementById('folderPrefix').value = this.downloadSettings.folderPrefix || '';
                document.getElementById('useSubfolders').checked = this.downloadSettings.useSubfolders || false;
                document.getElementById('frontFolderName').value = this.downloadSettings.subfolderNames.front || 'Mat_truoc';
                document.getElementById('backFolderName').value = this.downloadSettings.subfolderNames.back || 'Mat_sau';
                document.getElementById('croppedFolderName').value = this.downloadSettings.subfolderNames.cropped || 'Da_cat';
                document.getElementById('galleryFolderName').value = this.downloadSettings.subfolderNames.gallery || 'Kho_anh';
                
                // Show/hide subfolder settings
                const subfolderSettings = document.getElementById('subfolderSettings');
                if (subfolderSettings) {
                    subfolderSettings.style.display = this.downloadSettings.useSubfolders ? 'block' : 'none';
                }
            }

            // Save download settings v√†o file system
            async saveDownloadSettings() {
                this.downloadSettings.folderPrefix = document.getElementById('folderPrefix').value.trim();
                this.downloadSettings.useSubfolders = document.getElementById('useSubfolders').checked;
                this.downloadSettings.subfolderNames.front = document.getElementById('frontFolderName').value.trim() || 'Mat_truoc';
                this.downloadSettings.subfolderNames.back = document.getElementById('backFolderName').value.trim() || 'Mat_sau';
                this.downloadSettings.subfolderNames.cropped = document.getElementById('croppedFolderName').value.trim() || 'Da_cat';
                this.downloadSettings.subfolderNames.gallery = document.getElementById('galleryFolderName').value.trim() || 'Kho_anh';

                try {
                    await this.initFileSystemStorage();
                    await this.fileSystemStorage.setItem('downloadSettings', this.downloadSettings);
                    this.showToast('‚úÖ ƒê√£ l∆∞u c√†i ƒë·∫∑t th∆∞ m·ª•c t·∫£i v·ªÅ v√†o file system!', 'success');
                } catch (error) {
                    console.error('Error saving download settings to file system:', error);
                    // Fallback v·ªÅ localStorage
                    try {
                        localStorage.setItem('downloadSettings', JSON.stringify(this.downloadSettings));
                        this.showToast('‚úÖ ƒê√£ l∆∞u c√†i ƒë·∫∑t th∆∞ m·ª•c t·∫£i v·ªÅ (localStorage)!', 'success');
                    } catch (localError) {
                        console.error('Fallback localStorage c≈©ng l·ªói:', localError);
                        this.showToast('‚ùå L·ªói khi l∆∞u c√†i ƒë·∫∑t!', 'error');
                    }
                }
            }

            // Apply folder settings to filename
            applyDownloadFolderSettings(fileName, type) {
                let finalName = fileName;
                
                // Add folder prefix if enabled
                if (this.downloadSettings.folderPrefix) {
                    const prefix = this.downloadSettings.folderPrefix.replace(/[<>:"/\|?*]/g, '_');
                    finalName = `${prefix}${finalName}`;
                }
                
                // Add subfolder path if enabled
                if (this.downloadSettings.useSubfolders && this.downloadSettings.subfolderNames[type]) {
                    const subfolderName = this.downloadSettings.subfolderNames[type].replace(/[<>:"/\|?*]/g, '_');
                    finalName = `${subfolderName}/${finalName}`;
                }
                
                return finalName;
            }

            // Initialize keyboard shortcuts
            initKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Escape key to close preview modal or exit selection mode
                    if (e.key === 'Escape') {
                        const previewModal = document.getElementById('previewModal');
                        if (previewModal && previewModal.style.display === 'flex') {
                            this.hidePreviewModal();
                        } else if (this.selectionMode) {
                            this.exitSelectionMode();
                        }
                    }
                    
                    // Enter key to download in preview modal
                    if (e.key === 'Enter') {
                        const previewModal = document.getElementById('previewModal');
                        if (previewModal && previewModal.style.display === 'flex' && this.currentPreviewFileId) {
                            this.confirmDownload();
                        }
                    }
                    
                    // üóëÔ∏è PH√çM T·∫ÆT X√ìA NHANH: Ctrl+Shift+Delete - X√≥a t·∫•t c·∫£ d·ªØ li·ªáu ·∫£nh
                    if (e.ctrlKey && e.shiftKey && e.key === 'Delete') {
                        e.preventDefault();
                        this.clearAllImageData();
                        return;
                    }

                    // Quick selection shortcuts (only in Gallery tab)
                    const currentTab = document.querySelector('.function-section.active');
                    if (currentTab && currentTab.id === 'gallery') {
                        // Ctrl+F: Quick select front
                        if (e.ctrlKey && e.key === 'f') {
                            e.preventDefault();
                            if (!this.selectionMode || this.selectionType !== 'front') {
                                this.startQuickSelection('front');
                            }
                        }
                        
                        // Ctrl+B: Quick select back
                        if (e.ctrlKey && e.key === 'b') {
                            e.preventDefault();
                            if (!this.selectionMode || this.selectionType !== 'back') {
                                this.startQuickSelection('back');
                            }
                        }
                        
                        // Ctrl+A: Select all current images
                        if (e.ctrlKey && e.key === 'a' && this.selectionMode) {
                            e.preventDefault();
                            this.galleryImages.forEach(image => {
                                if (!this.selectedImages.includes(image.id)) {
                                    this.selectedImages.push(image.id);
                                }
                            });
                            this.updateGallerySelectionMode();
                            this.updateSelectionCounter();
                        }
                    }
                });
            }


            initializeEventListeners() {
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.addEventListener('change', (e) => {
                        try {
                            console.log('üî• ƒê√£ k√≠ch ho·∫°t s·ª± ki·ªán thay ƒë·ªïi file input');
                            this.handleFileSelect(e.target.files);
                        } catch (error) {
                            console.error('‚ùå L·ªói trong x·ª≠ l√Ω s·ª± ki·ªán thay ƒë·ªïi file input:', error);
                            this.showToast('L·ªói khi x·ª≠ l√Ω file ƒë√£ ch·ªçn!', 'error');
                        }
                    });
                    fileInput.removeAttribute('accept');
                } else {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y element file input!');
                }

                const uploadZone = document.querySelector('.upload-zone');
                if (uploadZone) {
                    uploadZone.addEventListener('dragover', this.handleDragOver.bind(this));
                    uploadZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
                    uploadZone.addEventListener('drop', (e) => {
                        try {
                            console.log('Drop event triggered');
                            this.handleDrop(e);
                        } catch (error) {
                            console.error('Error in drop handler:', error);
                            this.showToast('L·ªói khi th·∫£ file!', 'error');
                        }
                    });
                } else {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y element v√πng upload!');
                }

                // Quality slider with warnings
                const qualitySlider = document.getElementById('quality');
                if (qualitySlider) {
                    this.safeAddEventListener(qualitySlider, 'input', (e) => {
                        const value = parseInt(e.target.value);
                        const qualityValue = document.getElementById('qualityValue');
                        if (qualityValue) {
                            if (value === 100) {
                                qualityValue.textContent = '100% (Tuy·ªát ƒë·ªëi file g·ªëc)';
                            } else {
                                qualityValue.textContent = value + '%';
                            }
                        }
                        
                        // Show quality warnings
                        if (value < 70) {
                            this.showToast('‚ö†Ô∏è Ch·∫•t l∆∞·ª£ng th·∫•p c√≥ th·ªÉ l√†m gi·∫£m ƒë·ªô chi ti·∫øt ·∫£nh', 'error');
                        } else if (value < 85) {
                            this.showToast('üí° Khuy·∫øn ngh·ªã: Ch·∫•t l∆∞·ª£ng ‚â•85% cho k·∫øt qu·∫£ t·ªët nh·∫•t', 'success');
                        }
                    });
                }

                // Max quality button
                const maxQualityBtn = document.getElementById('maxQualityBtn');
                if (maxQualityBtn) {
                    this.safeAddEventListener(maxQualityBtn, 'click', () => {
                        const quality = document.getElementById('quality');
                        const qualityValue = document.getElementById('qualityValue');
                        if (quality) quality.value = 100;
                        if (qualityValue) qualityValue.textContent = '100% (Tuy·ªát ƒë·ªëi file g·ªëc)';
                    });
                }

                // Naming options
                const namingSelect = document.getElementById('namingOption');
                const customPrefix = document.getElementById('customPrefix');

                if (namingSelect && customPrefix) {
                    this.safeAddEventListener(namingSelect, 'change', (e) => {
                        if (e.target.value === 'custom') {
                            customPrefix.style.display = 'inline-block';
                        } else {
                            customPrefix.style.display = 'none';
                        }
                    });
                }

                // PDF Settings - Hi·ªÉn th·ªã input range khi ch·ªçn "Kho·∫£ng trang"
                const pdfPageSelection = document.getElementById('pdfPageSelection');
                const pdfPageRange = document.getElementById('pdfPageRange');

                if (pdfPageSelection && pdfPageRange) {
                    this.safeAddEventListener(pdfPageSelection, 'change', (e) => {
                        if (e.target.value === 'range') {
                            pdfPageRange.style.display = 'block';
                        } else {
                            pdfPageRange.style.display = 'none';
                        }
                    });
                }

                // Buttons with null checks and safe event listeners
                const convertAllBtn = document.getElementById('convertAllBtn');
                if (convertAllBtn) this.safeAddEventListener(convertAllBtn, 'click', () => this.convertAllFiles());
                
                const downloadAllBtn = document.getElementById('downloadAllBtn');
                if (downloadAllBtn) this.safeAddEventListener(downloadAllBtn, 'click', () => this.downloadAllFiles());
                
                const downloadZipBtn = document.getElementById('downloadZipBtn');
                if (downloadZipBtn) this.safeAddEventListener(downloadZipBtn, 'click', () => this.downloadAsZip());

                const saveToFileSystemBtn = document.getElementById('saveToFileSystemBtn');
                if (saveToFileSystemBtn) this.safeAddEventListener(saveToFileSystemBtn, 'click', () => this.saveConvertedToFileSystem());

                const createPdfBtn = document.getElementById('createPdfBtn');
                if (createPdfBtn) this.safeAddEventListener(createPdfBtn, 'click', () => this.showPdfModal());
                
                const cropImagesBtn = document.getElementById('cropImagesBtn');
                if (cropImagesBtn) this.safeAddEventListener(cropImagesBtn, 'click', () => this.showCropModal());
                
                const clearAllBtn = document.getElementById('clearAllBtn');
                if (clearAllBtn) this.safeAddEventListener(clearAllBtn, 'click', () => this.clearAllFiles());
                
                const showCropResultsBtn = document.getElementById('showCropResultsBtn');
                if (showCropResultsBtn) this.safeAddEventListener(showCropResultsBtn, 'click', () => {
                    console.log('üéØ Hi·ªÉn th·ªã k·∫øt qu·∫£ c·∫Øt ·∫£nh ƒë∆∞·ª£c y√™u c·∫ßu');
                    if (window.showCropResultsSection) {
                        window.showCropResultsSection();
                        // Switch to Template Crop tab to see results
                        const cropTab = document.getElementById('cropTab');
                        if (cropTab) {
                            cropTab.click();
                        }
                        this.showToast('‚úÖ ƒê√£ hi·ªÉn th·ªã k·∫øt qu·∫£ c·∫Øt ·∫£nh!', 'success');
                    }
                });
                
                const retryFailedBtn = document.getElementById('retryFailedBtn');
                if (retryFailedBtn) this.safeAddEventListener(retryFailedBtn, 'click', () => this.retryFailedFiles());
                
                // DPI change listener - update file list when DPI changes
                const customDPI = document.getElementById('customDPI');
                if (customDPI) this.safeAddEventListener(customDPI, 'change', () => {
                    console.log('üìê DPI changed, updating file list display');
                    this.renderFileList(); // Re-render to show updated cm calculations
                });

                // PDF Modal events
                const closePdfModal = document.getElementById('closePdfModal');
                if (closePdfModal) this.safeAddEventListener(closePdfModal, 'click', () => this.hidePdfModal());
                
                const cancelPdf = document.getElementById('cancelPdf');
                if (cancelPdf) this.safeAddEventListener(cancelPdf, 'click', () => this.hidePdfModal());
                
                const generatePdf = document.getElementById('generatePdf');
                if (generatePdf) this.safeAddEventListener(generatePdf, 'click', () => this.generatePDF());
                
                // Close modal when clicking outside
                const pdfModal = document.getElementById('pdfModal');
                if (pdfModal) {
                    this.safeAddEventListener(pdfModal, 'click', (e) => {
                        if (e.target.id === 'pdfModal') this.hidePdfModal();
                    });
                }

                // Crop Modal events
                const closeCropModal = document.getElementById('closeCropModal');
                if (closeCropModal) this.safeAddEventListener(closeCropModal, 'click', () => this.hideCropModal());
                
                const cancelCrop = document.getElementById('cancelCrop');
                if (cancelCrop) this.safeAddEventListener(cancelCrop, 'click', () => this.hideCropModal());
                
                const startCropping = document.getElementById('startCropping');
                if (startCropping) this.safeAddEventListener(startCropping, 'click', () => this.startCropping());
                
                const cropModal = document.getElementById('cropModal');
                if (cropModal) {
                    this.safeAddEventListener(cropModal, 'click', (e) => {
                        if (e.target.id === 'cropModal') this.hideCropModal();
                    });
                }

                // Template card click handlers
                this.initializeCropTemplateHandlers();
                
                const cropWidth = document.getElementById('cropWidth');
                if (cropWidth) {
                    this.safeAddEventListener(cropWidth, 'input', () => {
                        this.updateSizeDetails();
                        this.updateCropInfo();
                    });
                }
                
                const cropHeight = document.getElementById('cropHeight');
                if (cropHeight) {
                    this.safeAddEventListener(cropHeight, 'input', () => {
                        this.updateSizeDetails();
                        this.updateCropInfo();
                    });
                }
                
                const cropDPI = document.getElementById('cropDPI');
                if (cropDPI) {
                    this.safeAddEventListener(cropDPI, 'change', () => {
                        this.updateSizeDetails();
                        this.updateCropInfo();
                    });
                }

                // Crop Editor events (with null checks)
                const closeCropEditor = document.getElementById('closeCropEditor');
                if (closeCropEditor) {
                    this.safeAddEventListener(closeCropEditor, 'click', () => this.hideCropEditor());
                }
                
                const acceptCropImage = document.getElementById('acceptCropImage');
                if (acceptCropImage) {
                    this.safeAddEventListener(acceptCropImage, 'click', () => this.acceptCurrentCrop());
                }
                
                const skipCropImage = document.getElementById('skipCropImage');
                if (skipCropImage) {
                    this.safeAddEventListener(skipCropImage, 'click', () => this.skipCurrentCrop());
                }
                
                const prevCropImage = document.getElementById('prevCropImage');
                if (prevCropImage) {
                    prevCropImage.addEventListener('click', () => this.previousCropImage());
                }
                
                const nextCropImage = document.getElementById('nextCropImage');
                if (nextCropImage) {
                    nextCropImage.addEventListener('click', () => this.nextCropImage());
                }
                
                const cropReset = document.getElementById('cropReset');
                if (cropReset) {
                    cropReset.addEventListener('click', () => this.resetCropSelection());
                }
                
                const cropCenter = document.getElementById('cropCenter');
                if (cropCenter) {
                    cropCenter.addEventListener('click', () => this.centerCropSelection());
                }
                
                const cropFit = document.getElementById('cropFit');
                if (cropFit) {
                    cropFit.addEventListener('click', () => this.fitCropSelection());
                }

                // Crop Preview Modal events (with null checks)
                const closePreviewModal = document.getElementById('closePreviewModal');
                if (closePreviewModal) {
                    closePreviewModal.addEventListener('click', () => this.hideCropPreviewModal());
                }
                
                const cancelPreview = document.getElementById('cancelPreview');
                if (cancelPreview) {
                    cancelPreview.addEventListener('click', () => this.hideCropPreviewModal());
                }
                
                const cropAllPreviews = document.getElementById('cropAllPreviews');
                if (cropAllPreviews) {
                    cropAllPreviews.addEventListener('click', () => this.cropAllFromPreviews());
                }
                
                const cropSelectedPreviews = document.getElementById('cropSelectedPreviews');
                if (cropSelectedPreviews) {
                    cropSelectedPreviews.addEventListener('click', () => this.cropSelectedFromPreviews());
                }
                
                const selectAllPreviews = document.getElementById('selectAllPreviews');
                if (selectAllPreviews) {
                    selectAllPreviews.addEventListener('click', () => this.selectAllPreviews());
                }
                
                const clearAllPreviews = document.getElementById('clearAllPreviews');
                if (clearAllPreviews) {
                    clearAllPreviews.addEventListener('click', () => this.clearAllPreviews());
                }

                // Cutting guides toggle functionality
                const cuttingGuidesToggle = document.getElementById('cuttingGuidesToggle');
                const cuttingGuidesConfig = document.getElementById('cuttingGuidesConfig');
                if (cuttingGuidesToggle && cuttingGuidesConfig) {
                    cuttingGuidesToggle.addEventListener('click', () => {
                        const isVisible = cuttingGuidesConfig.style.display !== 'none';
                        cuttingGuidesConfig.style.display = isVisible ? 'none' : 'block';
                        const arrow = cuttingGuidesToggle.querySelector('.toggle-arrow');
                        if (arrow) {
                            arrow.style.transform = isVisible ? 'rotate(-90deg)' : 'rotate(0deg)';
                        }
                    });
                }
                
                const acceptAllPreviews = document.getElementById('acceptAllPreviews');
                if (acceptAllPreviews) {
                    acceptAllPreviews.addEventListener('click', () => this.acceptAllPreviews());
                }

                const cropPreviewModal = document.getElementById('cropPreviewModal');
                if (cropPreviewModal) {
                    cropPreviewModal.addEventListener('click', (e) => {
                        if (e.target.id === 'cropPreviewModal') this.hideCropPreviewModal();
                    });
                }

                // Tab switching functionality
                const convertTab = document.getElementById('convertTab');
                const cropTab = document.getElementById('cropTab');
                const templatesTab = document.getElementById('templatesTab');
                const galleryTab = document.getElementById('galleryTab');
                const printTab = document.getElementById('printTab');
                const filesystemTab = document.getElementById('filesystemTab');

                if (convertTab) {
                    convertTab.addEventListener('click', () => this.switchToTab('convert'));
                }
                if (cropTab) {
                    cropTab.addEventListener('click', () => this.switchToTab('crop'));
                }
                if (templatesTab) {
                    templatesTab.addEventListener('click', () => this.switchToTab('templates'));
                }
                if (galleryTab) {
                    galleryTab.addEventListener('click', () => this.switchToTab('gallery'));
                }
                if (printTab) {
                    printTab.addEventListener('click', () => this.switchToTab('print'));
                }
                if (filesystemTab) {
                    filesystemTab.addEventListener('click', () => this.switchToTab('filesystem'));
                }

                const sk316Tab = document.getElementById('sk316Tab');
                if (sk316Tab) {
                    sk316Tab.addEventListener('click', () => this.switchToTab('sk316'));
                }

                // Template sub-tabs
                const polaroidSubTab = document.getElementById('polaroidSubTab');
                const borderSubTab = document.getElementById('borderSubTab');
                const stripSubTab = document.getElementById('stripSubTab');
                
                if (polaroidSubTab) {
                    polaroidSubTab.addEventListener('click', () => this.switchTemplateSubTab('polaroid'));
                }
                if (borderSubTab) {
                    borderSubTab.addEventListener('click', () => this.switchTemplateSubTab('border'));
                }
                if (stripSubTab) {
                    stripSubTab.addEventListener('click', () => this.switchTemplateSubTab('strip'));
                }

                // Gallery event listeners
                this.initializeGalleryEventListeners();

                // Independent crop file input handler
                const cropFileInput = document.getElementById('cropFileInput');
                if (cropFileInput) {
                    cropFileInput.addEventListener('change', (e) => {
                        try {
                            console.log('Crop file input change event triggered');
                            this.handleCropFileSelect(e.target.files);
                        } catch (error) {
                            console.error('Error in crop file input change handler:', error);
                            this.showToast('L·ªói khi x·ª≠ l√Ω file crop!', 'error');
                        }
                    });
                }

                // Auto-rotate toggle handler
                const autoRotateToggle = document.getElementById('autoRotateToggle');
                const autoRotateLabel = document.getElementById('autoRotateLabel');
                if (autoRotateToggle && autoRotateLabel) {
                    autoRotateToggle.addEventListener('change', (e) => {
                        this.autoRotateEnabled = e.target.checked;
                        autoRotateLabel.textContent = e.target.checked ? 'B·∫≠t' : 'T·∫Øt';
                        console.log('Auto-rotate:', e.target.checked ? 'Enabled' : 'Disabled');
                    });
                    // Initialize state
                    this.autoRotateEnabled = autoRotateToggle.checked;
                }

                // Convert file input and upload zone handlers
                const convertFileInput = document.getElementById('convertFileInput');
                const convertUploadZone = document.getElementById('convertUploadZone');
                
                if (convertFileInput) {
                    // File input change handler
                    convertFileInput.addEventListener('change', (e) => {
                        try {
                            console.log('Convert file input change event triggered');
                            this.handleFileSelect(e.target.files);
                        } catch (error) {
                            console.error('Error in convert file input change handler:', error);
                            this.showToast('L·ªói khi x·ª≠ l√Ω file convert!', 'error');
                        }
                    });
                    convertFileInput.removeAttribute('accept');
                }
                
                // INSTANT FILE DIALOG - NO DELAY SOLUTION
                if (convertUploadZone && convertFileInput) {
                    // Remove existing listeners by cloning element
                    const clonedZone = convertUploadZone.cloneNode(true);
                    convertUploadZone.parentNode.replaceChild(clonedZone, convertUploadZone);
                    
                    // Get fresh reference to work with
                    const freshZone = document.getElementById('convertUploadZone');
                    
                    // Direct immediate handler - bypass all delays
                    freshZone.onmousedown = function(e) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        this.style.transform = 'scale(0.98)';
                        convertFileInput.click(); // INSTANT TRIGGER
                    };
                    
                    freshZone.onmouseup = function() {
                        this.style.transform = '';
                    };
                    
                    freshZone.onmouseleave = function() {
                        this.style.transform = '';
                    };
                }

                // Crop size selection handlers
                const sizeButtons = document.querySelectorAll('.size-option');
                sizeButtons.forEach(btn => {
                    btn.addEventListener('click', () => this.selectCropSize(btn.dataset.size));
                });

                // Crop ZIP download handlers
                const downloadCropZip = document.getElementById('downloadCropZip');
                if (downloadCropZip) {
                    downloadCropZip.addEventListener('click', () => this.downloadCropAsZip());
                }

                const downloadCropPreviewZip = document.getElementById('downloadCropPreviewZip');
                if (downloadCropPreviewZip) {
                    downloadCropPreviewZip.addEventListener('click', () => this.downloadCropAsZip());
                }

                const downloadCropConfigZip = document.getElementById('downloadCropConfigZip');
                if (downloadCropConfigZip) {
                    downloadCropConfigZip.addEventListener('click', () => this.downloadCropAsZip());
                }

                // Crop section action handlers
                const downloadCroppedAllBtn = document.getElementById('downloadCroppedAllBtn');
                if (downloadCroppedAllBtn) {
                    downloadCroppedAllBtn.addEventListener('click', () => this.downloadAllCroppedFiles());
                }

                const downloadCroppedZipBtn = document.getElementById('downloadCroppedZipBtn');
                if (downloadCroppedZipBtn) {
                    downloadCroppedZipBtn.addEventListener('click', () => this.downloadCropAsZip());
                }

                // Crop Page Download Buttons
                const downloadCroppedAllBtnPage = document.getElementById('downloadCroppedAllBtnPage');
                if (downloadCroppedAllBtnPage) {
                    downloadCroppedAllBtnPage.addEventListener('click', () => this.downloadAllCroppedFiles());
                }

                const downloadCroppedZipBtnPage = document.getElementById('downloadCroppedZipBtnPage');
                if (downloadCroppedZipBtnPage) {
                    downloadCroppedZipBtnPage.addEventListener('click', () => this.downloadCropAsZip());
                }

                const cropResultsBtnPage = document.getElementById('cropResultsBtnPage');
                if (cropResultsBtnPage) {
                    cropResultsBtnPage.addEventListener('click', () => this.showCropResults());
                }

                const cropResultsBtn = document.getElementById('cropResultsBtn');
                if (cropResultsBtn) {
                    cropResultsBtn.addEventListener('click', () => this.showCropResults());
                }

                const cropNewBatchBtn = document.getElementById('cropNewBatchBtn');
                if (cropNewBatchBtn) {
                    cropNewBatchBtn.addEventListener('click', () => this.startNewCropBatch());
                }
            }

            // Tab switching functionality
            switchToTab(tabName) {
                // Remove active class from all tabs and sections
                document.querySelectorAll('.tab-button').forEach(tab => tab.classList.remove('active'));
                document.querySelectorAll('.function-section').forEach(section => {
                    section.classList.remove('active');
                    section.style.display = 'none';
                });

                // Add active class to selected tab and section
                if (tabName === 'convert') {
                    document.getElementById('convertTab').classList.add('active');
                    const convertSection = document.getElementById('convertSection');
                    convertSection.classList.add('active');
                    convertSection.style.display = 'block';
                } else if (tabName === 'crop') {
                    document.getElementById('cropTab').classList.add('active');
                    const cropTabSection = document.getElementById('cropTabSection');
                    cropTabSection.classList.add('active');
                    cropTabSection.style.display = 'block';
                    
                    // Initialize crop page handlers if not already done
                    if (!this.cropHandlersInitialized) {
                        // Initialize template selection if not already done
                        if (!this.currentCropTemplate) {
                            this.currentCropTemplate = '5.5x8.5';
                        }
                        this.initializeCropPageHandlers();
                        this.cropHandlersInitialized = true;
                    }
                    // Always populate file grid and update details when switching to crop tab
                    this.populateCropFileGrid();
                    this.updateSizeDetailsPage();
                } else if (tabName === 'templates') {
                    document.getElementById('templatesTab').classList.add('active');
                    const templatesSection = document.getElementById('templatesSection');
                    templatesSection.classList.add('active');
                    templatesSection.style.display = 'block';
                    // Initialize current active template
                    this.initializeActiveTemplate();
                } else if (tabName === 'gallery') {
                    document.getElementById('galleryTab').classList.add('active');
                    const gallerySection = document.getElementById('gallerySection');
                    gallerySection.classList.add('active');
                    gallerySection.style.display = 'block';
                    this.updateGalleryDisplay();
                } else if (tabName === 'print') {
                    document.getElementById('printTab').classList.add('active');
                    const printSection = document.getElementById('printSection');
                    printSection.classList.add('active');
                    printSection.style.display = 'block';
                    this.initializePrintSection();
                } else if (tabName === 'filesystem') {
                    document.getElementById('filesystemTab').classList.add('active');
                    const filesystemSection = document.getElementById('filesystemSection');
                    filesystemSection.classList.add('active');
                    filesystemSection.style.display = 'block';
                } else if (tabName === 'sk316') {
                    document.getElementById('sk316Tab').classList.add('active');
                    const sk316Section = document.getElementById('sk316Section');
                    sk316Section.classList.add('active');
                    sk316Section.style.display = 'block';
                }
            }

            // Crop size selection
            selectCropSize(sizeValue) {
                // Remove active class from all size buttons
                document.querySelectorAll('.size-option').forEach(btn => btn.classList.remove('active'));
                
                // Add active class to selected button
                const selectedBtn = document.querySelector(`[data-size="${sizeValue}"]`);
                if (selectedBtn) {
                    selectedBtn.classList.add('active');
                }

                // Show/hide custom input
                const customSizeInput = document.getElementById('customSizeInput');
                if (sizeValue === 'custom') {
                    customSizeInput.style.display = 'block';
                } else {
                    customSizeInput.style.display = 'none';
                    
                // Set predefined values
                if (sizeValue === '5.5x8.5') {
                    this.currentCropSize = { width: 5.5, height: 8.5 };
                } else if (sizeValue === '3x4') {
                    this.currentCropSize = { width: 3, height: 4 };
                } else if (sizeValue === '4x6') {
                    this.currentCropSize = { width: 4, height: 6 };
                } else if (sizeValue === '10.5x14.8') {
                    this.currentCropSize = { width: 10.5, height: 14.8 };
                } else if (sizeValue === '5x15') {
                    this.currentCropSize = { width: 5, height: 15 };
                } else if (sizeValue === '14.8x21') {
                    this.currentCropSize = { width: 14.8, height: 21 };
                } else if (sizeValue === '21x29.7') {
                    this.currentCropSize = { width: 21, height: 29.7 };
                } else if (sizeValue === '6.3x8.8') {
                    this.currentCropSize = { width: 6.3, height: 8.8 };
                } else if (sizeValue === '7x10') {
                    this.currentCropSize = { width: 7, height: 10 };
                } else if (sizeValue === '4.74x6.6') {
                    this.currentCropSize = { width: 4.74, height: 6.6 };
                } else if (sizeValue === '5.4x9') {
                    this.currentCropSize = { width: 5.4, height: 9 };
                } else if (sizeValue === '6x9') {
                    this.currentCropSize = { width: 6, height: 9 };
                } else if (sizeValue === '10x15') {
                    this.currentCropSize = { width: 10, height: 15 };
                } else if (sizeValue === '13x18') {
                    this.currentCropSize = { width: 13, height: 18 };
                } else if (sizeValue === '20x25') {
                    this.currentCropSize = { width: 20, height: 25 };
                }
                }
            }

            // Handle crop file selection (independent workflow) - Updated 2025-08-19
            async handleCropFileSelect(files) {
                console.log('Processing crop files:', files.length);
                
                if (!files || files.length === 0) {
                    console.log('No files selected for cropping');
                    return;
                }

                // Get current crop size
                let cropSize = this.currentCropSize || { width: 5.5, height: 8.5 };
                
                // Check if custom size is selected
                const customSizeInput = document.getElementById('customSizeInput');
                if (customSizeInput && customSizeInput.style.display !== 'none') {
                    const customWidth = parseFloat(document.getElementById('customWidth').value);
                    const customHeight = parseFloat(document.getElementById('customHeight').value);
                    if (customWidth > 0 && customHeight > 0) {
                        cropSize = { width: customWidth, height: customHeight };
                    }
                }

                // Automatically detect image orientation and adapt crop ratio (if enabled)
                if (files.length > 0 && this.autoRotateEnabled !== false) {
                    const firstFile = files[0];
                    const imageOrientation = await this.detectImageOrientation(firstFile);
                    cropSize = this.adaptCropSizeToOrientation(cropSize, imageOrientation);
                    console.log('Adapted crop size for orientation:', imageOrientation, cropSize);
                } else if (files.length > 0 && this.autoRotateEnabled === false) {
                    console.log('Auto-rotate disabled, using original crop size:', cropSize);
                }

                console.log('Using crop size:', cropSize);

                // Validate files
                const validFiles = [];
                for (let file of files) {
                    const isValid = await this.validateImageFile(file);
                    if (isValid) {
                        validFiles.push(file);
                    } else {
                        console.log('Invalid image file:', file.name);
                        this.showToast(`File kh√¥ng h·ª£p l·ªá: ${file.name}`, 'error');
                    }
                }

                if (validFiles.length === 0) {
                    this.showToast('Kh√¥ng c√≥ file ·∫£nh h·ª£p l·ªá n√†o ƒë∆∞·ª£c ch·ªçn!', 'error');
                    return;
                }

                // Set crop mode and size
                this.currentCropMode = 'template';
                this.currentCropSize = cropSize;
                
                // Update crop modal with size info
                document.getElementById('cropWidth').value = cropSize.width;
                document.getElementById('cropHeight').value = cropSize.height;
                
                // Create simplified file data objects for cropping
                this.files = [];
                for (let index = 0; index < validFiles.length; index++) {
                    const file = validFiles[index];
                    
                    const fileData = {
                        id: `file_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`,
                        file: file,
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        hash: `hash_${Date.now()}_${index}`, // Simplified hash
                        lastModified: file.lastModified,
                        quality: { score: 80, issues: [] }, // Default quality
                        status: 'pending'
                    };
                    
                    this.files.push(fileData);
                }

                if (this.files.length > 0) {
                    // Update stats
                    this.updateStats();
                    
                    // Show crop actions
                    this.showCropActions();
                    
                    // Show crop modal directly
                    this.showCropModal();
                    this.showToast(`ƒê√£ load ${this.files.length} ·∫£nh ƒë·ªÉ crop`, 'success');
                } else {
                    this.showToast('Kh√¥ng th·ªÉ x·ª≠ l√Ω file ·∫£nh n√†o!', 'error');
                }
            }

            // Show crop actions bar
            showCropActions() {
                const cropActions = document.getElementById('cropActions');
                if (cropActions) {
                    cropActions.style.display = 'block';
                }
            }

            // Hide crop actions bar
            hideCropActions() {
                const cropActions = document.getElementById('cropActions');
                if (cropActions) {
                    cropActions.style.display = 'none';
                }
            }

            // Download all cropped files individually
            async downloadAllCroppedFiles() {
                console.log('üéØ downloadAllCroppedFiles called');
                console.log('üìä cropProcessedFiles:', this.cropProcessedFiles);
                console.log('üìä cropData.croppedImages:', this.cropData?.croppedImages);
                
                // Auto-sync first to ensure data is available
                this.syncCropProcessedFiles();
                
                // Also check alternative source from cropData
                const sourceFiles = this.cropProcessedFiles && this.cropProcessedFiles.length > 0 
                    ? this.cropProcessedFiles 
                    : this.cropData?.croppedImages || [];
                
                if (sourceFiles.length === 0) {
                    this.showToast('Ch∆∞a c√≥ ·∫£nh n√†o ƒë∆∞·ª£c c·∫Øt! H√£y c·∫Øt ·∫£nh tr∆∞·ªõc khi t·∫£i v·ªÅ.', 'error');
                    return;
                }

                // Prevent multiple downloads
                if (this.isDownloadingCropped) {
                    this.showToast('‚è≥ ƒêang t·∫£i ·∫£nh ƒë√£ c·∫Øt... Vui l√≤ng ch·ªù!', 'warning');
                    return;
                }

                this.isDownloadingCropped = true;
                this.showToast(`ƒêang t·∫£i v·ªÅ ${sourceFiles.length} ·∫£nh ƒë√£ c·∫Øt t·ª´ng file...`, 'success');

                // Fast batch download for cropped files
                const downloadedNames = new Set(); // Prevent duplicate names
                let downloadedCount = 0;
                const totalCount = sourceFiles.length;
                
                // Process in batches of 4 files to avoid browser limits
                const batchSize = 4;
                
                for (let i = 0; i < sourceFiles.length; i += batchSize) {
                    const batch = sourceFiles.slice(i, i + batchSize);
                    
                    // Process current batch in parallel
                    const batchPromises = batch.map((processedFile, indexInBatch) => {
                        return new Promise((resolve) => {
                            setTimeout(() => {
                                const fileBlob = processedFile.blob || processedFile.croppedBlob;
                                const fileName = processedFile.name || processedFile.croppedName;
                                
                                if (processedFile && fileBlob && !downloadedNames.has(fileName)) {
                                    downloadedNames.add(fileName);

                                    const url = this.safeCreateObjectURL(fileBlob);
                                    if (url) {
                                        // üöÄ S·ª¨ D·ª§NG PRE-AUTHORIZED ANCHOR - Bypass browser popup
                                        if (this.downloadAnchor) {
                                            this.downloadAnchor.href = url;
                                            this.downloadAnchor.download = fileName;
                                            this.downloadAnchor.click();
                                        } else {
                                            // Fallback to normal method
                                            const a = document.createElement('a');
                                            a.href = url;
                                            a.download = fileName;
                                            a.setAttribute('rel', 'noopener noreferrer');
                                            document.body.appendChild(a);
                                            a.click();
                                            document.body.removeChild(a);
                                        }

                                        // Safe cleanup with delay
                                        this.safeSetTimeout(() => this.safeRevokeObjectURL(url), 1000);

                                        downloadedCount++;
                                        console.log(`üì• Downloaded cropped file ${downloadedCount}/${totalCount}: ${fileName}`);
                                    } else {
                                        console.error(`‚ùå Failed to create URL for file: ${fileName}`);
                                        console.log(`Debug fileBlob:`, fileBlob);
                                    }
                                } else {
                                    if (!processedFile) console.error(`‚ùå No processedFile for index ${i + indexInBatch}`);
                                    if (!fileBlob) console.error(`‚ùå No fileBlob for: ${fileName}`);
                                    if (downloadedNames.has(fileName)) console.warn(`‚ö†Ô∏è Duplicate filename skipped: ${fileName}`);
                                }
                                resolve();
                            }, indexInBatch * 50); // 50ms delay within batch
                        });
                    });
                    
                    // Wait for current batch to complete before starting next batch
                    await Promise.all(batchPromises);
                    
                    // Small delay between batches
                    if (i + batchSize < sourceFiles.length) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }

                this.isDownloadingCropped = false;
                this.showToast('‚úÖ ƒê√£ t·∫£i v·ªÅ t·∫•t c·∫£ ·∫£nh ƒë√£ c·∫Øt t·ª´ng file ri√™ng l·∫ª!', 'success');
            }

            // Sync cropData to cropProcessedFiles automatically
            syncCropProcessedFiles() {
                console.log('üîÑ Syncing cropProcessedFiles...');
                
                // If cropProcessedFiles is empty but we have cropData.croppedImages, sync them
                if ((!this.cropProcessedFiles || this.cropProcessedFiles.length === 0) 
                    && this.cropData?.croppedImages?.length > 0) {
                    
                    console.log('üìã Auto-syncing from cropData.croppedImages:', this.cropData.croppedImages.length);
                    this.cropProcessedFiles = [];
                    
                    for (const croppedImage of this.cropData.croppedImages) {
                        this.cropProcessedFiles.push({
                            blob: croppedImage.croppedBlob,
                            name: croppedImage.croppedName,
                            size: croppedImage.croppedBlob.size
                        });
                    }
                    
                    console.log('‚úÖ Synced to cropProcessedFiles:', this.cropProcessedFiles.length);
                }
            }

            // Show crop results summary
            showCropResults() {
                // Auto-sync first
                this.syncCropProcessedFiles();
                
                if (!this.cropProcessedFiles || this.cropProcessedFiles.length === 0) {
                    this.showToast('Ch∆∞a c√≥ ·∫£nh n√†o ƒë∆∞·ª£c c·∫Øt!', 'error');
                    return;
                }

                const totalSize = this.cropProcessedFiles.reduce((sum, file) => sum + (file.blob?.size || 0), 0);
                const averageSize = (totalSize / this.cropProcessedFiles.length / 1024).toFixed(1);
                
                this.showToast(`üìä K·∫øt qu·∫£ c·∫Øt: ${this.cropProcessedFiles.length} ·∫£nh, trung b√¨nh ${averageSize}KB/·∫£nh`, 'success');
            }

            // Start new crop batch
            startNewCropBatch() {
                this.files = [];
                this.cropProcessedFiles = [];
                this.hideCropActions();
                this.updateStats();
                this.showToast('üîÑ ƒê√£ reset ƒë·ªÉ c·∫Øt batch m·ªõi. H√£y ch·ªçn ·∫£nh m·ªõi!', 'success');
            }

            // Download cropped images as ZIP
            async downloadCropAsZip() {
                // Check if there are cropped files to download
                if (!this.cropProcessedFiles || this.cropProcessedFiles.length === 0) {
                    this.showToast('Ch∆∞a c√≥ ·∫£nh n√†o ƒë∆∞·ª£c c·∫Øt! H√£y c·∫Øt ·∫£nh tr∆∞·ªõc khi t·∫£i v·ªÅ.', 'error');
                    return;
                }

                this.showToast('ƒêang t·∫°o file ZIP ch·ª©a ·∫£nh ƒë√£ c·∫Øt...', 'success');

                try {
                    // Disable ZIP buttons during processing
                    const zipBtn = document.getElementById('downloadCropZip');
                    const previewZipBtn = document.getElementById('downloadCropPreviewZip');
                    const configZipBtn = document.getElementById('downloadCropConfigZip');
                    const croppedZipBtn = document.getElementById('downloadCroppedZipBtn');
                    
                    if (zipBtn) {
                        zipBtn.disabled = true;
                        zipBtn.textContent = 'üì¶ ƒêang t·∫°o ZIP...';
                    }
                    if (previewZipBtn) {
                        previewZipBtn.disabled = true;
                        previewZipBtn.textContent = 'üì¶ ƒêang t·∫°o ZIP...';
                    }
                    if (configZipBtn) {
                        configZipBtn.disabled = true;
                        configZipBtn.textContent = 'üì¶ ƒêang t·∫°o ZIP...';
                    }
                    if (croppedZipBtn) {
                        croppedZipBtn.disabled = true;
                        croppedZipBtn.textContent = 'üì¶ ƒêang t·∫°o ZIP...';
                    }

                    // Prepare files for safe ZIP generation
                    const files = [];
                    for (let index = 0; index < this.cropProcessedFiles.length; index++) {
                        const processedFile = this.cropProcessedFiles[index];
                        if (processedFile && processedFile.blob) {
                            files.push({
                                filename: processedFile.name,
                                data: processedFile.blob
                            });
                        }
                    }

                    const zipName = `cropped_images_${new Date().getFullYear()}-${(new Date().getMonth() + 1).toString().padStart(2, '0')}-${new Date().getDate().toString().padStart(2, '0')}.zip`;
                    
                    // Generate safe ZIP
                    const zipBlob = await this.createSafeZip(
                        files,
                        zipName,
                        'Safe cropped images archive - Created by MEU Layout'
                    );

                    // Download safely
                    this.downloadSafeZip(zipBlob, zipName);

                    this.showToast(`‚úÖ ƒê√£ t·∫£i v·ªÅ ${this.cropProcessedFiles.length} ·∫£nh ƒë√£ c·∫Øt d∆∞·ªõi d·∫°ng ZIP!`, 'success');

                } catch (error) {
                    console.error('Error creating crop ZIP:', error);
                    this.showToast('‚ùå L·ªói khi t·∫°o file ZIP!', 'error');
                } finally {
                    // Re-enable ZIP buttons
                    const zipBtn = document.getElementById('downloadCropZip');
                    const previewZipBtn = document.getElementById('downloadCropPreviewZip');
                    const configZipBtn = document.getElementById('downloadCropConfigZip');
                    const croppedZipBtn = document.getElementById('downloadCroppedZipBtn');
                    
                    if (zipBtn) {
                        zipBtn.disabled = false;
                        zipBtn.textContent = 'üì¶ T·∫£i ZIP';
                    }
                    if (previewZipBtn) {
                        previewZipBtn.disabled = false;
                        previewZipBtn.textContent = 'üì¶ T·∫£i ZIP';
                    }
                    if (configZipBtn) {
                        configZipBtn.disabled = false;
                        configZipBtn.textContent = 'üì¶ T·∫£i ZIP';
                    }
                    if (croppedZipBtn) {
                        croppedZipBtn.disabled = false;
                        croppedZipBtn.textContent = 'üì¶ T·∫£i v·ªÅ ZIP';
                    }
                }
            }

            // Advanced image file validation
            // Detect image orientation (landscape/portrait) from first image
            async detectImageOrientation(file) {
                return new Promise((resolve) => {
                    const img = new Image();
                    const url = this.safeCreateObjectURL(file);
                    
                    if (!url) {
                        this.handleError(new Error('Failed to create URL for orientation detection'), 'detectImageOrientation');
                        resolve('portrait');
                        return;
                    }
                    
                    img.onload = () => {
                        try {
                            const orientation = img.width > img.height ? 'landscape' : 'portrait';
                            console.log(`Image orientation detected: ${orientation} (${img.width}√ó${img.height})`);
                            this.safeRevokeObjectURL(url);
                            resolve(orientation);
                        } catch (error) {
                            this.handleError(error, 'detectImageOrientation-onload');
                            this.safeRevokeObjectURL(url);
                            resolve('portrait');
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.warn('Failed to detect orientation, defaulting to portrait');
                        this.handleError(error, 'detectImageOrientation-onerror', false);
                        this.safeRevokeObjectURL(url);
                        resolve('portrait');
                    };
                    
                    img.src = url;
                });
            }

            // Adapt crop size based on image orientation
            adaptCropSizeToOrientation(originalCropSize, imageOrientation) {
                const { width, height } = originalCropSize;
                
                // Calculate original crop ratio
                const cropRatio = width / height;
                const isOriginalLandscape = cropRatio > 1;
                const isImageLandscape = imageOrientation === 'landscape';
                
                // If orientations match, keep original
                if (isOriginalLandscape === isImageLandscape) {
                    return originalCropSize;
                }
                
                // If orientations don't match, swap dimensions
                if (isImageLandscape && !isOriginalLandscape) {
                    // Image is landscape but crop is portrait -> make crop landscape
                    return { width: height, height: width };
                } else if (!isImageLandscape && isOriginalLandscape) {
                    // Image is portrait but crop is landscape -> make crop portrait  
                    return { width: height, height: width };
                }
                
                return originalCropSize;
            }

            // Detect image orientation from file data (for multi-crop)
            async detectImageOrientationFromFileData(fileData) {
                return new Promise((resolve) => {
                    const img = new Image();
                    // S·ª≠ d·ª•ng convertedBlob n·∫øu c√≥, kh√¥ng th√¨ d√πng file g·ªëc ho·∫∑c preview
                    let url = null;
                    if (fileData.convertedBlob) {
                        url = this.safeCreateObjectURL(fileData.convertedBlob);
                    } else if (fileData.file) {
                        url = this.safeCreateObjectURL(fileData.file);
                    } else if (fileData.preview) {
                        url = fileData.preview;
                    }

                    if (!url) {
                        console.warn(`No valid image source for file ${fileData.name || 'unknown'}, defaulting to portrait`);
                        resolve('portrait');
                        return;
                    }
                    
                    img.onload = () => {
                        try {
                            const orientation = img.width > img.height ? 'landscape' : 'portrait';
                            console.log(`File ${fileData.name}: ${orientation} (${img.width}√ó${img.height})`);
                            this.safeRevokeObjectURL(url);
                            resolve(orientation);
                        } catch (error) {
                            this.handleError(error, 'detectImageOrientationFromFileData-onload');
                            this.safeRevokeObjectURL(url);
                            resolve('portrait');
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.warn(`Failed to detect orientation for ${fileData.name}, defaulting to portrait`);
                        this.handleError(error, 'detectImageOrientationFromFileData-onerror', false);
                        this.safeRevokeObjectURL(url);
                        resolve('portrait');
                    };
                    
                    img.src = url;
                });
            }

            async validateImageFile(file) {
                console.log('Validating file:', file.name, 'MIME type:', file.type);

                // Check for PDF files - H·ªó tr·ª£ chuy·ªÉn ƒë·ªïi PDF sang JPG/PNG
                if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                    console.log('File is PDF - will be converted to images:', file.name);
                    return true;
                }

                // First check MIME type (for files with correct extensions)
                if (file.type && file.type.startsWith('image/')) {
                    console.log('File passed MIME type validation:', file.type);
                    return true;
                }

                // Also accept files with common image extensions even without MIME type
                const fileName = file.name.toLowerCase();
                const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.tif', '.heic', '.heif'];
                if (imageExtensions.some(ext => fileName.endsWith(ext))) {
                    console.log('File passed extension validation:', fileName);
                    return true;
                }
                
                // For files without proper MIME type, check file signatures
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const arr = new Uint8Array(e.target.result);
                        const isImage = this.checkImageSignature(arr);
                        console.log('File signature validation result:', isImage, 'for', file.name);
                        resolve(isImage);
                    };
                    reader.onerror = (error) => {
                        console.error('Error reading file for validation:', error);
                        resolve(false);
                    };
                    // Read first 20 bytes to check file signature
                    reader.readAsArrayBuffer(file.slice(0, 20));
                });
            }

            // Check file signature (magic numbers) to identify image files
            checkImageSignature(uint8Array) {
                const signatures = {
                    // JPEG signatures - more comprehensive
                    jpeg1: [0xFF, 0xD8, 0xFF, 0xE0],  // JFIF
                    jpeg2: [0xFF, 0xD8, 0xFF, 0xE1],  // EXIF
                    jpeg3: [0xFF, 0xD8, 0xFF, 0xE2],  // Canon
                    jpeg4: [0xFF, 0xD8, 0xFF, 0xE3],  // Samsung
                    jpeg5: [0xFF, 0xD8, 0xFF, 0xE8],  // SPIFF
                    jpeg6: [0xFF, 0xD8, 0xFF, 0xDB],  // Quantization tables
                    jpeg7: [0xFF, 0xD8, 0xFF, 0xC0],  // Start of Frame
                    jpeg8: [0xFF, 0xD8, 0xFF, 0xC2],  // Progressive JPEG
                    jpeg9: [0xFF, 0xD8, 0xFF, 0xC4],  // Huffman tables
                    jpeg10: [0xFF, 0xD8, 0xFF, 0xED], // Photoshop JPEG
                    jpeg11: [0xFF, 0xD8, 0xFF, 0xEE], // Adobe JPEG
                    jpeg_simple: [0xFF, 0xD8],        // Basic JPEG (2 bytes)
                    
                    // PNG signature
                    png: [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A],
                    
                    // GIF signatures
                    gif87a: [0x47, 0x49, 0x46, 0x38, 0x37, 0x61],
                    gif89a: [0x47, 0x49, 0x46, 0x38, 0x39, 0x61],
                    
                    // BMP signature
                    bmp: [0x42, 0x4D],
                    
                    // TIFF signatures
                    tiff1: [0x49, 0x49, 0x2A, 0x00],  // Little endian
                    tiff2: [0x4D, 0x4D, 0x00, 0x2A],  // Big endian
                    
                    // WebP signature (check first 4 bytes for RIFF)
                    webp: [0x52, 0x49, 0x46, 0x46],
                    
                    // ICO signature
                    ico: [0x00, 0x00, 0x01, 0x00],
                    cur: [0x00, 0x00, 0x02, 0x00],    // Cursor files
                    
                    // PSD signature
                    psd: [0x38, 0x42, 0x50, 0x53],
                    
                    // HEIC signatures
                    heic1: [0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63], // ftyp heic
                    heic2: [0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63], // ftyp heic (variant)
                    heic3: [0x00, 0x00, 0x00, 0x1C, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63], // ftyp heic (variant)
                    heif: [0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x66],  // ftyp heif
                    
                    // Additional formats for better detection
                    
                    // AVIF
                    avif: [0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66],
                    
                    // SVG (XML-based, check for '<svg' or '<?xml')
                    svg1: [0x3C, 0x73, 0x76, 0x67],   // <svg
                    svg2: [0x3C, 0x3F, 0x78, 0x6D, 0x6C] // <?xml
                };

                // Check each signature
                for (const [format, signature] of Object.entries(signatures)) {
                    if (this.matchesSignature(uint8Array, signature)) {
                        return true;
                    }
                }
                
                // Special check for WebP (need to check WEBP string at offset 8)
                if (uint8Array.length >= 12) {
                    const webpCheck = Array.from(uint8Array.slice(8, 12));
                    if (webpCheck[0] === 0x57 && webpCheck[1] === 0x45 && 
                        webpCheck[2] === 0x42 && webpCheck[3] === 0x50) {
                        return true;
                    }
                }
                
                return false;
            }

            // Helper function to match file signature
            matchesSignature(uint8Array, signature) {
                if (uint8Array.length < signature.length) return false;
                
                for (let i = 0; i < signature.length; i++) {
                    if (uint8Array[i] !== signature[i]) {
                        return false;
                    }
                }
                return true;
            }

            // Generate file hash for duplicate detection
            async generateFileHash(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const buffer = e.target.result;
                        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                        resolve(hashHex);
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            // Advanced image quality analysis
            async analyzeImageQuality(file) {
                return new Promise(async (resolve) => {
                    try {
                        let img;
                        
                        // Handle HEIC files differently - be more specific
                        const fileName = file.name.toLowerCase();
                        const isHEIC = (fileName.endsWith('.heic') || fileName.endsWith('.heif')) && 
                                       (!file.type || !file.type.startsWith('image/') || 
                                        file.type === 'image/heic' || file.type === 'image/heif');
                        
                        console.log('Quality analysis - File:', fileName, 'Type:', file.type, 'isHEIC:', isHEIC);
                        
                        if (isHEIC && typeof heic2any !== 'undefined') {
                            // Convert HEIC to blob first for analysis
                            const convertedBlob = await heic2any({
                                blob: file,
                                toType: 'image/jpeg',
                                quality: 1.0 // Maximum quality - no compression
                            });
                            const url = URL.createObjectURL(convertedBlob);
                            
                            img = new Image();
                            img.onload = () => {
                                URL.revokeObjectURL(url);
                                this.performQualityAnalysis(img, file, resolve);
                            };
                            img.onerror = () => {
                                URL.revokeObjectURL(url);
                                this.returnDefaultAnalysis(file, resolve);
                            };
                            img.src = url;
                        } else {
                            // Regular image files
                            img = new Image();
                            img.onload = () => {
                                this.performQualityAnalysis(img, file, resolve);
                            };
                            img.onerror = () => {
                                this.returnDefaultAnalysis(file, resolve);
                            };
                            img.src = URL.createObjectURL(file);
                        }
                    } catch (error) {
                        console.error('Quality analysis error:', error);
                        this.returnDefaultAnalysis(file, resolve);
                    }
                });
            }
            
            performQualityAnalysis(img, file, resolve) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                        
                // Get image data for analysis
                const imageData = ctx.getImageData(0, 0, img.width, img.height);
                const data = imageData.data;
                
                const analysis = {
                    width: img.width,
                    height: img.height,
                    totalPixels: img.width * img.height,
                    fileSize: file.size,
                    format: this.detectOriginalFormat(file),
                    hasTransparency: this.detectTransparency(data),
                    colorComplexity: this.calculateColorComplexity(data),
                    compressionArtifacts: this.detectCompressionArtifacts(data, img.width, img.height),
                    recommendedFormat: null,
                    qualityScore: 0
                };
                
                // Calculate quality metrics
                analysis.qualityScore = this.calculateQualityScore(analysis);
                analysis.recommendedFormat = this.recommendOptimalFormat(analysis);
                
                resolve(analysis);
            }
            
            returnDefaultAnalysis(file, resolve) {
                resolve({
                    width: 0, height: 0, totalPixels: 0,
                    fileSize: file.size, format: this.detectOriginalFormat(file),
                    hasTransparency: false, colorComplexity: 8,
                    compressionArtifacts: 0, qualityScore: 85,
                    recommendedFormat: 'jpeg'
                });
            }

            // Chuy·ªÉn ƒë·ªïi PDF sang ·∫£nh v·ªõi ch·∫•t l∆∞·ª£ng ho√†n h·∫£o
            async convertPDFToImages(file) {
                try {
                    console.log('üîÑ B·∫Øt ƒë·∫ßu chuy·ªÉn ƒë·ªïi PDF:', file.name);

                    // Ki·ªÉm tra PDF.js ƒë√£ load ch∆∞a
                    if (typeof pdfjsLib === 'undefined') {
                        throw new Error('Th∆∞ vi·ªán PDF.js ch∆∞a ƒë∆∞·ª£c t·∫£i. Vui l√≤ng t·∫£i l·∫°i trang.');
                    }

                    // ƒê·ªçc file PDF
                    const arrayBuffer = await file.arrayBuffer();
                    const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
                    const pdf = await loadingTask.promise;

                    const totalPages = pdf.numPages;
                    console.log(`üìÑ PDF c√≥ ${totalPages} trang`);

                    // L·∫•y c√†i ƒë·∫∑t t·ª´ UI
                    const pageSelection = document.getElementById('pdfPageSelection')?.value || 'all';
                    const dpi = parseInt(document.getElementById('pdfDPI')?.value || '300');
                    const scale = dpi / 72; // PDF m·∫∑c ƒë·ªãnh l√† 72 DPI

                    console.log(`üéØ C√†i ƒë·∫∑t: DPI=${dpi}, Scale=${scale.toFixed(2)}`);

                    // X√°c ƒë·ªãnh trang n√†o c·∫ßn chuy·ªÉn ƒë·ªïi
                    let pagesToConvert = [];
                    if (pageSelection === 'first') {
                        pagesToConvert = [1];
                    } else if (pageSelection === 'range') {
                        const rangeInput = document.getElementById('pdfPageRange')?.value || '';
                        pagesToConvert = this.parsePDFPageRange(rangeInput, totalPages);
                    } else {
                        // T·∫•t c·∫£ trang
                        pagesToConvert = Array.from({length: totalPages}, (_, i) => i + 1);
                    }

                    console.log(`üéØ S·∫Ω chuy·ªÉn ƒë·ªïi ${pagesToConvert.length} trang:`, pagesToConvert);

                    // Chuy·ªÉn ƒë·ªïi t·ª´ng trang
                    const convertedImages = [];
                    for (const pageNum of pagesToConvert) {
                        try {
                            const page = await pdf.getPage(pageNum);

                            // L·∫•y th√¥ng tin trang PDF g·ªëc
                            const viewport = page.getViewport({ scale: 1.0 });
                            const pageWidthInches = viewport.width / 72;
                            const pageHeightInches = viewport.height / 72;

                            console.log(`üìê Trang ${pageNum}: ${pageWidthInches.toFixed(2)}" √ó ${pageHeightInches.toFixed(2)}" (${viewport.width}√ó${viewport.height} pts)`);

                            // T√≠nh to√°n k√≠ch th∆∞·ªõc canvas d·ª±a tr√™n DPI
                            const targetWidth = Math.floor(pageWidthInches * dpi);
                            const targetHeight = Math.floor(pageHeightInches * dpi);

                            console.log(`üéØ K√≠ch th∆∞·ªõc m·ª•c ti√™u: ${targetWidth}√ó${targetHeight}px @ ${dpi} DPI`);

                            // T·∫°o canvas v·ªõi k√≠ch th∆∞·ªõc ch√≠nh x√°c
                            const canvas = document.createElement('canvas');
                            canvas.width = targetWidth;
                            canvas.height = targetHeight;

                            const context = canvas.getContext('2d', {
                                alpha: false,
                                willReadFrequently: false
                            });

                            // T√≠nh scale ƒë·ªÉ ƒë·∫°t ƒë∆∞·ª£c k√≠ch th∆∞·ªõc m·ª•c ti√™u
                            const renderScale = targetWidth / viewport.width;
                            const renderViewport = page.getViewport({ scale: renderScale });

                            console.log(`üîß Render scale: ${renderScale.toFixed(4)} | Viewport: ${renderViewport.width}√ó${renderViewport.height}px`);

                            // Kh√¥ng smoothing ƒë·ªÉ gi·ªØ text s·∫Øc n√©t
                            context.imageSmoothingEnabled = false;

                            // Render PDF
                            const renderContext = {
                                canvasContext: context,
                                viewport: renderViewport,
                                intent: 'print'
                            };

                            console.log(`‚è≥ ƒêang render trang ${pageNum}...`);
                            await page.render(renderContext).promise;
                            console.log(`‚úÖ Render xong trang ${pageNum}`);

                            // Chuy·ªÉn canvas sang blob v·ªõi ch·∫•t l∆∞·ª£ng TUY·ªÜT ƒê·ªêI
                            const outputFormat = document.getElementById('outputFormat')?.value || 'png';
                            let mimeType = 'image/png'; // M·∫∂C ƒê·ªäNH PNG cho lossless
                            let quality = 1.0;

                            if (outputFormat === 'png') {
                                mimeType = 'image/png'; // PNG = LOSSLESS 100%
                                // PNG kh√¥ng c√≥ quality parameter - lu√¥n lossless
                            } else if (outputFormat === 'jpeg' || outputFormat === 'jpg') {
                                mimeType = 'image/jpeg';
                                quality = 1.0; // JPEG quality 100% (v·∫´n c√≥ n√©n nh·∫π)
                            } else if (outputFormat === 'webp') {
                                mimeType = 'image/webp';
                                quality = 1.0; // WebP quality 100%
                            }

                            const blob = await new Promise(resolve => {
                                if (mimeType === 'image/png') {
                                    // PNG kh√¥ng c·∫ßn quality parameter - lu√¥n lossless
                                    canvas.toBlob(resolve, mimeType);
                                } else {
                                    // JPEG/WebP v·ªõi quality t·ªëi ƒëa
                                    canvas.toBlob(resolve, mimeType, quality);
                                }
                            });

                            // T·∫°o t√™n file cho trang
                            const baseName = file.name.replace(/\.pdf$/i, '');
                            const pageSuffix = totalPages > 1 ? `_page${pageNum}` : '';
                            const extension = outputFormat === 'jpeg' ? 'jpg' : outputFormat;
                            const fileName = `${baseName}${pageSuffix}.${extension}`;

                            convertedImages.push({
                                blob: blob,
                                fileName: fileName,
                                width: canvas.width,
                                height: canvas.height,
                                pageNum: pageNum
                            });

                            const actualDPI = Math.round((canvas.width / pageWidthInches));
                            const fileSizeMB = (blob.size / 1024 / 1024).toFixed(2);
                            console.log(`‚úÖ Ho√†n th√†nh trang ${pageNum}/${totalPages}:`);
                            console.log(`   üìè K√≠ch th∆∞·ªõc: ${canvas.width}√ó${canvas.height}px`);
                            console.log(`   üéØ DPI th·ª±c t·∫ø: ${actualDPI}`);
                            console.log(`   üíæ Dung l∆∞·ª£ng: ${fileSizeMB}MB`);

                        } catch (pageError) {
                            console.error(`‚ùå L·ªói khi chuy·ªÉn ƒë·ªïi trang ${pageNum}:`, pageError);
                        }
                    }

                    console.log(`üéâ Ho√†n th√†nh chuy·ªÉn ƒë·ªïi PDF: ${convertedImages.length} ·∫£nh`);
                    return convertedImages;

                } catch (error) {
                    console.error('‚ùå L·ªói chuy·ªÉn ƒë·ªïi PDF:', error);
                    throw error;
                }
            }

            // Parse PDF page range string (VD: "1-5, 7, 9-12")
            parsePDFPageRange(rangeStr, maxPages) {
                const pages = new Set();
                const parts = rangeStr.split(',').map(s => s.trim());

                for (const part of parts) {
                    if (part.includes('-')) {
                        // Range: "1-5"
                        const [start, end] = part.split('-').map(s => parseInt(s.trim()));
                        if (isNaN(start) || isNaN(end)) continue;
                        for (let i = Math.max(1, start); i <= Math.min(maxPages, end); i++) {
                            pages.add(i);
                        }
                    } else {
                        // Single page: "7"
                        const page = parseInt(part);
                        if (!isNaN(page) && page >= 1 && page <= maxPages) {
                            pages.add(page);
                        }
                    }
                }

                return Array.from(pages).sort((a, b) => a - b);
            }

            // Detect original image format from file signature
            detectOriginalFormat(file) {
                // Check file extension first for HEIC/HEIF
                const fileName = file.name.toLowerCase();
                if (fileName.endsWith('.heic')) return 'heic';
                if (fileName.endsWith('.heif')) return 'heif';
                
                // Then check MIME type
                if (file.type) {
                    const format = file.type.split('/')[1];
                    if (format === 'heic' || format === 'heif') return format;
                    return format || 'unknown';
                }
                
                // Fallback to extension detection
                if (fileName.endsWith('.jpg') || fileName.endsWith('.jpeg')) return 'jpeg';
                if (fileName.endsWith('.png')) return 'png';
                if (fileName.endsWith('.webp')) return 'webp';
                if (fileName.endsWith('.bmp')) return 'bmp';
                if (fileName.endsWith('.gif')) return 'gif';
                
                return 'unknown';
            }

            // Detect transparency in image
            detectTransparency(data) {
                for (let i = 3; i < data.length; i += 4) {
                    if (data[i] < 255) {
                        return true; // Found transparent/semi-transparent pixel
                    }
                }
                return false;
            }

            // Calculate color complexity (entropy-like measure)
            calculateColorComplexity(data) {
                const colorFreq = new Map();
                const totalPixels = data.length / 4;
                
                // Sample every 4th pixel for performance
                for (let i = 0; i < data.length; i += 16) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const color = (r << 16) | (g << 8) | b;
                    
                    colorFreq.set(color, (colorFreq.get(color) || 0) + 1);
                }
                
                // Calculate entropy-like score
                let entropy = 0;
                const sampleSize = Math.floor(totalPixels / 4);
                
                for (const freq of colorFreq.values()) {
                    const probability = freq / sampleSize;
                    if (probability > 0) {
                        entropy -= probability * Math.log2(probability);
                    }
                }
                
                return Math.min(entropy, 15); // Normalize to 0-15 range
            }

            // Detect compression artifacts (basic JPEG blockiness detection)
            detectCompressionArtifacts(data, width, height) {
                let blockiness = 0;
                const blockSize = 8; // JPEG uses 8x8 blocks
                
                // Sample some 8x8 blocks
                for (let y = 0; y < height - blockSize; y += blockSize * 2) {
                    for (let x = 0; x < width - blockSize; x += blockSize * 2) {
                        // Check horizontal discontinuity at block boundary
                        const leftIdx = (y * width + x + blockSize - 1) * 4;
                        const rightIdx = (y * width + x + blockSize) * 4;
                        
                        if (leftIdx >= 0 && rightIdx < data.length - 3) {
                            const leftBrightness = (data[leftIdx] + data[leftIdx + 1] + data[leftIdx + 2]) / 3;
                            const rightBrightness = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;
                            blockiness += Math.abs(leftBrightness - rightBrightness);
                        }
                    }
                }
                
                return Math.min(blockiness / 1000, 100); // Normalize
            }

            // Calculate overall quality score - NO SIZE BIAS
            calculateQualityScore(analysis) {
                let score = 100;
                
                // Penalize compression artifacts
                score -= analysis.compressionArtifacts * 0.5;
                
                // NO resolution rewards - all sizes are equally valid
                
                // Penalize low file size relative to dimensions (over-compression)
                const bytesPerPixel = analysis.fileSize / analysis.totalPixels;
                if (bytesPerPixel < 0.5) score -= 15; // Heavily compressed
                else if (bytesPerPixel < 1) score -= 10;
                else if (bytesPerPixel < 2) score -= 5;
                
                // Reward color complexity (more detail)
                score += analysis.colorComplexity;
                
                return Math.max(0, Math.min(100, Math.round(score)));
            }

            // Recommend optimal format based on analysis - NO SIZE CONSIDERATIONS
            recommendOptimalFormat(analysis) {
                // PNG for transparency or low color complexity (graphics/logos)
                if (analysis.hasTransparency) return 'png';
                if (analysis.colorComplexity < 8) return 'png';
                
                // WebP for modern browsers - ALL SIZES supported
                if (this.supportsWebP() && analysis.colorComplexity > 8) return 'webp';
                
                // JPEG for photos with high color complexity
                if (analysis.colorComplexity > 10) return 'jpeg';
                
                // Default to JPEG
                return 'jpeg';
            }

            // Check WebP support
            supportsWebP() {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 1;
                return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
            }

            // Fixed drag over handler
            handleDragOver(e) {
                e.preventDefault();
                e.currentTarget.classList.add('dragover');
            }

            handleDragLeave(e) {
                e.currentTarget.classList.remove('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('dragover');
                this.handleFileSelect(e.dataTransfer.files);
            }

            async handleFileSelect(fileList) {
                try {
                    console.log('üî• G·ªçi handleFileSelect v·ªõi', fileList?.length || 0, 'file(s)');
                    const files = Array.from(fileList);
                    const validFiles = [];
                    const invalidFiles = [];
                    const duplicateFiles = [];
                    
                    // Show upload progress overlay
                    if (files.length > 0) {
                        this.showUploadProgress(files.length);
                    }
                    
                    // Process each file with single progress tracking
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        
                        console.log('üîÑ ƒêang x·ª≠ l√Ω file:', file.name, 'ƒê·ªãnh d·∫°ng:', file.type, 'K√≠ch th∆∞·ªõc:', file.size);
                        
                        this.updateSingleUploadProgress(file.name, 'ƒêang validate...', i, 20);
                        const isValid = await this.validateImageFile(file);
                        console.log('‚úÖ K·∫øt qu·∫£ x√°c th·ª±c file cho', file.name, ':', isValid);
                        
                        if (isValid) {
                            this.updateSingleUploadProgress(file.name, 'ƒêang t·∫°o hash...', i, 50);
                            // Generate unique file hash for duplicate detection
                            const fileHash = await this.generateFileHash(file);
                            
                            this.updateSingleUploadProgress(file.name, 'Ki·ªÉm tra tr√πng l·∫∑p...', i, 70);
                            // Check for duplicates
                            const existingFile = this.files.find(f => f.hash === fileHash);
                            if (existingFile) {
                                duplicateFiles.push(file.name);
                                this.updateSingleUploadProgress(file.name, '‚ö†Ô∏è File tr√πng l·∫∑p', i, 100);
                                continue;
                            }
                            
                            validFiles.push({file, hash: fileHash});
                            this.updateSingleUploadProgress(file.name, '‚úÖ H·ª£p l·ªá', i, 100);
                        } else {
                            invalidFiles.push(file.name);
                            this.updateSingleUploadProgress(file.name, '‚ùå Kh√¥ng h·ª£p l·ªá', i, 100);
                        }
                    }
                    
                    if (validFiles.length === 0) {
                        let message = 'Kh√¥ng t√¨m th·∫•y file ·∫£nh h·ª£p l·ªá!';
                        if (duplicateFiles.length > 0) {
                            message += ` (${duplicateFiles.length} file tr√πng l·∫∑p)`;
                        }
                        this.showToast(message, 'error');
                        this.hideUploadProgress();
                        return;
                    }

                    // Analyze each valid file and create file data with quality info
                    for (let index = 0; index < validFiles.length; index++) {
                        const fileInfo = validFiles[index];
                        const file = fileInfo.file;

                        // Calculate actual file index in total files (not just valid files)
                        const totalFileIndex = files.findIndex(f => f.name === file.name);

                        // Ki·ªÉm tra n·∫øu l√† file PDF - chuy·ªÉn ƒë·ªïi sang ·∫£nh
                        const isPDF = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf');

                        if (isPDF) {
                            this.updateSingleUploadProgress(file.name, 'üìÑ ƒêang chuy·ªÉn ƒë·ªïi PDF...', totalFileIndex, 50);

                            try {
                                const convertedImages = await this.convertPDFToImages(file);

                                // Th√™m t·ª´ng ·∫£nh ƒë√£ chuy·ªÉn ƒë·ªïi t·ª´ PDF
                                for (let pdfImgIndex = 0; pdfImgIndex < convertedImages.length; pdfImgIndex++) {
                                    const pdfImage = convertedImages[pdfImgIndex];

                                    // T·∫°o File object t·ª´ blob ƒë·ªÉ ph√¢n t√≠ch ch·∫•t l∆∞·ª£ng
                                    const imageFile = new File([pdfImage.blob], pdfImage.fileName, { type: pdfImage.blob.type });

                                    const fileData = {
                                        id: `file_${Date.now()}_${index}_${pdfImgIndex}_${Math.random().toString(36).substr(2, 9)}`,
                                        file: imageFile,
                                        name: pdfImage.fileName,
                                        size: pdfImage.blob.size,
                                        status: 'success', // ƒê√£ chuy·ªÉn ƒë·ªïi xong
                                        convertedBlob: pdfImage.blob,
                                        convertedName: pdfImage.fileName,
                                        isImageFile: true,
                                        isPDFConverted: true,
                                        pdfSourceName: file.name,
                                        pdfPageNum: pdfImage.pageNum,
                                        hash: fileInfo.hash + '_page' + pdfImage.pageNum,
                                        originalIndex: this.files.length + index,
                                        qualityAnalysis: {
                                            width: pdfImage.width,
                                            height: pdfImage.height,
                                            totalPixels: pdfImage.width * pdfImage.height,
                                            fileSize: pdfImage.blob.size,
                                            format: pdfImage.blob.type.split('/')[1],
                                            hasTransparency: false,
                                            colorComplexity: 12,
                                            compressionArtifacts: 0,
                                            qualityScore: 100,
                                            recommendedFormat: pdfImage.blob.type.split('/')[1]
                                        }
                                    };
                                    this.files.push(fileData);
                                }

                                this.updateSingleUploadProgress(file.name, `‚úÖ ƒê√£ chuy·ªÉn ${convertedImages.length} trang`, totalFileIndex, 100);

                            } catch (pdfError) {
                                console.error('L·ªói chuy·ªÉn ƒë·ªïi PDF:', pdfError);
                                this.updateSingleUploadProgress(file.name, '‚ùå L·ªói chuy·ªÉn ƒë·ªïi PDF', totalFileIndex, 100);
                                this.showToast(`L·ªói chuy·ªÉn ƒë·ªïi PDF: ${file.name}`, 'error');
                            }

                        } else {
                            // File ·∫£nh th√¥ng th∆∞·ªùng
                            this.updateSingleUploadProgress(file.name, 'Ph√¢n t√≠ch ch·∫•t l∆∞·ª£ng...', totalFileIndex, 80);

                            // Analyze image quality
                            const qualityAnalysis = await this.analyzeImageQuality(file);

                            this.updateSingleUploadProgress(file.name, '‚úÖ Ho√†n th√†nh', totalFileIndex, 100);

                            const fileData = {
                                id: `file_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`, // Unique ID
                                file: file,
                                name: file.name,
                                size: file.size,
                                status: 'pending',
                                convertedBlob: null,
                                convertedName: null,
                                isImageFile: true,
                                hash: fileInfo.hash,
                                originalIndex: this.files.length + index, // Track order
                                qualityAnalysis: qualityAnalysis // Store quality analysis
                            };
                            this.files.push(fileData);
                        }
                    }

                    this.renderFileList();
                    this.updateStats();
                    this.updateControls();
                    
                    // Complete upload progress
                    this.completeUploadProgress();
                    
                    let message = `ƒê√£ th√™m ${validFiles.length} file ·∫£nh!`;
                    if (invalidFiles.length > 0) {
                        message += ` (B·ªè qua ${invalidFiles.length} file kh√¥ng ph·∫£i ·∫£nh)`;
                    }
                    this.showToast(message);
                    
                } catch (error) {
                    this.handleError(error, 'handleFileSelect');
                    this.completeUploadProgress(); // Ensure progress overlay is hidden
                } finally {
                    // Always update UI state
                    this.updateStats();
                    this.updateControls();
                }
            }

            getFileIcon(fileData) {
                if (fileData.status === 'success') return '‚úÖ';
                if (fileData.status === 'error') return '‚ùå';
                if (fileData.status === 'processing') return '‚è≥';
                return 'üñºÔ∏è';
            }

            renderFileList() {
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';

                // K·∫øt h·ª£p files t·ª´ c·∫£ hai ngu·ªìn
                const allFiles = [...this.files];
                if (window.converter && window.converter.files && window.converter.files !== this.files) {
                    allFiles.push(...window.converter.files);
                }

                allFiles.forEach(fileData => {
                    const fileItem = this.createFileItem(fileData);
                    fileList.appendChild(fileItem);
                });
            }

            createFileItem(fileData) {
                const item = document.createElement('div');
                item.className = 'file-item';
                
                const statusClass = {
                    pending: 'pending',
                    processing: 'converting', 
                    success: 'success',
                    error: 'error'
                }[fileData.status];

                // Create image preview
                const previewContent = this.createImagePreview(fileData);
                
                // Generate dimensions info with cm calculation
                let dimensionsInfo = '';
                if (fileData.qualityAnalysis) {
                    const analysis = fileData.qualityAnalysis;
                    const pixels = `${analysis.width}√ó${analysis.height}px`;
                    
                    // Calculate physical dimensions in cm (get DPI from current setting)
                    const dpiSelect = document.getElementById('customDPI');
                    const dpi = dpiSelect ? parseInt(dpiSelect.value) || 300 : 300;
                    const widthCm = (analysis.width / dpi * 2.54).toFixed(1);
                    const heightCm = (analysis.height / dpi * 2.54).toFixed(1);
                    const physicalSize = `${widthCm}√ó${heightCm}cm`;
                    
                    dimensionsInfo = `${pixels} ‚Ä¢ ${physicalSize} @ ${dpi} DPI`;
                }

                // Show conversion info for successful conversions
                let conversionInfo = '';
                if (fileData.status === 'success' && fileData.actualFormat) {
                    const qualityPercent = Math.round((fileData.usedQuality || 1) * 100);
                    conversionInfo = `‚ûú ${fileData.actualFormat.toUpperCase()} (${qualityPercent}%)`;
                }

                item.innerHTML = `
                    <div class="file-preview">
                        ${previewContent}
                    </div>
                    <div class="file-content">
                        <div class="file-header">
                            <div class="file-info">
                                <div class="file-name" title="${fileData.name}">${fileData.name}</div>
                            </div>
                        </div>
                        <div class="file-meta">
                            <div class="file-size">${this.formatFileSize(fileData.size)}</div>
                            <div class="file-status ${statusClass}">
                                ${this.getStatusText(fileData.status)}
                            </div>
                        </div>
                        ${dimensionsInfo ? `<div class="file-dimensions">${dimensionsInfo}</div>` : ''}
                        ${conversionInfo ? `<div class="conversion-info">${conversionInfo}</div>` : ''}
                        
                        <!-- Progress bar for conversion -->
                        <div class="file-progress ${fileData.status === 'processing' ? 'show' : ''}" id="progress-${fileData.id}">
                            <div class="progress-bar">
                                <div class="progress-fill" id="progress-fill-${fileData.id}"></div>
                            </div>
                            <div class="progress-text" id="progress-text-${fileData.id}">ƒêang x·ª≠ l√Ω...</div>
                            <div class="progress-time" id="progress-time-${fileData.id}"></div>
                        </div>
                        
                        <div class="file-actions">
                            <button class="file-action-btn download" ${fileData.status !== 'success' ? 'disabled' : ''}
                                    onclick="converter.showPreview('${fileData.id}')">
                                üëÅÔ∏è Preview
                            </button>
                            <button class="file-action-btn info" onclick="converter.showImageInfo('${fileData.id}')" title="Xem th√¥ng s·ªë ·∫£nh">
                                ‚ÑπÔ∏è Th√¥ng s·ªë
                            </button>
                            <button class="file-action-btn delete" onclick="converter.removeFile('${fileData.id}')">
                                X√≥a
                            </button>
                        </div>
                    </div>
                `;

                return item;
            }

            createImagePreview(fileData) {
                // Check if it's an image file (including HEIC/HEIF)
                const fileName = fileData.file.name.toLowerCase();
                const isImageFile = fileData.file.type.startsWith('image/') || 
                                   fileName.endsWith('.heic') || 
                                   fileName.endsWith('.heif');
                
                if (fileData.file && isImageFile) {
                    // Cleanup existing previewUrl if exists to prevent memory leak
                    if (fileData.previewUrl) {
                        URL.revokeObjectURL(fileData.previewUrl);
                    }
                    
                    // For HEIC/HEIF files, show a placeholder while processing
                    const isHEIC = (fileName.endsWith('.heic') || fileName.endsWith('.heif')) && 
                                   (!fileData.file.type || !fileData.file.type.startsWith('image/') || 
                                    fileData.file.type === 'image/heic' || fileData.file.type === 'image/heif');
                    if (isHEIC) {
                        // Store file reference for potential processing later
                        return `<div class="file-icon heic-placeholder">üñºÔ∏è<br><small>HEIC</small></div>`;
                    } else {
                        // Regular image files (not HEIC)
                        const previewUrl = this.safeCreateObjectURL(fileData.file);
                        if (previewUrl) {
                            fileData.previewUrl = previewUrl;
                            return `<img src="${previewUrl}" alt="${fileData.name}" loading="lazy">`;
                        } else {
                            // Fallback for files that can't create blob URL
                            return `<div class="file-icon">üñºÔ∏è<br><small>IMG</small></div>`;
                        }
                    }
                } else {
                    // Fallback icon for non-images
                    return `<div class="file-icon">${this.getFileIcon(fileData)}</div>`;
                }
            }

            // Get quality badge based on score
            getQualityBadge(score) {
                if (score >= 80) return 'üü¢ Cao';
                if (score >= 60) return 'üü° Trung b√¨nh';
                if (score >= 40) return 'üü† Th·∫•p';
                return 'üî¥ R·∫•t th·∫•p';
            }

            getStatusText(status) {
                const statusTexts = {
                    pending: 'Ch·ªù x·ª≠ l√Ω',
                    processing: 'ƒêang x·ª≠ l√Ω...',
                    success: 'Ho√†n th√†nh',
                    error: 'L·ªói'
                };
                return statusTexts[status] || 'Unknown';
            }

            async convertAllFiles() {
                // Get files from both this.files and window.converter.files
                const thisFiles = this.files || [];
                const windowFiles = (window.converter && window.converter.files) ? window.converter.files : [];

                // Combine files from both sources and filter for pending
                const combinedFiles = [...thisFiles, ...windowFiles];
                const pendingFiles = combinedFiles.filter(f => f.status === 'pending');

                console.log('üîç Convert DEBUG: this.files:', thisFiles.length, 'window.converter.files:', windowFiles.length);
                console.log('üîç Convert DEBUG: total files:', combinedFiles.length, 'pending files:', pendingFiles.length);

                if (pendingFiles.length === 0) {
                    this.showToast('Kh√¥ng c√≥ file n√†o c·∫ßn chuy·ªÉn ƒë·ªïi!', 'error');
                    return;
                }

                this.totalConversions = pendingFiles.length;
                this.currentConversion = 0;
                
                document.getElementById('progressContainer').style.display = 'block';
                const convertBtn = document.getElementById('convertAllBtn');
                convertBtn.disabled = true;
                convertBtn.innerHTML = '<span class="btn-indicator">‚ü≥</span>ƒêang x·ª≠ l√Ω 0/' + pendingFiles.length;

                // Process files with controlled concurrency to avoid overload
                const BATCH_SIZE = 8; // Process 8 files at a time for better performance while maintaining quality
                let successCount = 0;
                let errorCount = 0;

                for (let i = 0; i < pendingFiles.length; i += BATCH_SIZE) {
                    const batch = pendingFiles.slice(i, i + BATCH_SIZE);
                    
                    // Process batch concurrently
                    const batchPromises = batch.map(async (fileData) => {
                        try {
                            await this.convertFile(fileData);
                            if (fileData.status === 'success') {
                                successCount++;
                            } else {
                                errorCount++;
                            }
                        } catch (error) {
                            console.error('Error converting file:', fileData.name, error);
                            fileData.status = 'error';
                            errorCount++;
                        }
                        this.currentConversion++;
                        this.updateProgress();
                    });
                    
                    await Promise.all(batchPromises);
                    
                    // Optimized delay between batches - reduced for faster processing
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                document.getElementById('progressContainer').style.display = 'none';
                convertBtn.disabled = false;
                convertBtn.innerHTML = '<span class="btn-indicator">‚ñ∂</span>B·∫Øt ƒë·∫ßu chuy·ªÉn ƒë·ªïi';

                this.updateStats();
                this.updateControls();

                // üìä T·ªïng k·∫øt File System saves
                const totalFiles = [...this.files];
                if (window.converter && window.converter.files && window.converter.files !== this.files) {
                    totalFiles.push(...window.converter.files);
                }
                const fileSystemSavedCount = totalFiles.filter(f => f.fileSystemSaved === true).length;

                let message = `üéâ Ho√†n th√†nh chuy·ªÉn ƒë·ªïi: ${successCount} th√†nh c√¥ng`;
                if (errorCount > 0) {
                    message += `, ${errorCount} l·ªói`;
                }

                if (fileSystemSavedCount > 0) {
                    message += `\n\nüöÄ SI√äU NHANH: ${fileSystemSavedCount} ·∫£nh ƒë√£ t·ª± ƒë·ªông l∆∞u v√†o File System!`;
                    message += `\nüìÅ ƒê∆∞·ªùng d·∫´n: .../Converted/`;
                    message += `\nüéØ ƒê·ªãnh d·∫°ng ƒë√£ chuy·ªÉn ƒë·ªïi v√† t·ªëi ∆∞u`;
                    message += `\n‚ú® Truy c·∫≠p tr·ª±c ti·∫øp trong th∆∞ m·ª•c File System ƒë√£ c·∫•p quy·ªÅn!`;

                    // L·∫•y ƒë∆∞·ªùng d·∫´n th·ª±c t·∫ø
                    if (this.fileSystemStorage?.directoryHandle?.name) {
                        message += `\nüìÇ Th∆∞ m·ª•c: ${this.fileSystemStorage.directoryHandle.name}/Converted/`;
                    }
                }

                this.showToast(message, fileSystemSavedCount > 0 ? 'success' : 'info');
            }

            async convertFile(fileData) {
                const startTime = Date.now();
                fileData.status = 'processing';
                this.renderFileList();
                
                let canvas = null; // Declare canvas for cleanup
                
                // Show progress bar
                this.showProgress(fileData.id, 'ƒêang kh·ªüi t·∫°o...');

                try {
                    // Check if file is HEIC/HEIF format - be more specific  
                    const fileName = fileData.file.name.toLowerCase();
                    const isHEIC = (fileName.endsWith('.heic') || fileName.endsWith('.heif')) && 
                                   (!fileData.file.type || !fileData.file.type.startsWith('image/') || 
                                    fileData.file.type === 'image/heic' || fileData.file.type === 'image/heif');
                    
                    let img;
                    
                    if (isHEIC) {
                        // Handle HEIC/HEIF files using conversion
                        this.updateProgress(fileData.id, 10, 'ƒêang chuy·ªÉn ƒë·ªïi HEIC...');
                        img = await this.convertHEICToImage(fileData.file);
                        this.updateProgress(fileData.id, 30, 'HEIC ƒë√£ chuy·ªÉn ƒë·ªïi');
                    } else {
                        // Handle regular image files
                        this.updateProgress(fileData.id, 10, 'ƒêang t·∫£i ·∫£nh...');
                        const fileUrl = this.safeCreateObjectURL(fileData.file);
                        if (!fileUrl) {
                            throw new Error('Cannot create blob URL for this file type');
                        }
                        img = new Image();
                        
                        // Load image with error handling
                        await new Promise((resolve, reject) => {
                            img.onload = () => {
                                this.safeRevokeObjectURL(fileUrl);
                                resolve();
                            };
                            img.onerror = (error) => {
                                this.safeRevokeObjectURL(fileUrl);
                                this.handleError(error, 'convertFile-image-load', false);
                                reject(new Error('Cannot load image file'));
                            };
                            
                            // Set crossOrigin before src for security
                            img.crossOrigin = 'anonymous';
                            img.src = fileUrl;
                        });
                    }
                    
                    this.updateProgress(fileData.id, 40, 'ƒêang ph√¢n t√≠ch format...');
                    
                    // Determine optimal format and settings
                    const selectedFormat = document.getElementById('outputFormat').value;
                    let actualFormat = selectedFormat;
                    
                    if (selectedFormat === 'auto') {
                        // Use AI-analyzed recommendation, default to JPEG for HEIC
                        actualFormat = isHEIC ? 'jpeg' : (fileData.qualityAnalysis?.recommendedFormat || 'jpeg');
                    }

                    const canvas = this.safeCreateCanvas(img.width, img.height);
                    if (!canvas) {
                        throw new Error('Failed to create canvas for image conversion');
                    }
                    const ctx = canvas.getContext('2d', {
                        alpha: fileData.qualityAnalysis?.hasTransparency !== false,
                        colorSpace: 'srgb', // Ensure consistent color space
                        willReadFrequently: false
                    });
                    
                    // Configure canvas for high quality rendering
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // Set color profile optimizations
                    if (actualFormat === 'jpeg') {
                        // For JPEG, ensure no alpha channel confusion
                        ctx.globalCompositeOperation = 'source-over';
                    }

                    this.updateProgress(fileData.id, 60, 'ƒêang t·∫°o canvas...');
                    
                    // Set canvas dimensions - ALWAYS keep original size
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Draw image with original dimensions - NO SCALING
                    ctx.drawImage(img, 0, 0, img.width, img.height);
                    
                    this.updateProgress(fileData.id, 80, 'ƒêang chuy·ªÉn ƒë·ªïi format...');

                    let quality = parseInt(document.getElementById('quality').value) / 100;
                    
                    // Smart quality adjustment based on analysis
                    if (fileData.qualityAnalysis) {
                        quality = this.calculateOptimalQuality(fileData.qualityAnalysis, actualFormat, quality);
                    }
                    
                    // LU√îN s·ª≠ d·ª•ng ch·∫•t l∆∞·ª£ng t·ªëi ƒëa (100%) cho m·ªçi format
                    quality = 1.0; // Kh√¥ng n√©n ch·∫•t l∆∞·ª£ng
                    
                    const mimeType = {
                        'jpeg': 'image/jpeg',
                        'png': 'image/png', 
                        'webp': 'image/webp',
                        'bmp': 'image/bmp'
                    }[actualFormat];

                    // Convert to blob with optimized settings and 300 DPI metadata
                    const blob = await new Promise((resolve, reject) => {
                        try {
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    // For JPEG, enhance to maximum quality and add DPI metadata
                                    if (actualFormat === 'jpeg') {
                                        this.addDPIMetadata(blob, 300).then(resolve).catch(() => resolve(blob));
                                    } else {
                                        resolve(blob);
                                    }
                                } else {
                                    reject(new Error('Failed to convert image - canvas.toBlob returned null'));
                                }
                            }, mimeType, actualFormat === 'jpeg' ? 1.0 : quality); // Always max quality for JPEG
                        } catch (error) {
                            reject(new Error(`Canvas conversion failed: ${error.message}`));
                        }
                    });

                    this.updateProgress(fileData.id, 95, 'Ho√†n t·∫•t chuy·ªÉn ƒë·ªïi...');
                    
                    // Generate new filename based on naming option
                    const newFileName = this.generateFileName(fileData.name, actualFormat);

                    fileData.convertedBlob = blob;
                    fileData.convertedName = newFileName;
                    fileData.actualFormat = actualFormat; // Store the format used
                    fileData.usedQuality = quality; // Store the quality used
                    fileData.status = 'success';

                    // üöÄ AUTO-SAVE TO FILE SYSTEM - C·∫§U TR√öC CHU·∫®N
                    if (this.fileSystemStorage && this.fileSystemStorage.directoryHandle) {
                        try {
                            // üìÅ C·∫§U TR√öC TH∆Ø M·ª§C CHU·∫®N: Converted/ thay v√¨ ph√¢n lo·∫°i ph·ª©c t·∫°p
                            const subfolderName = 'Converted';

                            // L∆∞u v√†o File System v·ªõi c·∫•u tr√∫c chu·∫©n
                            await this.fileSystemStorage.saveImageToFileSystem(
                                blob,
                                newFileName,
                                subfolderName
                            );

                            console.log(`‚úÖ ƒê√£ auto-save Convert: ${subfolderName}/${newFileName}`);
                            fileData.fileSystemSaved = true;
                            fileData.fileSystemPath = `${subfolderName}/${newFileName}`;
                        } catch (fsError) {
                            console.error('‚ùå L·ªói auto-save Convert:', fsError);
                            fileData.fileSystemSaved = false;
                        }
                    }

                    // Calculate processing time
                    const processingTime = (Date.now() - startTime) / 1000;
                    let timeInfo = `Ho√†n th√†nh trong ${processingTime.toFixed(1)}s`;

                    // Th√™m th√¥ng tin File System save
                    if (fileData.fileSystemSaved) {
                        timeInfo += ` ‚Ä¢ üíæ ƒê√£ l∆∞u v√†o File System`;
                    }

                    // Complete progress with success
                    this.updateProgress(fileData.id, 100, '‚úÖ Ho√†n th√†nh', timeInfo);
                    setTimeout(() => this.hideProgress(fileData.id), 3000);

                } catch (error) {
                    this.handleError(error, `convertFile-${fileData.name}`);
                    fileData.status = 'error';
                    fileData.errorMessage = error.message;
                    
                    // Show user-friendly error in progress  
                    const userError = this.getUserFriendlyErrorMessage(error, 'convert');
                    this.updateProgress(fileData.id, 100, '‚ùå L·ªói chuy·ªÉn ƒë·ªïi', userError);
                    this.safeSetTimeout(() => this.hideProgress(fileData.id), 3000);
                } finally {
                    // Always cleanup canvas if it was created
                    if (canvas && canvas._cleanup) {
                        canvas._cleanup();
                    }
                }

                this.renderFileList();
            }


            // Calculate optimal quality based on image analysis - NO SIZE BIAS
            calculateOptimalQuality(analysis, format, userQuality) {
                let optimalQuality = userQuality;
                
                // For JPEG with high compression artifacts, use higher quality
                if (format === 'jpeg' && analysis.compressionArtifacts > 30) {
                    optimalQuality = Math.max(optimalQuality, 0.9);
                }
                
                // NO size-based quality adjustments - treat all sizes equally
                
                // For low-quality originals, don't go below certain threshold
                if (analysis.qualityScore < 60) {
                    optimalQuality = Math.max(optimalQuality, 0.85);
                }
                
                return optimalQuality;
            }

            // Generate filename based on naming options
            generateFileName(originalName, format) {
                const namingOption = document.getElementById('namingOption').value;
                const customPrefix = document.getElementById('customPrefix').value;
                
                // Define known image extensions
                const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff', 'tif', 'svg', 'ico'];
                
                // Get current extension (if any)
                const lastDotIndex = originalName.lastIndexOf('.');
                let baseName = originalName;
                let originalExt = '';
                
                if (lastDotIndex > 0) {
                    originalExt = originalName.substring(lastDotIndex + 1).toLowerCase();
                    
                    // Only remove extension if it's a known image extension
                    if (imageExtensions.includes(originalExt)) {
                        baseName = originalName.substring(0, lastDotIndex);
                        console.log(`Removed image extension .${originalExt} from ${originalName}`);
                    } else {
                        // Keep the "extension" as part of filename if it's not an image extension
                        baseName = originalName;
                        console.log(`Keeping non-image extension .${originalExt} in filename: ${originalName}`);
                    }
                } else {
                    // No extension found
                    baseName = originalName;
                }
                
                // Handle empty or very short names (like files from Google Drive)
                if (!baseName || baseName.trim() === '') {
                    baseName = 'converted_image';
                }
                
                const extension = {
                    'jpeg': 'jpg',
                    'png': 'png',
                    'webp': 'webp',
                    'bmp': 'bmp'
                }[format];

                let newName = baseName;
                
                switch(namingOption) {
                    case 'keep':
                        // Keep original name, just add new extension
                        break;
                    case 'add_converted':
                        newName = `${baseName}_converted`;
                        break;
                    case 'add_timestamp':
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                        newName = `${baseName}_${timestamp}`;
                        break;
                    case 'custom':
                        if (customPrefix && customPrefix.trim() !== '') {
                            newName = `${customPrefix.trim()}_${baseName}`;
                        }
                        break;
                }
                
                const finalName = `${newName}.${extension}`;
                console.log(`Generated filename: ${originalName} ‚Üí ${finalName}`);
                return finalName;
            }

            downloadFile(fileId) {
                const fileData = this.files.find(f => f.id == fileId);
                if (!fileData || !fileData.convertedBlob) return;

                // Create safe download with proper MIME type
                const safeBlob = new Blob([fileData.convertedBlob], { 
                    type: fileData.convertedBlob.type || 'image/jpeg' 
                });
                
                const url = URL.createObjectURL(safeBlob);
                const a = document.createElement('a');
                a.href = url;
                
                // Apply download folder settings
                const fileName = this.applyDownloadFolderSettings(fileData.convertedName, 'original');
                a.download = fileName;
                
                // Add attributes to prevent browser warnings
                a.setAttribute('rel', 'noopener noreferrer');
                a.setAttribute('target', '_self');
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up URL after short delay to ensure download starts
                setTimeout(() => URL.revokeObjectURL(url), 1000);

                this.showToast(`ƒê√£ t·∫£i xu·ªëng: ${fileData.convertedName}`);
            }

            // Show preview modal before download
            showPreview(fileId) {
                const fileData = this.files.find(f => f.id == fileId);
                if (!fileData || !fileData.convertedBlob || fileData.status !== 'success') {
                    this.showToast('File kh√¥ng s·∫µn s√†ng ƒë·ªÉ xem tr∆∞·ªõc!', 'error');
                    return;
                }

                this.currentPreviewFileId = fileId;
                
                // Show modal with loading state
                document.getElementById('previewModal').style.display = 'flex';
                document.getElementById('previewLoadingContainer').style.display = 'flex';
                document.getElementById('previewContentContainer').style.display = 'none';
                
                // Set title
                document.getElementById('previewModalTitle').textContent = `Preview - ${fileData.convertedName}`;
                
                // Load preview content
                this.loadPreviewContent(fileData);
            }

            // Load preview content
            async loadPreviewContent(fileData) {
                try {
                    // Create URL for preview - handle both converted files and crop tab files
                    const previewUrl = fileData.convertedBlob ? 
                        URL.createObjectURL(fileData.convertedBlob) : 
                        (fileData.preview || this.safeCreateObjectURL(fileData.file));
                    
                    // Load image
                    const img = document.getElementById('previewImage');
                    img.onload = () => {
                        // Hide loading and show content
                        document.getElementById('previewLoadingContainer').style.display = 'none';
                        document.getElementById('previewContentContainer').style.display = 'flex';
                        
                        // Update image dimensions in overlay and details
                        const dimensions = `${img.naturalWidth} √ó ${img.naturalHeight}px`;
                        document.getElementById('previewImageDimensions').textContent = dimensions;
                        document.getElementById('previewDimensions').textContent = dimensions;
                        
                        // Clean up URL
                        URL.revokeObjectURL(previewUrl);
                    };
                    
                    img.onerror = () => {
                        this.showToast('Kh√¥ng th·ªÉ t·∫£i preview image!', 'error');
                        this.hidePreviewModal();
                        URL.revokeObjectURL(previewUrl);
                    };
                    
                    img.src = previewUrl;
                    
                    // Update file details
                    this.updatePreviewDetails(fileData);
                    
                } catch (error) {
                    console.error('Load preview error:', error);
                    this.showToast('L·ªói khi t·∫£i preview!', 'error');
                    this.hidePreviewModal();
                }
            }

            // Update preview details
            updatePreviewDetails(fileData) {
                document.getElementById('previewFileName').textContent = fileData.convertedName;
                document.getElementById('previewFormat').textContent = this.getFileFormat(fileData.convertedName).toUpperCase();
                document.getElementById('previewFileSize').textContent = this.formatFileSize(fileData.convertedBlob.size);
                
                // Get quality info
                const qualityInfo = fileData.qualityAnalysis ? `${Math.round(fileData.qualityAnalysis.score)}%` : 'Ch·∫•t l∆∞·ª£ng cao';
                document.getElementById('previewQuality').textContent = qualityInfo;
                
                // Get dimensions (will be updated when image loads)
                document.getElementById('previewDimensions').textContent = fileData.dimensions || 'ƒêang t·∫£i...';
                
                // DPI info
                const format = this.getFileFormat(fileData.convertedName);
                const dpiText = (format === 'jpg' || format === 'jpeg') ? '300 DPI' : 'Vector/Lossless';
                document.getElementById('previewDPI').textContent = dpiText;
            }

            // Get file format from name
            getFileFormat(fileName) {
                const extension = fileName.split('.').pop().toLowerCase();
                return extension || 'unknown';
            }

            // Handle modal click (click outside to close)
            handleModalClick(event) {
                if (event.target.id === 'previewModal') {
                    this.hidePreviewModal();
                }
            }

            // Hide preview modal
            hidePreviewModal() {
                document.getElementById('previewModal').style.display = 'none';
                this.currentPreviewFileId = null;

                // Reset image src to prevent memory leaks
                const img = document.getElementById('previewImage');
                if (img.src) {
                    img.src = '';
                }
            }

            // Hi·ªÉn th·ªã th√¥ng tin chi ti·∫øt ·∫£nh
            async showImageInfo(fileId) {
                const fileData = this.files.find(f => f.id == fileId);
                if (!fileData) {
                    this.showToast('Kh√¥ng t√¨m th·∫•y th√¥ng tin file!', 'error');
                    return;
                }

                // T·∫°o modal loading
                const modal = document.createElement('div');
                modal.className = 'image-info-modal';
                modal.id = 'imageInfoModal';
                modal.innerHTML = `
                    <div class="image-info-content">
                        <div class="image-info-header">
                            <h2>‚ÑπÔ∏è ƒêang t·∫£i th√¥ng tin...</h2>
                            <button class="close" onclick="document.getElementById('imageInfoModal').remove()">√ó</button>
                        </div>
                        <div class="image-info-body" style="text-align: center; padding: 50px;">
                            <div class="preview-loading-spinner"></div>
                            <p>ƒêang ph√¢n t√≠ch ·∫£nh...</p>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);

                // L·∫•y th√¥ng tin th·ª±c t·∫ø t·ª´ ·∫£nh - ph√¢n t√≠ch ƒë·∫ßy ƒë·ªß n·∫øu ch∆∞a c√≥
                let analysis = fileData.qualityAnalysis;
                if (!analysis || !analysis.width || !analysis.height || !analysis.score) {
                    // Ph√¢n t√≠ch ƒë·∫ßy ƒë·ªß ch·∫•t l∆∞·ª£ng ·∫£nh
                    analysis = await this.analyzeImageQuality(fileData.file);
                    // L∆∞u l·∫°i v√†o fileData ƒë·ªÉ l·∫ßn sau kh√¥ng ph·∫£i ph√¢n t√≠ch l·∫°i
                    fileData.qualityAnalysis = analysis;
                }

                const width = analysis.width || 0;
                const height = analysis.height || 0;
                const colorSpace = this.detectColorSpace(fileData);
                const fileFormat = this.getFileFormat(fileData.name).toUpperCase();

                // T√≠nh to√°n DPI v√† k√≠ch th∆∞·ªõc v·∫≠t l√Ω
                const dpiSelect = document.getElementById('customDPI');
                const dpi = dpiSelect ? parseInt(dpiSelect.value) || 300 : 300;
                const widthCm = width ? (width / dpi * 2.54).toFixed(2) : '0';
                const heightCm = height ? (height / dpi * 2.54).toFixed(2) : '0';
                const widthInch = width ? (width / dpi).toFixed(2) : '0';
                const heightInch = height ? (height / dpi).toFixed(2) : '0';

                // Th√¥ng tin ch·∫•t l∆∞·ª£ng - hi·ªÉn th·ªã th·ª±c t·∫ø ho·∫∑c ·∫©n n·∫øu kh√¥ng c√≥
                const qualityScore = analysis.score ? `${Math.round(analysis.score)}%` : 'Cao';
                const sharpness = analysis.sharpness ? `${Math.round(analysis.sharpness * 100)}%` : 'T·ªët';
                const contrast = analysis.contrast ? `${Math.round(analysis.contrast * 100)}%` : 'T·ªët';
                const brightness = analysis.brightness ? `${Math.round(analysis.brightness * 100)}%` : 'T·ªët';

                // T·ªïng s·ªë pixel
                const totalPixels = width && height ?
                    `${((width * height) / 1000000).toFixed(2)} MP` : '0 MP';

                // T·ª∑ l·ªá khung h√¨nh
                const aspectRatio = this.calculateAspectRatio(width, height);

                modal.innerHTML = `
                    <div class="image-info-content">
                        <div class="image-info-header">
                            <h2>‚ÑπÔ∏è Th√¥ng s·ªë ·∫£nh</h2>
                            <button class="close" onclick="document.getElementById('imageInfoModal').remove()">√ó</button>
                        </div>
                        <div class="image-info-body">
                            <!-- Th√¥ng tin c∆° b·∫£n -->
                            <div class="info-section">
                                <div class="info-section-title">üìã Th√¥ng tin c∆° b·∫£n</div>
                                <div class="info-grid">
                                    <div class="info-item">
                                        <div class="info-item-label">T√™n file</div>
                                        <div class="info-item-value">${fileData.name}</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">ƒê·ªãnh d·∫°ng</div>
                                        <div class="info-item-value">${fileFormat}</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">K√≠ch th∆∞·ªõc file</div>
                                        <div class="info-item-value">${this.formatFileSize(fileData.size)}</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">Tr·∫°ng th√°i</div>
                                        <div class="info-item-value">${this.getStatusText(fileData.status)}</div>
                                    </div>
                                </div>
                            </div>

                            <!-- K√≠ch th∆∞·ªõc ·∫£nh -->
                            <div class="info-section">
                                <div class="info-section-title">üìê K√≠ch th∆∞·ªõc & ƒê·ªô ph√¢n gi·∫£i</div>
                                <div class="info-grid">
                                    <div class="info-item">
                                        <div class="info-item-label">K√≠ch th∆∞·ªõc (Pixels)</div>
                                        <div class="info-item-value">${width} √ó ${height} px</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">T·ªïng Pixels</div>
                                        <div class="info-item-value">${totalPixels}</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">T·ª∑ l·ªá khung h√¨nh</div>
                                        <div class="info-item-value">${aspectRatio}</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">DPI</div>
                                        <div class="info-item-value">${dpi} DPI</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">K√≠ch th∆∞·ªõc (cm)</div>
                                        <div class="info-item-value">${widthCm} √ó ${heightCm} cm</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">K√≠ch th∆∞·ªõc (inch)</div>
                                        <div class="info-item-value">${widthInch} √ó ${heightInch} inch</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Th√¥ng tin m√†u s·∫Øc -->
                            <div class="info-section">
                                <div class="info-section-title">üé® Th√¥ng tin m√†u s·∫Øc</div>
                                <div class="info-grid">
                                    <div class="info-item">
                                        <div class="info-item-label">H·ªá m√†u</div>
                                        <div class="info-item-value">${colorSpace}</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">ƒê·ªô s√°ng</div>
                                        <div class="info-item-value">${brightness}</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">ƒê·ªô t∆∞∆°ng ph·∫£n</div>
                                        <div class="info-item-value">${contrast}</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Ch·∫•t l∆∞·ª£ng ·∫£nh -->
                            <div class="info-section">
                                <div class="info-section-title">‚≠ê Ch·∫•t l∆∞·ª£ng ·∫£nh</div>
                                <div class="info-grid">
                                    <div class="info-item">
                                        <div class="info-item-label">ƒêi·ªÉm ch·∫•t l∆∞·ª£ng</div>
                                        <div class="info-item-value">${qualityScore}</div>
                                    </div>
                                    <div class="info-item">
                                        <div class="info-item-label">ƒê·ªô s·∫Øc n√©t</div>
                                        <div class="info-item-value">${sharpness}</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="image-info-footer">
                            <button class="info-close-btn" onclick="document.getElementById('imageInfoModal').remove()">
                                ƒê√≥ng
                            </button>
                        </div>
                    </div>
                `;

                // Th√™m modal v√†o body
                document.body.appendChild(modal);

                // ƒê√≥ng modal khi click b√™n ngo√†i
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            // Ph√°t hi·ªán h·ªá m√†u
            detectColorSpace(fileData) {
                const fileName = fileData.name.toLowerCase();
                if (fileName.endsWith('.png')) {
                    return 'RGBA (PNG v·ªõi alpha channel)';
                } else if (fileName.endsWith('.jpg') || fileName.endsWith('.jpeg')) {
                    return 'RGB (JPEG)';
                } else if (fileName.endsWith('.webp')) {
                    return 'RGB/RGBA (WebP)';
                } else if (fileName.endsWith('.gif')) {
                    return 'Indexed Color (GIF)';
                }
                return 'RGB (M·∫∑c ƒë·ªãnh)';
            }

            // T√≠nh t·ª∑ l·ªá khung h√¨nh
            calculateAspectRatio(width, height) {
                if (!width || !height) return 'N/A';
                const gcd = this.getGCD(width, height);
                const ratioW = width / gcd;
                const ratioH = height / gcd;

                // Ki·ªÉm tra c√°c t·ª∑ l·ªá ph·ªï bi·∫øn
                const ratio = width / height;
                if (Math.abs(ratio - 16/9) < 0.01) return '16:9 (Widescreen)';
                if (Math.abs(ratio - 4/3) < 0.01) return '4:3 (Standard)';
                if (Math.abs(ratio - 1) < 0.01) return '1:1 (Vu√¥ng)';
                if (Math.abs(ratio - 3/2) < 0.01) return '3:2 (M√°y ·∫£nh)';
                if (Math.abs(ratio - 21/9) < 0.01) return '21:9 (Ultrawide)';

                return `${ratioW}:${ratioH}`;
            }

            // L·∫•y k√≠ch th∆∞·ªõc ·∫£nh t·ª´ file
            async getImageDimensions(file) {
                return new Promise((resolve) => {
                    const img = new Image();
                    const url = URL.createObjectURL(file);

                    img.onload = () => {
                        URL.revokeObjectURL(url);
                        resolve({
                            width: img.width,
                            height: img.height,
                            score: 0,
                            sharpness: 0,
                            contrast: 0,
                            brightness: 0
                        });
                    };

                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        resolve({
                            width: 0,
                            height: 0,
                            score: 0,
                            sharpness: 0,
                            contrast: 0,
                            brightness: 0
                        });
                    };

                    img.src = url;
                });
            }

            // Confirm download from preview
            confirmDownload() {
                if (this.currentPreviewFileId) {
                    this.hidePreviewModal();
                    // Use original download function
                    this.downloadFile(this.currentPreviewFileId);
                    this.showToast('üéâ B·∫Øt ƒë·∫ßu t·∫£i xu·ªëng!', 'success');
                }
            }

            downloadAllFiles() {
                // K·∫øt h·ª£p files t·ª´ c·∫£ hai ngu·ªìn
                const allFiles = [...this.files];
                if (window.converter && window.converter.files && window.converter.files !== this.files) {
                    allFiles.push(...window.converter.files);
                }

                const successFiles = allFiles.filter(f => f.status === 'success');
                if (successFiles.length === 0) {
                    this.showToast('Kh√¥ng c√≥ file n√†o ƒë·ªÉ t·∫£i xu·ªëng!', 'error');
                    return;
                }

                // Prevent multiple downloads - check if already downloading
                if (this.isDownloading) {
                    this.showToast('‚è≥ ƒêang t·∫£i xu·ªëng... Vui l√≤ng ch·ªù!', 'warning');
                    return;
                }

                const downloadBtn = document.getElementById('downloadAllBtn');
                if (downloadBtn && downloadBtn.disabled) {
                    this.showToast('‚è≥ ƒêang t·∫£i xu·ªëng... Vui l√≤ng ch·ªù!', 'warning');
                    return;
                }

                // Set download flag
                this.isDownloading = true;
                if (downloadBtn) {
                    downloadBtn.disabled = true;
                    downloadBtn.textContent = `üì• ƒêang t·∫£i ${successFiles.length} files...`;
                }

                // Warn if user has cropped images but downloading originals
                if (this.cropProcessedFiles && this.cropProcessedFiles.length > 0) {
                    const confirmDownload = confirm(
                        `‚ö†Ô∏è C·∫¢NH B√ÅO: B·∫°n ƒë√£ c·∫Øt ${this.cropProcessedFiles.length} ·∫£nh!\n\n` +
                        `B·∫°n ƒëang t·∫£i v·ªÅ FILE G·ªêC (ch∆∞a c·∫Øt).\n` +
                        `ƒê·ªÉ t·∫£i ·∫£nh ƒë√£ c·∫Øt, h√£y d√πng n√∫t "‚úÇÔ∏è T·∫£i t·ª´ng file ƒë√£ c·∫Øt".\n\n` +
                        `V·∫´n mu·ªën t·∫£i file g·ªëc?`
                    );
                    
                    if (!confirmDownload) {
                        // Re-enable button and reset flag if cancelled
                        this.isDownloading = false;
                        if (downloadBtn) {
                            downloadBtn.disabled = false;
                            downloadBtn.textContent = 'üì• T·∫£i t·ª´ng file g·ªëc';
                        }
                        this.showToast('‚ùå ƒê√£ h·ªßy t·∫£i file g·ªëc. H√£y d√πng n√∫t "‚úÇÔ∏è T·∫£i t·ª´ng file ƒë√£ c·∫Øt" ƒë·ªÉ t·∫£i ·∫£nh ƒë√£ c·∫Øt!', 'warning');
                        return;
                    }
                }

                // Fast parallel download with reduced delays
                this.performFastDownload(successFiles, downloadBtn);

                this.showToast(`üì• ƒêang t·∫£i xu·ªëng ${successFiles.length} file G·ªêC... (üí° Tip: D√πng n√∫t "‚úÇÔ∏è T·∫£i t·ª´ng file ƒë√£ c·∫Øt" ƒë·ªÉ t·∫£i ·∫£nh ƒë√£ c·∫Øt!)`);
            }

            // Fast parallel download method - much faster for many files
            performFastDownload(successFiles, downloadBtn) {
                const totalCount = successFiles.length;
                const downloadedIds = new Set();
                let downloadedCount = 0;
                
                // Batch size for parallel downloads (browser can handle ~6 parallel requests)
                const batchSize = Math.min(6, totalCount);
                const batches = [];
                
                // Split files into batches
                for (let i = 0; i < totalCount; i += batchSize) {
                    batches.push(successFiles.slice(i, i + batchSize));
                }
                
                console.log(`üöÄ Starting fast download: ${totalCount} files in ${batches.length} batches`);
                
                // Process batches sequentially, but files within batch in parallel
                const processBatch = (batchIndex) => {
                    if (batchIndex >= batches.length) {
                        // All batches completed
                        setTimeout(() => {
                            this.isDownloading = false;
                            if (downloadBtn) {
                                downloadBtn.disabled = false;
                                downloadBtn.textContent = 'üì• T·∫£i t·ª´ng file g·ªëc';
                            }
                            this.showToast(`‚úÖ ƒê√£ t·∫£i xong ${totalCount} file g·ªëc!`, 'success');
                        }, 200);
                        return;
                    }
                    
                    const currentBatch = batches[batchIndex];
                    
                    // Process all files in current batch in parallel
                    currentBatch.forEach((fileData, indexInBatch) => {
                        setTimeout(() => {
                            if (!downloadedIds.has(fileData.id)) {
                                downloadedIds.add(fileData.id);
                                this.downloadFile(fileData.id);
                                downloadedCount++;
                                
                                // Update progress
                                if (downloadBtn) {
                                    downloadBtn.textContent = `üì• ƒêang t·∫£i ${downloadedCount}/${totalCount}...`;
                                }
                                
                                // Check if this batch is complete
                                if (downloadedCount === (batchIndex + 1) * batchSize || 
                                    downloadedCount === totalCount) {
                                    // Wait a bit then process next batch
                                    setTimeout(() => processBatch(batchIndex + 1), 150);
                                }
                            }
                        }, indexInBatch * 20); // Very small delay within batch (20ms)
                    });
                };
                
                // Start processing
                processBatch(0);
            }

            async downloadAsZip() {
                try {
                    // K·∫øt h·ª£p files t·ª´ c·∫£ hai ngu·ªìn
                    const allFiles = [...this.files];
                    if (window.converter && window.converter.files && window.converter.files !== this.files) {
                        allFiles.push(...window.converter.files);
                    }

                    const successFiles = allFiles.filter(f => f.status === 'success');
                    if (successFiles.length === 0) {
                        this.showToast('Kh√¥ng c√≥ file n√†o ƒë·ªÉ t·∫°o ZIP!', 'error');
                        return;
                    }

                    // Warn if user has cropped images but downloading originals
                    if (this.cropProcessedFiles && this.cropProcessedFiles.length > 0) {
                        const confirmDownload = confirm(
                            `‚ö†Ô∏è C·∫¢NH B√ÅO: B·∫°n ƒë√£ c·∫Øt ${this.cropProcessedFiles.length} ·∫£nh!\n\n` +
                            `B·∫°n ƒëang t·∫£i v·ªÅ ZIP FILE G·ªêC (ch∆∞a c·∫Øt).\n` +
                            `ƒê·ªÉ t·∫£i ZIP ·∫£nh ƒë√£ c·∫Øt, h√£y d√πng n√∫t "üì¶ T·∫£i ZIP ƒë√£ c·∫Øt".\n\n` +
                            `V·∫´n mu·ªën t·∫°o ZIP file g·ªëc?`
                        );
                        
                        if (!confirmDownload) {
                            this.showToast('‚ùå ƒê√£ h·ªßy t·∫£i ZIP g·ªëc. H√£y d√πng n√∫t "üì¶ T·∫£i ZIP ƒë√£ c·∫Øt" ƒë·ªÉ t·∫£i ZIP ·∫£nh ƒë√£ c·∫Øt!', 'warning');
                            return;
                        }
                    }

                    this.showToast('ƒêang t·∫°o ZIP file G·ªêC ch·∫•t l∆∞·ª£ng cao...', 'success');
                    
                    // Disable button during process
                    const zipBtn = document.getElementById('downloadZipBtn');
                    zipBtn.disabled = true;
                    zipBtn.textContent = 'üì¶ ƒêang t·∫°o ZIP...';

                    // Prepare files for safe ZIP generation
                    const files = [];
                    
                    // Create high-quality versions and prepare for ZIP
                    for (let i = 0; i < successFiles.length; i++) {
                        const fileData = successFiles[i];
                        
                        // Get high-quality version
                        let finalBlob;
                        if (this.needsHighQualityReconversion(fileData)) {
                            // Reconvert at maximum quality
                            finalBlob = await this.createHighQualityVersion(fileData);
                        } else {
                            // Use existing blob if already high quality
                            finalBlob = fileData.convertedBlob;
                        }

                        files.push({
                            filename: fileData.convertedName,
                            data: finalBlob
                        });
                        
                        // Update progress
                        zipBtn.textContent = `üì¶ ƒêang t·∫°o ZIP... (${i + 1}/${successFiles.length})`;
                    }

                    // Generate safe ZIP
                    zipBtn.textContent = 'üì¶ ƒêang n√©n file...';
                    
                    const timestamp = new Date().toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '-');
                    const zipName = `converted_images_300dpi_${timestamp}.zip`;
                    
                    const zipBlob = await this.createSafeZip(
                        files,
                        zipName,
                        'Safe high-quality converted images archive - Created by MEU Layout'
                    );

                    // Download safely
                    this.downloadSafeZip(zipBlob, zipName);

                    this.showToast(`‚úÖ ƒê√£ t·∫£i ZIP: ${zipName} (${successFiles.length} ·∫£nh ch·∫•t l∆∞·ª£ng cao)`);

                } catch (error) {
                    this.handleError(error, 'downloadAsZip');
                } finally {
                    // Re-enable button
                    const zipBtn = document.getElementById('downloadZipBtn');
                    if (zipBtn) {
                        zipBtn.disabled = false;
                        zipBtn.textContent = 'üì¶ T·∫£i v·ªÅ ZIP (Ch·∫•t l∆∞·ª£ng cao)';
                    }
                }
            }

            // üíæ L∆∞u file ƒë√£ convert v√†o File System v·ªõi th∆∞ m·ª•c ri√™ng
            async saveConvertedToFileSystem() {
                try {
                    // Ki·ªÉm tra File System storage
                    if (!this.fileSystemStorage) {
                        this.fileSystemStorage = window.createFileSystemStorage();
                    }

                    if (!this.fileSystemStorage || !this.fileSystemStorage.directoryHandle) {
                        this.showToast('‚ùå File System ch∆∞a ƒë∆∞·ª£c c·∫•p quy·ªÅn! Vui l√≤ng c·∫•p quy·ªÅn tr∆∞·ªõc.', 'error');
                        return;
                    }

                    // L·∫•y files ƒë√£ convert th√†nh c√¥ng
                    const allFiles = [...this.files];
                    if (window.converter && window.converter.files && window.converter.files !== this.files) {
                        allFiles.push(...window.converter.files);
                    }

                    const successFiles = allFiles.filter(f => f.status === 'success' && f.convertedBlob);
                    if (successFiles.length === 0) {
                        this.showToast('‚ùå Kh√¥ng c√≥ file n√†o ƒë√£ convert ƒë·ªÉ l∆∞u!', 'error');
                        return;
                    }

                    // Prevent multiple operations
                    const saveBtn = document.getElementById('saveToFileSystemBtn');
                    if (saveBtn && saveBtn.disabled) {
                        this.showToast('‚è≥ ƒêang l∆∞u... Vui l√≤ng ch·ªù!', 'warning');
                        return;
                    }

                    // Set loading state
                    if (saveBtn) {
                        saveBtn.disabled = true;
                        saveBtn.textContent = `üíæ ƒêang l∆∞u ${successFiles.length} files...`;
                    }

                    this.showToast(`üöÄ B·∫Øt ƒë·∫ßu l∆∞u ${successFiles.length} file v√†o File System...`, 'info');

                    let savedCount = 0;
                    let errorCount = 0;

                    // L∆∞u t·ª´ng file v√†o th∆∞ m·ª•c Converted
                    for (const fileData of successFiles) {
                        try {
                            // T·∫°o filename v·ªõi extension ƒë√∫ng
                            const originalName = fileData.file.name;
                            const nameWithoutExt = originalName.substring(0, originalName.lastIndexOf('.'));

                            // L·∫•y format t·ª´ active tab thay v√¨ select element
                            const activeFormatTab = document.querySelector('.format-tab.active');
                            const formatData = activeFormatTab ? activeFormatTab.dataset.format : 'jpg-zip';

                            // Extract actual format from data-format (e.g., 'jpg-zip' -> 'jpg')
                            const targetFormat = formatData.split('-')[0];
                            const newFileName = `${nameWithoutExt}.${targetFormat}`;

                            // L∆∞u v√†o th∆∞ m·ª•c Converted
                            await this.fileSystemStorage.saveImageToFileSystem(
                                fileData.convertedBlob,
                                newFileName,
                                'Converted' // Th∆∞ m·ª•c ri√™ng cho file ƒë√£ convert
                            );

                            savedCount++;
                            console.log(`‚úÖ ƒê√£ l∆∞u ${newFileName} v√†o File System`);

                            // Update progress
                            if (saveBtn) {
                                saveBtn.textContent = `üíæ ƒê√£ l∆∞u ${savedCount}/${successFiles.length}...`;
                            }

                        } catch (error) {
                            errorCount++;
                            console.error(`‚ùå L·ªói l∆∞u ${fileData.file.name}:`, error);
                        }
                    }

                    // Ho√†n th√†nh
                    const message = errorCount > 0
                        ? `‚úÖ ƒê√£ l∆∞u ${savedCount}/${successFiles.length} file v√†o File System (${errorCount} l·ªói)`
                        : `‚úÖ ƒê√£ l∆∞u t·∫•t c·∫£ ${savedCount} file v√†o th∆∞ m·ª•c Converted!`;

                    this.showToast(message, errorCount > 0 ? 'warning' : 'success');

                } catch (error) {
                    console.error('‚ùå L·ªói l∆∞u converted files v√†o File System:', error);
                    this.showToast('‚ùå L·ªói l∆∞u files v√†o File System!', 'error');
                } finally {
                    // Reset button
                    const saveBtn = document.getElementById('saveToFileSystemBtn');
                    if (saveBtn) {
                        saveBtn.disabled = false;
                        saveBtn.textContent = 'üíæ L∆∞u v√†o File System';
                    }
                }
            }

            // Check if file needs high-quality reconversion
            needsHighQualityReconversion(fileData) {
                const currentQuality = parseInt(document.getElementById('quality').value);
                return currentQuality < 100; // Reconvert if not at maximum quality
            }

            // Create high-quality version of the image
            async createHighQualityVersion(fileData) {
                try {
                    const fileUrl = this.safeCreateObjectURL(fileData.file);
                    if (!fileUrl) {
                        throw new Error('Cannot create blob URL for this file type');
                    }
                    const canvas = this.safeCreateCanvas(1, 1); // Will be resized later
                    const ctx = canvas.getContext('2d');
                    const img = new Image();

                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            this.safeRevokeObjectURL(fileUrl);
                            resolve();
                        };
                        img.onerror = (error) => {
                            this.safeRevokeObjectURL(fileUrl);
                            this.handleError(error, 'createHighQualityVersion-image-load', false);
                            reject(error);
                        };
                        img.crossOrigin = 'anonymous';
                        img.src = fileUrl;
                    });

                    // Always preserve original dimensions
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0, img.width, img.height);

                    // Get format from filename
                    const format = this.getFormatFromFileName(fileData.convertedName);
                    const mimeType = {
                        'jpg': 'image/jpeg',
                        'jpeg': 'image/jpeg',
                        'png': 'image/png',
                        'webp': 'image/webp',
                        'bmp': 'image/bmp'
                    }[format.toLowerCase()] || 'image/jpeg';

                    // Always use maximum quality (1.0)
                    const quality = 1.0;

                    const blob = await new Promise((resolve, reject) => {
                        canvas.toBlob(async (blob) => {
                            if (blob) {
                                // Add DPI metadata for JPEG
                                if (format.toLowerCase() === 'jpg' || format.toLowerCase() === 'jpeg') {
                                    try {
                                        const enhancedBlob = await this.addDPIMetadata(blob, 300);
                                        resolve(enhancedBlob);
                                    } catch (error) {
                                        resolve(blob); // Fallback to original
                                    }
                                } else {
                                    resolve(blob);
                                }
                            } else {
                                reject(new Error('Failed to create high-quality version'));
                            }
                        }, mimeType, 1.0); // Always maximum quality
                    });

                    return blob;

                } catch (error) {
                    this.handleError(error, 'createHighQualityVersion');
                    // Return original if reconversion fails
                    return fileData.convertedBlob;
                } finally {
                    // Always cleanup canvas
                    if (canvas && canvas._cleanup) {
                        canvas._cleanup();
                    }
                }
            }

            // Get format from filename
            getFormatFromFileName(fileName) {
                const extension = fileName.split('.').pop();
                return extension || 'jpg';
            }

            // Add safe 300 DPI metadata with EXIF resolution to JPEG blob
            async addDPIMetadata(blob, dpi = 300) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const arrayBuffer = e.target.result;
                            const uint8Array = new Uint8Array(arrayBuffer);
                            
                            // Create enhanced JFIF header with proper DPI
                            const jfifHeader = this.createEnhancedJFIFHeader(dpi);
                            
                            // Create comprehensive EXIF metadata with resolution
                            const exifHeader = this.createResolutionEXIFHeader(dpi);
                            
                            // Find the end of SOI (Start of Image) marker
                            let insertIndex = 2; // After FF D8
                            
                            // Remove any existing JFIF/EXIF headers
                            while (insertIndex < uint8Array.length - 1 && 
                                   uint8Array[insertIndex] === 0xFF && 
                                   (uint8Array[insertIndex + 1] === 0xE0 || 
                                    uint8Array[insertIndex + 1] === 0xE1)) {
                                const length = (uint8Array[insertIndex + 2] << 8) | uint8Array[insertIndex + 3];
                                insertIndex += 2 + length;
                            }
                            
                            // Create new array with enhanced headers
                            const totalHeaderLength = jfifHeader.length + exifHeader.length;
                            const newArray = new Uint8Array(uint8Array.length - insertIndex + 2 + totalHeaderLength);
                            let offset = 0;
                            
                            // Add SOI marker
                            newArray[offset++] = 0xFF;
                            newArray[offset++] = 0xD8;
                            
                            // Add enhanced JFIF header
                            newArray.set(jfifHeader, offset);
                            offset += jfifHeader.length;
                            
                            // Add resolution EXIF header
                            newArray.set(exifHeader, offset);
                            offset += exifHeader.length;
                            
                            // Add rest of original image (skip old headers)
                            newArray.set(uint8Array.slice(insertIndex), offset);
                            
                            const newBlob = new Blob([newArray], { 
                                type: 'image/jpeg',
                                lastModified: Date.now()
                            });
                            console.log(`‚úÖ Enhanced DPI metadata: ${dpi} DPI added to JPEG`);
                            console.log(`üìè Physical size should be: ${(newArray.length > 50000 ? 'Large file' : 'Small file')} - Check with image viewer that supports DPI`);
                            resolve(newBlob);
                        } catch (error) {
                            console.warn('Failed to add enhanced DPI metadata:', error);
                            resolve(blob); // Return original if failed
                        }
                    };
                    reader.readAsArrayBuffer(blob);
                });
            }

            // Create enhanced JFIF header with proper DPI encoding
            createEnhancedJFIFHeader(dpi) {
                const header = new Uint8Array(18);
                let offset = 0;
                
                // JFIF marker
                header[offset++] = 0xFF; // Marker prefix
                header[offset++] = 0xE0; // JFIF marker
                
                // Length (16 bytes after this field)
                header[offset++] = 0x00;
                header[offset++] = 0x10;
                
                // JFIF identifier
                header[offset++] = 0x4A; // 'J'
                header[offset++] = 0x46; // 'F'
                header[offset++] = 0x49; // 'I'
                header[offset++] = 0x46; // 'F'
                header[offset++] = 0x00; // null terminator
                
                // Version (1.02 for better compatibility)
                header[offset++] = 0x01; // Major
                header[offset++] = 0x02; // Minor
                
                // Density units (1 = pixels per inch, 2 = pixels per cm)
                header[offset++] = 0x01; // Keep as PPI
                
                // X density (DPI) - Big endian format
                header[offset++] = (dpi >> 8) & 0xFF;
                header[offset++] = dpi & 0xFF;
                
                // Y density (DPI) - Big endian format
                header[offset++] = (dpi >> 8) & 0xFF;
                header[offset++] = dpi & 0xFF;
                
                // Thumbnail dimensions (0x0 = no thumbnail)
                header[offset++] = 0x00; // X thumbnail
                header[offset++] = 0x00; // Y thumbnail
                
                return header;
            }

            // Create comprehensive EXIF header with resolution information
            createResolutionEXIFHeader(dpi = 300) {
                // Enhanced EXIF header with proper resolution tags
                const header = new Uint8Array(98);
                let offset = 0;
                
                // EXIF marker
                header[offset++] = 0xFF; // Marker prefix
                header[offset++] = 0xE1; // EXIF marker
                
                // Length (96 bytes after this field)
                header[offset++] = 0x00;
                header[offset++] = 0x60;
                
                // EXIF identifier
                header[offset++] = 0x45; // 'E'
                header[offset++] = 0x78; // 'x'
                header[offset++] = 0x69; // 'i'
                header[offset++] = 0x66; // 'f'
                header[offset++] = 0x00; // null terminator
                header[offset++] = 0x00; // padding
                
                // TIFF header (little-endian)
                header[offset++] = 0x49; // 'I'
                header[offset++] = 0x49; // 'I' (little-endian)
                header[offset++] = 0x2A; // TIFF magic number
                header[offset++] = 0x00;
                header[offset++] = 0x08; // IFD offset
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // IFD (Image File Directory) - 3 entries
                header[offset++] = 0x03; // Number of entries
                header[offset++] = 0x00;
                
                // Entry 1: Software tag (safe identifier)
                header[offset++] = 0x31; // Tag 0x0131 (Software)
                header[offset++] = 0x01;
                header[offset++] = 0x02; // ASCII type
                header[offset++] = 0x00;
                header[offset++] = 0x1A; // 26 characters
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x32; // Offset to string
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // Entry 2: DateTime tag
                header[offset++] = 0x32; // Tag 0x0132 (DateTime)
                header[offset++] = 0x01;
                header[offset++] = 0x02; // ASCII type
                header[offset++] = 0x00;
                header[offset++] = 0x14; // 20 characters
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x4C; // Offset to datetime
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // Entry 3: Image description (digital signature)
                header[offset++] = 0x0E; // Tag 0x010E (ImageDescription)
                header[offset++] = 0x01;
                header[offset++] = 0x02; // ASCII type
                header[offset++] = 0x00;
                header[offset++] = 0x06; // 6 characters
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x70; // Offset to string
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // Next IFD offset (0 = no more IFDs)
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // XResolution rational value (DPI/1)
                header[offset++] = dpi & 0xFF;        // DPI numerator low
                header[offset++] = (dpi >> 8) & 0xFF; // DPI numerator high
                header[offset++] = (dpi >> 16) & 0xFF;// DPI numerator
                header[offset++] = (dpi >> 24) & 0xFF;// DPI numerator
                header[offset++] = 0x01; // Denominator = 1
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // YResolution rational value (same as X)
                header[offset++] = dpi & 0xFF;        // DPI numerator low
                header[offset++] = (dpi >> 8) & 0xFF; // DPI numerator high
                header[offset++] = (dpi >> 16) & 0xFF;// DPI numerator
                header[offset++] = (dpi >> 24) & 0xFF;// DPI numerator
                header[offset++] = 0x01; // Denominator = 1
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                header[offset++] = 0x00;
                
                // Software string: "ImgConv\0\0\0"
                const software = "ImgConv\0\0\0";
                for (let i = 0; i < Math.min(software.length, 10); i++) {
                    header[offset++] = software.charCodeAt(i);
                }
                
                // Image description: "HiRes\0"
                const description = "HiRes\0";
                for (let i = 0; i < Math.min(description.length, 6); i++) {
                    header[offset++] = description.charCodeAt(i);
                }
                
                console.log(`EXIF Resolution metadata: ${dpi} DPI encoded in EXIF`);
                return header;
            }

            removeFile(fileId) {
                // Find file to cleanup blob URLs before removing
                const fileToRemove = this.files.find(f => f.id === fileId);
                if (fileToRemove && fileToRemove.previewUrl) {
                    URL.revokeObjectURL(fileToRemove.previewUrl);
                }
                
                this.files = this.files.filter(f => f.id != fileId);
                this.renderFileList();
                this.updateStats();
                this.updateControls();
                this.showToast('ƒê√£ x√≥a file!');
            }

            clearAllFiles() {
                if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ file?')) {
                    // Cleanup all blob URLs before clearing files
                    this.files.forEach(file => {
                        if (file.previewUrl) {
                            URL.revokeObjectURL(file.previewUrl);
                        }
                    });

                    this.files = [];
                    this.renderFileList();
                    this.updateStats();
                    this.updateControls();
                    this.showToast('ƒê√£ x√≥a t·∫•t c·∫£ file!');
                }
            }

            // üöÄ PH√çM T·∫ÆT X√ìA NHANH: Ctrl+Shift+Delete - T·ªëi ∆∞u hi·ªáu su·∫•t
            clearAllImageData() {
                const startTime = performance.now();

                try {
                    this.showToast('üóëÔ∏è ƒêang x√≥a t·∫•t c·∫£ d·ªØ li·ªáu...', 'info');

                    // üî• BATCH CLEANUP - X√≥a h√†ng lo·∫°t ƒë·ªÉ gi·∫£m lag
                    const urlsToRevoke = [];

                    // Thu th·∫≠p t·∫•t c·∫£ URLs c·∫ßn x√≥a
                    if (this.files && this.files.length > 0) {
                        this.files.forEach(file => {
                            if (file.previewUrl) urlsToRevoke.push(file.previewUrl);
                            if (file.originalUrl) urlsToRevoke.push(file.originalUrl);
                            if (file.convertedUrl) urlsToRevoke.push(file.convertedUrl);
                        });
                    }

                    if (this.cropProcessedFiles && this.cropProcessedFiles.length > 0) {
                        this.cropProcessedFiles.forEach(file => {
                            if (file.previewUrl) urlsToRevoke.push(file.previewUrl);
                            if (file.objectUrl) urlsToRevoke.push(file.objectUrl);
                        });
                    }

                    if (this.cropData?.croppedImages && this.cropData.croppedImages.length > 0) {
                        this.cropData.croppedImages.forEach(img => {
                            if (img.previewUrl) urlsToRevoke.push(img.previewUrl);
                            if (img.objectUrl) urlsToRevoke.push(img.objectUrl);
                        });
                    }

                    // üéØ X√ìA DATA C·ªêT L√ïI
                    this.files = [];
                    this.convertedFiles = [];
                    this.cropProcessedFiles = [];
                    this.cropFiles = [];

                    // X√≥a d·ªØ li·ªáu crop
                    if (this.cropData) {
                        this.cropData.croppedImages = [];
                        this.cropData.files = [];
                    }

                    // X√≥a d·ªØ li·ªáu multi-crop
                    if (this.multiCropData) {
                        this.multiCropData.files = [];
                        this.multiCropData.selectedFiles = new Set();
                        this.multiCropData.cropSelections = new Map();
                    }

                    // üíæ GI·∫¢I PH√ìNG MEMORY - Batch revoke URLs ƒë·ªÉ tr√°nh lag
                    if (urlsToRevoke.length > 0) {
                        // X·ª≠ l√Ω t·ª´ng batch 50 URLs ƒë·ªÉ tr√°nh block UI
                        const batchSize = 50;
                        let processed = 0;

                        const processBatch = () => {
                            const batch = urlsToRevoke.slice(processed, processed + batchSize);
                            batch.forEach(url => {
                                try {
                                    URL.revokeObjectURL(url);
                                } catch (e) {
                                    // Ignore revoke errors
                                }
                            });
                            processed += batchSize;

                            if (processed < urlsToRevoke.length) {
                                // Ti·∫øp t·ª•c batch ti·∫øp theo v·ªõi micro-delay
                                setTimeout(processBatch, 1);
                            }
                        };

                        processBatch();
                    }

                    // üé® C·∫¨P NH·∫¨T GIAO DI·ªÜN
                    requestAnimationFrame(() => {
                        this.renderFileList();
                        this.updateStats();
                        this.updateControls();

                        // Clear UI elements
                        const filesList = document.getElementById('filesList');
                        const cropFilesList = document.getElementById('cropFilesList');
                        const multiCropGrid = document.getElementById('multiCropGrid');

                        if (filesList) filesList.innerHTML = '';
                        if (cropFilesList) cropFilesList.innerHTML = '';
                        if (multiCropGrid) multiCropGrid.innerHTML = '';

                        const endTime = performance.now();
                        const duration = Math.round(endTime - startTime);

                        this.showToast(`‚úÖ ƒê√£ x√≥a t·∫•t c·∫£ d·ªØ li·ªáu! (${duration}ms) - Memory freed: ${urlsToRevoke.length} URLs`, 'success');

                        // Force garbage collection hint
                        if (window.gc) {
                            setTimeout(() => window.gc(), 100);
                        }
                    });

                } catch (error) {
                    console.error('Error clearing data:', error);
                    this.showToast('‚ùå L·ªói khi x√≥a d·ªØ li·ªáu!', 'error');
                }
            }

            // üéØ SETUP AUTO DOWNLOAD PERMISSION - DISABLED
            setupAutoDownloadPermission() {
                console.log('üö´ Auto download permission setup disabled');

                // Still create download anchor for manual downloads but without auto-permission
                this.downloadAnchor = document.createElement('a');
                this.downloadAnchor.style.display = 'none';
                this.downloadAnchor.setAttribute('download', '');
                document.body.appendChild(this.downloadAnchor);

                // Disable auto permission setup
                return;

                /*
                // Preload user gesture for downloads - DISABLED
                const enableDownloads = () => {
                    try {
                        // Mock download to establish permission
                        const tempBlob = new Blob([''], { type: 'text/plain' });
                        const tempUrl = URL.createObjectURL(tempBlob);

                        this.downloadAnchor.href = tempUrl;
                        this.downloadAnchor.download = 'temp.txt';

                        // Trigger silent download (will be cancelled)
                        this.downloadAnchor.click();

                        // Cleanup immediately
                        setTimeout(() => {
                            URL.revokeObjectURL(tempUrl);
                        }, 100);

                        console.log('üöÄ Download permissions pre-authorized');
                    } catch (e) {
                        console.warn('Download permission setup failed:', e);
                    }
                };
                */

                /*
                // Setup on first user interaction - DISABLED
                const setupOnce = () => {
                    enableDownloads();

                    // Remove listeners after first setup
                    ['click', 'keydown', 'touchstart'].forEach(event => {
                        document.removeEventListener(event, setupOnce);
                    });
                };

                // Wait for user interaction - DISABLED
                ['click', 'keydown', 'touchstart'].forEach(event => {
                    document.addEventListener(event, setupOnce, { passive: true });
                });
                */
            }

            retryFailedFiles() {
                const failedFiles = this.files.filter(f => f.status === 'error');
                failedFiles.forEach(f => f.status = 'pending');
                this.renderFileList();
                this.showToast(`ƒê√£ ƒë·∫∑t l·∫°i ${failedFiles.length} file l·ªói!`);
            }

            updateProgress() {
                const progress = (this.currentConversion / this.totalConversions) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
                
                // Update convert button text with progress
                const convertBtn = document.getElementById('convertAllBtn');
                if (convertBtn && this.totalConversions > 0) {
                    convertBtn.innerHTML = `<span class="btn-indicator">‚ü≥</span>ƒêang x·ª≠ l√Ω ${this.currentConversion}/${this.totalConversions} (${Math.round(progress)}%)`;
                }
            }

            updateStats() {
                // K·∫øt h·ª£p files t·ª´ c·∫£ hai ngu·ªìn
                const allFiles = [...this.files];
                if (window.converter && window.converter.files && window.converter.files !== this.files) {
                    allFiles.push(...window.converter.files);
                }

                const totalFiles = allFiles.length;
                const convertedFiles = allFiles.filter(f => f.status === 'success').length;
                const totalSize = allFiles.reduce((sum, f) => sum + f.size, 0);
                const successRate = totalFiles > 0 ? Math.round((convertedFiles / totalFiles) * 100) : 0;

                document.getElementById('totalFiles').textContent = totalFiles;
                document.getElementById('convertedFiles').textContent = convertedFiles;
                document.getElementById('totalSize').textContent = this.formatFileSize(totalSize);
                document.getElementById('successRate').textContent = successRate + '%';
            }

            updateControls() {
                // K·∫øt h·ª£p files t·ª´ c·∫£ hai ngu·ªìn
                const allFiles = [...this.files];
                if (window.converter && window.converter.files && window.converter.files !== this.files) {
                    allFiles.push(...window.converter.files);
                }

                const hasPendingFiles = allFiles.some(f => f.status === 'pending');
                const hasSuccessFiles = allFiles.some(f => f.status === 'success');
                const hasFiles = allFiles.length > 0;

                // Ki·ªÉm tra xem c√≥ file PDF n√†o trong danh s√°ch kh√¥ng
                const hasPDFFiles = allFiles.some(f => {
                    const fileName = f.name || f.file?.name || '';
                    return fileName.toLowerCase().endsWith('.pdf') || f.file?.type === 'application/pdf';
                });

                // Hi·ªÉn th·ªã/·∫©n PDF settings container
                const pdfSettingsContainer = document.getElementById('pdfSettingsContainer');
                if (pdfSettingsContainer) {
                    pdfSettingsContainer.style.display = hasPDFFiles ? 'block' : 'none';
                }

                document.getElementById('convertAllBtn').disabled = !hasPendingFiles;
                document.getElementById('bulkActions').style.display = hasFiles ? 'flex' : 'none';
                document.getElementById('downloadAllBtn').disabled = !hasSuccessFiles;
                document.getElementById('downloadZipBtn').disabled = !hasSuccessFiles;
                document.getElementById('saveToFileSystemBtn').disabled = !hasSuccessFiles;
                document.getElementById('createPdfBtn').disabled = !hasSuccessFiles;
                document.getElementById('cropImagesBtn').disabled = !hasSuccessFiles;
            }

            // Show crop configuration modal
            showCropModal() {
                this.showCropPage();
            }

            showCropPage() {
                // K·∫øt h·ª£p files t·ª´ c·∫£ hai ngu·ªìn
                const allFiles = [...this.files];
                if (window.converter && window.converter.files && window.converter.files !== this.files) {
                    allFiles.push(...window.converter.files);
                }

                const successFiles = allFiles.filter(f => f.status === 'success');
                if (successFiles.length === 0) {
                    this.showToast('Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ c·∫Øt!', 'error');
                    return;
                }
                
                // Switch to crop tab instead of showing separate page
                this.switchToTab('crop');
                
                // Initialize template selection if not already done
                if (!this.currentCropTemplate) {
                    this.currentCropTemplate = '5.5x8.5';
                }
                
                this.initializeCropPageHandlers();
                this.populateCropFileGrid();
                this.updateSizeDetailsPage();
            }

            hideCropPage() {
                // Switch back to convert tab instead of hiding crop page
                this.switchToTab('convert');
            }

            // Hide crop modal (legacy)
            hideCropModal() {
                document.getElementById('cropModal').style.display = 'none';
            }

            initializeCropPageHandlers() {
                console.log('üîß Initializing crop page handlers...');
                
                // Initialize crop upload handlers
                this.initializeCropUploadHandlers();
                
                // Back button - REMOVED (no longer needed in tab mode)
                // document.getElementById('backToMain').addEventListener('click', () => {
                //     this.hideCropPage();
                // });

                // Size cards in page - updated for minimalist design
                const sizeCards = document.querySelectorAll('#cropPage .size-option, #cropPage .size-card-compact, #cropPage .size-option-minimal, #cropPage .size-card-minimal');
                console.log('üìã Found', sizeCards.length, 'size cards');

                sizeCards.forEach((card, index) => {
                    card.addEventListener('click', () => {
                        console.log('üéØ Size card clicked:', card.getAttribute('data-size'));
                        // Remove active from all cards
                        sizeCards.forEach(c => c.classList.remove('active'));
                        card.classList.add('active');

                        const templateSize = card.getAttribute('data-size');
                        this.selectCropTemplatePage(templateSize);
                    });
                });

                // Custom inputs - RESTORED for full cropPage
                const cropWidthPage = document.getElementById('cropWidthPage');
                const cropHeightPage = document.getElementById('cropHeightPage');
                const cropDPIPage = document.getElementById('cropDPIPage');
                const startCroppingPage = document.getElementById('startCroppingPage');
                
                if (cropWidthPage) {
                    cropWidthPage.addEventListener('input', () => {
                        this.validateCustomSizeInputs();
                        this.updateSizeDetailsPage();
                    });
                    console.log('‚úÖ cropWidthPage handler added');
                }

                if (cropHeightPage) {
                    cropHeightPage.addEventListener('input', () => {
                        this.validateCustomSizeInputs();
                        this.updateSizeDetailsPage();
                    });
                    console.log('‚úÖ cropHeightPage handler added');
                }
                
                if (cropDPIPage) {
                    cropDPIPage.addEventListener('change', () => {
                        this.updateSizeDetailsPage();
                    });
                    console.log('‚úÖ cropDPIPage handler added');
                }

                // Start cropping button
                if (startCroppingPage) {
                    startCroppingPage.addEventListener('click', () => {
                        this.startCroppingFromPage();
                    });
                    console.log('‚úÖ startCroppingPage handler added');
                }
                
                console.log('‚úÖ All crop page handlers initialized');
            }

            initializeCropUploadHandlers() {
                console.log('üîß Initializing crop upload handlers...');
                
                // Prevent duplicate initialization
                if (this.cropUploadInitialized) {
                    console.log('‚ö†Ô∏è Crop upload handlers already initialized, skipping...');
                    return;
                }
                
                // Initialize crop files array if not exists
                if (!this.cropFiles) {
                    this.cropFiles = [];
                }
                
                const cropFileInput = document.getElementById('cropFileInput');
                const cropSelectFilesBtn = document.getElementById('cropSelectFilesBtn');
                const cropUploadZone = document.getElementById('cropUploadZone');
                const uploadAreaCrop = document.querySelector('.upload-area-crop');
                const cropClearAllBtn = document.getElementById('cropClearAllBtn');
                
                if (!cropFileInput || !cropSelectFilesBtn || !uploadAreaCrop) {
                    console.error('‚ùå Crop upload elements not found');
                    return;
                }
                
                // Select files button - immediate trigger with feedback
                cropSelectFilesBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Immediate visual feedback
                    cropSelectFilesBtn.style.transform = 'scale(0.95)';
                    // Direct call to maintain user activation
                    cropFileInput.click();
                    // Reset visual feedback after
                    setTimeout(() => {
                        cropSelectFilesBtn.style.transform = '';
                    }, 50);
                });
                
                // Upload area click - avoid button check
                uploadAreaCrop.addEventListener('click', (e) => {
                    if (!e.target.closest('.select-files-btn-crop')) {
                        cropFileInput.click();
                    }
                });
                
                // File input change
                cropFileInput.addEventListener('change', (e) => {
                    this.handleCropFiles(e.target.files);
                });
                
                // Drag and drop
                uploadAreaCrop.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadAreaCrop.classList.add('dragover');
                });
                
                uploadAreaCrop.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadAreaCrop.classList.remove('dragover');
                });
                
                uploadAreaCrop.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadAreaCrop.classList.remove('dragover');
                    this.handleCropFiles(e.dataTransfer.files);
                });
                
                // Clear all button
                if (cropClearAllBtn) {
                    cropClearAllBtn.addEventListener('click', () => {
                        this.clearAllCropFiles();
                    });
                }
                
                // Mark as initialized to prevent duplicates
                this.cropUploadInitialized = true;
                console.log('‚úÖ Crop upload handlers initialized');
            }

            handleCropFiles(fileList) {
                console.log('üìÅ Handling crop files:', fileList.length);
                
                const validFiles = Array.from(fileList).filter(file => {
                    if (file.type.startsWith('image/')) {
                        return true;
                    } else {
                        this.showToast(`B·ªè qua file kh√¥ng ph·∫£i ·∫£nh: ${file.name}`);
                        return false;
                    }
                });
                
                validFiles.forEach(file => {
                    // Check if file already exists
                    const exists = this.cropFiles.some(f => f.name === file.name && f.size === file.size);
                    if (!exists) {
                        const fileData = {
                            file: file,
                            name: file.name,
                            size: file.size,
                            type: file.type,
                            preview: null,
                            id: Date.now() + Math.random()
                        };
                        
                        // Generate preview
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            fileData.preview = e.target.result;
                            this.updateCropFilesDisplay();
                        };
                        reader.readAsDataURL(file);
                        
                        this.cropFiles.push(fileData);
                    }
                });
                
                this.updateCropFilesDisplay();
                this.showToast(`ƒê√£ th√™m ${validFiles.length} ·∫£nh v√†o crop tab`);
            }

            updateCropFilesDisplay() {
                const cropFilesGrid = document.getElementById('cropFilesGrid');
                const cropFilesList = document.getElementById('cropFilesList');
                const cropFileCount = document.getElementById('cropFileCount');
                
                if (!cropFilesGrid || !cropFilesList || !cropFileCount) return;
                
                // Update count
                cropFileCount.textContent = this.cropFiles.length;
                
                // Show/hide grid
                if (this.cropFiles.length > 0) {
                    cropFilesGrid.style.display = 'block';
                } else {
                    cropFilesGrid.style.display = 'none';
                    return;
                }
                
                // Clear current list
                cropFilesList.innerHTML = '';
                
                // Add files to list
                this.cropFiles.forEach((fileData, index) => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'crop-file-item';
                    fileItem.innerHTML = `
                        <img src="${fileData.preview || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjRjVGNUY1Ii8+CjxwYXRoIGQ9Ik0yMCAyMEw0MCA0ME0yMCA0MEw0MCAyMCIgc3Ryb2tlPSIjQ0NDIiBzdHJva2Utd2lkdGg9IjIiLz4KPC9zdmc+'}" alt="${fileData.name}" class="crop-file-preview">
                        <div class="crop-file-info">
                            <div class="crop-file-name">${fileData.name}</div>
                            <div class="crop-file-size">${this.formatFileSize(fileData.size)}</div>
                        </div>
                        <div class="crop-file-actions">
                            <button class="crop-file-btn remove" onclick="imageApp.removeCropFile(${index})">
                                <span class="btn-indicator">√ó</span>X√≥a
                            </button>
                        </div>
                    `;
                    cropFilesList.appendChild(fileItem);
                });
            }

            removeCropFile(index) {
                if (index >= 0 && index < this.cropFiles.length) {
                    const fileName = this.cropFiles[index].name;
                    this.cropFiles.splice(index, 1);
                    this.updateCropFilesDisplay();
                    this.showToast(`ƒê√£ x√≥a ${fileName}`);
                }
            }

            clearAllCropFiles() {
                const count = this.cropFiles.length;
                this.cropFiles = [];
                this.updateCropFilesDisplay();
                this.showToast(`ƒê√£ x√≥a t·∫•t c·∫£ ${count} ·∫£nh`);
            }

            selectCropTemplatePage(template) {
                console.log('üéØ Selecting crop template:', template);

                const customSection = document.getElementById('customSizeSectionPage');
                const widthInput = document.getElementById('cropWidthPage');
                const heightInput = document.getElementById('cropHeightPage');

                // Remove active state from all size cards
                document.querySelectorAll('#cropPage .size-option, #cropPage .size-card-compact, #cropPage .size-card, #cropPage .size-option-minimal, #cropPage .size-card-minimal').forEach(card => {
                    card.classList.remove('active');
                });

                // Add active state to selected card
                const selectedCard = document.querySelector(`#cropPage [data-size="${template}"]`);
                if (selectedCard) {
                    selectedCard.classList.add('active');
                }

                if (template === 'custom') {
                    // Show custom size section with clear indication
                    customSection.style.display = 'block';
                    customSection.style.background = '#f0f9ff';
                    customSection.style.border = '2px solid #3b82f6';
                    customSection.style.borderRadius = '8px';
                    customSection.style.padding = '15px';

                    // Enable and highlight custom inputs
                    if (widthInput) {
                        widthInput.disabled = false;
                        widthInput.style.background = '#ffffff';
                        widthInput.style.border = '2px solid #3b82f6';
                    }
                    if (heightInput) {
                        heightInput.disabled = false;
                        heightInput.style.background = '#ffffff';
                        heightInput.style.border = '2px solid #3b82f6';
                    }

                    console.log('‚úÖ Custom size mode enabled - inputs are editable');
                } else {
                    // Hide custom section and reset styles
                    customSection.style.display = 'none';
                    customSection.style.background = '';
                    customSection.style.border = '';
                    customSection.style.borderRadius = '';
                    customSection.style.padding = '';

                    // Set predefined size values
                    const [width, height] = template.split('x').map(s => parseFloat(s));
                    if (widthInput) {
                        widthInput.value = width;
                        widthInput.disabled = true;
                        widthInput.style.background = '#f3f4f6';
                        widthInput.style.border = '1px solid #d1d5db';
                    }
                    if (heightInput) {
                        heightInput.value = height;
                        heightInput.disabled = true;
                        heightInput.style.background = '#f3f4f6';
                        heightInput.style.border = '1px solid #d1d5db';
                    }

                    console.log(`‚úÖ Predefined size selected: ${width}x${height}cm - inputs are locked`);
                }

                this.currentCropTemplate = template;
                this.updateSizeDetailsPage();
            }

            validateCustomSizeInputs() {
                const widthInput = document.getElementById('cropWidthPage');
                const heightInput = document.getElementById('cropHeightPage');
                const startButton = document.getElementById('startCroppingPage');

                if (!widthInput || !heightInput || !startButton) return;

                const width = parseFloat(widthInput.value);
                const height = parseFloat(heightInput.value);

                // Reset styles
                widthInput.style.borderColor = '#3b82f6';
                heightInput.style.borderColor = '#3b82f6';

                let isValid = true;
                let errorMessage = '';

                // Validate width
                if (isNaN(width) || width < 0.5 || width > 50) {
                    widthInput.style.borderColor = '#ef4444';
                    isValid = false;
                    errorMessage = 'Chi·ªÅu r·ªông ph·∫£i t·ª´ 0.5 ƒë·∫øn 50 cm';
                }

                // Validate height
                if (isNaN(height) || height < 0.5 || height > 50) {
                    heightInput.style.borderColor = '#ef4444';
                    isValid = false;
                    errorMessage = 'Chi·ªÅu cao ph·∫£i t·ª´ 0.5 ƒë·∫øn 50 cm';
                }

                // Update start button state
                if (isValid && this.currentCropTemplate === 'custom') {
                    startButton.disabled = false;
                    startButton.style.opacity = '1';
                    startButton.style.background = '#3b82f6';
                } else if (this.currentCropTemplate === 'custom') {
                    startButton.disabled = true;
                    startButton.style.opacity = '0.5';
                    startButton.style.background = '#9ca3af';
                }

                // Show error message if needed
                const existingError = document.getElementById('customSizeError');
                if (existingError) existingError.remove();

                if (!isValid && errorMessage) {
                    const errorDiv = document.createElement('div');
                    errorDiv.id = 'customSizeError';
                    errorDiv.style.color = '#ef4444';
                    errorDiv.style.fontSize = '12px';
                    errorDiv.style.marginTop = '5px';
                    errorDiv.textContent = errorMessage;
                    document.getElementById('customSizeSectionPage').appendChild(errorDiv);
                }

                return isValid;
            }

            updateSizeDetailsPage() {
                // Lu√¥n ƒë·ªçc t·ª´ input thay v√¨ d√πng currentCropTemplate
                const widthInput = document.getElementById('cropWidthPage');
                const heightInput = document.getElementById('cropHeightPage');

                if (!widthInput || !heightInput) return;

                let width = parseFloat(widthInput.value);
                let height = parseFloat(heightInput.value);

                // N·∫øu input kh√¥ng h·ª£p l·ªá, d√πng template m·∫∑c ƒë·ªãnh
                if (isNaN(width) || isNaN(height)) {
                    const template = this.currentCropTemplate || '5.5x8.5';
                    if (template === 'custom') {
                        width = 5.5;
                        height = 8.5;
                    } else {
                        [width, height] = template.split('x').map(s => parseFloat(s));
                    }
                }

                // C√îNG TH·ª®C CH√çNH X√ÅC: C·ªë ƒë·ªãnh DPI = 300
                const DPI = 300;
                const pixelWidth = Math.round((width / 2.54) * DPI); // (cm √∑ 2.54) √ó 300
                const pixelHeight = Math.round((height / 2.54) * DPI); // (cm √∑ 2.54) √ó 300
                const ratio = this.getSimpleRatio(width, height);

                // C·∫≠p nh·∫≠t t·∫•t c·∫£ c√°c element c√≥ id n√†y
                const sizeElements = document.querySelectorAll('#currentSizePage');
                const pixelElements = document.querySelectorAll('#currentPixelsPage');
                const ratioElements = document.querySelectorAll('#currentRatioPage');

                sizeElements.forEach(el => el.textContent = `${width}√ó${height} cm`);
                pixelElements.forEach(el => el.textContent = `${pixelWidth}√ó${pixelHeight}px`);
                ratioElements.forEach(el => el.textContent = ratio);
            }

            populateCropFileGrid() {
                const grid = document.getElementById('cropFilesList');
                if (!grid) {
                    console.warn('cropFilesList element not found');
                    return;
                }

                // Combine files from both sources: crop tab upload and convert section
                const successFiles = this.files.filter(f => f.status === 'success');
                const cropTabFiles = this.cropFiles || [];

                grid.innerHTML = '';
                
                // Add converted files first
                successFiles.forEach((fileData, index) => {
                    const item = this.createCropFileItem(fileData, index, 'converted');
                    grid.appendChild(item);
                });
                
                // Add crop tab files
                cropTabFiles.forEach((fileData, index) => {
                    const item = this.createCropFileItem(fileData, index + successFiles.length, 'crop');
                    grid.appendChild(item);
                });

                // Update file count
                const totalFiles = successFiles.length + cropTabFiles.length;
                document.getElementById('cropFileCount').textContent = `${totalFiles} ·∫£nh ƒë∆∞·ª£c ch·ªçn`;
            }

            createCropFileItem(fileData, index, source = 'converted') {
                const item = document.createElement('div');
                item.className = 'crop-file-item selected';
                item.setAttribute('data-file-id', fileData.id);
                item.setAttribute('data-source', source);

                let previewUrl;
                if (source === 'crop') {
                    // For crop tab files, use preview or file directly
                    previewUrl = fileData.preview || this.safeCreateObjectURL(fileData.file);
                } else {
                    // For converted files, use convertedBlob or original file
                    previewUrl = fileData.convertedBlob ? 
                        URL.createObjectURL(fileData.convertedBlob) : 
                        this.safeCreateObjectURL(fileData.file);
                }

                const imageContent = previewUrl ? 
                    `<img src="${previewUrl}" alt="${fileData.name}" loading="lazy">` :
                    `<div class="file-icon">‚ñ°</div>`;

                item.innerHTML = `
                    <div class="crop-file-preview">
                        ${imageContent}
                    </div>
                    <div class="crop-file-info">
                        <div class="crop-file-name" title="${fileData.name}">${fileData.name}</div>
                        <div class="crop-file-size">${this.formatFileSize(fileData.size)}</div>
                    </div>
                `;

                item.addEventListener('click', () => {
                    item.classList.toggle('selected');
                    this.updateCropFileCount();
                });

                return item;
            }

            updateCropFileCount() {
                const selectedItems = document.querySelectorAll('.crop-file-item.selected');
                document.getElementById('cropFileCount').textContent = `${selectedItems.length} ·∫£nh ƒë∆∞·ª£c ch·ªçn`;
            }

            startCroppingFromPage() {
                // Check for files from both sources: convert section and crop tab upload
                // Accept both 'success' and 'pending' files from convert section
                const convertFiles = this.files.filter(f => f.status === 'success' || f.status === 'pending');

                // Get cropFiles from both this.cropFiles and window.converter.cropFiles
                const thisCropFiles = this.cropFiles || [];
                const windowCropFiles = (window.converter && window.converter.cropFiles) ? window.converter.cropFiles : [];

                // Combine crop files from both sources
                const cropTabFiles = [...thisCropFiles, ...windowCropFiles];
                const totalFiles = convertFiles.length + cropTabFiles.length;

                console.log('üîç Checking files for cropping:');
                console.log('- Convert section files (success + pending):', convertFiles.length);
                console.log('- Crop tab files (combined):', cropTabFiles.length);
                console.log('- Total files:', totalFiles);
                console.log('üîç DEBUG: this.files array:', this.files);
                console.log('üîç DEBUG: this.cropFiles array:', this.cropFiles);
                console.log('üîç DEBUG: thisCropFiles:', thisCropFiles.length);
                console.log('üîç DEBUG: windowCropFiles:', windowCropFiles.length);
                console.log('üîç DEBUG: combined cropTabFiles:', cropTabFiles);

                if (totalFiles === 0) {
                    console.error('‚ùå CROP ERROR: No files available for cropping!');
                    console.error('‚ùå this.files:', this.files ? this.files.length : 'undefined');
                    console.error('‚ùå this.cropFiles:', this.cropFiles ? this.cropFiles.length : 'undefined');

                    this.showToast('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt ·∫£nh ƒë·ªÉ c·∫Øt!', 'error');
                    return;
                }

                // Get settings from page
                const width = parseFloat(document.getElementById('cropWidthPage').value);
                const height = parseFloat(document.getElementById('cropHeightPage').value);
                const dpi = parseInt(document.getElementById('cropDPIPage').value) || 300;
                const mode = document.getElementById('cropModePage').value;
                const background = document.getElementById('cropBackgroundPage').value;
                const naming = document.getElementById('cropNamingPage').value;
                const processMode = document.querySelector('input[name="cropProcessModePage"]:checked').value;

                // Update the original controls for compatibility
                document.getElementById('cropWidth').value = width;
                document.getElementById('cropHeight').value = height;
                document.getElementById('cropDPI').value = dpi;
                document.getElementById('cropMode').value = mode;
                document.getElementById('cropBackground').value = background;
                document.getElementById('cropNaming').value = naming;
                document.querySelector(`input[name="cropProcessMode"][value="${processMode}"]`).checked = true;

                // Hide crop page and start cropping
                this.hideCropPage();
                this.startCropping();
            }

            // Update crop template
            initializeCropTemplateHandlers() {
                const templateCards = document.querySelectorAll('.template-card');
                templateCards.forEach(card => {
                    card.addEventListener('click', () => {
                        // Remove active class from all cards
                        templateCards.forEach(c => c.classList.remove('active'));
                        // Add active class to clicked card
                        card.classList.add('active');
                        
                        // Get the template size
                        const templateSize = card.getAttribute('data-size');
                        this.selectCropTemplate(templateSize);
                    });
                });
            }

            selectCropTemplate(template) {
                const customSection = document.getElementById('customSizeSection');
                
                if (template === 'custom') {
                    customSection.style.display = 'block';
                    // Enable custom inputs for custom template
                    const widthInput = document.getElementById('cropWidth');
                    const heightInput = document.getElementById('cropHeight');
                    if (widthInput) widthInput.disabled = false;
                    if (heightInput) heightInput.disabled = false;
                } else {
                    customSection.style.display = 'none';
                    const [width, height] = template.split('x').map(s => parseFloat(s));
                    document.getElementById('cropWidth').value = width;
                    document.getElementById('cropHeight').value = height;
                    
                    // LOCK SIZE INPUTS - CANNOT CHANGE PREDEFINED TEMPLATES
                    const widthInput = document.getElementById('cropWidth');
                    const heightInput = document.getElementById('cropHeight');
                    if (widthInput) widthInput.disabled = true;
                    if (heightInput) heightInput.disabled = true;
                }
                
                this.currentCropTemplate = template;
                this.updateSizeDetails();
                this.updateCropInfo();
            }

            updateSizeDetails() {
                const template = this.currentCropTemplate || '10x15';
                let width, height;
                
                if (template === 'custom') {
                    width = parseFloat(document.getElementById('cropWidth').value);
                    height = parseFloat(document.getElementById('cropHeight').value);
                } else {
                    [width, height] = template.split('x').map(s => parseFloat(s));
                }
                
                // C√îNG TH·ª®C CH√çNH X√ÅC: C·ªë ƒë·ªãnh DPI = 300
                const DPI = 300;
                const pixelWidth = Math.round((width / 2.54) * DPI); // (cm √∑ 2.54) √ó 300
                const pixelHeight = Math.round((height / 2.54) * DPI); // (cm √∑ 2.54) √ó 300
                const ratio = this.getSimpleRatio(width, height);
                
                document.getElementById('currentSize').textContent = `${width}√ó${height} cm`;
                document.getElementById('currentPixels').textContent = `${pixelWidth}√ó${pixelHeight}px`;
                document.getElementById('currentRatio').textContent = ratio;
            }

            getSimpleRatio(width, height) {
                const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
                const divisor = gcd(width * 10, height * 10);
                const w = (width * 10) / divisor;
                const h = (height * 10) / divisor;
                return `${w}:${h}`;
            }

            updateCropTemplate() {
                // Legacy function for compatibility
                this.updateSizeDetails();
            }

            // Update template preview (legacy function for compatibility)
            updateTemplatePreview() {
                // This function is now handled by updateSizeDetails()
                this.updateSizeDetails();
            }

            // Update crop information display
            updateCropInfo() {
                const width = parseFloat(document.getElementById('cropWidth').value);
                const height = parseFloat(document.getElementById('cropHeight').value);
                const dpi = parseInt(document.getElementById('cropDPI').value);
                
                if (!width || !height || width <= 0 || height <= 0) return;
                
                // Calculate pixels at specified DPI
                const pixelWidth = Math.round((width * dpi) / 2.54); // cm to inches to pixels
                const pixelHeight = Math.round((height * dpi) / 2.54);
                
                // Calculate aspect ratio
                const gcd = this.getGCD(Math.round(width * 10), Math.round(height * 10));
                const ratioW = Math.round(width * 10) / gcd;
                const ratioH = Math.round(height * 10) / gcd;
                
                // Update display
                document.getElementById('cropSizeInfo').textContent = `${width}√ó${height} cm`;
                document.getElementById('cropPixelInfo').textContent = `${pixelWidth}√ó${pixelHeight} px`;
                document.getElementById('cropRatioInfo').textContent = `${ratioW}:${ratioH}`;
            }

            // Get Greatest Common Divisor
            getGCD(a, b) {
                return b === 0 ? a : this.getGCD(b, a % b);
            }

            // Start cropping process
            async startCropping() {
                // Combine files from both sources: convert section and crop tab upload
                // Accept both 'success' and 'pending' files from convert section
                const convertFiles = this.files.filter(f => f.status === 'success' || f.status === 'pending');

                // Get cropFiles from both this.cropFiles and window.converter.cropFiles
                const thisCropFiles = this.cropFiles || [];
                const windowCropFiles = (window.converter && window.converter.cropFiles) ? window.converter.cropFiles : [];

                // Combine crop files from both sources
                const cropTabFiles = [...thisCropFiles, ...windowCropFiles];

                // Create unified file array with proper structure
                const allFiles = [
                    ...convertFiles,
                    ...cropTabFiles.map(cropFile => ({
                        ...cropFile,
                        status: 'success',
                        convertedBlob: null, // Crop tab files don't have converted blob
                        preview: cropFile.preview || URL.createObjectURL(cropFile.file)
                    }))
                ];

                console.log('üéØ Starting crop with files:', allFiles.length);
                console.log('üîç DEBUG: convertFiles:', convertFiles.length, 'cropTabFiles:', cropTabFiles.length);
                console.log('üîç DEBUG: thisCropFiles vs windowCropFiles:', thisCropFiles.length, 'vs', windowCropFiles.length);
                
                const cropMode = document.getElementById('cropMode').value;
                const cropProcessMode = document.querySelector('input[name="cropProcessMode"]:checked')?.value || 'individual';
                
                this.hideCropModal();
                
                // Check if this is template mode (size crop)
                if (cropMode === 'size') {
                    return await this.startTemplateCropping(allFiles, cropProcessMode);
                }
                
                // Handle different crop modes
                switch (cropProcessMode) {
                    case 'batch':
                        return await this.startBatchCropping(allFiles, cropMode);
                    case 'preview':
                        return await this.startPreviewMode(allFiles, cropMode);
                    case 'individual':
                    default:
                        return await this.startIndividualCropping(allFiles, cropMode);
                }
            }

            // Template cropping with fixed aspect ratio
            async startTemplateCropping(successFiles, processMode) {
                // Get template size configuration
                const width = parseFloat(document.getElementById('cropWidth').value);
                const height = parseFloat(document.getElementById('cropHeight').value);
                const dpi = parseInt(document.getElementById('cropDPI').value) || 300;
                const unit = document.getElementById('cropUnit').value;
                
                // C√îNG TH·ª®C CH√çNH X√ÅC: C·ªë ƒë·ªãnh DPI = 300
                const DPI = 300;
                let targetWidth, targetHeight;
                if (unit === 'cm') {
                    targetWidth = Math.round((width / 2.54) * DPI); // (cm √∑ 2.54) √ó 300
                    targetHeight = Math.round((height / 2.54) * DPI); // (cm √∑ 2.54) √ó 300
                } else {
                    targetWidth = Math.round(width * DPI);
                    targetHeight = Math.round(height * DPI);
                }
                
                // Initialize template crop data
                this.templateCropData = {
                    files: successFiles,
                    currentIndex: 0,
                    croppedImages: [],
                    config: {
                        width: width,
                        height: height,
                        dpi: dpi,
                        unit: unit,
                        targetWidth: targetWidth,
                        targetHeight: targetHeight,
                        aspectRatio: width / height,
                        naming: document.getElementById('cropNaming').value
                    },
                    processMode: processMode
                };
                
                // Start template cropping based on process mode
                switch (processMode) {
                    case 'batch':
                        return await this.startBatchTemplateCropping();
                    case 'preview':
                        return await this.startPreviewTemplateCropping();
                    case 'individual':
                    default:
                        return await this.startIndividualTemplateCropping();
                }
            }
            
            // Individual template cropping
            async startIndividualTemplateCropping() {
                this.showTemplateCropEditor();
                await this.loadImageForTemplateCropping(0);
            }

            // Individual cropping (original method)
            async startIndividualCropping(successFiles, cropMode) {
                // Initialize crop data
                this.cropData = {
                    files: successFiles,
                    currentIndex: 0,
                    croppedImages: [],
                    config: {
                        width: parseFloat(document.getElementById('cropWidth').value),
                        height: parseFloat(document.getElementById('cropHeight').value),
                        dpi: parseInt(document.getElementById('cropDPI').value),
                        mode: cropMode,
                        background: document.getElementById('cropBackground').value,
                        naming: document.getElementById('cropNaming').value
                    }
                };
                
                try {
                    if (cropMode === 'manual') {
                        await this.startManualCropping();
                    } else {
                        await this.processAutoCropping();
                    }
                } catch (error) {
                    console.error('Cropping error:', error);
                    this.showToast('L·ªói khi c·∫Øt ·∫£nh!', 'error');
                }
            }

            // Process auto cropping (center or smart)
            async processAutoCropping() {
                this.showToast('üé® T·∫°o preview cho t·∫•t c·∫£ ·∫£nh...', 'success');
                
                // Initialize preview data
                this.cropData.previewData = [];
                this.cropData.selectedFiles = new Set();
                
                // Generate previews for all files
                for (let i = 0; i < this.cropData.files.length; i++) {
                    const fileData = this.cropData.files[i];
                    try {
                        const previewData = await this.generateCropPreview(fileData);
                        this.cropData.previewData.push(previewData);
                        
                        this.showToast(`üé® T·∫°o preview ${i + 1}/${this.cropData.files.length}`, 'success');
                    } catch (error) {
                        console.error('Error generating preview:', fileData.name, error);
                    }
                }
                
                // Show preview gallery before download
                this.showPreviewGallery();
            }

            // Batch cropping - applies same template to all images automatically
            async startBatchCropping(successFiles, cropMode) {
                this.showToast('üé® T·∫°o preview cho t·∫•t c·∫£ ·∫£nh...', 'success');
                
                // Initialize crop data
                this.cropData = {
                    files: successFiles,
                    croppedImages: [],
                    previewData: [],
                    selectedFiles: new Set(),
                    config: {
                        width: parseFloat(document.getElementById('cropWidth').value),
                        height: parseFloat(document.getElementById('cropHeight').value),
                        dpi: parseInt(document.getElementById('cropDPI').value),
                        mode: cropMode,
                        background: document.getElementById('cropBackground').value,
                        naming: document.getElementById('cropNaming').value
                    }
                };

                try {
                    // Generate previews for all files first
                    for (let i = 0; i < successFiles.length; i++) {
                        const fileData = successFiles[i];
                        try {
                            const previewData = await this.generateCropPreview(fileData);
                            this.cropData.previewData.push(previewData);
                            
                            this.showToast(`üé® T·∫°o preview ${i + 1}/${successFiles.length}`, 'success');
                        } catch (error) {
                            console.error('Error generating preview:', fileData.name, error);
                        }
                    }
                    
                    // Show preview gallery before download
                    this.showPreviewGallery();
                } catch (error) {
                    console.error('Batch cropping error:', error);
                    this.showToast('‚ùå L·ªói khi c·∫Øt h√†ng lo·∫°t!', 'error');
                }
            }

            // Preview mode - shows preview gallery before cropping
            async startPreviewMode(successFiles, cropMode) {
                this.showToast('üëÅÔ∏è T·∫°o preview cho t·∫•t c·∫£ ·∫£nh...', 'success');
                
                // Initialize crop data
                this.cropData = {
                    files: successFiles,
                    croppedImages: [],
                    previewData: [],
                    selectedFiles: new Set(),
                    config: {
                        width: parseFloat(document.getElementById('cropWidth').value),
                        height: parseFloat(document.getElementById('cropHeight').value),
                        dpi: parseInt(document.getElementById('cropDPI').value),
                        mode: cropMode,
                        background: document.getElementById('cropBackground').value,
                        naming: document.getElementById('cropNaming').value
                    }
                };

                try {
                    // Generate previews for all files
                    for (let i = 0; i < successFiles.length; i++) {
                        const fileData = successFiles[i];
                        const previewData = await this.generateCropPreview(fileData);
                        this.cropData.previewData.push(previewData);
                        
                        this.showToast(`üé® T·∫°o preview ${i + 1}/${successFiles.length}`, 'success');
                    }

                    // Show preview gallery
                    this.showPreviewGallery();
                } catch (error) {
                    console.error('Preview generation error:', error);
                    this.showToast('‚ùå L·ªói khi t·∫°o preview!', 'error');
                }
            }

            // Start multi-image manual cropping process
            async startManualCropping() {
                if (this.cropData.files.length === 0) return;

                console.log(`üé® Starting manual cropping with ${this.cropData.files.length} files`);

                // Remove duplicates from files based on file properties
                const uniqueFiles = [];
                const seenFiles = new Set();

                for (const fileData of this.cropData.files) {
                    const fileKey = `${fileData.name}_${fileData.file?.size}_${fileData.file?.lastModified}`;
                    if (!seenFiles.has(fileKey)) {
                        seenFiles.add(fileKey);
                        uniqueFiles.push(fileData);
                    } else {
                        console.warn(`‚ö†Ô∏è Skipping duplicate file: ${fileData.name}`);
                    }
                }

                console.log(`‚úÖ After deduplication: ${uniqueFiles.length} unique files`);

                // Initialize multi-crop data with deduplicated files
                this.multiCropData = {
                    files: uniqueFiles,
                    selectedFiles: new Set(),
                    cropSelections: new Map(), // Store crop area for each file
                    globalSettings: {
                        aspectLocked: true, // Start with aspect lock enabled
                        sizeLocked: false
                    }
                };

                // Show multi-crop editor
                await this.showMultiCropEditor();
            }

            // Load image for manual cropping
            async loadImageForCropping(index) {
                if (index < 0 || index >= this.cropData.files.length) return;
                
                this.cropData.currentIndex = index;
                const fileData = this.cropData.files[index];
                
                // Update UI
                document.getElementById('currentImageName').textContent = fileData.name;
                document.getElementById('cropProgress').textContent = `${index + 1}/${this.cropData.files.length}`;
                
                // Load image onto canvas
                const canvas = document.getElementById('cropCanvas');
                const ctx = canvas.getContext('2d');
                
                const img = new Image();
                // Handle both converted files and crop tab files
                const imageUrl = fileData.convertedBlob ? 
                    URL.createObjectURL(fileData.convertedBlob) : 
                    (fileData.preview || this.safeCreateObjectURL(fileData.file));
                
                img.onload = () => {
                    // Set canvas size
                    const maxWidth = 800;
                    const maxHeight = 600;
                    let { width, height } = this.calculateDisplaySize(img.width, img.height, maxWidth, maxHeight);
                    
                    canvas.width = width;
                    canvas.height = height;
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    
                    // Draw image
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Sync overlay size with canvas
                    this.syncOverlayWithCanvas();
                    
                    // Initialize crop selection
                    this.initializeCropSelection(width, height);
                    
                    URL.revokeObjectURL(imageUrl);
                };
                
                img.src = imageUrl;
                
                // Update navigation buttons
                document.getElementById('prevCropImage').disabled = index === 0;
                document.getElementById('nextCropImage').disabled = index === this.cropData.files.length - 1;
            }

            // Sync overlay size with canvas
            syncOverlayWithCanvas() {
                const canvas = document.getElementById('cropCanvas');
                const overlay = document.getElementById('cropOverlay');
                
                if (!canvas || !overlay) return;
                
                // Set overlay dimensions to match canvas exactly
                overlay.style.width = canvas.style.width || canvas.width + 'px';
                overlay.style.height = canvas.style.height || canvas.height + 'px';
                
            }

            // Calculate display size maintaining aspect ratio
            calculateDisplaySize(imgWidth, imgHeight, maxWidth, maxHeight) {
                const aspectRatio = imgWidth / imgHeight;
                
                let width = Math.min(imgWidth, maxWidth);
                let height = width / aspectRatio;
                
                if (height > maxHeight) {
                    height = maxHeight;
                    width = height * aspectRatio;
                }
                
                return { width: Math.round(width), height: Math.round(height) };
            }

            // Initialize crop selection overlay
            initializeCropSelection(canvasWidth, canvasHeight) {
                // T√≠nh to√°n targetRatio d·ª±a tr√™n orientation c·ªßa ·∫£nh v√† config
                let targetRatio;
                const canvasRatio = canvasWidth / canvasHeight;
                const configRatio = this.cropData.config.width / this.cropData.config.height;

                // X√°c ƒë·ªãnh xem ·∫£nh l√† ngang hay d·ªçc
                const isImageLandscape = canvasWidth > canvasHeight;
                const isConfigLandscape = this.cropData.config.width > this.cropData.config.height;

                // T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh ratio n·∫øu orientation kh√°c nhau
                if (isImageLandscape !== isConfigLandscape) {
                    // ƒê·∫£o ng∆∞·ª£c ratio ƒë·ªÉ ph√π h·ª£p v·ªõi orientation c·ªßa ·∫£nh
                    targetRatio = 1 / configRatio;
                    console.log(`üîÑ T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh crop ratio: ${configRatio.toFixed(3)} ‚Üí ${targetRatio.toFixed(3)} (·∫£nh ${isImageLandscape ? 'ngang' : 'd·ªçc'}, config ${isConfigLandscape ? 'ngang' : 'd·ªçc'})`);
                } else {
                    targetRatio = configRatio;
                }

                let selectionWidth, selectionHeight;

                // Lu√¥n s·ª≠ d·ª•ng k√≠ch th∆∞·ªõc t·ªëi ƒëa c√≥ th·ªÉ (95% ƒë·ªÉ c√≥ margin nh·ªè)
                if (targetRatio > canvasRatio) {
                    // Target r·ªông h∆°n canvas - fit theo chi·ªÅu r·ªông
                    selectionWidth = canvasWidth * 0.95;
                    selectionHeight = selectionWidth / targetRatio;

                    // N·∫øu chi·ªÅu cao v∆∞·ª£t qu√° canvas, fit theo chi·ªÅu cao
                    if (selectionHeight > canvasHeight * 0.95) {
                        selectionHeight = canvasHeight * 0.95;
                        selectionWidth = selectionHeight * targetRatio;
                    }
                } else {
                    // Target cao h∆°n canvas - fit theo chi·ªÅu cao
                    selectionHeight = canvasHeight * 0.95;
                    selectionWidth = selectionHeight * targetRatio;

                    // N·∫øu chi·ªÅu r·ªông v∆∞·ª£t qu√° canvas, fit theo chi·ªÅu r·ªông
                    if (selectionWidth > canvasWidth * 0.95) {
                        selectionWidth = canvasWidth * 0.95;
                        selectionHeight = selectionWidth / targetRatio;
                    }
                }

                const x = (canvasWidth - selectionWidth) / 2;
                const y = (canvasHeight - selectionHeight) / 2;

                this.updateCropSelection(x, y, selectionWidth, selectionHeight);
                this.initializeCropHandlers();
            }

            // Update crop selection display
            updateCropSelection(x, y, width, height) {
                const selection = document.getElementById('cropSelection');
                const canvas = document.getElementById('cropCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                selection.style.left = x + 'px';
                selection.style.top = y + 'px';
                selection.style.width = width + 'px';
                selection.style.height = height + 'px';
                
                // Update size display
                const scaleX = this.cropData.files[this.cropData.currentIndex].qualityAnalysis.width / canvas.width;
                const scaleY = this.cropData.files[this.cropData.currentIndex].qualityAnalysis.height / canvas.height;
                const actualWidth = Math.round(width * scaleX);
                const actualHeight = Math.round(height * scaleY);
                
                document.getElementById('selectionSize').textContent = `${actualWidth}√ó${actualHeight}px`;
            }

            // Initialize crop selection handlers
            initializeCropHandlers() {
                const selection = document.getElementById('cropSelection');
                const canvas = document.getElementById('cropCanvas');
                
                // Setup aspect lock button
                const aspectLockBtn = document.getElementById('toggleAspectLock');
                if (aspectLockBtn) {
                    aspectLockBtn.classList.add('active'); // Start active
                }
                
                let isDragging = false;
                let isResizing = false;
                let resizeDirection = '';
                let startX = 0, startY = 0, startLeft = 0, startTop = 0, startWidth = 0, startHeight = 0;
                let aspectLocked = true; // Can be toggled
                let sizeLocked = false;

                // T√≠nh targetAspectRatio d·ª±a tr√™n orientation c·ªßa canvas
                const isCanvasLandscape = canvas.width > canvas.height;
                const isConfigLandscape = this.cropData.config.width > this.cropData.config.height;
                let targetAspectRatio;
                if (isCanvasLandscape !== isConfigLandscape) {
                    targetAspectRatio = this.cropData.config.height / this.cropData.config.width;
                } else {
                    targetAspectRatio = this.cropData.config.width / this.cropData.config.height;
                }

                let snapToGrid = true;
                let snapThreshold = 10;
                let lockedWidth = 0;
                let lockedHeight = 0;
                
                // Helper function for snapping
                const snapToValue = (value, snapPoints, threshold = snapThreshold) => {
                    for (let snap of snapPoints) {
                        if (Math.abs(value - snap) <= threshold) {
                            return snap;
                        }
                    }
                    return value;
                };

                // DISABLED - NO RESIZE HANDLES ALLOWED
                // const handles = selection.querySelectorAll('.crop-handle');
                // handles.forEach(handle => {
                //     handle.addEventListener('mousedown', (e) => {
                //         e.preventDefault();
                //         
                //         // Prevent resizing if size is locked or aspect ratio is locked
                //         if (sizeLocked) {
                //             this.showToast('‚ö†Ô∏è K√≠ch th∆∞·ªõc ƒë√£ b·ªã kh√≥a! B·∫•m n√∫t üìê ƒë·ªÉ m·ªü kh√≥a', 'warning');
                //             return;
                //         }
                //         
                //         if (aspectLocked) {
                //             this.showToast('‚ö†Ô∏è T·ª∑ l·ªá ƒë√£ b·ªã kh√≥a! Ch·ªâ c√≥ th·ªÉ di chuy·ªÉn, kh√¥ng th·ªÉ thay ƒë·ªïi k√≠ch th∆∞·ªõc', 'warning');
                //             return;
                //         }
                //         
                //         isResizing = true;
                //         resizeDirection = handle.getAttribute('data-direction');
                //         startX = e.clientX; startY = e.clientY;
                //         
                //         const rect = selection.getBoundingClientRect();
                //         const canvasRect = canvas.getBoundingClientRect();
                //         startLeft = rect.left - canvasRect.left;
                //         startTop = rect.top - canvasRect.top;
                //         startWidth = rect.width; startHeight = rect.height;
                //         
                //         // Add visual feedback
                //         selection.classList.add('resizing');
                //         document.body.style.cursor = handle.style.cursor;
                //         
                //         document.addEventListener('mousemove', onMouseMove);
                //         document.addEventListener('mouseup', onMouseUp);
                //     });
                // }); // DISABLED RESIZE HANDLES

                // Add move handle listener
                const moveHandle = selection.querySelector('.crop-move-handle');
                if (moveHandle) {
                    moveHandle.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        isDragging = true;
                        startX = e.clientX; startY = e.clientY;
                        
                        const rect = selection.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();
                        startLeft = rect.left - canvasRect.left;
                        startTop = rect.top - canvasRect.top;
                        
                        // Add visual feedback
                        selection.classList.add('dragging');
                        document.body.style.cursor = 'grabbing';
                        
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    });
                }

                // Smooth animation frame for better performance
                let animationId = null;
                
                const onMouseMove = (e) => {
                    if (animationId) cancelAnimationFrame(animationId);
                    
                    animationId = requestAnimationFrame(() => {
                        if (isDragging) {
                            const deltaX = e.clientX - startX;
                            const deltaY = e.clientY - startY;
                            let newLeft = startLeft + deltaX;
                            let newTop = startTop + deltaY;
                            
                            // Snap to grid if enabled
                            if (snapToGrid) {
                                const gridSize = canvas.width / 3; // 3x3 grid
                                const snapPointsX = [0, gridSize, gridSize * 2, canvas.width - selection.offsetWidth];
                                const snapPointsY = [0, canvas.height / 3, (canvas.height / 3) * 2, canvas.height - selection.offsetHeight];
                                
                                newLeft = snapToValue(newLeft, snapPointsX);
                                newTop = snapToValue(newTop, snapPointsY);
                            }
                            
                            // Constrain within canvas
                            newLeft = Math.max(0, Math.min(canvas.width - selection.offsetWidth, newLeft));
                            newTop = Math.max(0, Math.min(canvas.height - selection.offsetHeight, newTop));
                            
                            selection.style.left = newLeft + 'px';
                            selection.style.top = newTop + 'px';
                            this.updateCropDisplayInfo();
                        } else if (isResizing && !sizeLocked) {
                            const deltaX = e.clientX - startX;
                            const deltaY = e.clientY - startY;
                            let newWidth = startWidth, newHeight = startHeight, newLeft = startLeft, newTop = startTop;
                            
                            switch (resizeDirection) {
                                case 'se': newWidth = startWidth + deltaX; newHeight = startHeight + deltaY; break;
                                case 'nw': newWidth = startWidth - deltaX; newHeight = startHeight - deltaY; 
                                          newLeft = startLeft + deltaX; newTop = startTop + deltaY; break;
                                case 'ne': newWidth = startWidth + deltaX; newHeight = startHeight - deltaY; 
                                          newTop = startTop + deltaY; break;
                                case 'sw': newWidth = startWidth - deltaX; newHeight = startHeight + deltaY; 
                                          newLeft = startLeft + deltaX; break;
                            }
                            
                            // Maintain aspect ratio if locked
                            if (aspectLocked && ['nw', 'ne', 'sw', 'se'].includes(resizeDirection)) {
                                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                    newHeight = newWidth / targetAspectRatio;
                                } else {
                                    newWidth = newHeight * targetAspectRatio;
                                }
                            }
                            
                            // Apply constraints
                            newWidth = Math.max(50, Math.min(newWidth, canvas.width - newLeft));
                            newHeight = Math.max(50, Math.min(newHeight, canvas.height - newTop));
                            newLeft = Math.max(0, Math.min(canvas.width - newWidth, newLeft));
                            newTop = Math.max(0, Math.min(canvas.height - newHeight, newTop));
                            
                            selection.style.left = newLeft + 'px'; selection.style.top = newTop + 'px';
                            selection.style.width = newWidth + 'px'; selection.style.height = newHeight + 'px';
                            this.updateCropDisplayInfo();
                        }
                    });
                };

                const onMouseUp = () => {
                    // Remove visual feedback
                    selection.classList.remove('dragging', 'resizing');
                    document.body.style.cursor = '';
                    
                    isDragging = false; isResizing = false; resizeDirection = '';
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };

                // Toggle controls (reuse aspectLockBtn from above)
                const gridBtn = document.getElementById('toggleGrid');
                const sizeLockBtn = document.getElementById('toggleSizeLock');
                const grid = document.getElementById('cropGrid');
                
                // Aspect lock toggle
                aspectLockBtn?.addEventListener('click', () => {
                    aspectLocked = !aspectLocked;
                    aspectLockBtn.classList.toggle('active', aspectLocked);
                    
                    if (aspectLocked) {
                        this.showToast('üîí Kh√≥a t·ª∑ l·ªá: B·∫¨T - Gi·ªØ nguy√™n t·ª∑ l·ªá khi k√©o', 'success');
                    } else {
                        this.showToast('üîì Kh√≥a t·ª∑ l·ªá: T·∫ÆT - C√≥ th·ªÉ k√©o t·ª± do', 'info');
                    }
                });
                
                gridBtn?.addEventListener('click', () => {
                    grid?.classList.toggle('visible');
                    gridBtn.classList.toggle('active', grid?.classList.contains('visible'));
                });
                
                sizeLockBtn?.addEventListener('click', () => {
                    sizeLocked = !sizeLocked;
                    if (sizeLocked) {
                        // Store current ACTUAL dimensions when locking (not display dimensions)
                        const rect = selection.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();
                        
                        // Calculate scale factors to convert display pixels to actual pixels
                        const scaleX = canvas.width / canvasRect.width;
                        const scaleY = canvas.height / canvasRect.height;
                        
                        // Store actual pixel dimensions (zoom-independent)
                        lockedWidth = Math.round(rect.width * scaleX);
                        lockedHeight = Math.round(rect.height * scaleY);
                        
                        // Also store in global scope for zoom handling
                        window.cropSizeLockData = {
                            sizeLocked: true,
                            lockedWidth: lockedWidth,
                            lockedHeight: lockedHeight
                        };
                        
                        console.log(`Locked actual size: ${lockedWidth}x${lockedHeight}px (display: ${rect.width}x${rect.height}px)`);
                        this.showToast('üîí ƒê√£ kh√≥a k√≠ch th∆∞·ªõc khung c·∫Øt', 'info');
                    } else {
                        // Clear global lock data when unlocking
                        if (window.cropSizeLockData) {
                            window.cropSizeLockData.sizeLocked = false;
                        }
                        this.showToast('üîì ƒê√£ m·ªü kh√≥a k√≠ch th∆∞·ªõc khung c·∫Øt', 'info');
                    }
                    sizeLockBtn.classList.toggle('active', sizeLocked);
                    
                    // NO RESIZE HANDLES - NO CURSOR UPDATE NEEDED
                    // const handles = selection.querySelectorAll('.crop-handle');
                    // handles.forEach(handle => {
                    //     if (aspectLocked || sizeLocked) {
                    //         handle.style.cursor = 'not-allowed';
                    //     } else {
                    //         handle.style.cursor = handle.getAttribute('data-cursor') || 'nw-resize';
                    //     }
                    // });
                });
                
                // Setup ResizeObserver for single crop mode zoom handling
                if (window.ResizeObserver && !canvas._singleCropResizeObserver) {
                    const resizeObserver = new ResizeObserver(() => {
                        setTimeout(() => {
                            this.syncOverlayWithCanvas();
                            // Apply size lock after zoom if it's active
                            this.applySizeLockAfterZoom(null); // null for single crop mode
                        }, 50);
                    });
                    resizeObserver.observe(canvas);
                    canvas._singleCropResizeObserver = resizeObserver;
                }
                
                // Show helpful tip about max sizing
                setTimeout(() => {
                    this.showToast('üí° Khung c·∫Øt ƒë√£ t·ªëi ∆∞u k√≠ch th∆∞·ªõc t·ªëi ƒëa c√≥ th·ªÉ!', 'success');
                }, 500);
                
                // Initialize display
                this.updateCropDisplayInfo();
                
                // Add edge mode explanation functionality
                const cropBackground = document.getElementById('cropBackground');
                const edgeModeDetails = document.getElementById('edgeModeDetails');
                
                const updateEdgeModeExplanation = () => {
                    const mode = cropBackground.value;
                    let explanation = '';
                    
                    switch(mode) {
                        case 'stretch':
                            explanation = '<strong>üîÑ K√©o gi√£n (Stretch):</strong><br>' +
                                        '‚Ä¢ K√©o gi√£n ·∫£nh ƒë·ªÉ v·ª´a khung c·∫Øt<br>' +
                                        '‚Ä¢ <span style="color: #f59e0b;">‚ö†Ô∏è C√≥ th·ªÉ l√†m bi·∫øn d·∫°ng ·∫£nh</span><br>' +
                                        '‚Ä¢ Ph√π h·ª£p: Logo, h√¨nh ƒë∆°n gi·∫£n<br>' +
                                        '‚Ä¢ <strong>V√≠ d·ª•:</strong> ·∫¢nh 4:3 ‚Üí 16:9 s·∫Ω b·ªã gi√£n ngang';
                            break;
                        case 'fit':
                            explanation = '<strong>‚¨ú V·ª´a kh√≠t + vi·ªÅn tr·∫Øng:</strong><br>' +
                                        '‚Ä¢ Gi·ªØ nguy√™n t·ª∑ l·ªá ·∫£nh g·ªëc<br>' +
                                        '‚Ä¢ <span style="color: #10b981;">‚úÖ Th√™m vi·ªÅn tr·∫Øng ƒë·ªÉ ƒë·∫ßy khung</span><br>' +
                                        '‚Ä¢ Ph√π h·ª£p: ·∫¢nh ch√¢n dung, t√†i li·ªáu<br>' +
                                        '‚Ä¢ <strong>V√≠ d·ª•:</strong> ·∫¢nh vu√¥ng trong khung ch·ªØ nh·∫≠t c√≥ vi·ªÅn tr·∫Øng 2 b√™n';
                            break;
                        case 'fill':
                            explanation = '<strong>üìè ƒê·∫ßy khung (Cover):</strong><br>' +
                                        '‚Ä¢ Ph√≥ng to ·∫£nh ƒë·ªÉ ƒë·∫ßy khung<br>' +
                                        '‚Ä¢ <span style="color: #f59e0b;">‚ö†Ô∏è C·∫Øt b·ªõt ·∫£nh n·∫øu t·ª∑ l·ªá kh√°c nhau</span><br>' +
                                        '‚Ä¢ Ph√π h·ª£p: ·∫¢nh phong c·∫£nh, background<br>' +
                                        '‚Ä¢ <strong>V√≠ d·ª•:</strong> ·∫¢nh vu√¥ng trong khung ch·ªØ nh·∫≠t s·∫Ω b·ªã c·∫Øt tr√™n/d∆∞·ªõi';
                            break;
                    }
                    
                    edgeModeDetails.innerHTML = explanation;
                };
                
                cropBackground?.addEventListener('change', updateEdgeModeExplanation);
                
                // Show initial explanation
                updateEdgeModeExplanation();
            }

            // Update crop display info
            updateCropDisplayInfo() {
                const selection = document.getElementById('cropSelection');
                const canvas = document.getElementById('cropCanvas');
                
                if (!selection || !canvas) return;
                
                const rect = selection.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calculate actual pixel dimensions
                const scaleX = canvas.width / canvasRect.width;
                const scaleY = canvas.height / canvasRect.height;
                const actualWidth = Math.round(rect.width * scaleX);
                const actualHeight = Math.round(rect.height * scaleY);
                
                // Update selection size
                const selectionSizeEl = document.getElementById('selectionSize');
                if (selectionSizeEl) {
                    selectionSizeEl.textContent = `${actualWidth}√ó${actualHeight}px`;
                }
                
                // Update ratio status
                const ratioStatusEl = document.getElementById('cropRatioStatus');
                if (ratioStatusEl && this.cropData?.config) {
                    const currentRatio = actualWidth / actualHeight;
                    const targetRatio = this.cropData.config.width / this.cropData.config.height;
                    const ratioDiff = Math.abs(currentRatio - targetRatio) / targetRatio;
                    
                    if (ratioDiff < 0.05) {
                        ratioStatusEl.textContent = '‚úÖ ƒê√∫ng t·ª∑ l·ªá';
                        ratioStatusEl.style.color = '#10b981';
                    } else {
                        ratioStatusEl.textContent = '‚ö†Ô∏è Sai t·ª∑ l·ªá';
                        ratioStatusEl.style.color = '#f59e0b';
                    }
                }
                
                // Update mini preview
                this.updateMiniPreview();
            }

            // Update mini preview
            updateMiniPreview() {
                const previewCanvas = document.getElementById('previewCanvas');
                const mainCanvas = document.getElementById('cropCanvas');
                const selection = document.getElementById('cropSelection');
                
                if (!previewCanvas || !mainCanvas || !selection) return;
                
                try {
                    const ctx = previewCanvas.getContext('2d');
                    const mainCtx = mainCanvas.getContext('2d');
                    
                    // Get selection coordinates
                    const rect = selection.getBoundingClientRect();
                    const canvasRect = mainCanvas.getBoundingClientRect();
                    
                    const scaleX = mainCanvas.width / canvasRect.width;
                    const scaleY = mainCanvas.height / canvasRect.height;
                    
                    const cropX = (rect.left - canvasRect.left) * scaleX;
                    const cropY = (rect.top - canvasRect.top) * scaleY;
                    const cropWidth = rect.width * scaleX;
                    const cropHeight = rect.height * scaleY;
                    
                    // Clear preview canvas
                    ctx.clearRect(0, 0, 80, 80);
                    
                    // Draw scaled version of crop area
                    const scale = Math.min(80 / cropWidth, 80 / cropHeight);
                    const scaledWidth = cropWidth * scale;
                    const scaledHeight = cropHeight * scale;
                    const offsetX = (80 - scaledWidth) / 2;
                    const offsetY = (80 - scaledHeight) / 2;
                    
                    ctx.drawImage(mainCanvas, cropX, cropY, cropWidth, cropHeight, offsetX, offsetY, scaledWidth, scaledHeight);
                } catch (error) {
                }
            }

            // Reset crop selection
            resetCropSelection() {
                const canvas = document.getElementById('cropCanvas');
                this.initializeCropSelection(canvas.width, canvas.height);
            }

            // Center crop selection
            centerCropSelection() {
                const canvas = document.getElementById('cropCanvas');
                const selection = document.getElementById('cropSelection');
                const selectionRect = selection.getBoundingClientRect();
                
                const x = (canvas.width - selection.offsetWidth) / 2;
                const y = (canvas.height - selection.offsetHeight) / 2;
                
                this.updateCropSelection(x, y, selection.offsetWidth, selection.offsetHeight);
            }

            // Fit crop selection to canvas
            fitCropSelection() {
                const canvas = document.getElementById('cropCanvas');
                this.initializeCropSelection(canvas.width, canvas.height);
            }

            // Accept current crop
            async acceptCurrentCrop() {
                try {
                    const croppedBlob = await this.performCrop();
                    const fileData = this.cropData.files[this.cropData.currentIndex];
                    const croppedName = this.generateCropName(fileData.convertedName);
                    
                    this.cropData.croppedImages.push({
                        originalFile: fileData,
                        croppedBlob,
                        croppedName
                    });
                    
                    if (this.cropData.currentIndex < this.cropData.files.length - 1) {
                        await this.loadImageForCropping(this.cropData.currentIndex + 1);
                    } else {
                        this.finishManualCropping();
                    }
                } catch (error) {
                    console.error('Error accepting crop:', error);
                    this.showToast('L·ªói khi c·∫Øt ·∫£nh!', 'error');
                }
            }

            // Skip current crop
            skipCurrentCrop() {
                if (this.cropData.currentIndex < this.cropData.files.length - 1) {
                    this.loadImageForCropping(this.cropData.currentIndex + 1);
                } else {
                    this.finishManualCropping();
                }
            }

            // Navigate to previous image
            previousCropImage() {
                if (this.cropData.currentIndex > 0) {
                    this.loadImageForCropping(this.cropData.currentIndex - 1);
                }
            }

            // Navigate to next image
            nextCropImage() {
                if (this.cropData.currentIndex < this.cropData.files.length - 1) {
                    this.loadImageForCropping(this.cropData.currentIndex + 1);
                }
            }

            // Perform actual crop
            async performCrop() {
                const canvas = document.getElementById('cropCanvas');
                const selection = document.getElementById('cropSelection');
                const fileData = this.cropData.files[this.cropData.currentIndex];
                
                // Get crop coordinates
                const cropX = parseInt(selection.style.left);
                const cropY = parseInt(selection.style.top);
                const cropWidth = selection.offsetWidth;
                const cropHeight = selection.offsetHeight;
                
                // Scale to original image dimensions
                const scaleX = fileData.qualityAnalysis.width / canvas.width;
                const scaleY = fileData.qualityAnalysis.height / canvas.height;
                
                const originalCropX = cropX * scaleX;
                const originalCropY = cropY * scaleY;
                const originalCropWidth = cropWidth * scaleX;
                const originalCropHeight = cropHeight * scaleY;
                
                return await this.cropImageToSize(
                    fileData, 
                    originalCropX, 
                    originalCropY, 
                    originalCropWidth, 
                    originalCropHeight
                );
            }

            // Crop image to exact size
            async cropImageToSize(fileData, sourceX, sourceY, sourceWidth, sourceHeight) {
                // C√îNG TH·ª®C CH√çNH X√ÅC: (k√≠ch_th∆∞·ªõc_cm √∑ 2.54) √ó 300
                // C·ªë ƒë·ªãnh DPI = 300 (KH√îNG BAO GI·ªú thay ƒë·ªïi)
                const DPI = 300;

                // T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh width/height d·ª±a tr√™n orientation c·ªßa v√πng crop
                const isCropLandscape = sourceWidth > sourceHeight;
                const isConfigLandscape = this.cropData.config.width > this.cropData.config.height;

                let finalWidth, finalHeight;
                if (isCropLandscape === isConfigLandscape) {
                    // Orientation kh·ªõp - gi·ªØ nguy√™n
                    finalWidth = this.cropData.config.width;
                    finalHeight = this.cropData.config.height;
                } else {
                    // Orientation kh√°c - ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ kh·ªõp v·ªõi ·∫£nh
                    finalWidth = this.cropData.config.height;
                    finalHeight = this.cropData.config.width;
                    console.log(`üîÑ ƒê·∫£o ng∆∞·ª£c k√≠ch th∆∞·ªõc output: ${this.cropData.config.width}√ó${this.cropData.config.height}cm ‚Üí ${finalWidth}√ó${finalHeight}cm`);
                }

                const targetWidth = Math.round((finalWidth / 2.54) * DPI);
                const targetHeight = Math.round((finalHeight / 2.54) * DPI);

                console.log(`‚úÖ K√çCH TH∆Ø·ªöC CH√çNH X√ÅC: ${finalWidth}√ó${finalHeight}cm at ${DPI}DPI ‚Üí ${targetWidth}√ó${targetHeight}px`);
                console.log(`üìê C√¥ng th·ª©c: (${finalWidth}√∑2.54)√ó${DPI} √ó (${finalHeight}√∑2.54)√ó${DPI} = ${targetWidth}√ó${targetHeight} pixels`);
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                
                // Load original image
                const img = new Image();
                const imageUrl = this.safeCreateObjectURL(fileData.file);
                if (!imageUrl) {
                    resolve({ success: false, error: 'Cannot create blob URL for this file type' });
                    return;
                }
                
                return new Promise((resolve) => {
                    img.onload = async () => {
                        // Draw cropped and resized image
                        ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, targetWidth, targetHeight);
                        
                        // Convert to blob v·ªõi ch·∫•t l∆∞·ª£ng t·ªëi ƒëa
                        canvas.toBlob(async (blob) => {
                            // LU√îN th√™m DPI metadata = 300
                            try {
                                const enhancedBlob = await this.addDPIMetadata(blob, DPI);
                                resolve(enhancedBlob);
                            } catch (error) {
                                console.warn('Kh√¥ng th·ªÉ th√™m DPI metadata:', error);
                                resolve(blob);
                            }
                        }, 'image/jpeg', 1.0);
                        
                        URL.revokeObjectURL(imageUrl);
                    };
                    img.src = imageUrl;
                });
            }

            // Auto crop image (center or smart)
            async cropImageAuto(fileData) {
                const img = new Image();
                // Handle both converted files and crop tab files
                const imageUrl = fileData.convertedBlob ?
                    URL.createObjectURL(fileData.convertedBlob) :
                    (fileData.preview || this.safeCreateObjectURL(fileData.file));

                return new Promise((resolve) => {
                    img.onload = async () => {
                        // T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh targetRatio d·ª±a tr√™n orientation c·ªßa ·∫£nh
                        const isImageLandscape = img.width > img.height;
                        const isConfigLandscape = this.cropData.config.width > this.cropData.config.height;

                        let targetRatio;
                        if (isImageLandscape !== isConfigLandscape) {
                            // ƒê·∫£o ng∆∞·ª£c ratio ƒë·ªÉ ph√π h·ª£p v·ªõi orientation c·ªßa ·∫£nh
                            targetRatio = this.cropData.config.height / this.cropData.config.width;
                        } else {
                            targetRatio = this.cropData.config.width / this.cropData.config.height;
                        }

                        const sourceRatio = img.width / img.height;
                        
                        let sourceX, sourceY, sourceWidth, sourceHeight;
                        
                        if (this.cropData.config.mode === 'smart') {
                            // Smart cropping - try to detect subject
                            const cropArea = await this.detectSmartCropArea(img, targetRatio);
                            ({ sourceX, sourceY, sourceWidth, sourceHeight } = cropArea);
                        } else {
                            // Center cropping
                            if (sourceRatio > targetRatio) {
                                // Source is wider, crop sides
                                sourceHeight = img.height;
                                sourceWidth = sourceHeight * targetRatio;
                                sourceX = (img.width - sourceWidth) / 2;
                                sourceY = 0;
                            } else {
                                // Source is taller, crop top/bottom
                                sourceWidth = img.width;
                                sourceHeight = sourceWidth / targetRatio;
                                sourceX = 0;
                                sourceY = (img.height - sourceHeight) / 2;
                            }
                        }
                        
                        const croppedBlob = await this.cropImageToSize(fileData, sourceX, sourceY, sourceWidth, sourceHeight);
                        URL.revokeObjectURL(imageUrl);
                        resolve(croppedBlob);
                    };
                    img.src = imageUrl;
                });
            }

            // Detect smart crop area (basic implementation)
            async detectSmartCropArea(img, targetRatio) {
                // For now, use center cropping with slight bias toward upper third
                const sourceRatio = img.width / img.height;
                let sourceX, sourceY, sourceWidth, sourceHeight;
                
                if (sourceRatio > targetRatio) {
                    sourceHeight = img.height;
                    sourceWidth = sourceHeight * targetRatio;
                    sourceX = (img.width - sourceWidth) / 2;
                    sourceY = 0;
                } else {
                    sourceWidth = img.width;
                    sourceHeight = sourceWidth / targetRatio;
                    sourceX = 0;
                    sourceY = img.height * 0.1; // Slight upward bias
                }
                
                return { sourceX, sourceY, sourceWidth, sourceHeight };
            }

            // Generate crop file name
            generateCropName(originalName) {
                const naming = this.cropData.config.naming;
                const pixelWidth = Math.round((this.cropData.config.width * this.cropData.config.dpi) / 2.54);
                const pixelHeight = Math.round((this.cropData.config.height * this.cropData.config.dpi) / 2.54);
                const size = `${this.cropData.config.width}x${this.cropData.config.height}cm_${pixelWidth}x${pixelHeight}px_${this.cropData.config.dpi}DPI`;
                
                const nameWithoutExt = originalName.replace(/\.[^/.]+$/, "");
                const ext = 'jpg'; // Always output as JPG for consistency
                
                switch (naming) {
                    case 'append':
                        return `${nameWithoutExt}_${size}.${ext}`;
                    case 'replace':
                        return `cropped_${size}_${Date.now()}.${ext}`;
                    case 'keep':
                    default:
                        return `${nameWithoutExt}.${ext}`;
                }
            }

            // Finish manual cropping
            async finishManualCropping() {
                this.hideCropEditor();
                await this.saveCroppedImages();
            }

            // Hide crop editor
            hideCropEditor() {
                document.getElementById('cropEditorModal').style.display = 'none';

                // Cleanup resize listener if exists
                if (this.multiCropData?.resizeHandler) {
                    window.removeEventListener('resize', this.multiCropData.resizeHandler);
                    this.multiCropData.resizeHandler = null;
                }

                // Cleanup ResizeObserver cho t·ª´ng canvas
                if (this.multiCropData?.files) {
                    for (let i = 0; i < this.multiCropData.files.length; i++) {
                        const canvas = document.getElementById(`canvas-${i}`);
                        if (canvas?._multiCropResizeObserver) {
                            canvas._multiCropResizeObserver.disconnect();
                            canvas._multiCropResizeObserver = null;
                        }
                    }
                }
            }

            // Download all cropped images
            // Save cropped images for later download (don't auto-download)
            async saveCroppedImages() {
                if (this.cropData.croppedImages.length === 0) {
                    this.showToast('Kh√¥ng c√≥ ·∫£nh n√†o ƒë∆∞·ª£c c·∫Øt!', 'error');
                    return;
                }

                this.showToast('‚úÇÔ∏è ƒêang c·∫Øt v√† l∆∞u ·∫£nh v√†o File System...', 'info');

                // Update crop page download status
                this.updateCropDownloadStatus();

                // üöÄ INSTANT SAVE TO FILE SYSTEM - SI√äU NHANH!
                let fileSystemSaveCount = 0;
                let fileSystemErrors = [];

                // Debug logging
                console.log('üîç Crop save debug:', {
                    croppedImagesCount: this.cropData.croppedImages.length,
                    thisFileSystemStorage: !!this.fileSystemStorage,
                    windowFileSystemStorage: !!window.converter?.fileSystemStorage,
                    directoryHandle: !!(this.fileSystemStorage?.directoryHandle || window.converter?.fileSystemStorage?.directoryHandle)
                });

                // Save to cropProcessedFiles for ZIP download
                this.cropProcessedFiles = [];
                for (let i = 0; i < this.cropData.croppedImages.length; i++) {
                    const { croppedBlob, croppedName } = this.cropData.croppedImages[i];

                    this.cropProcessedFiles.push({
                        blob: croppedBlob,
                        name: croppedName,
                        size: croppedBlob.size
                    });

                    // Auto-save to gallery
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        await this.addImageToGallery(e.target.result, croppedName, true);
                    };
                    reader.readAsDataURL(croppedBlob);

                    // üíæ AUTO-SAVE TO FILE SYSTEM - C·∫§U TR√öC CHU·∫®N
                    const fileSystemStorage = this.fileSystemStorage || window.converter?.fileSystemStorage;
                    console.log('üîç FileSystem check:', {
                        hasStorage: !!fileSystemStorage,
                        hasHandle: !!fileSystemStorage?.directoryHandle,
                        fileName: croppedName
                    });

                    if (fileSystemStorage && fileSystemStorage.directoryHandle) {
                        try {
                            // üìÅ C·∫§U TR√öC TH∆Ø M·ª§C CHU·∫®N: Cropped/ thay v√¨ ph√¢n lo·∫°i ph·ª©c t·∫°p
                            const subfolderName = 'Cropped';

                            // üéØ ƒê·∫£m b·∫£o ƒë·ªãnh d·∫°ng JPG cho ·∫£nh ƒë√£ c·∫Øt
                            let finalBlob = croppedBlob;
                            let finalName = croppedName;

                            // üéØ L∆ØU V·ªöI K√çCH TH∆Ø·ªöC V√Ä DPI CH√çNH X√ÅC
                            // KH√îNG re-render ƒë·ªÉ gi·ªØ nguy√™n k√≠ch th∆∞·ªõc v√† DPI metadata
                            console.log('üíæ L∆∞u File System v·ªõi k√≠ch th∆∞·ªõc g·ªëc ƒë√£ crop (300 DPI):', {
                                fileName: croppedName,
                                expectedSize: `${this.cropData.config.width}x${this.cropData.config.height}cm`,
                                blobSize: croppedBlob.size
                            });

                            // üö® QUAN TR·ªåNG: Kh√¥ng re-render canvas ƒë·ªÉ gi·ªØ nguy√™n k√≠ch th∆∞·ªõc DPI 300
                            // croppedBlob ƒë√£ ƒë∆∞·ª£c t·∫°o v·ªõi ƒë√∫ng k√≠ch th∆∞·ªõc v√† DPI t·ª´ cropImageToSize()
                            finalBlob = croppedBlob;
                            finalName = croppedName;

                            // üîß CH·ªà C·∫¶N TH√äM DPI METADATA n·∫øu ch∆∞a c√≥
                            if (croppedName.toLowerCase().match(/\.(jpg|jpeg)$/)) {
                                try {
                                    // Th√™m DPI metadata m√† kh√¥ng thay ƒë·ªïi k√≠ch th∆∞·ªõc
                                    finalBlob = await this.addDPIMetadata(croppedBlob, 300);
                                    console.log('‚úÖ ƒê√£ th√™m DPI 300 metadata cho File System save');
                                } catch (error) {
                                    console.warn('‚ö†Ô∏è Kh√¥ng th·ªÉ th√™m DPI metadata:', error);
                                    finalBlob = croppedBlob; // Fallback to original
                                }
                            }

                            // L∆∞u v√†o File System v·ªõi c·∫•u tr√∫c chu·∫©n
                            await fileSystemStorage.saveImageToFileSystem(
                                finalBlob,
                                finalName,
                                subfolderName
                            );

                            fileSystemSaveCount++;
                            console.log(`‚úÖ ƒê√£ l∆∞u v√†o File System: ${subfolderName}/${finalName}`);
                        } catch (fsError) {
                            console.error('‚ùå L·ªói l∆∞u File System:', fsError);
                            fileSystemErrors.push({
                                fileName: croppedName,
                                error: fsError.message
                            });
                        }
                    }
                }

                // üìä Th√¥ng b√°o k·∫øt qu·∫£ File System save
                let resultMessage = `‚úÖ ƒê√£ c·∫Øt xong ${this.cropData.croppedImages.length} ·∫£nh k√≠ch th∆∞·ªõc ${this.cropData.config.width}√ó${this.cropData.config.height}cm!`;

                if (fileSystemSaveCount > 0) {
                    resultMessage += `\n\nüöÄ SI√äU NHANH: ƒê√£ t·ª± ƒë·ªông l∆∞u ${fileSystemSaveCount} ·∫£nh v√†o File System!`;
                    resultMessage += `\nüìÅ ƒê∆∞·ªùng d·∫´n: .../Cropped/`;
                    resultMessage += `\nüéØ ƒê·ªãnh d·∫°ng: JPG/PNG ch·∫•t l∆∞·ª£ng cao`;
                    resultMessage += `\n‚ú® Truy c·∫≠p tr·ª±c ti·∫øp trong th∆∞ m·ª•c File System ƒë√£ c·∫•p quy·ªÅn!`;

                    // L·∫•y ƒë∆∞·ªùng d·∫´n th·ª±c t·∫ø
                    const fsStorage = this.fileSystemStorage || window.converter?.fileSystemStorage;
                    if (fsStorage?.directoryHandle?.name) {
                        resultMessage += `\nüìÇ Th∆∞ m·ª•c: ${fsStorage.directoryHandle.name}/Cropped/`;
                    }
                }

                if (fileSystemErrors.length > 0) {
                    resultMessage += `\n\n‚ö†Ô∏è ${fileSystemErrors.length} ·∫£nh kh√¥ng l∆∞u ƒë∆∞·ª£c v√†o File System`;
                    resultMessage += `\nüí° D√πng n√∫t t·∫£i v·ªÅ cho nh·ªØng ·∫£nh n√†y`;
                }

                this.showToast(resultMessage, fileSystemSaveCount > 0 ? 'success' : 'info');
                
                // Show crop actions after processing
                this.showCropActions();
                
                // Auto-sync crop data
                this.syncCropProcessedFiles();
            }

            // Update crop download status in crop page
            updateCropDownloadStatus() {
                const cropedFilesCount = document.getElementById('cropedFilesCount');
                const cropedTotalSize = document.getElementById('cropedTotalSize');
                
                if (this.cropProcessedFiles && this.cropProcessedFiles.length > 0) {
                    const totalSize = this.cropProcessedFiles.reduce((acc, file) => acc + file.size, 0);
                    const sizeMB = (totalSize / (1024 * 1024)).toFixed(1);
                    
                    if (cropedFilesCount) {
                        cropedFilesCount.textContent = `${this.cropProcessedFiles.length} ·∫£nh ƒë√£ c·∫Øt`;
                    }
                    if (cropedTotalSize) {
                        cropedTotalSize.textContent = `${sizeMB} MB`;
                    }
                } else {
                    if (cropedFilesCount) {
                        cropedFilesCount.textContent = '0 ·∫£nh ƒë√£ c·∫Øt';
                    }
                    if (cropedTotalSize) {
                        cropedTotalSize.textContent = '0 MB';
                    }
                }
            }

            // Keep original method for backward compatibility 
            async downloadCroppedImages() {
                if (this.cropData.croppedImages.length === 0) {
                    this.showToast('Kh√¥ng c√≥ ·∫£nh n√†o ƒë∆∞·ª£c c·∫Øt!', 'error');
                    return;
                }
                
                this.showToast('ƒêang t·∫£i xu·ªëng ·∫£nh ƒë√£ c·∫Øt...', 'success');
                
                // Download individual files
                for (let i = 0; i < this.cropData.croppedImages.length; i++) {
                    const { croppedBlob, croppedName } = this.cropData.croppedImages[i];
                    
                    const url = URL.createObjectURL(croppedBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = croppedName;
                    a.setAttribute('rel', 'noopener noreferrer');
                    
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                    
                    // Small delay between downloads
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
                
                const message = `‚úÖ ƒê√£ t·∫£i xu·ªëng ${this.cropData.croppedImages.length} ·∫£nh ƒë√£ c·∫Øt k√≠ch th∆∞·ªõc ${this.cropData.config.width}√ó${this.cropData.config.height}cm!`;
                this.showToast(message);
                
                // Clear crop data
                this.cropData = null;
            }

            // Show PDF configuration modal
            showPdfModal() {
                // K·∫øt h·ª£p files t·ª´ c·∫£ hai ngu·ªìn
                const allFiles = [...this.files];
                if (window.converter && window.converter.files && window.converter.files !== this.files) {
                    allFiles.push(...window.converter.files);
                }

                const successFiles = allFiles.filter(f => f.status === 'success');
                if (successFiles.length === 0) {
                    this.showToast('Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ t·∫°o PDF!', 'error');
                    return;
                }
                document.getElementById('pdfModal').style.display = 'flex';
            }

            // Hide PDF modal
            hidePdfModal() {
                document.getElementById('pdfModal').style.display = 'none';
            }

            // Generate PDF with custom configuration
            async generatePDF() {
                // K·∫øt h·ª£p files t·ª´ c·∫£ hai ngu·ªìn
                const allFiles = [...this.files];
                if (window.converter && window.converter.files && window.converter.files !== this.files) {
                    allFiles.push(...window.converter.files);
                }

                const successFiles = allFiles.filter(f => f.status === 'success');
                if (successFiles.length === 0) {
                    this.showToast('Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ t·∫°o PDF!', 'error');
                    return;
                }

                // Get configuration
                const config = {
                    pageSize: document.getElementById('pdfPageSize').value,
                    orientation: document.getElementById('pdfOrientation').value,
                    layout: document.getElementById('pdfLayout').value,
                    imagesPerPage: parseInt(document.getElementById('imagesPerPage').value),
                    title: document.getElementById('pdfTitle').value.trim(),
                    description: document.getElementById('pdfDescription').value.trim(),
                    showFilenames: document.getElementById('showFilenames').checked,
                    showImageInfo: document.getElementById('showImageInfo').checked,
                    addTimestamp: document.getElementById('addTimestamp').checked
                };

                this.hidePdfModal();
                
                try {
                    const generateBtn = document.getElementById('generatePdf');
                    generateBtn.disabled = true;
                    generateBtn.textContent = 'üìÑ ƒêang t·∫°o PDF...';

                    this.showToast('ƒêang t·∫°o PDF b·∫£n in...', 'success');
                    
                    await this.createPDFDocument(successFiles, config);
                    
                    this.showToast(`‚úÖ ƒê√£ t·∫°o PDF th√†nh c√¥ng v·ªõi ${successFiles.length} ·∫£nh!`);

                } catch (error) {
                    console.error('Error creating PDF:', error);
                    this.showToast('L·ªói khi t·∫°o PDF!', 'error');
                } finally {
                    const generateBtn = document.getElementById('generatePdf');
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'üìÑ T·∫°o PDF';
                }
            }

            // Create PDF document
            async createPDFDocument(files, config) {
                const { jsPDF } = window.jspdf;
                
                // Page dimensions
                const pageSizes = {
                    a4: [210, 297],
                    a3: [297, 420],
                    letter: [216, 279],
                    legal: [216, 356]
                };
                
                const [pageWidth, pageHeight] = pageSizes[config.pageSize];
                const pdf = new jsPDF({
                    orientation: config.orientation,
                    unit: 'mm',
                    format: config.pageSize
                });

                // Set PDF metadata
                pdf.setProperties({
                    title: config.title || 'Converted Images',
                    subject: config.description || 'Image conversion result',
                    author: 'Image Converter Tool',
                    creator: 'Image Converter Tool v1.0'
                });

                let currentPage = 1;
                let imagesOnCurrentPage = 0;
                
                // Calculate layout dimensions
                const margin = 20;
                const availableWidth = (config.orientation === 'landscape' ? pageHeight : pageWidth) - (margin * 2);
                const availableHeight = (config.orientation === 'landscape' ? pageWidth : pageHeight) - (margin * 3) - 30; // Extra space for title/footer
                
                // Add title page
                this.addPDFTitlePage(pdf, config, files.length);
                pdf.addPage();
                currentPage++;

                for (let i = 0; i < files.length; i++) {
                    const fileData = files[i];
                    
                    if (config.layout === 'single') {
                        // One image per page
                        if (i > 0) {
                            pdf.addPage();
                            currentPage++;
                        }
                        await this.addImageToPDF(pdf, fileData, config, margin, availableWidth, availableHeight, true);
                        
                    } else {
                        // Multiple images per page
                        if (imagesOnCurrentPage >= config.imagesPerPage) {
                            pdf.addPage();
                            currentPage++;
                            imagesOnCurrentPage = 0;
                        }
                        
                        const position = this.calculateImagePosition(
                            imagesOnCurrentPage, 
                            config.imagesPerPage, 
                            availableWidth, 
                            availableHeight, 
                            margin,
                            config.layout
                        );
                        
                        await this.addImageToPDF(pdf, fileData, config, position.x, position.width, position.height, false, position.y);
                        imagesOnCurrentPage++;
                    }
                }

                // Add footer to all pages
                const totalPages = pdf.internal.getNumberOfPages();
                for (let i = 1; i <= totalPages; i++) {
                    pdf.setPage(i);
                    this.addPDFFooter(pdf, config, i, totalPages, pageWidth, pageHeight);
                }

                // Download PDF
                const timestamp = new Date().toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '-');
                const fileName = `${config.title.replace(/[^a-zA-Z0-9]/g, '_')}_${timestamp}.pdf`;
                
                pdf.save(fileName);
            }

            // Add title page to PDF
            addPDFTitlePage(pdf, config, imageCount) {
                const pageWidth = pdf.internal.pageSize.width;
                const pageHeight = pdf.internal.pageSize.height;
                
                // Title
                pdf.setFontSize(24);
                pdf.setFont(undefined, 'bold');
                pdf.text(config.title, pageWidth / 2, 60, { align: 'center' });
                
                // Description
                if (config.description) {
                    pdf.setFontSize(12);
                    pdf.setFont(undefined, 'normal');
                    const lines = pdf.splitTextToSize(config.description, pageWidth - 40);
                    pdf.text(lines, pageWidth / 2, 80, { align: 'center' });
                }
                
                // Statistics
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text('üìä Th·ªëng k√™:', 20, 120);
                
                pdf.setFontSize(12);
                pdf.setFont(undefined, 'normal');
                pdf.text(`‚Ä¢ T·ªïng s·ªë ·∫£nh: ${imageCount}`, 20, 135);
                pdf.text(`‚Ä¢ ƒê·ªãnh d·∫°ng trang: ${config.pageSize.toUpperCase()} ${config.orientation}`, 20, 150);
                pdf.text(`‚Ä¢ Layout: ${config.layout}`, 20, 165);
                
                if (config.addTimestamp) {
                    pdf.text(`‚Ä¢ Ng√†y t·∫°o: ${new Date().toLocaleString('vi-VN')}`, 20, 180);
                }
            }

            // Calculate image position based on layout
            calculateImagePosition(index, imagesPerPage, availableWidth, availableHeight, margin, layout) {
                let cols, rows;
                
                if (layout === 'list') {
                    cols = 1;
                    rows = imagesPerPage;
                } else { // grid
                    cols = Math.ceil(Math.sqrt(imagesPerPage));
                    rows = Math.ceil(imagesPerPage / cols);
                }
                
                const cellWidth = availableWidth / cols;
                const cellHeight = availableHeight / rows;
                
                const col = index % cols;
                const row = Math.floor(index / cols);
                
                return {
                    x: margin + (col * cellWidth),
                    y: margin + 30 + (row * cellHeight), // 30mm for page header
                    width: cellWidth - 5, // 5mm padding
                    height: cellHeight - 10 // 10mm padding for text
                };
            }

            // Add single image to PDF
            async addImageToPDF(pdf, fileData, config, x, width, height, fullPage = false, y = null) {
                try {
                    // Convert blob to base64
                    const base64 = await this.blobToBase64(fileData.convertedBlob);
                    const imageFormat = this.getImageFormat(fileData.convertedName);
                    
                    // Calculate image dimensions maintaining aspect ratio
                    const img = new Image();
                    await new Promise((resolve) => {
                        img.onload = resolve;
                        img.src = base64;
                    });
                    
                    const aspectRatio = img.width / img.height;
                    let imgWidth, imgHeight, imgX, imgY;
                    
                    if (fullPage) {
                        // Full page image
                        if (aspectRatio > width / height) {
                            imgWidth = width;
                            imgHeight = width / aspectRatio;
                        } else {
                            imgHeight = height - 20; // Space for filename
                            imgWidth = imgHeight * aspectRatio;
                        }
                        imgX = x + (width - imgWidth) / 2;
                        imgY = y || (pdf.internal.pageSize.height - imgHeight) / 2;
                    } else {
                        // Grid/list image
                        const textSpace = config.showFilenames || config.showImageInfo ? 15 : 5;
                        const availableImgHeight = height - textSpace;
                        
                        if (aspectRatio > width / availableImgHeight) {
                            imgWidth = width;
                            imgHeight = width / aspectRatio;
                        } else {
                            imgHeight = availableImgHeight;
                            imgWidth = imgHeight * aspectRatio;
                        }
                        imgX = x + (width - imgWidth) / 2;
                        imgY = y;
                    }
                    
                    // Add image
                    pdf.addImage(base64, imageFormat, imgX, imgY, imgWidth, imgHeight);
                    
                    // Add filename and info
                    if (config.showFilenames || config.showImageInfo) {
                        const textY = imgY + imgHeight + 5;
                        pdf.setFontSize(8);
                        
                        if (config.showFilenames) {
                            pdf.text(fileData.convertedName, imgX + imgWidth / 2, textY, { align: 'center' });
                        }
                        
                        if (config.showImageInfo) {
                            const info = `${img.width}√ó${img.height} ${fileData.actualFormat?.toUpperCase() || 'IMG'}`;
                            pdf.text(info, imgX + imgWidth / 2, textY + 7, { align: 'center' });
                        }
                    }
                    
                } catch (error) {
                    console.error('Error adding image to PDF:', error);
                }
            }

            // Add footer to PDF
            addPDFFooter(pdf, config, pageNum, totalPages, pageWidth, pageHeight) {
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'normal');
                
                // Page number
                pdf.text(`Trang ${pageNum}/${totalPages}`, pageWidth - 20, pageHeight - 10, { align: 'right' });
                
                // Generator info
                pdf.text('T·∫°o b·ªüi Image Converter Tool', 20, pageHeight - 10);
                
                if (config.addTimestamp && pageNum === 1) {
                    const timestamp = new Date().toLocaleString('vi-VN');
                    pdf.text(timestamp, pageWidth / 2, pageHeight - 10, { align: 'center' });
                }
            }

            // Convert blob to base64
            async blobToBase64(blob) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });
            }

            // Get image format for jsPDF
            getImageFormat(fileName) {
                const ext = fileName.split('.').pop().toLowerCase();
                if (ext === 'jpg' || ext === 'jpeg') return 'JPEG';
                if (ext === 'png') return 'PNG';
                if (ext === 'webp') return 'WEBP';
                return 'JPEG'; // Default
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }

            showToast(message, type = 'success') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast ${type}`;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }

            // Generate crop preview for a file
            async generateCropPreview(fileData) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        try {
                            // Create preview canvas
                            const previewCanvas = document.createElement('canvas');
                            const previewCtx = previewCanvas.getContext('2d');
                            
                            // Set preview size
                            const previewSize = 200;
                            previewCanvas.width = previewSize;
                            previewCanvas.height = previewSize;
                            
                            // Calculate crop area based on current config and mode
                            const targetRatio = this.cropData.config.width / this.cropData.config.height;
                            const sourceRatio = img.width / img.height;
                            
                            let sourceX, sourceY, sourceWidth, sourceHeight;
                            
                            // Apply crop logic based on mode
                            switch (this.cropData.config.mode) {
                                case 'smart':
                                    // Smart crop - detect interesting areas
                                    const smartCrop = this.detectSmartCropAreaSync(img, targetRatio);
                                    ({ sourceX, sourceY, sourceWidth, sourceHeight } = smartCrop);
                                    break;
                                case 'center':
                                    // Center crop
                                    if (sourceRatio > targetRatio) {
                                        sourceHeight = img.height;
                                        sourceWidth = sourceHeight * targetRatio;
                                        sourceX = (img.width - sourceWidth) / 2;
                                        sourceY = 0;
                                    } else {
                                        sourceWidth = img.width;
                                        sourceHeight = sourceWidth / targetRatio;
                                        sourceX = 0;
                                        sourceY = (img.height - sourceHeight) / 2;
                                    }
                                    break;
                                case 'manual':
                                default:
                                    // For manual, show full image with overlay indication
                                    sourceX = 0;
                                    sourceY = 0;
                                    sourceWidth = img.width;
                                    sourceHeight = img.height;
                                    break;
                            }
                            
                            // Draw preview with crop area highlighted
                            previewCtx.fillStyle = '#f8f9fa';
                            previewCtx.fillRect(0, 0, previewSize, previewSize);
                            
                            // Calculate how to fit the image in preview
                            const scale = Math.min(previewSize / sourceWidth, previewSize / sourceHeight);
                            const scaledWidth = sourceWidth * scale;
                            const scaledHeight = sourceHeight * scale;
                            const offsetX = (previewSize - scaledWidth) / 2;
                            const offsetY = (previewSize - scaledHeight) / 2;
                            
                            // Draw the cropped area
                            previewCtx.drawImage(
                                img, 
                                sourceX, sourceY, sourceWidth, sourceHeight,
                                offsetX, offsetY, scaledWidth, scaledHeight
                            );
                            
                            // Add border
                            previewCtx.strokeStyle = 'var(--primary-blue)';
                            previewCtx.lineWidth = 2;
                            previewCtx.strokeRect(offsetX, offsetY, scaledWidth, scaledHeight);
                            
                            // Convert to blob
                            previewCanvas.toBlob((blob) => {
                                resolve({
                                    fileData,
                                    previewBlob: blob,
                                    previewUrl: URL.createObjectURL(blob),
                                    cropArea: { sourceX, sourceY, sourceWidth, sourceHeight }
                                });
                            }, 'image/jpeg', 0.8);
                            
                        } catch (error) {
                            console.error('Error generating preview:', error);
                            resolve({ fileData, previewBlob: null, previewUrl: null, cropArea: null });
                        }
                    };
                    
                    const imageUrl = this.safeCreateObjectURL(fileData.file);
                    if (!imageUrl) {
                        reject(new Error('Cannot create blob URL for this file type'));
                        return;
                    }
                    img.src = imageUrl;
                });
            }

            // Synchronous version of smart crop detection for preview
            detectSmartCropAreaSync(img, targetRatio) {
                const sourceRatio = img.width / img.height;
                let sourceX, sourceY, sourceWidth, sourceHeight;
                
                if (sourceRatio > targetRatio) {
                    sourceHeight = img.height;
                    sourceWidth = sourceHeight * targetRatio;
                    sourceX = (img.width - sourceWidth) / 2;
                    sourceY = 0;
                } else {
                    sourceWidth = img.width;
                    sourceHeight = sourceWidth / targetRatio;
                    sourceX = 0;
                    sourceY = img.height * 0.1; // Slight upward bias
                }
                
                return { sourceX, sourceY, sourceWidth, sourceHeight };
            }

            // Show preview gallery with all cropped images
            showPreviewGallery() {
                const modal = document.getElementById('cropPreviewModal');
                const gallery = document.getElementById('previewGallery');
                const modeTitle = document.getElementById('previewModeTitle');
                const previewCount = document.getElementById('previewCount');
                
                // Update title based on mode
                const modeNames = {
                    'smart': 'Ch·∫ø ƒë·ªô th√¥ng minh',
                    'center': 'Ch·∫ø ƒë·ªô trung t√¢m', 
                    'manual': 'Ch·∫ø ƒë·ªô th·ªß c√¥ng'
                };
                modeTitle.textContent = modeNames[this.cropData.config.mode] || 'Ch·∫ø ƒë·ªô m·∫´u';
                
                // Update count
                previewCount.textContent = `${this.cropData.previewData.length} ·∫£nh`;
                
                // Clear gallery
                gallery.innerHTML = '';
                
                // Create preview grid
                this.cropData.previewData.forEach((preview, index) => {
                    const previewItem = document.createElement('div');
                    previewItem.className = 'preview-item';
                    previewItem.innerHTML = `
                        <div class="preview-image-container">
                            <img src="${preview.previewUrl}" alt="${preview.fileData.name}" class="preview-image">
                            <div class="preview-overlay">
                                <div class="preview-info">
                                    <div class="preview-name">${preview.fileData.name}</div>
                                    <div class="preview-size">${this.cropData.config.width}√ó${this.cropData.config.height}cm</div>
                                </div>
                            </div>
                        </div>
                        <div class="preview-controls">
                            <button class="preview-btn edit" onclick="converter.editPreviewCrop(${index})">
                                Ch·ªânh s·ª≠a
                            </button>
                            <button class="preview-btn remove" onclick="converter.removeFromPreview(${index})">
                                Lo·∫°i b·ªè
                            </button>
                        </div>
                    `;
                    gallery.appendChild(previewItem);
                });
                
                modal.style.display = 'flex';
            }

            // Edit individual crop in preview
            editPreviewCrop(index) {
                // Store current preview state
                this.cropData.currentPreviewIndex = index;
                const preview = this.cropData.previewData[index];
                
                // Switch to manual editing mode for this specific image
                document.getElementById('cropPreviewModal').style.display = 'none';
                document.getElementById('cropEditorModal').style.display = 'flex';
                
                // Load the specific image
                this.loadImageForPreviewEdit(preview);
            }

            // Load image for preview editing
            async loadImageForPreviewEdit(preview) {
                const canvas = document.getElementById('cropCanvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    // Set canvas size to image size with max constraints
                    const maxSize = 800;
                    let displayWidth = img.width;
                    let displayHeight = img.height;
                    
                    if (img.width > maxSize || img.height > maxSize) {
                        const scale = Math.min(maxSize / img.width, maxSize / img.height);
                        displayWidth = img.width * scale;
                        displayHeight = img.height * scale;
                    }
                    
                    canvas.width = displayWidth;
                    canvas.height = displayHeight;
                    
                    // Clear and draw image
                    ctx.clearRect(0, 0, displayWidth, displayHeight);
                    ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                    
                    // Update UI
                    document.getElementById('currentImageName').textContent = preview.fileData.name;
                    document.getElementById('cropProgress').textContent = `Ch·ªânh s·ª≠a preview`;
                    
                    // Initialize crop selection based on existing crop area
                    if (preview.cropArea) {
                        const scale = displayWidth / img.width;
                        const scaledCropArea = {
                            x: preview.cropArea.sourceX * scale,
                            y: preview.cropArea.sourceY * scale,
                            width: preview.cropArea.sourceWidth * scale,
                            height: preview.cropArea.sourceHeight * scale
                        };
                        this.updateCropSelection(scaledCropArea.x, scaledCropArea.y, scaledCropArea.width, scaledCropArea.height);
                    } else {
                        this.initializeCropSelection(displayWidth, displayHeight);
                    }
                    
                    // Setup interactions with pixel-perfect precision
                    this.setupPixelPerfectCropInteractions();
                };
                
                const imgUrl = this.safeCreateObjectURL(preview.fileData.file);
                if (!imgUrl) {
                    console.error('Cannot create blob URL for file:', preview.fileData.file.name);
                    return;
                }
                img.src = imgUrl;
            }

            // Setup pixel-perfect crop interactions
            setupPixelPerfectCropInteractions() {
                const selection = document.getElementById('cropSelection');
                const canvas = document.getElementById('cropCanvas');

                let isDragging = false;
                let isResizing = false;
                let resizeDirection = '';
                let startX = 0, startY = 0, startLeft = 0, startTop = 0, startWidth = 0, startHeight = 0;
                // ALWAYS lock aspect ratio for manual crop with template size
                let aspectLocked = true; // Changed: always maintain aspect ratio for template crops
                let sizeLocked = false;

                // T√≠nh targetAspectRatio d·ª±a tr√™n orientation c·ªßa canvas
                const isCanvasLandscape = canvas.width > canvas.height;
                const isConfigLandscape = this.cropData.config.width > this.cropData.config.height;
                let targetAspectRatio;
                if (isCanvasLandscape !== isConfigLandscape) {
                    targetAspectRatio = this.cropData.config.height / this.cropData.config.width;
                } else {
                    targetAspectRatio = this.cropData.config.width / this.cropData.config.height;
                }
                
                // Pixel-perfect movement with sub-pixel precision
                let rafId = null;
                
                const onMouseMove = (e) => {
                    if (rafId) cancelAnimationFrame(rafId);
                    
                    rafId = requestAnimationFrame(() => {
                        if (isDragging) {
                            const deltaX = e.clientX - startX;
                            const deltaY = e.clientY - startY;
                            
                            // Calculate new position with pixel precision
                            let newLeft = Math.round(startLeft + deltaX);
                            let newTop = Math.round(startTop + deltaY);
                            
                            // Constrain within canvas with pixel precision
                            newLeft = Math.max(0, Math.min(canvas.width - selection.offsetWidth, newLeft));
                            newTop = Math.max(0, Math.min(canvas.height - selection.offsetHeight, newTop));
                            
                            // Apply with transform for smooth animation
                            selection.style.transform = `translate(${newLeft}px, ${newTop}px)`;
                            selection.style.left = '0px';
                            selection.style.top = '0px';
                            
                            this.updateCropDisplayInfo();
                        } else if (isResizing && !sizeLocked) {
                            const deltaX = e.clientX - startX;
                            const deltaY = e.clientY - startY;
                            let newWidth = startWidth, newHeight = startHeight;
                            let newLeft = startLeft, newTop = startTop;
                            
                            // Apply resize based on direction with pixel precision
                            switch (resizeDirection) {
                                case 'se': 
                                    newWidth = Math.round(startWidth + deltaX); 
                                    newHeight = Math.round(startHeight + deltaY); 
                                    break;
                                case 'nw': 
                                    newWidth = Math.round(startWidth - deltaX); 
                                    newHeight = Math.round(startHeight - deltaY); 
                                    newLeft = Math.round(startLeft + deltaX); 
                                    newTop = Math.round(startTop + deltaY); 
                                    break;
                                case 'ne': 
                                    newWidth = Math.round(startWidth + deltaX); 
                                    newHeight = Math.round(startHeight - deltaY); 
                                    newTop = Math.round(startTop + deltaY); 
                                    break;
                                case 'sw': 
                                    newWidth = Math.round(startWidth - deltaX); 
                                    newHeight = Math.round(startHeight + deltaY); 
                                    newLeft = Math.round(startLeft + deltaX); 
                                    break;
                            }
                            
                            // Maintain aspect ratio if locked
                            if (aspectLocked && ['nw', 'ne', 'sw', 'se'].includes(resizeDirection)) {
                                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                                    newHeight = Math.round(newWidth / targetAspectRatio);
                                } else {
                                    newWidth = Math.round(newHeight * targetAspectRatio);
                                }
                            }
                            
                            // Apply constraints with pixel precision
                            newWidth = Math.max(20, Math.min(newWidth, canvas.width - newLeft));
                            newHeight = Math.max(20, Math.min(newHeight, canvas.height - newTop));
                            newLeft = Math.max(0, Math.min(canvas.width - newWidth, newLeft));
                            newTop = Math.max(0, Math.min(canvas.height - newHeight, newTop));
                            
                            // Apply with pixel-perfect positioning
                            selection.style.transform = `translate(${newLeft}px, ${newTop}px)`;
                            selection.style.width = newWidth + 'px';
                            selection.style.height = newHeight + 'px';
                            selection.style.left = '0px';
                            selection.style.top = '0px';
                            
                            this.updateCropDisplayInfo();
                        }
                    });
                };
                
                // Setup event listeners for pixel-perfect interactions
                // ... (rest of the interaction setup)
            }

            // Remove image from preview
            removeFromPreview(index) {
                this.cropData.previewData.splice(index, 1);
                this.showPreviewGallery(); // Refresh gallery
            }

            // Show multi-image crop editor
            async showMultiCropEditor() {
                const modal = document.getElementById('cropEditorModal');
                const container = document.getElementById('multiCropContainer');
                const progress = document.getElementById('multiCropProgress');
                const globalTargetSize = document.getElementById('globalTargetSize');
                const globalAspectRatio = document.getElementById('globalAspectRatio');
                
                // S·ª≠ d·ª•ng crop size t·ª´ config (kh√¥ng auto-adapt ·ªü ƒë√¢y)
                // Logic auto-adapt ƒë√£ ƒë∆∞·ª£c chuy·ªÉn v√†o initializeMultiCropSelection() ƒë·ªÉ x·ª≠ l√Ω t·ª´ng ·∫£nh ri√™ng bi·ªát
                const baseCropSize = { width: this.cropData.config.width, height: this.cropData.config.height };

                console.log(`üéØ Multi-crop editor: Base size ${baseCropSize.width}√ó${baseCropSize.height}cm`);
                console.log(`üìê M·ªói ·∫£nh s·∫Ω t·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh khung c·∫Øt d·ª±a tr√™n orientation ri√™ng`);

                // Update global info
                progress.textContent = `${this.multiCropData.files.length} ·∫£nh`;
                globalTargetSize.textContent = `${baseCropSize.width}√ó${baseCropSize.height}cm`;
                globalAspectRatio.textContent = `${baseCropSize.width}:${baseCropSize.height}`;
                
                // Clear container
                container.innerHTML = '';
                
                // Create crop cards for each image (display all)
                for (let i = 0; i < this.multiCropData.files.length; i++) {
                    const fileData = this.multiCropData.files[i];
                    this.createMultiCropCard(fileData, i, container);
                }
                
                // Setup global controls
                this.setupGlobalCropControls();
                
                modal.style.display = 'flex';
                
                // Auto-select all files initially
                this.multiCropData.files.forEach((_, index) => {
                    this.multiCropData.selectedFiles.add(index);
                });
                this.updateMultiCropSelections();

                // Add resize listener to re-sync overlays
                const resizeHandler = () => {
                    for (let i = 0; i < this.multiCropData.files.length; i++) {
                        this.syncOverlayWithCanvas(i);
                    }
                };
                window.addEventListener('resize', resizeHandler);
                
                // Store handler for cleanup
                this.multiCropData.resizeHandler = resizeHandler;
            }

            // Create individual crop card
            async createMultiCropCard(fileData, index, container) {
                const cardId = `crop-card-${index}`;
                const card = document.createElement('div');
                card.className = 'multi-crop-card selected';
                card.id = cardId;
                
                // Create card HTML
                card.innerHTML = `
                    <div class="multi-crop-header">
                        <div class="multi-crop-name" title="${fileData.name}">${fileData.name}</div>
                        <div class="multi-crop-selector">
                            <div class="multi-crop-checkbox checked" data-action="toggle" data-index="${index}">
                                ‚úì
                            </div>
                        </div>
                    </div>
                    <div class="multi-crop-canvas-container">
                        <canvas class="multi-crop-canvas" id="canvas-${index}"></canvas>
                        <div class="multi-crop-overlay">
                            <div class="multi-crop-selection" id="selection-${index}">
                                <!-- Move handle -->
                                <div class="multi-crop-move-handle">‚ú•</div>
                                
                                <!-- Resize handles for changing crop size -->
                                <div class="multi-crop-resize-handle nw" data-direction="nw" data-index="${index}"></div>
                                <div class="multi-crop-resize-handle ne" data-direction="ne" data-index="${index}"></div>
                                <div class="multi-crop-resize-handle sw" data-direction="sw" data-index="${index}"></div>
                                <div class="multi-crop-resize-handle se" data-direction="se" data-index="${index}"></div>
                            </div>
                        </div>
                    </div>
                    <div class="multi-crop-controls">
                        <button class="multi-crop-btn" data-action="rotate" data-index="${index}" title="Xoay ·∫£nh 90¬∞">üîÑ</button>
                        <button class="multi-crop-btn" data-action="reset" data-index="${index}">ƒê·∫∑t l·∫°i</button>
                        <button class="multi-crop-btn" data-action="center" data-index="${index}">CƒÉn gi·ªØa</button>
                        <button class="multi-crop-btn" data-action="fit" data-index="${index}">T·ªëi ƒëa</button>
                    </div>
                    <div class="multi-crop-info">
                        <span id="crop-info-${index}">Ch·ªù t·∫£i ·∫£nh...</span>
                    </div>
                `;
                
                container.appendChild(card);
                
                // Setup button event listeners
                this.setupMultiCropCardButtons(index);
                
                // Setup resize handles
                this.setupMultiCropResizeHandles(index);
                
                // Load image into canvas
                await this.loadImageIntoMultiCropCard(fileData, index);
            }

            // Load image into crop card
            async loadImageIntoMultiCropCard(fileData, index) {
                const canvas = document.getElementById(`canvas-${index}`);
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    // L∆∞u metadata ·∫£nh g·ªëc ngay khi load
                    fileData.originalWidth = img.naturalWidth || img.width;
                    fileData.originalHeight = img.naturalHeight || img.height;
                    fileData.width = img.width;
                    fileData.height = img.height;
                    if (!fileData.dpi) {
                        fileData.dpi = 300; // Default DPI
                    }

                    // Hi·ªÉn th·ªã th√¥ng tin ngay l·∫≠p t·ª©c (tr∆∞·ªõc khi c√≥ crop area)
                    this.updateMultiCropInfo(index);

                    // Wait for container to be properly sized
                    setTimeout(() => {
                        try {
                            // Always use full container size for maximum visibility
                            const container = canvas.parentElement;
                            const containerWidth = container.clientWidth || 380;
                            const containerHeight = container.clientHeight || 320;

                            // Use full container width, dynamically scale height based on image aspect ratio
                            const maxWidth = containerWidth;
                            const maxHeight = containerHeight;

                        console.log(`Image ${index}: ${img.width}x${img.height}, Container max: ${maxWidth}x${maxHeight}`);
                        
                        // Calculate scale to fit within max dimensions
                        const scaleX = maxWidth / img.width;
                        const scaleY = maxHeight / img.height;
                        const scale = Math.min(scaleX, scaleY, 1); // Don't scale up
                        
                        // Calculate final display size
                        const displayWidth = Math.floor(img.width * scale);
                        const displayHeight = Math.floor(img.height * scale);
                        
                        // Set canvas dimensions
                        canvas.width = displayWidth;
                        canvas.height = displayHeight;
                        
                        // Style canvas to be centered in container
                        canvas.style.display = 'block';
                        canvas.style.margin = 'auto';
                        canvas.style.maxWidth = '100%';
                        canvas.style.maxHeight = '100%';
                        
                        // Clear canvas and set white background
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, displayWidth, displayHeight);
                        
                        // Draw image
                        ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                        
                        console.log(`Canvas ${index}: ${displayWidth}x${displayHeight}, scale: ${scale}`);
                        
                        // Wait for layout to settle, then sync overlay
                        setTimeout(async () => {
                            this.syncOverlayWithCanvas(index);
                            // Initialize crop selection
                            await this.initializeMultiCropSelection(index, displayWidth, displayHeight);
                        }, 100);
                        
                        // Setup interactions
                        this.setupMultiCropInteractions(index);
                        
                        // Update info
                        this.updateMultiCropInfo(index);
                        
                        // Setup ResizeObserver to handle zoom changes and layout updates
                        if (window.ResizeObserver && !canvas._multiCropResizeObserver) {
                            const resizeObserver = new ResizeObserver(() => {
                                setTimeout(() => {
                                    this.syncOverlayWithCanvas(index);
                                    // Apply size lock after zoom if it's active
                                    this.applySizeLockAfterZoom(index);
                                }, 50);
                            });
                            resizeObserver.observe(canvas.parentElement);
                            resizeObserver.observe(canvas);
                            resizeObserver.observe(container);

                            // Store reference ƒë·ªÉ c√≥ th·ªÉ cleanup sau
                            canvas._multiCropResizeObserver = resizeObserver;
                        }
                        } catch (error) {
                            console.error(`Error loading image for canvas ${index}:`, error);
                        }
                    }, 100); // 100ms delay to ensure container is sized
                };
                
                img.onerror = (error) => {
                    console.error(`Failed to load image for canvas ${index}:`, error);
                    // Show error message in canvas
                    canvas.width = 200;
                    canvas.height = 100;
                    ctx.fillStyle = '#f8f9fa';
                    ctx.fillRect(0, 0, 200, 100);
                    ctx.fillStyle = '#dc3545';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('L·ªói t·∫£i ·∫£nh', 100, 50);
                };
                
                const imgUrl = this.safeCreateObjectURL(fileData.file);
                if (!imgUrl) {
                    console.error('Cannot create blob URL for file:', fileData.file.name);
                    return;
                }
                img.src = imgUrl;
            }

            // Initialize crop selection for a card
            async initializeMultiCropSelection(index, canvasWidth, canvasHeight) {
                // Get individual crop size adapted to this specific image's orientation (if auto-rotate enabled)
                const fileData = this.multiCropData.files[index];

                // Use base crop size from config
                const baseCropSize = {
                    width: this.cropData.config.width,
                    height: this.cropData.config.height
                };

                // X√°c ƒë·ªãnh targetRatio d·ª±a tr√™n canvas hi·ªán t·∫°i (ƒë√£ xoay n·∫øu c√≥)
                let targetRatio;
                const canvasRatio = canvasWidth / canvasHeight;
                const configRatio = baseCropSize.width / baseCropSize.height;

                // Ki·ªÉm tra xem canvas orientation c√≥ kh·ªõp v·ªõi config kh√¥ng
                const isCanvasLandscape = canvasWidth > canvasHeight;
                const isConfigLandscape = baseCropSize.width > baseCropSize.height;

                // T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh ratio n·∫øu orientation kh√°c nhau
                if (isCanvasLandscape !== isConfigLandscape) {
                    targetRatio = 1 / configRatio; // ƒê·∫£o ng∆∞·ª£c ratio
                    console.log(`üîÑ Image ${index}: Canvas ${isCanvasLandscape ? 'ngang' : 'd·ªçc'} vs Config ${isConfigLandscape ? 'ngang' : 'd·ªçc'} ‚Üí ƒê·∫£o ratio ${configRatio.toFixed(3)} ‚Üí ${targetRatio.toFixed(3)}`);
                } else {
                    targetRatio = configRatio;
                    console.log(`‚úÖ Image ${index}: Canvas v√† Config c√πng orientation ‚Üí Gi·ªØ ratio ${targetRatio.toFixed(3)}`);
                }

                let selectionWidth, selectionHeight;
                
                // Use 100% of available canvas space for MAXIMUM crop area
                console.log(`Target ratio: ${targetRatio.toFixed(3)}, Canvas ratio: ${canvasRatio.toFixed(3)}`);
                
                // Calculate MAXIMUM selection size while maintaining aspect ratio
                if (targetRatio > canvasRatio) {
                    // Target is wider than canvas - limit by width (use full width)
                    selectionWidth = canvasWidth; // 100% width - MAXIMUM!
                    selectionHeight = selectionWidth / targetRatio;
                    
                    console.log(`Width-limited: ${selectionWidth}x${selectionHeight}`);
                } else {
                    // Target is taller than canvas - limit by height (use full height)
                    selectionHeight = canvasHeight; // 100% height - MAXIMUM!
                    selectionWidth = selectionHeight * targetRatio;
                    
                    console.log(`Height-limited: ${selectionWidth}x${selectionHeight}`);
                }
                
                // Final bounds check (should not be needed with proper calculation)
                selectionWidth = Math.min(selectionWidth, canvasWidth);
                selectionHeight = Math.min(selectionHeight, canvasHeight);
                
                // Center the selection within canvas bounds
                const x = Math.max(0, (canvasWidth - selectionWidth) / 2);
                const y = Math.max(0, (canvasHeight - selectionHeight) / 2);
                
                console.log(`MAXIMUM Canvas ${index}: ${canvasWidth}x${canvasHeight}, Selection: ${Math.round(selectionWidth)}x${Math.round(selectionHeight)} at (${Math.round(x)}, ${Math.round(y)})`);
                console.log(`Selection uses ${((selectionWidth/canvasWidth)*100).toFixed(1)}% width, ${((selectionHeight/canvasHeight)*100).toFixed(1)}% height`);
                
                // Store crop selection with bounds checking
                this.multiCropData.cropSelections.set(index, {
                    x: Math.round(x), 
                    y: Math.round(y), 
                    width: Math.round(selectionWidth), 
                    height: Math.round(selectionHeight)
                });
                
                // Update visual selection
                this.updateMultiCropSelectionVisual(index);
            }

            // Update visual crop selection
            updateMultiCropSelectionVisual(index) {
                const selection = document.getElementById(`selection-${index}`);
                const cropArea = this.multiCropData.cropSelections.get(index);
                const canvas = document.getElementById(`canvas-${index}`);
                const container = canvas?.parentElement;

                if (selection && cropArea && canvas && container) {
                    // Ensure overlay is properly positioned first
                    this.syncOverlayWithCanvas(index);

                    // Validate crop area bounds
                    const maxX = canvas.width - cropArea.width;
                    const maxY = canvas.height - cropArea.height;

                    const validX = Math.max(0, Math.min(cropArea.x, maxX));
                    const validY = Math.max(0, Math.min(cropArea.y, maxY));
                    const validWidth = Math.min(cropArea.width, canvas.width - validX);
                    const validHeight = Math.min(cropArea.height, canvas.height - validY);

                    // Update crop area if bounds were adjusted
                    if (validX !== cropArea.x || validY !== cropArea.y ||
                        validWidth !== cropArea.width || validHeight !== cropArea.height) {
                        this.multiCropData.cropSelections.set(index, {
                            x: validX, y: validY, width: validWidth, height: validHeight
                        });
                    }

                    // T√≠nh to√°n v·ªã tr√≠ canvas trong container - s·ª≠ d·ª•ng offsetLeft/offsetTop
                    const canvasOffsetX = canvas.offsetLeft;
                    const canvasOffsetY = canvas.offsetTop;

                    // T√≠nh scale ratio gi·ªØa displayed canvas v√† actual canvas
                    const scaleX = canvas.offsetWidth / canvas.width;
                    const scaleY = canvas.offsetHeight / canvas.height;

                    // Set crop selection position v·ªõi scale
                    selection.style.position = 'absolute';
                    selection.style.left = (canvasOffsetX + (validX * scaleX)) + 'px';
                    selection.style.top = (canvasOffsetY + (validY * scaleY)) + 'px';
                    selection.style.width = (validWidth * scaleX) + 'px';
                    selection.style.height = (validHeight * scaleY) + 'px';

                    console.log(`Selection ${index}: canvas@${canvas.width}x${canvas.height} display@${canvas.offsetWidth}x${canvas.offsetHeight} scale=${scaleX.toFixed(2)}`);
                }
            }

            // Setup crop interactions for a card
            setupMultiCropInteractions(index) {
                const selection = document.getElementById(`selection-${index}`);
                const canvas = document.getElementById(`canvas-${index}`);
                
                if (!selection || !canvas) return;
                
                let isDragging = false;
                let isResizing = false;
                let resizeDirection = '';
                let startX = 0, startY = 0;
                let startCropArea = null;
                let animationId = null;
                
                // Handle move
                const moveHandle = selection.querySelector('.multi-crop-move-handle');
                moveHandle?.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startCropArea = { ...this.multiCropData.cropSelections.get(index) };
                    selection.classList.add('dragging');
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
                
                // DISABLED - NO RESIZE HANDLES IN MULTI-CROP
                // const handles = selection.querySelectorAll('.multi-crop-handle.corner');
                // handles.forEach(handle => {
                //     handle.addEventListener('mousedown', (e) => {
                //         e.preventDefault();
                //         
                //         if (this.multiCropData.globalSettings.sizeLocked) {
                //             this.showToast('K√≠ch th∆∞·ªõc ƒë√£ b·ªã kh√≥a!', 'warning');
                //             return;
                //         }
                //         
                //         isResizing = true;
                //         resizeDirection = handle.getAttribute('data-direction');
                //         startX = e.clientX;
                //         startY = e.clientY;
                //         startCropArea = { ...this.multiCropData.cropSelections.get(index) };
                //         
                //         document.addEventListener('mousemove', onMouseMove);
                //         document.addEventListener('mouseup', onMouseUp);
                //     });
                // }); // DISABLED MULTI-CROP RESIZE
                
                const onMouseMove = (e) => {
                    if (animationId) cancelAnimationFrame(animationId);

                    animationId = requestAnimationFrame(() => {
                        if (!startCropArea) return;

                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;

                        if (isDragging) {
                            // T√≠nh scale ƒë·ªÉ convert pixel delta sang canvas delta
                            const scaleX = canvas.offsetWidth / canvas.width;
                            const scaleY = canvas.offsetHeight / canvas.height;

                            // Convert pixel movement to canvas coordinates
                            const canvasDeltaX = deltaX / scaleX;
                            const canvasDeltaY = deltaY / scaleY;

                            // Move crop area with pixel precision
                            const newX = Math.round(Math.max(0, Math.min(canvas.width - startCropArea.width, startCropArea.x + canvasDeltaX)));
                            const newY = Math.round(Math.max(0, Math.min(canvas.height - startCropArea.height, startCropArea.y + canvasDeltaY)));

                            this.multiCropData.cropSelections.set(index, {
                                ...startCropArea,
                                x: newX,
                                y: newY
                            });
                        }
                        // REMOVED RESIZE LOGIC - ONLY DRAG IS ALLOWED

                        this.updateMultiCropSelectionVisual(index);
                        this.updateMultiCropInfo(index);
                    });
                };
                
                const onMouseUp = () => {
                    if (animationId) cancelAnimationFrame(animationId);
                    isDragging = false;
                    isResizing = false;
                    resizeDirection = '';
                    startCropArea = null;
                    selection.classList.remove('dragging');
                    
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
            }

            // Toggle crop selection
            toggleCropSelection(index) {
                const checkbox = document.querySelector(`#crop-card-${index} .multi-crop-checkbox`);
                const card = document.getElementById(`crop-card-${index}`);
                
                if (this.multiCropData.selectedFiles.has(index)) {
                    this.multiCropData.selectedFiles.delete(index);
                    checkbox.classList.remove('checked');
                    card.classList.remove('selected');
                } else {
                    this.multiCropData.selectedFiles.add(index);
                    checkbox.classList.add('checked');
                    card.classList.add('selected');
                }
                
                this.updateMultiCropSelections();
            }

            // Setup global crop controls
            setupGlobalCropControls() {
                // Remove existing listeners first
                const globalControls = ['resetAllCrops', 'centerAllCrops', 'fitAllCrops', 'globalAspectLock', 'globalSizeLock', 'selectAllCrops', 'acceptAllCrops', 'cancelMultiCrop'];
                globalControls.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.replaceWith(element.cloneNode(true));
                    }
                });
                
                // Global aspect lock - allow toggle
                const globalAspectLockBtn = document.getElementById('globalAspectLock');
                if (globalAspectLockBtn) {
                    globalAspectLockBtn.classList.add('active'); // Start as active
                }
                
                // Global aspect lock toggle functionality
                document.getElementById('globalAspectLock')?.addEventListener('click', () => {
                    const btn = document.getElementById('globalAspectLock');
                    const isActive = btn.classList.toggle('active');
                    
                    // Update global setting
                    this.multiCropData.globalSettings.aspectLocked = isActive;
                    
                    // Show status
                    if (isActive) {
                        this.showToast('üîí Kh√≥a t·ª∑ l·ªá: B·∫¨T - Gi·ªØ nguy√™n t·ª∑ l·ªá khi k√©o', 'success');
                    } else {
                        this.showToast('üîì Kh√≥a t·ª∑ l·ªá: T·∫ÆT - C√≥ th·ªÉ k√©o t·ª± do', 'info');
                    }
                });
                
                // Global size lock
                document.getElementById('globalSizeLock')?.addEventListener('click', () => {
                    this.multiCropData.globalSettings.sizeLocked = !this.multiCropData.globalSettings.sizeLocked;
                    const btn = document.getElementById('globalSizeLock');
                    btn.classList.toggle('active', this.multiCropData.globalSettings.sizeLocked);
                    
                    if (this.multiCropData.globalSettings.sizeLocked) {
                        // Store current actual sizes for all selected cards
                        this.multiCropData.selectedFiles.forEach(index => {
                            const selection = document.querySelector(`#selection-${index}`);
                            const canvas = document.getElementById(`canvas-${index}`);
                            if (selection && canvas) {
                                const rect = selection.getBoundingClientRect();
                                const canvasRect = canvas.getBoundingClientRect();
                                
                                // Calculate scale factors
                                const scaleX = canvas.width / canvasRect.width;
                                const scaleY = canvas.height / canvasRect.height;
                                
                                // Store actual dimensions for this card
                                const cropData = this.multiCropData.cropSelections.get(index) || {};
                                cropData.lockedActualWidth = Math.round(rect.width * scaleX);
                                cropData.lockedActualHeight = Math.round(rect.height * scaleY);
                                this.multiCropData.cropSelections.set(index, cropData);
                                
                                console.log(`Locked card ${index}: ${cropData.lockedActualWidth}x${cropData.lockedActualHeight}px actual`);
                            }
                        });
                        this.showToast('üîí ƒê√£ kh√≥a k√≠ch th∆∞·ªõc t·∫•t c·∫£ khung c·∫Øt', 'info');
                    } else {
                        // Clear locked sizes
                        this.multiCropData.selectedFiles.forEach(index => {
                            const cropData = this.multiCropData.cropSelections.get(index);
                            if (cropData) {
                                delete cropData.lockedActualWidth;
                                delete cropData.lockedActualHeight;
                                this.multiCropData.cropSelections.set(index, cropData);
                            }
                        });
                        this.showToast('üîì ƒê√£ m·ªü kh√≥a k√≠ch th∆∞·ªõc t·∫•t c·∫£ khung c·∫Øt', 'info');
                    }
                });
                
                // Global actions
                document.getElementById('resetAllCrops')?.addEventListener('click', async () => {
                    for (const index of this.multiCropData.selectedFiles) {
                        await this.resetCropCard(index);
                    }
                });
                
                document.getElementById('centerAllCrops')?.addEventListener('click', () => {
                    this.multiCropData.selectedFiles.forEach(index => this.centerCropCard(index));
                });
                
                document.getElementById('fitAllCrops')?.addEventListener('click', async () => {
                    for (const index of this.multiCropData.selectedFiles) {
                        await this.fitCropCard(index);
                    }
                });
                
                document.getElementById('selectAllCrops')?.addEventListener('click', () => {
                    this.multiCropData.files.forEach((_, index) => {
                        this.multiCropData.selectedFiles.add(index);
                    });
                    this.updateAllCropCardSelections();
                });
                
                document.getElementById('acceptAllCrops')?.addEventListener('click', () => {
                    this.processMultiCropSelection();
                });

                // Cancel button - close modal
                document.getElementById('cancelMultiCrop')?.addEventListener('click', () => {
                    this.hideCropEditor();
                });
            }

            // Update multi-crop selections
            updateMultiCropSelections() {
                const selectedCount = this.multiCropData.selectedFiles.size;
                const acceptButton = document.getElementById('acceptAllCrops');
                
                if (acceptButton) {
                    acceptButton.textContent = `C·∫Øt ${selectedCount} ·∫£nh ƒë√£ ch·ªçn`;
                    acceptButton.disabled = selectedCount === 0;
                }
            }

            // Reset, center, fit crop cards
            async resetCropCard(index) {
                const canvas = document.getElementById(`canvas-${index}`);
                if (canvas) {
                    await this.initializeMultiCropSelection(index, canvas.width, canvas.height);
                }
            }

            centerCropCard(index) {
                const cropArea = this.multiCropData.cropSelections.get(index);
                const canvas = document.getElementById(`canvas-${index}`);
                
                if (cropArea && canvas) {
                    const newX = (canvas.width - cropArea.width) / 2;
                    const newY = (canvas.height - cropArea.height) / 2;
                    
                    this.multiCropData.cropSelections.set(index, {
                        ...cropArea, x: newX, y: newY
                    });
                    this.updateMultiCropSelectionVisual(index);
                }
            }

            async fitCropCard(index) {
                const canvas = document.getElementById(`canvas-${index}`);
                if (canvas) {
                    await this.initializeMultiCropSelection(index, canvas.width, canvas.height);
                }
            }

            async rotateCropCard(index) {
                const canvas = document.getElementById(`canvas-${index}`);
                const fileData = this.multiCropData.files[index];
                if (!canvas || !fileData) return;

                // L∆∞u rotation state cho file n√†y
                if (!fileData.rotation) {
                    fileData.rotation = 0;
                }
                fileData.rotation = (fileData.rotation + 90) % 360;

                console.log(`üîÑ Rotating image ${index} to ${fileData.rotation}¬∞`);

                // Reload image v·ªõi rotation m·ªõi
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = () => {
                    // Calculate rotated dimensions
                    const isVertical = fileData.rotation === 90 || fileData.rotation === 270;
                    let imgWidth = isVertical ? img.height : img.width;
                    let imgHeight = isVertical ? img.width : img.height;

                    // Container dimensions
                    const container = canvas.parentElement;
                    const containerWidth = container.clientWidth || 380;
                    const containerHeight = container.clientHeight || 320;

                    // Calculate scale to fit
                    const scaleX = containerWidth / imgWidth;
                    const scaleY = containerHeight / imgHeight;
                    const scale = Math.min(scaleX, scaleY, 1);

                    // Canvas size for rotated image
                    const displayWidth = Math.floor(imgWidth * scale);
                    const displayHeight = Math.floor(imgHeight * scale);

                    canvas.width = displayWidth;
                    canvas.height = displayHeight;

                    // Clear and setup for rotation
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, displayWidth, displayHeight);

                    // Apply rotation
                    ctx.save();
                    ctx.translate(displayWidth / 2, displayHeight / 2);
                    ctx.rotate((fileData.rotation * Math.PI) / 180);
                    ctx.translate(-displayWidth / 2, -displayHeight / 2);

                    // Draw rotated image
                    if (isVertical) {
                        // Swap width/height for vertical rotation
                        ctx.drawImage(img, (displayWidth - displayHeight) / 2, (displayHeight - displayWidth) / 2, displayHeight, displayWidth);
                    } else {
                        ctx.drawImage(img, 0, 0, displayWidth, displayHeight);
                    }
                    ctx.restore();

                    // Re-sync overlay and reinitialize crop selection
                    setTimeout(async () => {
                        this.syncOverlayWithCanvas(index);
                        await this.initializeMultiCropSelection(index, displayWidth, displayHeight);
                        this.updateMultiCropInfo(index);
                    }, 100);
                };

                const imgUrl = this.safeCreateObjectURL(fileData.file);
                if (imgUrl) {
                    img.src = imgUrl;
                }
            }

            // Multi-crop resize handles setup
            setupMultiCropResizeHandles(index) {
                const selection = document.getElementById(`selection-${index}`);
                const canvas = document.getElementById(`canvas-${index}`);
                const resizeHandles = selection.querySelectorAll('.multi-crop-resize-handle');
                
                if (!selection || !canvas || !resizeHandles.length) return;
                
                resizeHandles.forEach(handle => {
                    let isResizing = false;
                    let startX = 0, startY = 0;
                    let startWidth = 0, startHeight = 0;
                    let startLeft = 0, startTop = 0;
                    const direction = handle.getAttribute('data-direction');
                    
                    const onMouseDown = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        isResizing = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        startWidth = selection.offsetWidth;
                        startHeight = selection.offsetHeight;
                        startLeft = parseInt(selection.style.left);
                        startTop = parseInt(selection.style.top);
                        
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    };
                    
                    const onMouseMove = (e) => {
                        if (!isResizing) return;

                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;
                        const aspectLocked = this.multiCropData.globalSettings.aspectLocked;

                        // T√≠nh targetAspectRatio d·ª±a tr√™n orientation c·ªßa canvas
                        const isCanvasLandscape = canvas.width > canvas.height;
                        const isConfigLandscape = this.cropData.config.width > this.cropData.config.height;
                        let targetAspectRatio;
                        if (isCanvasLandscape !== isConfigLandscape) {
                            targetAspectRatio = this.cropData.config.height / this.cropData.config.width;
                        } else {
                            targetAspectRatio = this.cropData.config.width / this.cropData.config.height;
                        }

                        // L·∫•y scale ƒë·ªÉ convert gi·ªØa display v√† canvas coordinates
                        const scaleX = canvas.offsetWidth / canvas.width;
                        const scaleY = canvas.offsetHeight / canvas.height;
                        const canvasOffsetX = canvas.offsetLeft;
                        const canvasOffsetY = canvas.offsetTop;

                        // L·∫•y crop data hi·ªán t·∫°i (canvas coordinates)
                        const currentCrop = this.multiCropData.cropSelections.get(index);

                        let newWidth, newHeight, newLeft, newTop;

                        // Calculate new dimensions based on direction and aspect lock
                        if (aspectLocked) {
                            // Maintain aspect ratio
                            switch (direction) {
                                case 'se':
                                    newWidth = Math.max(50, startWidth + deltaX);
                                    newHeight = newWidth / targetAspectRatio;
                                    newLeft = startLeft;
                                    newTop = startTop;
                                    break;
                                case 'sw':
                                    newWidth = Math.max(50, startWidth - deltaX);
                                    newHeight = newWidth / targetAspectRatio;
                                    newLeft = startLeft + (startWidth - newWidth);
                                    newTop = startTop;
                                    break;
                                case 'ne':
                                    newWidth = Math.max(50, startWidth + deltaX);
                                    newHeight = newWidth / targetAspectRatio;
                                    newLeft = startLeft;
                                    newTop = startTop + (startHeight - newHeight);
                                    break;
                                case 'nw':
                                    newWidth = Math.max(50, startWidth - deltaX);
                                    newHeight = newWidth / targetAspectRatio;
                                    newLeft = startLeft + (startWidth - newWidth);
                                    newTop = startTop + (startHeight - newHeight);
                                    break;
                            }
                        } else {
                            // Free resize
                            switch (direction) {
                                case 'se':
                                    newWidth = Math.max(50, startWidth + deltaX);
                                    newHeight = Math.max(50, startHeight + deltaY);
                                    newLeft = startLeft;
                                    newTop = startTop;
                                    break;
                                case 'sw':
                                    newWidth = Math.max(50, startWidth - deltaX);
                                    newHeight = Math.max(50, startHeight + deltaY);
                                    newLeft = startLeft + (startWidth - newWidth);
                                    newTop = startTop;
                                    break;
                                case 'ne':
                                    newWidth = Math.max(50, startWidth + deltaX);
                                    newHeight = Math.max(50, startHeight - deltaY);
                                    newLeft = startLeft;
                                    newTop = startTop + (startHeight - newHeight);
                                    break;
                                case 'nw':
                                    newWidth = Math.max(50, startWidth - deltaX);
                                    newHeight = Math.max(50, startHeight - deltaY);
                                    newLeft = startLeft + (startWidth - newWidth);
                                    newTop = startTop + (startHeight - newHeight);
                                    break;
                            }
                        }

                        // Convert display coordinates to canvas coordinates
                        const canvasWidth = newWidth / scaleX;
                        const canvasHeight = newHeight / scaleY;
                        const canvasLeft = (newLeft - canvasOffsetX) / scaleX;
                        const canvasTop = (newTop - canvasOffsetY) / scaleY;

                        // Keep within canvas bounds (in canvas coordinates)
                        const boundedCanvasWidth = Math.min(canvasWidth, canvas.width - Math.max(0, canvasLeft));
                        const boundedCanvasHeight = Math.min(canvasHeight, canvas.height - Math.max(0, canvasTop));
                        const boundedCanvasLeft = Math.max(0, Math.min(canvas.width - boundedCanvasWidth, canvasLeft));
                        const boundedCanvasTop = Math.max(0, Math.min(canvas.height - boundedCanvasHeight, canvasTop));

                        // Update stored crop data (canvas coordinates)
                        this.multiCropData.cropSelections.set(index, {
                            x: Math.round(boundedCanvasLeft),
                            y: Math.round(boundedCanvasTop),
                            width: Math.round(boundedCanvasWidth),
                            height: Math.round(boundedCanvasHeight)
                        });

                        // Update visual (s·∫Ω convert l·∫°i sang display coordinates)
                        this.updateMultiCropSelectionVisual(index);
                        this.updateMultiCropInfo(index);
                    };
                    
                    const onMouseUp = () => {
                        isResizing = false;
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };
                    
                    handle.addEventListener('mousedown', onMouseDown);
                });
            }

            updateAllCropCardSelections() {
                this.multiCropData.files.forEach((_, index) => {
                    const checkbox = document.querySelector(`#crop-card-${index} .multi-crop-checkbox`);
                    const card = document.getElementById(`crop-card-${index}`);
                    
                    if (this.multiCropData.selectedFiles.has(index)) {
                        checkbox?.classList.add('checked');
                        card?.classList.add('selected');
                    } else {
                        checkbox?.classList.remove('checked');
                        card?.classList.remove('selected');
                    }
                });
                this.updateMultiCropSelections();
            }

            updateMultiCropInfo(index) {
                const infoElement = document.getElementById(`crop-info-${index}`);
                const fileData = this.multiCropData.files[index];

                if (!infoElement || !fileData) return;

                // L·∫•y k√≠ch th∆∞·ªõc g·ªëc t·ª´ file metadata
                const originalWidth = fileData.originalWidth || fileData.width;
                const originalHeight = fileData.originalHeight || fileData.height;
                const dpi = fileData.dpi || 300; // Default 300 DPI

                // T√≠nh k√≠ch th∆∞·ªõc th·ª±c t·∫ø (cm)
                const widthCm = ((originalWidth / dpi) * 2.54).toFixed(1);
                const heightCm = ((originalHeight / dpi) * 2.54).toFixed(1);

                // Ch·ªâ hi·ªÉn th·ªã k√≠ch th∆∞·ªõc g·ªëc (target size ƒë√£ c√≥ ·ªü global-crop-controls)
                infoElement.innerHTML = `
                    <div style="font-size: 0.85rem;">
                        <strong>·∫¢nh g·ªëc:</strong> ${widthCm}√ó${heightCm} cm (${originalWidth}√ó${originalHeight}px @ ${dpi} DPI)
                    </div>
                `;
            }

            // Process multi-crop selection
            async processMultiCropSelection() {
                const selectedFiles = Array.from(this.multiCropData.selectedFiles);
                
                if (selectedFiles.length === 0) {
                    this.showToast('Ch·ªçn √≠t nh·∫•t 1 ·∫£nh ƒë·ªÉ c·∫Øt!', 'warning');
                    return;
                }
                
                this.showToast(`ƒêang c·∫Øt ${selectedFiles.length} ·∫£nh...`, 'success');
                
                // Process each selected file
                for (const index of selectedFiles) {
                    const fileData = this.multiCropData.files[index];
                    const cropArea = this.multiCropData.cropSelections.get(index);
                    const canvas = document.getElementById(`canvas-${index}`);
                    
                    if (fileData && cropArea && canvas) {
                        try {
                            const croppedBlob = await this.performMultiCrop(fileData, cropArea, canvas);
                            const croppedName = this.generateCropName(fileData.convertedName || fileData.name);
                            
                            this.cropData.croppedImages.push({
                                originalFile: fileData,
                                croppedBlob,
                                croppedName
                            });
                        } catch (error) {
                            console.error(`Error cropping ${fileData.name}:`, error);
                        }
                    }
                }
                
                // Close editor and download
                this.hideCropEditor(); // Use hideCropEditor to properly cleanup
                await this.saveCroppedImages();
                
                // Auto-sync crop data
                this.syncCropProcessedFiles();
            }

            // Perform crop for multi-crop
            async performMultiCrop(fileData, cropArea, canvas) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        // T·∫°o temporary canvas ƒë·ªÉ x·ª≠ l√Ω rotation tr∆∞·ªõc
                        const tempCanvas = document.createElement('canvas');
                        const tempCtx = tempCanvas.getContext('2d');

                        // Ki·ªÉm tra rotation
                        const rotation = fileData.rotation || 0;
                        const isVertical = rotation === 90 || rotation === 270;

                        // Set temp canvas size theo rotation
                        if (isVertical) {
                            tempCanvas.width = img.height;
                            tempCanvas.height = img.width;
                        } else {
                            tempCanvas.width = img.width;
                            tempCanvas.height = img.height;
                        }

                        // Apply rotation n·∫øu c·∫ßn
                        if (rotation !== 0) {
                            tempCtx.save();
                            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
                            tempCtx.rotate((rotation * Math.PI) / 180);
                            if (isVertical) {
                                tempCtx.drawImage(img, -img.width / 2, -img.height / 2);
                            } else {
                                tempCtx.drawImage(img, -img.width / 2, -img.height / 2);
                            }
                            tempCtx.restore();
                        } else {
                            tempCtx.drawImage(img, 0, 0);
                        }

                        // B√¢y gi·ªù crop t·ª´ rotated image
                        const cropCanvas = document.createElement('canvas');
                        const cropCtx = cropCanvas.getContext('2d');

                        // Calculate actual crop coordinates t·ª´ rotated image
                        const scaleX = tempCanvas.width / canvas.width;
                        const scaleY = tempCanvas.height / canvas.height;

                        const sourceX = cropArea.x * scaleX;
                        const sourceY = cropArea.y * scaleY;
                        const sourceWidth = cropArea.width * scaleX;
                        const sourceHeight = cropArea.height * scaleY;

                        // C√îNG TH·ª®C CH√çNH X√ÅC: C·ªë ƒë·ªãnh DPI = 300
                        const DPI = 300;

                        // T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh width/height d·ª±a tr√™n orientation c·ªßa v√πng crop
                        const isCropLandscape = sourceWidth > sourceHeight;
                        const isConfigLandscape = this.cropData.config.width > this.cropData.config.height;

                        let finalWidth, finalHeight;
                        if (isCropLandscape === isConfigLandscape) {
                            // Orientation kh·ªõp - gi·ªØ nguy√™n
                            finalWidth = this.cropData.config.width;
                            finalHeight = this.cropData.config.height;
                        } else {
                            // Orientation kh√°c - ƒë·∫£o ng∆∞·ª£c ƒë·ªÉ kh·ªõp v·ªõi crop area
                            finalWidth = this.cropData.config.height;
                            finalHeight = this.cropData.config.width;
                            console.log(`üîÑ Multi-crop: ƒê·∫£o ng∆∞·ª£c output size ${this.cropData.config.width}√ó${this.cropData.config.height}cm ‚Üí ${finalWidth}√ó${finalHeight}cm`);
                        }

                        const targetWidth = Math.round((finalWidth / 2.54) * DPI); // (cm √∑ 2.54) √ó 300
                        const targetHeight = Math.round((finalHeight / 2.54) * DPI); // (cm √∑ 2.54) √ó 300

                        cropCanvas.width = targetWidth;
                        cropCanvas.height = targetHeight;

                        // Draw cropped image t·ª´ rotated temp canvas
                        cropCtx.drawImage(tempCanvas, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, targetWidth, targetHeight);
                        
                        // Convert to blob with DPI metadata for exact physical dimensions
                        cropCanvas.toBlob(async (blob) => {
                            try {
                                // CRITICAL: Add DPI metadata to ensure exact physical dimensions
                                const blobWithDPI = await this.addDPIMetadata(blob, DPI);

                                // Verify dimensions match expected physical size
                                const expectedPhysicalWidth = targetWidth / DPI * 2.54; // Convert px to cm
                                const expectedPhysicalHeight = targetHeight / DPI * 2.54; // Convert px to cm

                                console.log(`‚úÖ Multi-crop output: ${targetWidth}x${targetHeight}px at ${DPI} DPI = ${this.cropData.config.width}x${this.cropData.config.height}cm`);
                                console.log(`üîç Verification: ${targetWidth}px √∑ ${DPI} √ó 2.54 = ${expectedPhysicalWidth.toFixed(2)}cm (should be ${this.cropData.config.width}cm)`);
                                console.log(`üîç Verification: ${targetHeight}px √∑ ${DPI} √ó 2.54 = ${expectedPhysicalHeight.toFixed(2)}cm (should be ${this.cropData.config.height}cm)`);

                                resolve(blobWithDPI);
                            } catch (error) {
                                console.warn('Failed to add DPI metadata to crop:', error);
                                resolve(blob); // Return original if DPI metadata fails
                            }
                        }, 'image/jpeg', 1.0); // ‚úÖ Ch·∫•t l∆∞·ª£ng t·ªëi ƒëa 100% - ƒë·∫£m b·∫£o ho√†n h·∫£o nh∆∞ file g·ªëc
                    };
                    
                    const imgUrl = this.safeCreateObjectURL(fileData.file);
                    if (!imgUrl) {
                        console.error('Cannot create blob URL for file:', fileData.file.name);
                        return;
                    }
                    img.src = imgUrl;
                });
            }

            // Setup button event listeners for a crop card
            setupMultiCropCardButtons(index) {
                const card = document.getElementById(`crop-card-${index}`);
                if (!card) return;
                
                // Handle control buttons (reset, center, fit)
                const buttons = card.querySelectorAll('.multi-crop-btn[data-action]');
                buttons.forEach(button => {
                    const action = button.getAttribute('data-action');
                    const buttonIndex = parseInt(button.getAttribute('data-index'));
                    
                    button.addEventListener('click', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        switch (action) {
                            case 'rotate':
                                await this.rotateCropCard(buttonIndex);
                                break;
                            case 'reset':
                                await this.resetCropCard(buttonIndex);
                                break;
                            case 'center':
                                this.centerCropCard(buttonIndex);
                                break;
                            case 'fit':
                                await this.fitCropCard(buttonIndex);
                                break;
                        }
                    });
                });
                
                // Handle checkbox toggle
                const checkbox = card.querySelector('.multi-crop-checkbox[data-action="toggle"]');
                if (checkbox) {
                    checkbox.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const checkboxIndex = parseInt(checkbox.getAttribute('data-index'));
                        this.toggleCropSelection(checkboxIndex);
                    });
                }
            }

            // Apply size lock after zoom changes
            applySizeLockAfterZoom(index) {
                // Check if this is for multi-crop or single crop
                const isMultiCrop = this.multiCropData && this.multiCropData.files;
                
                if (isMultiCrop) {
                    // Multi-crop mode - check global size lock
                    if (!this.multiCropData.globalSettings.sizeLocked) return;
                    
                    const selection = document.querySelector(`#selection-${index}`);
                    const canvas = document.getElementById(`canvas-${index}`);
                    if (!selection || !canvas) return;
                    
                    // Get stored locked dimensions for this card (if any)
                    const cropData = this.multiCropData.cropSelections.get(index);
                    if (!cropData || !cropData.lockedActualWidth || !cropData.lockedActualHeight) return;
                    
                    this.applySizeConstraint(selection, canvas, cropData.lockedActualWidth, cropData.lockedActualHeight);
                } else {
                    // Single crop mode - check individual size lock
                    const selection = document.getElementById('cropSelection');
                    const canvas = document.getElementById('cropCanvas');
                    if (!selection || !canvas) return;
                    
                    // Get locked dimensions from global storage
                    if (!window.cropSizeLockData || !window.cropSizeLockData.sizeLocked) return;
                    
                    this.applySizeConstraint(selection, canvas, window.cropSizeLockData.lockedWidth, window.cropSizeLockData.lockedHeight);
                }
            }
            
            // Apply size constraint to selection
            applySizeConstraint(selection, canvas, lockedActualWidth, lockedActualHeight) {
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calculate current scale factors
                const scaleX = canvas.width / canvasRect.width;
                const scaleY = canvas.height / canvasRect.height;
                
                // Convert locked actual dimensions back to display dimensions
                const displayWidth = lockedActualWidth / scaleX;
                const displayHeight = lockedActualHeight / scaleY;
                
                // Apply the locked size
                selection.style.width = Math.round(displayWidth) + 'px';
                selection.style.height = Math.round(displayHeight) + 'px';
                
                // Ensure selection stays within canvas bounds
                const currentLeft = parseInt(selection.style.left) || 0;
                const currentTop = parseInt(selection.style.top) || 0;
                const maxLeft = canvasRect.width - displayWidth;
                const maxTop = canvasRect.height - displayHeight;
                
                if (currentLeft > maxLeft) selection.style.left = Math.max(0, maxLeft) + 'px';
                if (currentTop > maxTop) selection.style.top = Math.max(0, maxTop) + 'px';
                
                console.log(`Applied size lock: ${lockedActualWidth}x${lockedActualHeight}px actual -> ${Math.round(displayWidth)}x${Math.round(displayHeight)}px display`);
            }

            // Sync overlay position with canvas position
            syncOverlayWithCanvas(index) {
                const canvas = document.getElementById(`canvas-${index}`);
                const overlay = document.querySelector(`#canvas-${index}`).parentElement.querySelector('.multi-crop-overlay');

                if (!canvas || !overlay) return;

                // Use immediate sync for single crop mode
                if (index === undefined) {
                    overlay.style.width = canvas.style.width || canvas.width + 'px';
                    overlay.style.height = canvas.style.height || canvas.height + 'px';
                    return;
                }

                // For multi-crop, ƒë∆°n gi·∫£n h√≥a - overlay s·∫Ω lu√¥n kh·ªõp v·ªõi canvas
                // Kh√¥ng c·∫ßn t√≠nh to√°n offset v√¨ c·∫£ canvas v√† overlay ƒë·ªÅu absolute trong c√πng container
                overlay.style.position = 'absolute';
                overlay.style.left = '0';
                overlay.style.top = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.pointerEvents = 'auto';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
            }

            // Preview Modal Functions
            hideCropPreviewModal() {
                document.getElementById('cropPreviewModal').style.display = 'none';
            }

            async cropAllFromPreviews() {
                if (!this.cropData.previewData || this.cropData.previewData.length === 0) {
                    this.showToast('Kh√¥ng c√≥ preview n√†o ƒë·ªÉ x·ª≠ l√Ω!', 'error');
                    return;
                }
                
                // Select all previews
                this.cropData.selectedFiles.clear();
                for (let i = 0; i < this.cropData.previewData.length; i++) {
                    this.cropData.selectedFiles.add(i);
                }
                
                await this.processSelectedPreviews();
            }

            async cropSelectedFromPreviews() {
                if (!this.cropData.selectedFiles || this.cropData.selectedFiles.size === 0) {
                    this.showToast('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt ·∫£nh ƒë·ªÉ c·∫Øt!', 'error');
                    return;
                }
                
                await this.processSelectedPreviews();
            }

            async processSelectedPreviews() {
                this.showToast('üöÄ B·∫Øt ƒë·∫ßu c·∫Øt ·∫£nh...', 'success');
                this.hideCropPreviewModal();
                
                try {
                    const selectedIndices = Array.from(this.cropData.selectedFiles);
                    this.cropData.croppedImages = [];
                    
                    for (let i = 0; i < selectedIndices.length; i++) {
                        const index = selectedIndices[i];
                        const fileData = this.cropData.files[index];
                        
                        try {
                            const croppedBlob = await this.cropImageAuto(fileData);
                            const croppedName = this.generateCropName(fileData.convertedName);
                            
                            this.cropData.croppedImages.push({
                                originalFile: fileData,
                                croppedBlob,
                                croppedName
                            });
                            
                            this.showToast(`‚úÇÔ∏è ƒê√£ c·∫Øt ${i + 1}/${selectedIndices.length} ·∫£nh`, 'success');
                        } catch (error) {
                            console.error('Error cropping image:', fileData.name, error);
                        }
                    }
                    
                    await this.saveCroppedImages();
                    
                    // Auto-sync crop data
                    this.syncCropProcessedFiles();
                } catch (error) {
                    console.error('Process previews error:', error);
                    this.showToast('‚ùå L·ªói khi x·ª≠ l√Ω preview!', 'error');
                }
            }

            selectAllPreviews() {
                if (!this.cropData.previewData) return;
                
                this.cropData.selectedFiles.clear();
                for (let i = 0; i < this.cropData.previewData.length; i++) {
                    this.cropData.selectedFiles.add(i);
                }
                
                this.updatePreviewSelections();
                this.updateSelectedCount();
            }

            clearAllPreviews() {
                if (!this.cropData.selectedFiles) return;
                
                this.cropData.selectedFiles.clear();
                this.updatePreviewSelections();
                this.updateSelectedCount();
            }

            acceptAllPreviews() {
                this.selectAllPreviews();
                this.cropAllFromPreviews();
            }

            updatePreviewSelections() {
                const gallery = document.getElementById('previewGallery');
                const items = gallery.querySelectorAll('.preview-item');
                
                items.forEach((item, index) => {
                    const checkbox = item.querySelector('.preview-checkbox');
                    if (this.cropData.selectedFiles.has(index)) {
                        item.classList.add('selected');
                        checkbox.classList.add('checked');
                    } else {
                        item.classList.remove('selected');
                        checkbox.classList.remove('checked');
                    }
                });
            }

            updateSelectedCount() {
                const count = this.cropData.selectedFiles ? this.cropData.selectedFiles.size : 0;
                const selectedCountElement = document.getElementById('selectedCount');
                if (selectedCountElement) {
                    selectedCountElement.textContent = count;
                }
                // C·∫≠p nh·∫≠t sticky action indicator
                const selectedImagesCount = document.getElementById('selectedImagesCount');
                if (selectedImagesCount) {
                    selectedImagesCount.textContent = `${count} ·∫£nh ƒë√£ ch·ªçn`;
                }
            }

            // Template crop editor functions
            showTemplateCropEditor() {
            const modal = document.getElementById('templateCropModal');
            modal.style.display = 'flex';
            
            // Update UI elements
            const config = this.templateCropData.config;
            document.getElementById('templateSizeDisplay').textContent = `${config.width}√ó${config.height} ${config.unit}`;
            document.getElementById('templateCropProgress').textContent = `1/${this.templateCropData.files.length}`;
            document.getElementById('templateAspectRatio').textContent = `1:${(config.aspectRatio).toFixed(2)}`;
            document.getElementById('templateTargetSize').textContent = `${config.width}√ó${config.height} ${config.unit} (${config.targetWidth}√ó${config.targetHeight}px)`;
            
            // Initialize template crop handlers
            this.initializeTemplateCropHandlers();
        }
        
        async loadImageForTemplateCropping(index) {
            if (index < 0 || index >= this.templateCropData.files.length) return;
            
            this.templateCropData.currentIndex = index;
            const fileData = this.templateCropData.files[index];
            
            // Update navigation
            document.getElementById('templateImageName').textContent = fileData.name;
            document.getElementById('prevTemplateImage').disabled = index === 0;
            document.getElementById('nextTemplateImage').disabled = index === this.templateCropData.files.length - 1;
            
            // Load image
            const canvas = document.getElementById('templateCropCanvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            // Handle dataURL (from template mode) or file/blob (from regular crop mode)
            let imageUrl;
            if (fileData.dataURL) {
                imageUrl = fileData.dataURL; // Direct dataURL from template
            } else if (fileData.convertedBlob) {
                imageUrl = URL.createObjectURL(fileData.convertedBlob);
            } else if (fileData.file) {
                imageUrl = this.safeCreateObjectURL(fileData.file);
            } else {
                console.error('Cannot create image URL for template crop - no data source found');
                return;
            }
            
            console.log('üñºÔ∏è Loading image for template crop:', imageUrl?.substring(0, 50) + '...');
            
            img.onload = () => {
                // Calculate canvas size to fit container while maintaining image aspect ratio
                const container = canvas.parentElement;
                
                // Use larger minimum sizes for better visibility
                const minCanvasWidth = 400;
                const minCanvasHeight = 300;
                const maxWidth = Math.max(container.clientWidth - 40, minCanvasWidth);
                const maxHeight = Math.max(container.clientHeight - 40, minCanvasHeight);
                
                const imgAspect = img.width / img.height;
                let canvasWidth, canvasHeight;
                
                if (imgAspect > maxWidth / maxHeight) {
                    canvasWidth = Math.max(maxWidth, minCanvasWidth);
                    canvasHeight = Math.max(canvasWidth / imgAspect, minCanvasHeight);
                } else {
                    canvasHeight = Math.max(maxHeight, minCanvasHeight);
                    canvasWidth = Math.max(canvasHeight * imgAspect, minCanvasWidth);
                }
                
                console.log(`üñºÔ∏è Canvas size: ${canvasWidth}√ó${canvasHeight} (image: ${img.width}√ó${img.height}, container: ${container.clientWidth}√ó${container.clientHeight})`);
                
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                
                // Draw image
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                
                // Initialize template crop selection
                this.initializeTemplateCropSelection();
                
                // Only revoke URL if it's a blob URL, not a dataURL
                if (imageUrl && imageUrl.startsWith('blob:')) {
                    URL.revokeObjectURL(imageUrl);
                }
            };
            
            img.src = imageUrl;
        }
        
        initializeTemplateCropSelection() {
            const canvas = document.getElementById('templateCropCanvas');
            const selection = document.getElementById('templateCropSelection');
            const config = this.templateCropData.config;
            
            // ENSURE EXACT ASPECT RATIO from the start
            const targetAspectRatio = config.width / config.height; // Exact ratio from config
            const canvasAspectRatio = canvas.width / canvas.height;
            
            console.log(`Initializing template crop: Target size ${config.width}x${config.height}${config.unit}, aspect ratio: ${targetAspectRatio.toFixed(4)}`);
            
            let cropWidth, cropHeight;
            
            // Fit template within canvas while maintaining EXACT aspect ratio - USE MAXIMUM SIZE
            if (targetAspectRatio > canvasAspectRatio) {
                // Template is wider relative to canvas - limit by width (use FULL width)
                cropWidth = canvas.width; // 100% width - MAXIMUM!
                cropHeight = Math.round(cropWidth / targetAspectRatio); // EXACT division
            } else {
                // Template is taller relative to canvas - limit by height (use FULL height)  
                cropHeight = canvas.height; // 100% height - MAXIMUM!
                cropWidth = Math.round(cropHeight * targetAspectRatio); // EXACT multiplication
            }
            
            // VALIDATE: Check final aspect ratio after rounding
            const actualRatio = cropWidth / cropHeight;
            const ratioError = Math.abs(actualRatio - targetAspectRatio) / targetAspectRatio;
            
            console.log(`Initial crop size: ${cropWidth}x${cropHeight}px, ratio: ${actualRatio.toFixed(4)}, error: ${(ratioError * 100).toFixed(2)}%`);
            
            // If rounding caused ratio drift, correct it
            if (ratioError > 0.001) { // 0.1% tolerance
                if (targetAspectRatio > canvasAspectRatio) {
                    // Re-calculate height to maintain exact ratio
                    cropHeight = Math.round(cropWidth / targetAspectRatio);
                } else {
                    // Re-calculate width to maintain exact ratio
                    cropWidth = Math.round(cropHeight * targetAspectRatio);
                }
                console.log(`Corrected to: ${cropWidth}x${cropHeight}px`);
            }
            
            // Center the selection within canvas
            const x = Math.round((canvas.width - cropWidth) / 2);
            const y = Math.round((canvas.height - cropHeight) / 2);
            
            // Position selection
            selection.style.left = x + 'px';
            selection.style.top = y + 'px';
            selection.style.width = cropWidth + 'px';
            selection.style.height = cropHeight + 'px';
            
            // Store current crop scale
            this.templateCropData.currentScale = 1;
            
            console.log(`Template crop initialized: ${cropWidth}x${cropHeight}px at (${x}, ${y}) with scale 1.0`);
            
            // Update displays
            this.updateTemplateCropInfo();
        }
        
        initializeTemplateCropHandlers() {
            console.log('üîß initializeTemplateCropHandlers() called');
            const selection = document.getElementById('templateCropSelection');
            const canvas = document.getElementById('templateCropCanvas');
            const moveHandle = document.querySelector('.template-move-handle');
            
            let isDragging = false;
            let startX = 0, startY = 0, startLeft = 0, startTop = 0;
            
            // Drag functionality
            moveHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = parseInt(selection.style.left) || 0;
                startTop = parseInt(selection.style.top) || 0;
                
                selection.classList.add('dragging');
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
            
            const onMouseMove = (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                let newLeft = startLeft + deltaX;
                let newTop = startTop + deltaY;
                
                // Keep within canvas bounds
                newLeft = Math.max(0, Math.min(canvas.width - selection.offsetWidth, newLeft));
                newTop = Math.max(0, Math.min(canvas.height - selection.offsetHeight, newTop));
                
                selection.style.left = newLeft + 'px';
                selection.style.top = newTop + 'px';
                
                this.updateTemplateCropInfo();
            };
            
            const onMouseUp = () => {
                if (isDragging) {
                    isDragging = false;
                    selection.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                }
            };
            
            // Resize handles functionality
            const resizeHandles = document.querySelectorAll('.template-resize-handle');
            
            resizeHandles.forEach(handle => {
                let isResizing = false;
                let startX = 0, startY = 0;
                let startWidth = 0, startHeight = 0;
                let startLeft = 0, startTop = 0;
                const direction = handle.getAttribute('data-direction');
                
                const onMouseDown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = selection.offsetWidth;
                    startHeight = selection.offsetHeight;
                    startLeft = parseInt(selection.style.left);
                    startTop = parseInt(selection.style.top);
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };
                
                const onMouseMove = (e) => {
                    if (!isResizing) return;
                    
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    const config = this.templateCropData.config;
                    const targetAspectRatio = config.width / config.height;
                    
                    // Check if aspect ratio should be locked (always true for template crop)
                    const aspectLocked = true; // Template crop always maintains aspect ratio
                    
                    let newWidth, newHeight, newLeft, newTop;
                    
                    // Calculate new dimensions based on direction
                    if (aspectLocked) {
                        // Maintain aspect ratio
                        switch (direction) {
                            case 'se': // Southeast - expand/contract from bottom-right
                                newWidth = Math.max(50, startWidth + deltaX);
                                newHeight = newWidth / targetAspectRatio;
                                newLeft = startLeft;
                                newTop = startTop;
                                break;
                                
                            case 'sw': // Southwest - expand/contract from bottom-left
                                newWidth = Math.max(50, startWidth - deltaX);
                                newHeight = newWidth / targetAspectRatio;
                                newLeft = startLeft + (startWidth - newWidth);
                                newTop = startTop;
                                break;
                                
                            case 'ne': // Northeast - expand/contract from top-right
                                newWidth = Math.max(50, startWidth + deltaX);
                                newHeight = newWidth / targetAspectRatio;
                                newLeft = startLeft;
                                newTop = startTop + (startHeight - newHeight);
                                break;
                                
                            case 'nw': // Northwest - expand/contract from top-left
                                newWidth = Math.max(50, startWidth - deltaX);
                                newHeight = newWidth / targetAspectRatio;
                                newLeft = startLeft + (startWidth - newWidth);
                                newTop = startTop + (startHeight - newHeight);
                                break;
                        }
                    } else {
                        // Free resize (not applicable to template crop, but keeping for completeness)
                        switch (direction) {
                            case 'se':
                                newWidth = Math.max(50, startWidth + deltaX);
                                newHeight = Math.max(50, startHeight + deltaY);
                                newLeft = startLeft;
                                newTop = startTop;
                                break;
                            case 'sw':
                                newWidth = Math.max(50, startWidth - deltaX);
                                newHeight = Math.max(50, startHeight + deltaY);
                                newLeft = startLeft + (startWidth - newWidth);
                                newTop = startTop;
                                break;
                            case 'ne':
                                newWidth = Math.max(50, startWidth + deltaX);
                                newHeight = Math.max(50, startHeight - deltaY);
                                newLeft = startLeft;
                                newTop = startTop + (startHeight - newHeight);
                                break;
                            case 'nw':
                                newWidth = Math.max(50, startWidth - deltaX);
                                newHeight = Math.max(50, startHeight - deltaY);
                                newLeft = startLeft + (startWidth - newWidth);
                                newTop = startTop + (startHeight - newHeight);
                                break;
                        }
                    }
                    
                    // Ensure selection stays within canvas bounds
                    const maxWidth = canvas.width - Math.max(0, newLeft);
                    const maxHeight = canvas.height - Math.max(0, newTop);
                    
                    if (newWidth > maxWidth) {
                        newWidth = maxWidth;
                        newHeight = newWidth / targetAspectRatio;
                    }
                    if (newHeight > maxHeight) {
                        newHeight = maxHeight;
                        newWidth = newHeight * targetAspectRatio;
                    }
                    
                    // Adjust position if needed
                    newLeft = Math.max(0, Math.min(canvas.width - newWidth, newLeft));
                    newTop = Math.max(0, Math.min(canvas.height - newHeight, newTop));
                    
                    // Apply changes
                    selection.style.width = Math.round(newWidth) + 'px';
                    selection.style.height = Math.round(newHeight) + 'px';
                    selection.style.left = Math.round(newLeft) + 'px';
                    selection.style.top = Math.round(newTop) + 'px';
                    
                    this.updateTemplateCropInfo();
                };
                
                const onMouseUp = () => {
                    isResizing = false;
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                handle.addEventListener('mousedown', onMouseDown);
            });
            
            // Position controls
            document.getElementById('templateCenter').addEventListener('click', () => {
                this.centerTemplateCropModal();
            });
            
            document.getElementById('templateReset').addEventListener('click', () => {
                this.resetTemplateCropModal();
            });
            
            // templateCropEdit button listener is handled in setupTemplateEventListeners()
            
            // Navigation controls
            document.getElementById('prevTemplateImage').addEventListener('click', () => {
                if (this.templateCropData.currentIndex > 0) {
                    this.loadImageForTemplateCropping(this.templateCropData.currentIndex - 1);
                }
            });
            
            document.getElementById('nextTemplateImage').addEventListener('click', () => {
                if (this.templateCropData.currentIndex < this.templateCropData.files.length - 1) {
                    this.loadImageForTemplateCropping(this.templateCropData.currentIndex + 1);
                }
            });
            
            // Action controls - handled by setupTemplateCropModalListeners()
            console.log('üìù Modal button listeners are handled by setupTemplateCropModalListeners()');
        }
        
        // Removed applyTemplateCropZoom - now using resize handles instead
        
        centerTemplateCropModal() {
            const selection = document.getElementById('templateCropSelection');
            const canvas = document.getElementById('templateCropCanvas');
            
            const x = (canvas.width - selection.offsetWidth) / 2;
            const y = (canvas.height - selection.offsetHeight) / 2;
            
            selection.style.left = x + 'px';
            selection.style.top = y + 'px';
            
            this.updateTemplateCropInfo();
        }
        
        resetTemplateCropModal() {
            document.getElementById('templateZoomSlider').value = 1;
            document.getElementById('templateZoomValue').textContent = '100%';
            this.templateCropData.currentScale = 1;
            this.initializeTemplateCropSelection();
        }
        
        updateTemplateCropInfo() {
            const selection = document.getElementById('templateCropSelection');
            const canvas = document.getElementById('templateCropCanvas');
            const config = this.templateCropData.config;
            
            // Calculate actual pixel dimensions
            const scaleX = canvas.width / canvas.offsetWidth;
            const scaleY = canvas.height / canvas.offsetHeight;
            const actualWidth = Math.round(selection.offsetWidth * scaleX);
            const actualHeight = Math.round(selection.offsetHeight * scaleY);
            
            // Update displays
            document.getElementById('templateSelectionSize').textContent = `${actualWidth}√ó${actualHeight}px`;
            document.getElementById('templateCurrentSize').textContent = `${actualWidth}√ó${actualHeight}px`;
            
            // Check if ratio is correct using exact target aspect ratio
            const currentRatio = actualWidth / actualHeight;
            const targetRatio = config.width / config.height; // Use exact ratio from config
            const ratioDiff = Math.abs(currentRatio - targetRatio) / targetRatio;
            
            console.log(`Template info update: ${actualWidth}x${actualHeight}px, ratio: ${currentRatio.toFixed(4)}, target: ${targetRatio.toFixed(4)}, diff: ${(ratioDiff * 100).toFixed(2)}%`);
            
            const ratioStatus = document.getElementById('templateRatioStatus');
            if (ratioDiff < 0.005) { // Tighter tolerance: 0.5%
                ratioStatus.textContent = `‚úÖ ƒê√∫ng t·ª∑ l·ªá (${config.width}:${config.height})`;
                ratioStatus.style.color = 'green';
            } else {
                ratioStatus.textContent = `‚ö†Ô∏è Sai t·ª∑ l·ªá (hi·ªán t·∫°i: ${currentRatio.toFixed(3)}, c·∫ßn: ${targetRatio.toFixed(3)})`;
                ratioStatus.style.color = 'orange';
            }
            
            // Show that output will always be correct regardless of template zoom
            const outputInfo = document.getElementById('templateOutputInfo');
            if (outputInfo) {
                outputInfo.textContent = `üéØ Output: ${config.targetWidth}√ó${config.targetHeight}px = ${config.width}√ó${config.height}${config.unit} @ 300 DPI`;
                outputInfo.style.color = 'blue';
                outputInfo.style.fontWeight = 'bold';
            }
        }
        
        async cropCurrentTemplateImage() {
            console.log('üöÄ cropCurrentTemplateImage() called');
            console.log('templateCropData:', this.templateCropData);
            
            const selection = document.getElementById('templateCropSelection');
            const canvas = document.getElementById('templateCropCanvas');
            const config = this.templateCropData?.config;
            const fileData = this.templateCropData?.files?.[this.templateCropData?.currentIndex];
            
            console.log('Elements found:', { selection, canvas, config, fileData });
            
            try {
                // Get crop coordinates
                const scaleX = canvas.width / canvas.offsetWidth;
                const scaleY = canvas.height / canvas.offsetHeight;
                
                const cropX = parseInt(selection.style.left) * scaleX;
                const cropY = parseInt(selection.style.top) * scaleY;
                const cropWidth = selection.offsetWidth * scaleX;
                const cropHeight = selection.offsetHeight * scaleY;
                
                // Create output canvas with exact target dimensions
                // Ensure canvas dimensions match exactly the requested physical size at 300 DPI
                const targetDPI = 300;
                const exactTargetWidth = Math.round((config.width / 2.54) * targetDPI);
                const exactTargetHeight = Math.round((config.height / 2.54) * targetDPI);
                
                const outputCanvas = document.createElement('canvas');
                outputCanvas.width = exactTargetWidth;
                outputCanvas.height = exactTargetHeight;
                
                console.log(`üéØ Creating canvas: ${exactTargetWidth}x${exactTargetHeight}px for ${config.width}x${config.height}cm at ${targetDPI} DPI`);
                const outputCtx = outputCanvas.getContext('2d');
                
                // Load original image for cropping
                const img = new Image();
                let imageUrl;
                
                // Handle different data sources (dataURL from template mode, or file/blob from regular crop mode)
                if (fileData.dataURL) {
                    imageUrl = fileData.dataURL; // Direct dataURL from template
                } else if (fileData.convertedBlob) {
                    imageUrl = URL.createObjectURL(fileData.convertedBlob);
                } else if (fileData.file) {
                    imageUrl = this.safeCreateObjectURL(fileData.file);
                } else {
                    console.error('Cannot create image URL for template crop - no data source found', fileData);
                    return;
                }
                
                img.onload = () => {
                    // Calculate scale from canvas to original image
                    const imageScaleX = img.width / canvas.width;
                    const imageScaleY = img.height / canvas.height;
                    
                    // Apply crop to original image
                    const originalCropX = cropX * imageScaleX;
                    const originalCropY = cropY * imageScaleY;
                    const originalCropWidth = cropWidth * imageScaleX;
                    const originalCropHeight = cropHeight * imageScaleY;
                    
                    // Draw cropped area to output canvas with exact dimensions
                    outputCtx.fillStyle = '#ffffff';
                    outputCtx.fillRect(0, 0, exactTargetWidth, exactTargetHeight);
                    outputCtx.drawImage(
                        img,
                        originalCropX, originalCropY, originalCropWidth, originalCropHeight,
                        0, 0, exactTargetWidth, exactTargetHeight
                    );
                    
                    // Convert to blob with DPI metadata for exact output size
                    outputCanvas.toBlob(async (blob) => {
                        try {
                            // CRITICAL: Add DPI metadata to ensure exact physical dimensions
                            // LU√îN s·ª≠ d·ª•ng DPI = 300 cho ch·∫•t l∆∞·ª£ng t·ªëi ƒëa
                            const blobWithDPI = await this.addDPIMetadata(blob, 300);
                            
                            // Verify dimensions match expected physical size
                            const expectedPhysicalWidth = exactTargetWidth / 300 * 2.54; // Convert px to cm
                            const expectedPhysicalHeight = exactTargetHeight / 300 * 2.54; // Convert px to cm
                            
                            console.log(`‚úÖ Template crop output: ${exactTargetWidth}x${exactTargetHeight}px at 300 DPI = ${config.width}x${config.height}${config.unit}`);
                            console.log(`üîç Verification: ${exactTargetWidth}px √∑ 300 √ó 2.54 = ${expectedPhysicalWidth.toFixed(2)}cm (should be ${config.width}cm)`);
                            console.log(`üîç Verification: ${exactTargetHeight}px √∑ 300 √ó 2.54 = ${expectedPhysicalHeight.toFixed(2)}cm (should be ${config.height}cm)`);
                            
                            // Store cropped result with DPI metadata
                            const croppedImage = {
                                originalFile: fileData,
                                blob: blobWithDPI, // Use blob with DPI metadata
                                filename: this.generateTemplateCropFilename(fileData.name),
                                dimensions: `${exactTargetWidth}√ó${exactTargetHeight}px`,
                                size: `${config.width}√ó${config.height} ${config.unit}`,
                                dpi: 300 // C·ªë ƒë·ªãnh 300 DPI
                            };
                            
                            // Update template data with cropped result
                            const currentTemplateImage = this.templateData.images[this.templateData.currentIndex];
                            if (currentTemplateImage) {
                                // Convert blob to dataURL for template use
                                const reader = new FileReader();
                                reader.onload = () => {
                                    currentTemplateImage.croppedDataURL = reader.result;
                                    currentTemplateImage.cropSettings = {
                                        offsetX: originalCropX,
                                        offsetY: originalCropY,
                                        drawWidth: originalCropWidth,
                                        drawHeight: originalCropHeight,
                                        mode: 'manual'
                                    };
                                    
                                    // Update template preview and gallery
                                    this.updateTemplatePreview();
                                    this.updateTemplateGallery();
                                    
                                    // Close modal
                                    document.getElementById('templateCropModal').style.display = 'none';
                                    this.templateCropData = null;
                                    
                                    this.showToast(`‚úÖ ƒê√£ c·∫Øt ·∫£nh theo template ${config.width}√ó${config.height}${config.unit}`, 'success');
                                };
                                reader.readAsDataURL(blobWithDPI);
                            }
                            
                        } catch (error) {
                            console.error('Error adding DPI metadata to template crop:', error);
                            // Fallback: use original blob without DPI for template
                            const currentTemplateImage = this.templateData.images[this.templateData.currentIndex];
                            if (currentTemplateImage) {
                                const reader = new FileReader();
                                reader.onload = () => {
                                    currentTemplateImage.croppedDataURL = reader.result;
                                    this.updateTemplatePreview();
                                    this.updateTemplateGallery();
                                    document.getElementById('templateCropModal').style.display = 'none';
                                    this.templateCropData = null;
                                    this.showToast(`‚úÖ ƒê√£ c·∫Øt ·∫£nh (kh√¥ng c√≥ DPI metadata)`, 'warning');
                                };
                                reader.readAsDataURL(blob);
                            }
                        }
                        
                        // Only revoke URL if it's a blob URL, not a dataURL
                        if (imageUrl && imageUrl.startsWith('blob:')) {
                            URL.revokeObjectURL(imageUrl);
                        }
                    }, 'image/jpeg', 0.95);
                };
                
                img.src = imageUrl;
                
            } catch (error) {
                console.error('Error cropping template image:', error);
                this.showToast('‚ùå L·ªói khi c·∫Øt ·∫£nh: ' + error.message, 'error');
            }
        }
        
        generateTemplateCropFilename(originalName) {
            const config = this.templateCropData.config;
            const naming = config.naming;
            
            // Define known image extensions
            const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff', 'tif', 'svg', 'ico'];
            
            // Get current extension (if any)
            const lastDotIndex = originalName.lastIndexOf('.');
            let baseName = originalName;
            
            if (lastDotIndex > 0) {
                const originalExt = originalName.substring(lastDotIndex + 1).toLowerCase();
                
                // Only remove extension if it's a known image extension
                if (imageExtensions.includes(originalExt)) {
                    baseName = originalName.substring(0, lastDotIndex);
                    console.log(`Template crop: Removed image extension .${originalExt} from ${originalName}`);
                } else {
                    // Keep the "extension" as part of filename if it's not an image extension
                    baseName = originalName;
                    console.log(`Template crop: Keeping non-image extension .${originalExt} in filename: ${originalName}`);
                }
            }
            
            const extension = '.jpg';
            
            let finalName;
            switch (naming) {
                case 'size_prefix':
                    finalName = `${config.width}x${config.height}_${baseName}${extension}`;
                    break;
                case 'size_suffix':
                    finalName = `${baseName}_${config.width}x${config.height}${extension}`;
                    break;
                case 'original':
                default:
                    finalName = `${baseName}_cropped${extension}`;
                    break;
            }
            
            console.log(`Template crop filename: ${originalName} ‚Üí ${finalName}`);
            return finalName;
        }
        
        skipCurrentTemplateImage() {
            if (this.templateCropData.currentIndex < this.templateCropData.files.length - 1) {
                this.loadImageForTemplateCropping(this.templateCropData.currentIndex + 1);
            } else {
                this.finishTemplateCropping();
            }
        }
        
        async finishTemplateCropping() {
            if (this.templateCropData.croppedImages.length === 0) {
                this.showToast('Kh√¥ng c√≥ ·∫£nh n√†o ƒë∆∞·ª£c c·∫Øt!', 'warning');
                return;
            }
            
            this.hideTemplateCropEditor();
            
            // Download all cropped images
            await this.downloadTemplateCroppedImages();
            
            this.showToast(`üéâ Ho√†n th√†nh! ƒê√£ c·∫Øt ${this.templateCropData.croppedImages.length} ·∫£nh v·ªõi k√≠ch th∆∞·ªõc ch√≠nh x√°c ${this.templateCropData.config.width}√ó${this.templateCropData.config.height} ${this.templateCropData.config.unit}`, 'success');
        }
        
        async downloadTemplateCroppedImages() {
            for (let i = 0; i < this.templateCropData.croppedImages.length; i++) {
                const croppedImage = this.templateCropData.croppedImages[i];
                const url = URL.createObjectURL(croppedImage.blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = croppedImage.filename;
                a.click();
                
                URL.revokeObjectURL(url);
                
                // Small delay between downloads
                if (i < this.templateCropData.croppedImages.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
        }
        
        hideTemplateCropEditor() {
            document.getElementById('templateCropModal').style.display = 'none';
        }

        // Try alternative ZIP creation without JSZip first
        async createSafeZip(files, zipName, comment = 'Safe image archive created by MEU Layout') {
            // For small number of files, offer individual downloads to avoid ZIP security warnings
            if (files.length <= 5) {
                const userChoice = confirm(
                    `‚ö†Ô∏è WINDOWS SECURITY WARNING FIX:\n\n` +
                    `ƒê·ªÉ tr√°nh c·∫£nh b√°o "potentially harmful", b·∫°n c√≥ mu·ªën:\n\n` +
                    `‚úÖ T·∫£i t·ª´ng file ri√™ng l·∫ª (AN TO√ÄN - khuy√™n d√πng)\n` +
                    `‚ùå T·∫£i file ZIP (c√≥ th·ªÉ b·ªã c·∫£nh b√°o b·∫£o m·∫≠t)\n\n` +
                    `Nh·∫•n OK ƒë·ªÉ t·∫£i t·ª´ng file ri√™ng, Cancel ƒë·ªÉ t·∫°o ZIP`
                );
                
                if (userChoice) {
                    // Download individual files
                    await this.downloadIndividualFiles(files);
                    return null; // Signal that individual downloads were used
                }
            }
            
            // Fallback to safer JSZip approach
            return await this.createSaferZip(files, zipName, comment);
        }
        
        // Download files individually to avoid ZIP security warnings
        async downloadIndividualFiles(files) {
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                
                try {
                    let blob;
                    if (file.data instanceof Blob) {
                        blob = file.data;
                    } else if (typeof file.data === 'string') {
                        blob = await this.createSingleFileDownload(file);
                    } else {
                        continue;
                    }
                    
                    // Create individual download
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = file.filename || `image_${i + 1}.jpg`;
                    link.style.display = 'none';
                    
                    document.body.appendChild(link);
                    
                    // Delay between downloads to avoid browser blocking
                    setTimeout(() => {
                        link.click();
                        setTimeout(() => {
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                        }, 100);
                    }, i * 500); // 500ms delay between each download
                    
                } catch (error) {
                    console.error('Error downloading individual file:', error);
                    continue;
                }
            }
            
            // Show success message
            setTimeout(() => {
                this.showToast(`‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu t·∫£i ${files.length} file ri√™ng l·∫ª (tr√°nh c·∫£nh b√°o b·∫£o m·∫≠t)!`, 'success');
            }, 1000);
        }
        
        // Create single file download (bypasses ZIP completely)
        async createSingleFileDownload(file) {
            if (file.data instanceof Blob) {
                return file.data;
            } else if (typeof file.data === 'string') {
                let base64Data = file.data;
                if (base64Data.startsWith('data:')) {
                    const commaIndex = base64Data.indexOf(',');
                    if (commaIndex !== -1) {
                        const mimeType = base64Data.substring(5, commaIndex).split(';')[0];
                        base64Data = base64Data.substring(commaIndex + 1);
                        
                        const byteCharacters = atob(base64Data);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        return new Blob([byteArray], { type: mimeType });
                    }
                }
            }
            throw new Error('Invalid file data');
        }
        
        // Safer ZIP Generation with minimal JSZip usage
        async createSaferZip(files, zipName, comment = 'Safe image archive created by MEU Layout') {
            const zip = new JSZip();
            
            // Add safe comment
            zip.comment = comment;
            
            let validFileCount = 0;
            
            for (const fileData of files) {
                try {
                    const { filename, data, blob } = fileData;
                    
                    // Validate filename
                    if (!filename || filename.trim() === '') {
                        console.warn('Skipping file with empty filename');
                        continue;
                    }
                    
                    // Sanitize filename - remove potentially harmful characters
                    const safeFilename = filename.replace(/[<>:"|?*]/g, '_').replace(/\.\.+/g, '_');
                    
                    // Validate file data
                    if (blob) {
                        // Validate blob size
                        if (blob.size === 0) {
                            console.warn(`Skipping empty file: ${safeFilename}`);
                            continue;
                        }
                        
                        if (blob.size > 50 * 1024 * 1024) { // 50MB limit per file
                            console.warn(`Skipping large file: ${safeFilename}`);
                            continue;
                        }
                        
                        // Add blob to ZIP with proper attributes
                        zip.file(safeFilename, blob, {
                            date: new Date(),
                            createFolders: false,
                            compression: 'DEFLATE',
                            compressionOptions: { level: 6 }
                        });
                        validFileCount++;
                    } else if (data) {
                        // Handle base64 data
                        if (typeof data !== 'string' || data.length === 0) {
                            console.warn(`Skipping invalid data for: ${safeFilename}`);
                            continue;
                        }
                        
                        // Extract base64 data (remove data URL prefix if present)
                        const base64Data = data.includes(',') ? data.split(',')[1] : data;
                        
                        if (!base64Data || base64Data.length === 0) {
                            console.warn(`Skipping empty base64 data for: ${safeFilename}`);
                            continue;
                        }
                        
                        // Add base64 to ZIP with proper attributes
                        zip.file(safeFilename, base64Data, {
                            base64: true,
                            date: new Date(),
                            createFolders: false,
                            compression: 'DEFLATE',
                            compressionOptions: { level: 6 }
                        });
                        validFileCount++;
                    }
                } catch (error) {
                    console.error('Error processing file for ZIP:', error);
                    continue;
                }
            }
            
            if (validFileCount === 0) {
                throw new Error('Kh√¥ng c√≥ file h·ª£p l·ªá ƒë·ªÉ t·∫°o ZIP');
            }
            
            console.log(`Creating ZIP with ${validFileCount} valid files`);
            
            // Generate ZIP with safe options
            const zipBlob = await zip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: { level: 6 },
                mimeType: 'application/zip',
                platform: 'DOS', // More compatible
                streamFiles: false,
                encodeFileName: function(name) {
                    // Ensure safe filename encoding
                    return name;
                }
            });
            
            // Validate generated ZIP
            if (zipBlob.size === 0) {
                throw new Error('Generated ZIP is empty');
            }
            
            if (zipBlob.size > 500 * 1024 * 1024) { // 500MB limit
                throw new Error('Generated ZIP is too large');
            }
            
            console.log(`Generated ZIP size: ${(zipBlob.size / 1024 / 1024).toFixed(2)} MB`);
            
            return zipBlob;
        }
        
        // Ultra-Safe ZIP Download Utility
        downloadSafeZip(zipBlob, filename) {
            // Handle case where individual downloads were used instead of ZIP
            if (!zipBlob) {
                return; // Individual downloads already handled
            }
            // Create the safest possible blob
            const safeBlob = new Blob([zipBlob], { 
                type: 'application/zip'
            });
            
            // Add virus-safe header information  
            const reader = new FileReader();
            reader.onload = () => {
                const arrayBuffer = reader.result;
                const view = new Uint8Array(arrayBuffer);
                
                // Verify ZIP signature
                if (view[0] !== 0x50 || view[1] !== 0x4B) {
                    throw new Error('Invalid ZIP signature');
                }
                
                // Create clean download with safe headers
                const cleanBlob = new Blob([view], {
                    type: 'application/zip, application/x-zip-compressed'
                });
                
                const url = URL.createObjectURL(cleanBlob);
                
                // Create download link with maximum security attributes
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.rel = 'noopener'; // Security attribute
                link.style.display = 'none';
                
                // Add to DOM, click, and clean up
                document.body.appendChild(link);
                link.click();
                
                // Clean up immediately
                setTimeout(() => {
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }, 1000);
            };
            
            reader.readAsArrayBuffer(safeBlob);
        }

        // Gallery Management Methods
        initializeGalleryEventListeners() {
            // Classification mode toggle
            const classifyBtn = document.getElementById('classifyBtn');
            if (classifyBtn) {
                classifyBtn.addEventListener('click', () => this.enterClassificationMode());
            }

            // Auto-classification based on filename
            const autoClassifyBtn = document.getElementById('autoClassifyBtn');
            if (autoClassifyBtn) {
                autoClassifyBtn.addEventListener('click', () => this.autoClassifyByFilename());
            }

            // Clear gallery
            const clearGalleryBtn = document.getElementById('clearGalleryBtn');
            if (clearGalleryBtn) {
                clearGalleryBtn.addEventListener('click', () => this.clearGallery());
            }

            // Exit classification
            const exitClassifyBtn = document.getElementById('exitClassifyBtn');
            if (exitClassifyBtn) {
                exitClassifyBtn.addEventListener('click', () => this.exitClassificationMode());
            }

            // Preview download
            const previewDownloadBtn = document.getElementById('previewDownloadBtn');
            if (previewDownloadBtn) {
                previewDownloadBtn.addEventListener('click', () => this.showDownloadPreview());
            }

            // Modal event listeners (removed - using hover actions now)

            // Download buttons
            const downloadBtns = {
                'downloadAllBtn': () => this.downloadAllImages(),
                'downloadFrontBtn': () => this.downloadFrontImages(),
                'downloadBackBtn': () => this.downloadBackImages(),
                'downloadZipAllBtn': () => this.downloadAllImagesZip(),
                'downloadZipFrontBtn': () => this.downloadFrontImagesZip(),
                'downloadZipBackBtn': () => this.downloadBackImagesZip()
            };

            Object.entries(downloadBtns).forEach(([id, handler]) => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.addEventListener('click', handler);
                }
            });

            // Download settings event listeners
            const saveDownloadSettingsBtn = document.getElementById('saveDownloadSettings');
            if (saveDownloadSettingsBtn) {
                saveDownloadSettingsBtn.addEventListener('click', () => {
                    this.saveDownloadSettings().catch(error => {
                        console.error('L·ªói l∆∞u settings:', error);
                    });
                });
            }

            const useSubfoldersCheckbox = document.getElementById('useSubfolders');
            if (useSubfoldersCheckbox) {
                useSubfoldersCheckbox.addEventListener('change', (e) => {
                    const subfolderSettings = document.getElementById('subfolderSettings');
                    if (subfolderSettings) {
                        subfolderSettings.style.display = e.target.checked ? 'block' : 'none';
                    }
                });
            }
            
            // New individual download buttons for classified images
            const downloadFrontIndividualBtn = document.getElementById('downloadFrontIndividualBtn');
            if (downloadFrontIndividualBtn) {
                downloadFrontIndividualBtn.addEventListener('click', () => this.downloadFrontImagesIndividual());
            }
            
            const downloadBackIndividualBtn = document.getElementById('downloadBackIndividualBtn');
            if (downloadBackIndividualBtn) {
                downloadBackIndividualBtn.addEventListener('click', () => this.downloadBackImagesIndividual());
            }
            
            const downloadAllIndividualBtn = document.getElementById('downloadAllIndividualBtn');
            if (downloadAllIndividualBtn) {
                downloadAllIndividualBtn.addEventListener('click', () => this.downloadAllClassifiedImagesIndividual());
            }

            // Upload button and file input
            const uploadBtn = document.getElementById('uploadBtn');
            const galleryFileInput = document.getElementById('galleryFileInput');
            
            if (uploadBtn && galleryFileInput) {
                uploadBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Immediate visual feedback
                    uploadBtn.style.transform = 'scale(0.95)';
                    // Direct call to maintain user activation
                    galleryFileInput.click();
                    // Reset visual feedback after
                    setTimeout(() => {
                        uploadBtn.style.transform = '';
                    }, 50);
                });
                
                galleryFileInput.addEventListener('change', (e) => {
                    if (e.target.files && e.target.files.length > 0) {
                        this.handleGalleryFileUpload(e.target.files);
                    }
                });
            }

            // Search and filter functionality
            const searchInput = document.getElementById('gallerySearchInput');
            const filterSelect = document.getElementById('galleryFilterSelect');
            
            if (searchInput) {
                searchInput.addEventListener('input', () => this.filterGalleryImages());
            }
            
            if (filterSelect) {
                filterSelect.addEventListener('change', () => this.filterGalleryImages());
            }

            // Prefix input change handlers
            const frontPrefix = document.getElementById('frontPrefix');
            const backPrefix = document.getElementById('backPrefix');
            if (frontPrefix) {
                frontPrefix.addEventListener('input', () => this.updateRenamePatterns());
            }
            if (backPrefix) {
                backPrefix.addEventListener('input', () => this.updateRenamePatterns());
            }

            // Setup drag and drop for classification
            this.setupClassificationDragDrop();
            
            // Quick selection event listeners - Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                console.log('üîç ƒêang t√¨m n√∫t quickSelectFrontBtn...');
                const quickSelectFrontBtn = document.getElementById('quickSelectFrontBtn');
                console.log('üîç T√¨m th·∫•y quickSelectFrontBtn:', !!quickSelectFrontBtn);
                
                if (quickSelectFrontBtn) {
                    console.log('üîç N·ªôi dung text c·ªßa n√∫t:', quickSelectFrontBtn.textContent);
                    console.log('üîç N√∫t b·ªã v√¥ hi·ªáu h√≥a:', quickSelectFrontBtn.disabled);
                    console.log('üîç Thu·ªôc t√≠nh display c·ªßa n√∫t:', quickSelectFrontBtn.style.display);
                    console.log('üîç Ph·∫ßn t·ª≠ cha c·ªßa n√∫t:', quickSelectFrontBtn.parentElement);
                    
                    // Remove any existing listeners first
                    const newFrontBtn = quickSelectFrontBtn.cloneNode(true);
                    quickSelectFrontBtn.parentNode.replaceChild(newFrontBtn, quickSelectFrontBtn);
                    
                    newFrontBtn.addEventListener('click', (event) => {
                        console.log('üî•üî•üî• FRONT BUTTON CLICKED! üî•üî•üî•');
                        console.log('Event:', event);
                        console.log('Button element:', newFrontBtn);
                        console.log('Current state before startQuickSelection:', {
                            selectionMode: this.selectionMode,
                            selectionType: this.selectionType,
                            classificationMode: this.classificationMode
                        });
                        event.preventDefault();
                        event.stopPropagation();
                        this.startQuickSelection('front');
                        console.log('üî•üî•üî• startQuickSelection(front) completed üî•üî•üî•');
                    });
                    console.log('‚úÖ ƒê√£ t√¨m th·∫•y n√∫t ch·ªçn nhanh M·∫∂T TR∆Ø·ªöC v√† th√™m listener');
                } else {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y quickSelectFrontBtn trong DOM');
                    console.log('‚ùå C√°c ph·∫ßn t·ª≠ c√≥ ID t∆∞∆°ng t·ª±:');
                    const similarElements = document.querySelectorAll('[id*="Front"], [id*="front"]');
                    similarElements.forEach(el => {
                        console.log('‚ùå T√¨m th·∫•y ph·∫ßn t·ª≠:', el.id, el.tagName, el.textContent);
                    });
                }
                
                const quickSelectBackBtn = document.getElementById('quickSelectBackBtn');
                if (quickSelectBackBtn) {
                    quickSelectBackBtn.addEventListener('click', () => {
                        console.log('üî• ƒê√£ nh·∫•n n√∫t ch·ªçn nhanh M·∫∂T SAU');
                        this.startQuickSelection('back');
                    });
                    console.log('‚úÖ ƒê√£ t√¨m th·∫•y n√∫t ch·ªçn nhanh M·∫∂T SAU v√† th√™m listener');
                } else {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y quickSelectBackBtn');
                }
                
                const selectAllFrontBtn = document.getElementById('selectAllFrontBtn');
                if (selectAllFrontBtn) {
                    selectAllFrontBtn.addEventListener('click', () => {
                        console.log('üî• ƒê√£ nh·∫•n n√∫t ch·ªçn t·∫•t c·∫£ M·∫∂T TR∆Ø·ªöC');
                        this.selectAllAs('front');
                    });
                    console.log('‚úÖ ƒê√£ t√¨m th·∫•y n√∫t ch·ªçn t·∫•t c·∫£ M·∫∂T TR∆Ø·ªöC v√† th√™m listener');
                } else {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y selectAllFrontBtn');
                }
                
                const selectAllBackBtn = document.getElementById('selectAllBackBtn');
                if (selectAllBackBtn) {
                    selectAllBackBtn.addEventListener('click', () => {
                        console.log('üî• ƒê√£ nh·∫•n n√∫t ch·ªçn t·∫•t c·∫£ M·∫∂T SAU');
                        this.selectAllAs('back');
                    });
                    console.log('‚úÖ ƒê√£ t√¨m th·∫•y n√∫t ch·ªçn t·∫•t c·∫£ M·∫∂T SAU v√† th√™m listener');
                } else {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y selectAllBackBtn');
                }

                // ü§ñ Auto Classify Button
                const autoClassifyBtnDuplex = document.getElementById('autoClassifyBtnDuplex');
                if (autoClassifyBtnDuplex) {
                    autoClassifyBtnDuplex.addEventListener('click', () => {
                        console.log('ü§ñ ƒê√£ nh·∫•n n√∫t t·ª± ƒë·ªông ph√¢n lo·∫°i');
                        this.autoClassifyDuplexImages();
                    });
                    console.log('‚úÖ ƒê√£ t√¨m th·∫•y n√∫t t·ª± ƒë·ªông ph√¢n lo·∫°i v√† th√™m listener');
                } else {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y autoClassifyBtnDuplex');
                }

                // üìÅ Duplex Upload Zone
                const duplexUploadZone = document.getElementById('duplexUploadZone');
                const duplexFileInput = document.getElementById('duplexFileInput');

                if (duplexUploadZone && duplexFileInput) {
                    // Click to upload
                    duplexUploadZone.addEventListener('click', () => {
                        duplexFileInput.click();
                    });

                    // File input change
                    duplexFileInput.addEventListener('change', async (e) => {
                        const files = Array.from(e.target.files);
                        if (files.length > 0) {
                            console.log(`üìÅ Uploading ${files.length} files to duplex gallery...`);
                            await this.handleDuplexUpload(files);
                            duplexFileInput.value = ''; // Reset input
                        }
                    });

                    // Drag & Drop
                    duplexUploadZone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        duplexUploadZone.classList.add('drag-over');
                    });

                    duplexUploadZone.addEventListener('dragleave', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        duplexUploadZone.classList.remove('drag-over');
                    });

                    duplexUploadZone.addEventListener('drop', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        duplexUploadZone.classList.remove('drag-over');

                        const files = Array.from(e.dataTransfer.files).filter(file =>
                            file.type.startsWith('image/')
                        );

                        if (files.length > 0) {
                            console.log(`üìÅ Dropped ${files.length} files to duplex gallery...`);
                            await this.handleDuplexUpload(files);
                        } else {
                            this.showToast('‚ö†Ô∏è Ch·ªâ h·ªó tr·ª£ file ·∫£nh (JPG, PNG, WebP)', 'warning');
                        }
                    });

                    console.log('‚úÖ ƒê√£ kh·ªüi t·∫°o Duplex Upload Zone');
                } else {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y duplexUploadZone ho·∫∑c duplexFileInput');
                }

                const applySelectionBtn = document.getElementById('applySelectionBtn');
                if (applySelectionBtn) {
                    applySelectionBtn.addEventListener('click', (event) => {
                        console.log('üî• ƒê√£ nh·∫•n n√∫t √°p d·ª•ng l·ª±a ch·ªçn!');
                        console.log('Chi ti·∫øt s·ª± ki·ªán:', {
                            target: event.target,
                            currentTarget: event.currentTarget,
                            bubbles: event.bubbles,
                            defaultPrevented: event.defaultPrevented
                        });
                        console.log('Tr·∫°ng th√°i hi·ªán t·∫°i TR∆Ø·ªöC preventDefault:', {
                            selectedImages: this.selectedImages,
                            selectionType: this.selectionType,
                            selectionMode: this.selectionMode,
                            currentTab: this.getCurrentActiveTab()
                        });
                        
                        event.preventDefault();
                        event.stopPropagation();
                        
                        console.log('Tr·∫°ng th√°i hi·ªán t·∫°i SAU preventDefault:', {
                            selectedImages: this.selectedImages,
                            selectionType: this.selectionType,
                            selectionMode: this.selectionMode
                        });
                        
                        this.applySelectionOnly();
                    });
                    console.log('‚úÖ ƒê√£ t√¨m th·∫•y n√∫t √°p d·ª•ng l·ª±a ch·ªçn v√† th√™m listener');
                } else {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y applySelectionBtn');
                }
                
                const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
                if (cancelSelectionBtn) {
                    cancelSelectionBtn.addEventListener('click', () => {
                        console.log('üî• ƒê√£ nh·∫•n n√∫t h·ªßy l·ª±a ch·ªçn');
                        this.cancelSelectionMode();
                    });
                    console.log('‚úÖ ƒê√£ t√¨m th·∫•y n√∫t h·ªßy l·ª±a ch·ªçn v√† th√™m listener');
                } else {
                    console.error('‚ùå Kh√¥ng t√¨m th·∫•y cancelSelectionBtn');
                }
            }, 1000);
        }

        async loadGalleryFromStorage() {
            try {
                // Ch·ªâ s·ª≠ d·ª•ng File System n·∫øu ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o v√† c√≥ quy·ªÅn
                if (this.fileSystemStorage && this.fileSystemStorage.directoryHandle) {
                    const stored = await this.fileSystemStorage.getItem('meu-layout-gallery');
                    return stored || [];
                }

                // M·∫∑c ƒë·ªãnh s·ª≠ d·ª•ng localStorage
                const storedLocal = localStorage.getItem('meu-layout-gallery');
                return storedLocal ? JSON.parse(storedLocal) : [];
            } catch (error) {
                console.error('Error loading gallery from storage:', error);
                // Fallback v·ªÅ localStorage
                try {
                    const storedLocal = localStorage.getItem('meu-layout-gallery');
                    return storedLocal ? JSON.parse(storedLocal) : [];
                } catch (localError) {
                    console.error('Fallback localStorage c≈©ng l·ªói:', localError);
                    return [];
                }
            }
        }

        async saveGalleryToStorage() {
            try {
                // üö´ KI·ªÇM TRA FILE SYSTEM TR∆Ø·ªöC - N·∫øu ƒë√£ c√≥ th√¨ KH√îNG d√πng localStorage
                const hasFileSystemAccess = window.globalDirectoryHandle && window.FileSystemStorage;

                if (hasFileSystemAccess) {
                    console.log('üéØ ƒê√£ c√≥ File System - KH√îNG l∆∞u gallery v√†o localStorage');
                    return; // D·ª™NG LU√îN - Kh√¥ng c·∫ßn l∆∞u gallery v√†o storage n√†o c·∫£
                }

                if (!this.fileSystemStorage) {
                    try {
                        if (typeof window.FileSystemStorage === 'function') {
                            this.fileSystemStorage = new window.FileSystemStorage();
                        } else {
                            console.warn('‚ö†Ô∏è FileSystemStorage kh√¥ng kh·∫£ d·ª•ng, fallback localStorage');
                            // Ch·ªâ fallback khi th·∫≠t s·ª± kh√¥ng c√≥ File System
                            localStorage.setItem('meu-layout-gallery', JSON.stringify(this.galleryImages));
                            return;
                        }
                    } catch (error) {
                        console.error('‚ùå L·ªói kh·ªüi t·∫°o FileSystemStorage, fallback localStorage:', error);
                        // Ch·ªâ fallback khi th·∫≠t s·ª± l·ªói
                        localStorage.setItem('meu-layout-gallery', JSON.stringify(this.galleryImages));
                        return;
                    }
                }

                // Ch·ªâ init n·∫øu ch∆∞a c√≥ permission v√† c√≥ user action
                if (!this.fileSystemStorage.directoryHandle) {
                    console.log('üîê File System ch∆∞a ƒë∆∞·ª£c c·∫•p quy·ªÅn - Ch·ªù user c·∫•p quy·ªÅn');
                    return; // KH√îNG l∆∞u g√¨ c·∫£ khi ch∆∞a c√≥ quy·ªÅn
                }

                await this.fileSystemStorage.setItem('meu-layout-gallery', this.galleryImages);
            } catch (error) {
                console.error('‚ùå Error saving gallery to file system:', error);
                // üö´ KH√îNG FALLBACK V·ªÄ LOCALSTORAGE N·ªÆA ƒë·ªÉ tr√°nh ƒë·∫ßy b·ªô nh·ªõ
                console.log('üö´ ƒê√£ c√≥ File System - KH√îNG fallback v·ªÅ localStorage');
            }
        }

        handleStorageQuotaExceeded() {
            const currentCount = this.galleryImages.length;
            const maxImages = Math.floor(currentCount * 0.7); // Keep 70% of images
            
            const confirmCleanup = confirm(
                `‚ö†Ô∏è B·ªò NH·ªö STORAGE ƒê√É ƒê·∫¶Y!\n\n` +
                `Hi·ªán t·∫°i: ${currentCount} ·∫£nh\n` +
                `ƒê·ªÅ xu·∫•t: Ch·ªâ gi·ªØ l·∫°i ${maxImages} ·∫£nh m·ªõi nh·∫•t\n\n` +
                `B·∫°n c√≥ mu·ªën d·ªçn d·∫πp ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng kh√¥ng?\n` +
                `(C√°c ·∫£nh s·∫Ω b·ªã x√≥a kh·ªèi kho nh∆∞ng v·∫´n c√≥ th·ªÉ t·∫£i l·∫°i)`
            );
            
            if (confirmCleanup) {
                try {
                    // Sort by newest first and keep only the most recent ones
                    this.galleryImages.sort((a, b) => new Date(b.timestamp || 0) - new Date(a.timestamp || 0));
                    this.galleryImages = this.galleryImages.slice(0, maxImages);
                    
                    // Try saving again
                    const dataString = JSON.stringify(this.galleryImages);
                    localStorage.setItem('meu-layout-gallery', dataString);
                    
                    this.updateGalleryDisplay();
                    this.showToast(`‚úÖ ƒê√£ d·ªçn d·∫πp! Gi·ªØ l·∫°i ${maxImages}/${currentCount} ·∫£nh m·ªõi nh·∫•t`, 'success');
                    
                } catch (retryError) {
                    console.error('Still quota exceeded after cleanup:', retryError);
                    this.showToast('‚ö†Ô∏è V·∫´n kh√¥ng ƒë·ªß b·ªô nh·ªõ. H√£y x√≥a th√™m ·∫£nh ho·∫∑c t·∫£i v·ªÅ v√† x√≥a to√†n b·ªô!', 'error');
                }
            } else {
                this.showToast('‚ö†Ô∏è Kh√¥ng th·ªÉ l∆∞u ·∫£nh m·ªõi. Kho ƒë√£ ƒë·∫ßy!', 'error');
            }
        }

        // Prepare image for storage while preserving original dimensions
        async compressImageForStorage(imageData, maxWidth = null, quality = 1.0) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = () => {
                    // Preserve original dimensions - DO NOT resize for storage
                    const { width, height } = img;

                    // Keep original canvas size to preserve exact dimensions
                    canvas.width = width;
                    canvas.height = height;

                    // Enable high quality rendering
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';

                    // Draw at original size to preserve exact dimensions
                    ctx.drawImage(img, 0, 0, width, height);

                    // Convert with maximum quality to preserve 100% original image data
                    const compressedData = canvas.toDataURL('image/jpeg', quality);
                    resolve(compressedData);
                };

                img.src = imageData;
            });
        }

        async addImageToGallery(imageData, filename, isCropped = false) {
            try {
                // üéØ KI·ªÇM TRA FILE SYSTEM - N·∫øu ƒë√£ c√≥ th√¨ KH√îNG l∆∞u gallery metadata
                const hasFileSystemAccess = window.globalDirectoryHandle && window.FileSystemStorage;

                if (hasFileSystemAccess) {
                    console.log('üéØ ƒê√£ c√≥ File System - ·∫¢nh ƒë√£ ƒë∆∞·ª£c l∆∞u v√†o File System, KH√îNG c·∫ßn gallery metadata');
                    this.updateGalleryDisplay(); // Ch·ªâ update UI
                    return; // D·ª™NG LU√îN - Kh√¥ng t·∫°o gallery metadata
                }

                // Store image while preserving original dimensions
                const compressedData = await this.compressImageForStorage(imageData);

                const galleryItem = {
                    id: Date.now() + Math.random(),
                    data: compressedData,
                    filename: filename,
                    originalName: isCropped ? null : filename, // null means uploaded, not cropped
                    timestamp: new Date().toISOString(),
                    size: Math.round(compressedData.length * 0.75), // Approximate size
                    type: isCropped ? 'cropped' : 'uploaded'
                };

                this.galleryImages.push(galleryItem);
                this.saveGalleryToStorage().catch(error => {
                    console.error('L·ªói l∆∞u gallery:', error);
                });
                this.updateGalleryDisplay();
            } catch (error) {
                console.error('Error adding image to gallery:', error);
                this.showToast('L·ªói th√™m ·∫£nh v√†o kho!', 'error');
            }
        }

        // Handle multiple file upload with progress
        async handleGalleryFileUpload(files) {
            const validFiles = [];
            const supportedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
            
            // Filter valid image files
            for (let file of files) {
                if (supportedTypes.includes(file.type.toLowerCase())) {
                    validFiles.push(file);
                } else {
                    this.showToast(`File ${file.name} kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£`, 'error');
                }
            }

            if (validFiles.length === 0) {
                this.showToast('Kh√¥ng c√≥ file h·ª£p l·ªá ƒë·ªÉ t·∫£i l√™n', 'error');
                return;
            }

            // Show progress bar
            const uploadProgress = document.getElementById('uploadProgress');
            const progressFill = document.getElementById('progressFill');
            const progressCount = document.getElementById('progressCount');
            const progressDetails = document.getElementById('progressDetails');
            
            uploadProgress.style.display = 'block';
            progressCount.textContent = `0/${validFiles.length}`;
            progressFill.style.width = '0%';
            progressDetails.textContent = 'B·∫Øt ƒë·∫ßu t·∫£i l√™n...';

            let successCount = 0;
            let errorCount = 0;

            for (let i = 0; i < validFiles.length; i++) {
                const file = validFiles[i];
                
                try {
                    progressDetails.textContent = `ƒêang x·ª≠ l√Ω: ${file.name}`;
                    
                    // Convert file to base64
                    const imageData = await this.fileToBase64(file);
                    
                    // Add to gallery
                    await this.addImageToGallery(imageData, file.name, false);
                    
                    successCount++;
                    
                } catch (error) {
                    console.error(`Error processing file ${file.name}:`, error);
                    errorCount++;
                }

                // Update progress
                const progress = ((i + 1) / validFiles.length) * 100;
                progressFill.style.width = progress + '%';
                progressCount.textContent = `${i + 1}/${validFiles.length}`;
                
                // Small delay to show progress
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Show completion status in progress bar
            progressDetails.textContent = successCount > 0 ?
                `‚úÖ Ho√†n th√†nh! ${successCount} ·∫£nh th√†nh c√¥ng${errorCount > 0 ? `, ${errorCount} l·ªói` : ''}` :
                '‚ùå Kh√¥ng th·ªÉ t·∫£i l√™n ·∫£nh n√†o';

            // Show completion message
            if (successCount > 0) {
                this.showToast(`‚úÖ ƒê√£ t·∫£i l√™n th√†nh c√¥ng ${successCount} ·∫£nh${errorCount > 0 ? `, ${errorCount} ·∫£nh l·ªói` : ''}!`, 'success');
            } else {
                this.showToast('Kh√¥ng th·ªÉ t·∫£i l√™n ·∫£nh n√†o', 'error');
            }

            // Auto-hide progress bar with smooth animation
            setTimeout(() => {
                uploadProgress.style.opacity = '0.5';
                uploadProgress.style.transform = 'translateY(-10px)';
            }, 1500);

            setTimeout(() => {
                uploadProgress.style.display = 'none';
                // Reset styles for next use
                uploadProgress.style.opacity = '1';
                uploadProgress.style.transform = 'translateY(0)';
            }, 2500);

            // Reset file input
            document.getElementById('galleryFileInput').value = '';
        }

        // Convert file to base64
        fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Gallery Management Functions
        renameGalleryItem(imageId) {
            const image = this.galleryImages.find(img => img.id == imageId);
            if (!image) return;

            const newName = prompt('Nh·∫≠p t√™n m·ªõi cho ·∫£nh:', image.filename);
            if (newName && newName.trim() !== '' && newName !== image.filename) {
                // Ensure proper extension
                const extension = image.filename.split('.').pop();
                const finalName = newName.includes('.') ? newName : `${newName}.${extension}`;
                
                image.filename = finalName;
                this.saveGalleryToStorage().catch(error => {
                    console.error('L·ªói l∆∞u gallery:', error);
                });
                this.updateGalleryDisplay();
                this.showToast(`ƒê√£ ƒë·ªïi t√™n th√†nh: ${finalName}`, 'success');
            }
        }

        deleteGalleryItem(imageId) {
            const image = this.galleryImages.find(img => img.id == imageId);
            if (!image) return;

            if (confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ·∫£nh "${image.filename}"?`)) {
                this.galleryImages = this.galleryImages.filter(img => img.id != imageId);
                this.saveGalleryToStorage().catch(error => {
                    console.error('L·ªói l∆∞u gallery:', error);
                });
                this.updateGalleryDisplay();
                this.showToast('ƒê√£ x√≥a ·∫£nh kh·ªèi kho', 'success');
            }
        }

        downloadGalleryItem(imageId) {
            const image = this.galleryImages.find(img => img.id == imageId);
            if (!image) return;

            const link = document.createElement('a');
            link.href = image.data;
            
            // Apply download folder settings for gallery items
            const fileName = this.applyDownloadFolderSettings(image.filename, 'gallery');
            link.download = fileName;
            link.style.display = 'none';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            this.showToast(`ƒê√£ t·∫£i v·ªÅ: ${image.filename}`, 'success');
        }

        updateGalleryDisplay() {
            const galleryGrid = document.getElementById('galleryGrid');
            const galleryCount = document.getElementById('galleryCount');
            const classifyBtn = document.getElementById('classifyBtn');
            const clearGalleryBtn = document.getElementById('clearGalleryBtn');

            // Auto-update duplex grid if in duplex mode (ƒë·ªÉ tr√°nh c·∫ßn reload)
            if (this.printData?.config?.printMode === 'duplex') {
                setTimeout(() => this.updateGalleryGridDuplex(), 50);
            }

            if (!galleryGrid) return;

            // K·∫øt h·ª£p files t·ª´ File System th√†nh gallery images
            const allGalleryImages = [...this.galleryImages];
            if (window.converter && window.converter.files) {
                // Chuy·ªÉn ƒë·ªïi files t·ª´ File System th√†nh gallery format
                const fileSystemImages = window.converter.files
                    .filter(f => f.status === 'success' && f.convertedBlob)
                    .map(f => ({
                        id: 'fs_' + f.id,
                        data: f.convertedBlob,
                        filename: f.name,
                        originalName: f.name,
                        timestamp: new Date().toISOString(),
                        source: 'filesystem'
                    }));
                allGalleryImages.push(...fileSystemImages);
            }

            // Update count v·ªõi total files
            if (galleryCount) {
                galleryCount.textContent = `${allGalleryImages.length} ·∫£nh`;
            }

            // Update button states
            const hasImages = allGalleryImages.length > 0;
            if (classifyBtn) classifyBtn.disabled = !hasImages;
            if (clearGalleryBtn) clearGalleryBtn.disabled = !hasImages;
            
            const autoClassifyBtn = document.getElementById('autoClassifyBtn');
            if (autoClassifyBtn) autoClassifyBtn.disabled = !hasImages;

            // Clear existing content
            galleryGrid.innerHTML = '';

            if (allGalleryImages.length === 0) {
                galleryGrid.innerHTML = `
                    <div class="empty-gallery">
                        <div class="empty-icon">üì∑</div>
                        <div class="empty-text">Ch∆∞a c√≥ ·∫£nh n√†o trong kho</div>
                        <div class="empty-hint">Nh·∫•n "T·∫£i ·∫£nh l√™n" ƒë·ªÉ th√™m ·∫£nh ho·∫∑c s·ª≠ d·ª•ng Template Crop ho·∫∑c File System</div>
                    </div>
                `;
                return;
            }

            // Show loading state for large galleries
            if (allGalleryImages.length > 30) {
                galleryGrid.innerHTML = `
                    <div class="gallery-loading" id="galleryLoading">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">ƒêang t·∫£i ${allGalleryImages.length} ·∫£nh...</div>
                    </div>
                `;

                // Use batch processing for better performance
                requestAnimationFrame(() => {
                    galleryGrid.innerHTML = '';
                    this.renderGalleryWithLazyLoading(galleryGrid, allGalleryImages);
                });
                return;
            }

            // Render gallery items normally for small galleries
            const fragment = document.createDocumentFragment();
            allGalleryImages.forEach((item, index) => {
                const itemEl = this.createGalleryItemOptimized(item, index);
                fragment.appendChild(itemEl);
            });

            galleryGrid.appendChild(fragment);
        }
        
        createGalleryItemOptimized(item, index) {
            const itemEl = document.createElement('div');
            itemEl.className = 'gallery-item';
            itemEl.draggable = true;
            itemEl.dataset.imageId = item.id;
            itemEl.dataset.index = index;

            // Use thumbnail for better performance
            const imageSrc = this.galleryImages.length > 50 ? this.createThumbnail(item.data) : item.data;

            itemEl.innerHTML = `
                <div class="gallery-item-image-container">
                    <img src="${imageSrc}" alt="${item.filename}" class="gallery-item-image" loading="lazy">
                    <div class="selection-checkbox">‚úì</div>
                    <div class="gallery-item-actions">
                        <button class="gallery-action-btn rename-btn" onclick="converter.renameGalleryItem('${item.id}')" title="ƒê·ªïi t√™n">
                            <span>‚úèÔ∏è</span>
                        </button>
                        <button class="gallery-action-btn download-btn" onclick="converter.downloadGalleryItem('${item.id}')" title="T·∫£i v·ªÅ">
                            <span>üì•</span>
                        </button>
                        <button class="gallery-action-btn delete-btn" onclick="converter.deleteGalleryItem('${item.id}')" title="X√≥a">
                            <span>üóëÔ∏è</span>
                        </button>
                    </div>
                </div>
                <div class="gallery-item-info">
                    <div class="gallery-item-name" title="${item.filename}">${item.filename}</div>
                    <div class="gallery-item-details">
                        <span class="gallery-item-size">${this.formatFileSize(item.size)}</span>
                        <span class="gallery-item-type">${item.type === 'cropped' ? 'Crop' : 'Upload'}</span>
                    </div>
                </div>
            `;

            // Add drag event listeners
            itemEl.addEventListener('dragstart', (e) => this.handleGalleryDragStart(e));
            itemEl.addEventListener('dragend', (e) => this.handleGalleryDragEnd(e));
            
            // Add selection mode click listener
            itemEl.addEventListener('click', (e) => this.handleGalleryItemSelection(e, item.id));

            return itemEl;
        }

        formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
            return Math.round(bytes / (1024 * 1024)) + ' MB';
        }
        
        // Performance optimization methods
        renderGalleryWithLazyLoading(galleryGrid, imagesToRender = null) {
            const images = imagesToRender || this.galleryImages;
            const batchSize = 15; // Render 15 items at a time
            let currentBatch = 0;

            const renderBatch = () => {
                const startIndex = currentBatch * batchSize;
                const endIndex = Math.min(startIndex + batchSize, images.length);
                const fragment = document.createDocumentFragment();

                for (let i = startIndex; i < endIndex; i++) {
                    const item = images[i];
                    const itemEl = this.createGalleryItemFast(item, i);
                    fragment.appendChild(itemEl);
                }
                
                galleryGrid.appendChild(fragment);
                currentBatch++;
                
                // Continue rendering if more items exist
                if (endIndex < images.length) {
                    requestAnimationFrame(() => {
                        setTimeout(renderBatch, 10); // Small delay to prevent blocking
                    });
                }
            };
            
            renderBatch();
        }
        
        createGalleryItemFast(item, index) {
            const itemEl = document.createElement('div');
            itemEl.className = 'gallery-item';
            itemEl.draggable = true;
            itemEl.dataset.imageId = item.id;
            itemEl.dataset.index = index;
            
            // Create thumbnail on demand instead of using full image
            const thumbnailSrc = this.createThumbnail(item.data);
            
            itemEl.innerHTML = `
                <div class="gallery-item-image-container">
                    <img src="${thumbnailSrc}" alt="${item.filename}" class="gallery-item-image" loading="lazy">
                    <div class="selection-checkbox">‚úì</div>
                    <div class="gallery-item-actions">
                        <button class="gallery-action-btn rename-btn" onclick="converter.renameGalleryItem('${item.id}')" title="ƒê·ªïi t√™n">
                            <span>‚úèÔ∏è</span>
                        </button>
                        <button class="gallery-action-btn download-btn" onclick="converter.downloadGalleryItem('${item.id}')" title="T·∫£i v·ªÅ">
                            <span>üìÖ</span>
                        </button>
                        <button class="gallery-action-btn delete-btn" onclick="converter.deleteGalleryItem('${item.id}')" title="X√≥a">
                            <span>üóëÔ∏è</span>
                        </button>
                    </div>
                </div>
                <div class="gallery-item-info">
                    <div class="gallery-item-name" title="${item.filename}">${item.filename}</div>
                    <div class="gallery-item-details">
                        <span class="gallery-item-size">${this.formatFileSize(item.size)}</span>
                        <span class="gallery-item-type">${item.type === 'cropped' ? 'C·∫Øt' : 'T·∫£i'}</span>
                    </div>
                </div>
            `;
            
            // Add event listeners
            itemEl.addEventListener('dragstart', (e) => this.handleGalleryDragStart(e));
            itemEl.addEventListener('dragend', (e) => this.handleGalleryDragEnd(e));
            itemEl.addEventListener('click', (e) => this.handleGalleryItemSelection(e, item.id));
            
            return itemEl;
        }
        
        createThumbnail(imageData, maxSize = 150) {
            // Check cache first
            const cacheKey = `thumb_${this.hashString(imageData.substring(0, 100))}`;
            if (this.thumbnailCache.has(cacheKey)) {
                return this.thumbnailCache.get(cacheKey);
            }
            
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = () => {
                    const ratio = Math.min(maxSize / img.width, maxSize / img.height);
                    canvas.width = Math.floor(img.width * ratio);
                    canvas.height = Math.floor(img.height * ratio);
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const thumbnail = canvas.toDataURL('image/jpeg', 1.0);
                    
                    // Cache with size limit
                    if (this.thumbnailCache.size > 200) {
                        const firstKey = this.thumbnailCache.keys().next().value;
                        this.thumbnailCache.delete(firstKey);
                    }
                    this.thumbnailCache.set(cacheKey, thumbnail);
                };
                
                img.src = imageData;
                return imageData; // Return original while thumbnail processes
            } catch (error) {
                return imageData; // Fallback to original
            }
        }
        
        hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash.toString();
        }

        // New method for filtering gallery images
        filterGalleryImages() {
            const searchInput = document.getElementById('gallerySearchInput');
            const filterSelect = document.getElementById('galleryFilterSelect');
            
            if (!searchInput || !filterSelect) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            const filterType = filterSelect.value;
            
            let filteredImages = this.galleryImages;
            
            // Apply type filter
            if (filterType !== 'all') {
                filteredImages = filteredImages.filter(image => {
                    if (filterType === 'uploaded') return image.type === 'uploaded';
                    if (filterType === 'cropped') return image.type === 'cropped';
                    return true;
                });
            }
            
            // Apply search filter
            if (searchTerm) {
                filteredImages = filteredImages.filter(image => 
                    image.filename.toLowerCase().includes(searchTerm)
                );
            }
            
            this.renderFilteredGallery(filteredImages);
        }

        // New method to render filtered results
        renderFilteredGallery(filteredImages) {
            const galleryGrid = document.getElementById('galleryGrid');
            const galleryCount = document.getElementById('galleryCount');
            
            if (!galleryGrid) return;
            
            // Update count display
            if (galleryCount) {
                if (filteredImages.length !== this.galleryImages.length) {
                    galleryCount.textContent = `${filteredImages.length}/${this.galleryImages.length} ·∫£nh`;
                } else {
                    galleryCount.textContent = `${this.galleryImages.length} ·∫£nh`;
                }
            }
            
            galleryGrid.innerHTML = '';
            
            if (filteredImages.length === 0) {
                if (this.galleryImages.length === 0) {
                    galleryGrid.innerHTML = `
                        <div class="empty-gallery">
                            <div class="empty-icon">üì∑</div>
                            <div class="empty-text">Ch∆∞a c√≥ ·∫£nh n√†o trong kho</div>
                            <div class="empty-hint">Nh·∫•n "T·∫£i ·∫£nh l√™n" ƒë·ªÉ th√™m ·∫£nh ho·∫∑c s·ª≠ d·ª•ng Template Crop</div>
                        </div>
                    `;
                } else {
                    galleryGrid.innerHTML = `
                        <div class="empty-gallery">
                            <div class="empty-icon">üîç</div>
                            <div class="empty-text">Kh√¥ng t√¨m th·∫•y ·∫£nh</div>
                            <div class="empty-hint">Th·ª≠ thay ƒë·ªïi t·ª´ kh√≥a t√¨m ki·∫øm ho·∫∑c b·ªô l·ªçc</div>
                        </div>
                    `;
                }
                return;
            }
            
            // Render filtered gallery items
            filteredImages.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'gallery-item';
                itemEl.dataset.imageId = item.id;
                itemEl.draggable = true;
                
                // Add type indicator for better visual distinction
                const typeIndicator = item.type === 'cropped' ? '‚úÇÔ∏è' : 'üì∑';
                
                itemEl.innerHTML = `
                    <div class="gallery-item-image-container">
                        <img src="${item.data}" alt="${item.filename}" class="gallery-item-image" loading="lazy">
                        <div class="gallery-image-tooltip">
                            <img src="${item.data}" alt="${item.filename}" class="tooltip-image">
                            <div class="tooltip-info">
                                <div><strong>${item.filename}</strong></div>
                                <div>${this.formatFileSize(item.size)} ‚Ä¢ ${item.type === 'cropped' ? 'ƒê√£ c·∫Øt' : 'T·∫£i l√™n'}</div>
                                <div style="color: #6b7280; font-size: 0.7rem;">
                                    ${new Date(item.timestamp).toLocaleDateString('vi-VN')}
                                </div>
                            </div>
                        </div>
                        <div class="gallery-item-actions">
                            <button class="gallery-action-btn rename-btn" onclick="converter.renameGalleryItem('${item.id}')" title="ƒê·ªïi t√™n">
                                <span>‚úèÔ∏è</span>
                            </button>
                            <button class="gallery-action-btn download-btn" onclick="converter.downloadGalleryItem('${item.id}')" title="T·∫£i v·ªÅ">
                                <span>üíæ</span>
                            </button>
                            <button class="gallery-action-btn delete-btn" onclick="converter.deleteGalleryItem('${item.id}')" title="X√≥a">
                                <span>üóëÔ∏è</span>
                            </button>
                        </div>
                    </div>
                    <div class="gallery-item-info">
                        <div class="gallery-item-name" title="${item.filename}">${typeIndicator} ${item.filename}</div>
                        <div class="gallery-item-details">
                            <span class="gallery-item-size">${this.formatFileSize(item.size)}</span>
                            <span class="gallery-item-type">${item.type === 'cropped' ? 'ƒê√£ c·∫Øt' : 'T·∫£i l√™n'}</span>
                        </div>
                    </div>
                `;

                // Event listeners
                itemEl.addEventListener('dragstart', (e) => this.handleGalleryDragStart(e));
                itemEl.addEventListener('dragend', (e) => this.handleGalleryDragEnd(e));
                itemEl.addEventListener('click', (e) => this.handleGalleryItemSelection(e, item.id));
                
                galleryGrid.appendChild(itemEl);
            });
        }

        clearGallery() {
            if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ ·∫£nh trong kho?')) {
                this.galleryImages = [];
                this.saveGalleryToStorage().catch(error => {
                    console.error('L·ªói l∆∞u gallery:', error);
                });
                this.updateGalleryDisplay();
                this.showToast('ƒê√£ x√≥a t·∫•t c·∫£ ·∫£nh kh·ªèi kho');
            }
        }

        // Quick Selection Methods
        startQuickSelection(type) {
            console.log('üîçüîçüîç GALLERY startQuickSelection called with type:', type);
            
            if (type === 'front') {
                console.log('üéØ DEBUGGING FRONT SELECTION SPECIFICALLY');
            }
            
            // Auto-enter classification mode if not already in it
            if (!this.classificationMode) {
                console.log('üîç Auto-entering classification mode for quick selection');
                this.enterClassificationMode();
            }
            
            this.selectionMode = true;
            this.selectionType = type;
            this.selectedImages = [];
            console.log('üéØ RESET selectedImages in startQuickSelection');
            
            // Add active-selection class to hide hover actions during selection
            const printContainer = document.querySelector('.print-container');
            if (printContainer) {
                printContainer.classList.add('active-selection');
            }
            
            console.log('üîç GALLERY Selection mode state AFTER setting:', {
                selectionMode: this.selectionMode,
                selectionType: this.selectionType,
                selectedImages: this.selectedImages,
                classificationMode: this.classificationMode,
                galleryImagesCount: this.galleryImages?.length
            });
            
            // Update UI
            console.log('üîç Calling updateSelectionUI...');
            this.updateSelectionUI();
            
            // Force refresh source grid to ensure visual effects work
            console.log('üîç GALLERY Updating source grid...');
            this.updateSourceGrid();
            console.log('üîç Calling updateSourceGridSelectionMode...');
            this.updateSourceGridSelectionMode();
            
            // Show status
            const typeText = type === 'front' ? 'M·∫∑t Tr∆∞·ªõc' : 'M·∫∑t Sau';
            this.showToast(`üéØ üìÇ KHO ·∫¢NH: Ch·∫ø ƒë·ªô ch·ªçn ${typeText} ƒë√£ b·∫≠t! Click ·∫£nh ƒë·ªÉ ch·ªçn, sau ƒë√≥ nh·∫•n "üìÇ Kho: √Åp d·ª•ng".`, 'info');
            
            if (type === 'front') {
                console.log('üéØ FRONT SELECTION SETUP COMPLETED');
            }
        }
        
        exitSelectionMode() {
            // Apply selection if there are selected images
            if (this.selectedImages.length > 0) {
                const typeText = this.selectionType === 'front' ? 'M·∫∑t Tr∆∞·ªõc' : 'M·∫∑t Sau';
                const confirmApply = confirm(`√Åp d·ª•ng ${this.selectedImages.length} ·∫£nh ƒë√£ ch·ªçn l√†m ${typeText}?`);
                
                if (confirmApply) {
                    this.applySelection();
                }
            }
            
            // Reset selection state
            this.selectionMode = false;
            this.selectionType = null;
            this.selectedImages = [];
            
            // Update UI
            this.updateSelectionUI();
            this.updateSourceGridSelectionMode();
            
            this.showToast('ƒê√£ tho√°t ch·∫ø ƒë·ªô ch·ªçn', 'success');
        }
        
        applySelectionOnly() {
            console.log('üîç applySelectionOnly called');
            console.log('Selected images:', this.selectedImages);
            console.log('Selection type:', this.selectionType);
            console.log('Current tab:', this.getCurrentActiveTab());
            console.log('Classification mode:', this.classificationMode);
            
            if (this.selectedImages.length === 0) {
                this.showToast('‚ö†Ô∏è Ch∆∞a ch·ªçn ·∫£nh n√†o ƒë·ªÉ √°p d·ª•ng!', 'error');
                return;
            }
            
            const typeText = this.selectionType === 'front' ? 'M·∫∑t Tr∆∞·ªõc' : 'M·∫∑t Sau';
            const selectedCount = this.selectedImages.length;
            const currentSelectionType = this.selectionType; // Store before reset
            
            console.log('üîÑ About to apply selection:', selectedCount, 'images as', typeText);
            
            // Apply selection to classification system
            this.applySelection();
            
            // Update UI immediately
            this.updateClassificationDisplay();
            
            console.log('‚úÖ Selection applied successfully');
            
            // Reset selection state after applying
            this.selectionMode = false;
            this.selectionType = null;
            this.selectedImages = [];
            console.log('üîÑ Selection state reset after apply');
            
            // Remove active-selection class to show hover actions again
            const printContainer = document.querySelector('.print-container');
            if (printContainer) {
                printContainer.classList.remove('active-selection');
            }
            
            // Update UI
            this.updateSelectionUI();
            this.updateSourceGridSelectionMode();
            
            this.showToast(`‚úÖ ƒê√£ √°p d·ª•ng ${selectedCount} ·∫£nh l√†m ${typeText}!`, 'success');
        }

        applyDuplexClassification() {
            if (this.selectedImages.length === 0) {
                this.showToast('Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 ·∫£nh', 'warning');
                return;
            }

            const type = this.selectionType;
            const targetArray = type === 'front' ? this.printData.frontImages : this.printData.backImages;
            
            // Add selected images to classification
            this.selectedImages.forEach(imageData => {
                // Check if already classified
                const existsInFront = this.printData.frontImages.some(img => img.id === imageData.id);
                const existsInBack = this.printData.backImages.some(img => img.id === imageData.id);
                
                if (!existsInFront && !existsInBack) {
                    targetArray.push({
                        id: imageData.id,
                        src: imageData.data,
                        name: imageData.filename,
                        file: imageData.file || null
                    });
                }
            });

            const selectedCount = this.selectedImages.length;
            const typeText = type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau';
            
            // Reset selection state
            this.selectionMode = false;
            this.selectionType = null;
            this.selectedImages = [];
            
            // Update UI
            this.updateClassificationUI();
            this.updateSourceGridSelectionMode();
            this.updateDuplexStats();
            this.updateClassificationDisplay();
            this.updateDuplexPreview();
            
            this.showToast(`‚úÖ ƒê√£ ph√¢n lo·∫°i ${selectedCount} ·∫£nh l√†m ${typeText}!`, 'success');
        }
        
        applyDuplexClassificationAuto() {
            // Auto-apply for immediate feedback in duplex mode
            if (!this.selectionType) return;
            
            const type = this.selectionType;
            const targetArray = type === 'front' ? this.printData.frontImages : this.printData.backImages;
            
            // Process each selected image immediately
            if (this.selectedImages.length > 0) {
                const lastImage = this.selectedImages[this.selectedImages.length - 1];
                
                // Check if already classified
                const existsInFront = this.printData.frontImages.some(img => img.id === lastImage.id);
                const existsInBack = this.printData.backImages.some(img => img.id === lastImage.id);
                
                if (!existsInFront && !existsInBack) {
                    targetArray.push({
                        id: lastImage.id,
                        src: lastImage.data,
                        name: lastImage.filename,
                        file: lastImage.file || null
                    });
                    
                    const typeText = type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau';
                    this.showToast(`üìå ƒê√£ th√™m v√†o ${typeText}`, 'success');
                } else {
                    this.showToast('·∫¢nh ƒë√£ ƒë∆∞·ª£c ph√¢n lo·∫°i tr∆∞·ªõc ƒë√≥', 'info');
                }
            }
            
            // Update UI immediately
            this.updateClassificationDisplay();
            this.updateDuplexStats();
            this.updateDuplexPreview();
            
            // Update printData.selectedImages with all classified images for preview
            this.updatePrintDataSelectedImages();
            
            // Clear current selection but keep selection mode active
            this.selectedImages = [];
            this.updateSourceGridSelectionMode();
        }
        
        updatePrintDataSelectedImages() {
            // Combine all classified images into selectedImages for preview
            if (this.printData.config.printMode === 'duplex') {
                const allClassifiedImages = [];
                
                // Add front images
                this.printData.frontImages.forEach(img => {
                    // Ki·ªÉm tra ƒë·ªÉ tr√°nh l·ªói undefined
                    if (img && img.src && img.name) {
                        allClassifiedImages.push({
                            id: img.id,
                            name: img.name,
                            data: img.src,  // img.src ch·ª©a base64 data
                            file: img.file
                        });
                    } else {
                        console.warn('Invalid front image data:', img);
                    }
                });
                
                // Add back images
                this.printData.backImages.forEach(img => {
                    // Ki·ªÉm tra ƒë·ªÉ tr√°nh l·ªói undefined
                    if (img && img.src && img.name) {
                        allClassifiedImages.push({
                            id: img.id,
                            name: img.name,
                            data: img.src,  // img.src ch·ª©a base64 data
                            file: img.file
                        });
                    } else {
                        console.warn('Invalid back image data:', img);
                    }
                });
                
                console.log('üìä Updated printData.selectedImages with', allClassifiedImages.length, 'classified images');
                
                // Update printData.selectedImages
                this.printData.selectedImages = allClassifiedImages;
                
                // Update display and preview
                this.updateSelectedImagesDisplay();
                this.updateTotalPages();
                this.updatePreview();
            }
        }
        
        cancelSelectionMode() {
            // Reset selection state without applying
            this.selectionMode = false;
            this.selectionType = null;
            this.selectedImages = [];
            
            // Remove active-selection class to show hover actions again
            const printContainer = document.querySelector('.print-container');
            if (printContainer) {
                printContainer.classList.remove('active-selection');
            }
            
            // Update UI
            this.updateSelectionUI();
            this.updateSourceGridSelectionMode();
            
            this.showToast('üö´ ƒê√£ h·ªßy ch·∫ø ƒë·ªô ch·ªçn', 'info');
        }
        
        handleGalleryItemSelection(event, imageId) {
            // Only handle clicks in selection mode
            if (!this.selectionMode) return;
            
            // Prevent event bubbling
            event.preventDefault();
            event.stopPropagation();
            
            // For duplex classification, we need image objects, not just IDs
            if (this.printData.config.printMode === 'duplex' && this.selectionType) {
                this.handleDuplexImageSelection(imageId);
            } else {
                // Original logic for gallery classification
                const isSelected = this.selectedImages.includes(imageId);
                
                if (isSelected) {
                    this.selectedImages = this.selectedImages.filter(id => id !== imageId);
                } else {
                    this.selectedImages.push(imageId);
                }
            }
            
            // Update visual feedback
            this.updateSourceGridSelectionMode();
            this.updateSelectionCounter();
        }

        handleDuplexImageSelection(imageId) {
            // Find the image object in gallery
            const imageObj = this.galleryImages.find(img => img.id == imageId);
            if (!imageObj) return;
            
            // For duplex classification, store consistent data format (objects)
            const isSelected = this.selectedImages.some(img => 
                (typeof img === 'object' ? img.id : img) == imageId
            );
            
            if (isSelected) {
                this.selectedImages = this.selectedImages.filter(img => 
                    (typeof img === 'object' ? img.id : img) != imageId
                );
            } else {
                this.selectedImages.push(imageObj);
            }
            
            // Auto-apply selection for better UX in duplex mode
            this.applyDuplexClassificationAuto();
        }
        
        handleSourceGridItemSelection(event, imageId) {
            console.log('handleSourceGridItemSelection called with:', { imageId, selectionMode: this.selectionMode });
            
            // Only handle clicks in selection mode
            if (!this.selectionMode) {
                console.log('Not in selection mode, ignoring click');
                return;
            }
            
            // Prevent event bubbling
            event.preventDefault();
            event.stopPropagation();
            
            console.log('Source grid item clicked:', imageId, 'Selection mode:', this.selectionMode, 'Print mode:', this.printData?.config?.printMode);
            
            console.log('üéØ About to check selection logic');
            console.log('üéØ Current selectedImages:', this.selectedImages);
            console.log('üéØ ImageId to check:', imageId);
            
            // Regular gallery selection logic for classification mode
            const isSelected = this.selectedImages.includes(imageId);
            console.log('üéØ Is image already selected?', isSelected);
            
            if (isSelected) {
                console.log('üéØ DESELECTING image:', imageId);
                this.selectedImages = this.selectedImages.filter(id => id !== imageId);
                console.log('Deselected image:', imageId);
            } else {
                console.log('üéØ SELECTING image:', imageId);
                this.selectedImages.push(imageId);
                console.log('Selected image:', imageId);
            }
            
            console.log('Selected images after toggle:', this.selectedImages);
            console.log('üéØ Selection toggle completed');
            
            // Update visual feedback
            this.updateSourceGridSelectionMode();
            this.updateSelectionCounter();
            
            // CRITICAL: Update selection UI to show/hide Apply button
            this.updateSelectionUI();
            
            // Show current selection status
            const typeText = this.selectionType === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau';
            const currentTab = this.getCurrentActiveTab();
            
            if (this.selectedImages.length > 0) {
                // Auto-apply for duplex mode, manual apply for gallery mode
                if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                    this.showToast(`üìå ƒê√£ ch·ªçn ${this.selectedImages.length} ·∫£nh l√†m ${typeText}. Click "‚ùå Tho√°t ch·∫ø ƒë·ªô ch·ªçn" ƒë·ªÉ ho√†n t·∫•t!`, 'info');
                } else {
                    this.showToast(`üìå ƒê√£ ch·ªçn ${this.selectedImages.length} ·∫£nh l√†m ${typeText}. Click "‚úÖ √Åp d·ª•ng l·ª±a ch·ªçn" ƒë·ªÉ ho√†n t·∫•t!`, 'info');
                }
            } else {
                this.showToast(`üîÑ Ch·∫ø ƒë·ªô ch·ªçn ${typeText} - Click ·∫£nh ƒë·ªÉ ch·ªçn`, 'info');
            }
        }

        async handleDuplexUpload(files) {
            console.log(`üìÅ handleDuplexUpload called with ${files.length} files`);

            if (!files || files.length === 0) {
                return;
            }

            let uploadedCount = 0;
            const totalFiles = files.length;

            // Show loading toast
            this.showToast(`üì§ ƒêang t·∫£i ${totalFiles} ·∫£nh...`, 'info');

            for (const file of files) {
                if (!file.type.startsWith('image/')) {
                    console.warn(`‚ö†Ô∏è Skipping non-image file: ${file.name}`);
                    continue;
                }

                try {
                    const reader = new FileReader();
                    await new Promise((resolve, reject) => {
                        reader.onload = async (e) => {
                            try {
                                await this.addImageToGallery(e.target.result, file.name, false);
                                uploadedCount++;
                                console.log(`‚úÖ Uploaded ${uploadedCount}/${totalFiles}: ${file.name}`);
                                resolve();
                            } catch (error) {
                                console.error(`‚ùå Error adding to gallery: ${file.name}`, error);
                                reject(error);
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                } catch (error) {
                    console.error(`‚ùå Error processing file: ${file.name}`, error);
                }
            }

            // Update duplex UI
            this.updateGalleryGridDuplexV2();

            // Show success toast
            if (uploadedCount > 0) {
                this.showToast(`‚úÖ ƒê√£ t·∫£i ${uploadedCount} ·∫£nh v√†o kho!`, 'success');
                console.log(`‚úÖ Duplex upload complete: ${uploadedCount}/${totalFiles} files`);
            } else {
                this.showToast('‚ùå Kh√¥ng th·ªÉ t·∫£i ·∫£nh n√†o!', 'error');
            }
        }

        autoClassifyDuplexImages() {
            console.log('ü§ñ Starting auto-classification...');

            if (this.printData.config.printMode !== 'duplex') {
                this.showToast('‚ö†Ô∏è Ch·ª©c nƒÉng n√†y ch·ªâ d√πng trong ch·∫ø ƒë·ªô In 2 m·∫∑t!', 'warning');
                return;
            }

            if (!this.galleryImages || this.galleryImages.length === 0) {
                this.showToast('‚ö†Ô∏è Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ ph√¢n lo·∫°i!', 'warning');
                return;
            }

            // Regex patterns ƒë·ªÉ nh·∫≠n di·ªán
            const patterns = {
                front: [
                    /m[·∫∑a]t\s*tr[∆∞∆°u][·ªõo]c/i,           // m·∫∑t tr∆∞·ªõc, mat truoc
                    /front/i,                           // front
                    /(\d+)[_\s\-]*a\b/i,               // 1a, 2a, 3a...
                    /m[·∫´a]u\s*(\d+)[_\s]*tr[∆∞∆°u][·ªõo]c/i, // m·∫´u 1 tr∆∞·ªõc
                    /tr[∆∞∆°u][·ªõo]c[_\s]*(\d+)/i,        // tr∆∞·ªõc 1, truoc 1
                    /\bmt\b/i,                          // MT (m·∫∑t tr∆∞·ªõc)
                    /\bF\b/i,                           // F
                    /_front\./i,                        // _front.jpg
                    /\-front\./i,                       // -front.jpg
                ],
                back: [
                    /m[·∫∑a]t\s*sau/i,                   // m·∫∑t sau, mat sau
                    /back/i,                            // back
                    /(\d+)[_\s\-]*b\b/i,               // 1b, 2b, 3b...
                    /m[·∫´a]u\s*(\d+)[_\s]*sau/i,        // m·∫´u 1 sau
                    /sau[_\s]*(\d+)/i,                 // sau 1
                    /\bms\b/i,                          // MS (m·∫∑t sau)
                    /\bB\b/i,                           // B
                    /_back\./i,                         // _back.jpg
                    /\-back\./i,                        // -back.jpg
                ]
            };

            let frontCount = 0;
            let backCount = 0;
            let unclassifiedCount = 0;

            // Clear existing classification
            this.printData.frontImages = [];
            this.printData.backImages = [];

            // Classify each image
            this.galleryImages.forEach(image => {
                const filename = image.filename || image.originalName || '';
                console.log(`üîç Checking file: ${filename}`);

                let classified = false;

                // Check front patterns
                for (const pattern of patterns.front) {
                    if (pattern.test(filename)) {
                        console.log(`‚úÖ FRONT matched: ${filename} with pattern ${pattern}`);
                        this.printData.frontImages.push(image);
                        frontCount++;
                        classified = true;
                        break;
                    }
                }

                // Check back patterns (only if not already classified as front)
                if (!classified) {
                    for (const pattern of patterns.back) {
                        if (pattern.test(filename)) {
                            console.log(`‚úÖ BACK matched: ${filename} with pattern ${pattern}`);
                            this.printData.backImages.push(image);
                            backCount++;
                            classified = true;
                            break;
                        }
                    }
                }

                if (!classified) {
                    console.log(`‚ö†Ô∏è Unclassified: ${filename}`);
                    unclassifiedCount++;
                }
            });

            // Save history
            this.saveDuplexHistory();

            // Update UI
            this.updateDuplexStats();
            this.updateClassificationDisplay();
            this.updateGalleryGridDuplexV2();

            // Render canvases
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');

            // Show results
            const message = `ü§ñ ƒê√£ ph√¢n lo·∫°i t·ª± ƒë·ªông:\n‚úÖ M·∫∑t tr∆∞·ªõc: ${frontCount}\n‚úÖ M·∫∑t sau: ${backCount}${unclassifiedCount > 0 ? `\n‚ö†Ô∏è Ch∆∞a ph√¢n lo·∫°i: ${unclassifiedCount}` : ''}`;
            this.showToast(message, frontCount > 0 || backCount > 0 ? 'success' : 'warning');

            console.log('ü§ñ Auto-classification completed:', {
                front: frontCount,
                back: backCount,
                unclassified: unclassifiedCount
            });
        }

        selectAllAs(type) {
            // Only work in classification mode
            if (!this.classificationMode) {
                this.showToast('‚ö†Ô∏è Ch·ª©c nƒÉng n√†y ch·ªâ ho·∫°t ƒë·ªông trong ch·∫ø ƒë·ªô ph√¢n lo·∫°i!', 'error');
                return;
            }

            if (this.galleryImages.length === 0) {
                this.showToast('Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ ch·ªçn', 'error');
                return;
            }
            
            const typeText = type === 'front' ? 'M·∫∑t Tr∆∞·ªõc' : 'M·∫∑t Sau';
            const confirmAll = confirm(`ƒê·∫∑t t·∫•t c·∫£ ${this.galleryImages.length} ·∫£nh l√†m ${typeText}?`);
            
            if (confirmAll) {
                // Apply to all images directly in classification system
                this.galleryImages.forEach(image => {
                    this.moveImageToClassification(image.id, type);
                });
                
                // Update classification UI
                this.updateClassificationDisplay();
                
                this.showToast(`‚úÖ ƒê√£ ƒë·∫∑t t·∫•t c·∫£ ${this.galleryImages.length} ·∫£nh l√†m ${typeText}`, 'success');
            }
        }
        
        applySelection() {
            console.log('üîç applySelection called');
            console.log('Selected images to apply:', this.selectedImages);
            console.log('Selection type:', this.selectionType);
            
            if (this.selectedImages.length === 0) return;
            
            const currentTab = this.getCurrentActiveTab();
            console.log('Current tab context:', currentTab);
            console.log('Print mode:', this.printData?.config?.printMode);
            
            // Apply selection to appropriate classification system
            this.selectedImages.forEach(imageId => {
                console.log('Moving image to classification:', imageId, this.selectionType);
                this.moveImageToClassification(imageId, this.selectionType);
            });
            
            // Update appropriate UI
            if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                // Update duplex UI
                console.log('Updating duplex UI');
                this.updateClassificationDisplay();
                this.updateDuplexPreview();
                this.updateDuplexStats();
                this.updateDuplexDistributionStats();
            } else {
                // Update gallery UI
                console.log('Updating gallery UI');
                this.updateClassificationDisplay();
            }
            
            const typeText = this.selectionType === 'front' ? 'M·∫∑t Tr∆∞·ªõc' : 'M·∫∑t Sau';
            this.showToast(`‚úÖ ƒê√£ √°p d·ª•ng ${this.selectedImages.length} ·∫£nh l√†m ${typeText}`, 'success');
            
            console.log('‚úÖ applySelection completed');
        }
        
        updateSelectionUI() {
            console.log('updateSelectionUI called');
            
            const selectionStatus = document.getElementById('selectionStatus');
            const selectionType = document.getElementById('selectionType');
            
            const quickSelectFrontBtn = document.getElementById('quickSelectFrontBtn');
            const quickSelectBackBtn = document.getElementById('quickSelectBackBtn');
            const applySelectionBtn = document.getElementById('applySelectionBtn');
            const cancelSelectionBtn = document.getElementById('cancelSelectionBtn');
            
            console.log('UI elements found:', {
                selectionStatus: !!selectionStatus,
                selectionType: !!selectionType,
                quickSelectFrontBtn: !!quickSelectFrontBtn,
                quickSelectBackBtn: !!quickSelectBackBtn,
                applySelectionBtn: !!applySelectionBtn,
                cancelSelectionBtn: !!cancelSelectionBtn
            });
            
            if (this.selectionMode) {
                // Show selection status
                if (selectionStatus) selectionStatus.style.display = 'flex';
                
                // Only show Apply button if there are selected images
                if (applySelectionBtn) {
                    applySelectionBtn.style.display = this.selectedImages.length > 0 ? 'inline-flex' : 'none';
                    console.log(`Apply button display: ${this.selectedImages.length > 0 ? 'show' : 'hide'} (${this.selectedImages.length} images selected)`);
                }
                
                if (cancelSelectionBtn) cancelSelectionBtn.style.display = 'inline-flex';
                
                // Update selection type text
                const typeText = this.selectionType === 'front' ? 'M·∫∑t Tr∆∞·ªõc' : 'M·∫∑t Sau';
                if (selectionType) selectionType.textContent = typeText;
                
                // Update button states
                if (quickSelectFrontBtn) {
                    quickSelectFrontBtn.classList.toggle('active', this.selectionType === 'front');
                }
                if (quickSelectBackBtn) {
                    quickSelectBackBtn.classList.toggle('active', this.selectionType === 'back');
                }
                
                this.updateSelectionCounter();
            } else {
                // Hide selection controls
                if (selectionStatus) selectionStatus.style.display = 'none';
                if (applySelectionBtn) applySelectionBtn.style.display = 'none';
                if (cancelSelectionBtn) cancelSelectionBtn.style.display = 'none';
                
                // Reset button states
                if (quickSelectFrontBtn) quickSelectFrontBtn.classList.remove('active');
                if (quickSelectBackBtn) quickSelectBackBtn.classList.remove('active');
            }
        }
        
        updateSelectionCounter() {
            const selectionCounter = document.getElementById('selectionCounter');
            if (selectionCounter && this.selectionMode) {
                selectionCounter.textContent = `(${this.selectedImages.length} ·∫£nh ƒë√£ ch·ªçn)`;
            }
        }
        
        updateSourceGridSelectionMode() {
            console.log('üîçüîçüîç updateSourceGridSelectionMode called', {
                selectionMode: this.selectionMode,
                selectionType: this.selectionType,
                selectedImages: this.selectedImages
            });
            
            if (this.selectionType === 'front') {
                console.log('üéØüéØüéØ FRONT SELECTION MODE - updateSourceGridSelectionMode');
            }
            
            const sourceGrid = document.getElementById('sourceGrid');
            if (!sourceGrid) {
                console.error('‚ùå Kh√¥ng t√¨m th·∫•y sourceGrid');
                return;
            }
            
            console.log('‚úÖ ƒê√£ t√¨m th·∫•y sourceGrid:', sourceGrid);
            
            const galleryItems = sourceGrid.querySelectorAll('.gallery-item');
            console.log('‚úÖ T√¨m th·∫•y c√°c gallery items trong source grid:', galleryItems.length);
            
            galleryItems.forEach((item, index) => {
                const imageId = item.dataset.imageId;
                console.log(`üîÑ ƒêang x·ª≠ l√Ω item ${index}:`, {
                    imageId,
                    hasSelectionCheckbox: !!item.querySelector('.selection-checkbox'),
                    currentClasses: item.className
                });
                
                if (this.selectionMode) {
                    // Add selection mode class
                    item.classList.add('selection-mode');
                    
                    // For duplex mode, check selection differently (objects vs IDs)
                    let isSelected = false;
                    if (this.printData?.config?.printMode === 'duplex') {
                        isSelected = this.selectedImages.some(img => 
                            (typeof img === 'object' ? img.id : img) == imageId
                        );
                    } else {
                        isSelected = this.selectedImages.includes(imageId);
                    }
                    console.log(`Item ${imageId} is selected:`, isSelected);
                    
                    if (isSelected) {
                        const selectionClass = this.selectionType === 'front' ? 'selected-front' : 'selected-back';
                        item.classList.add(selectionClass);
                        
                        // Remove other selection class
                        const otherClass = this.selectionType === 'front' ? 'selected-back' : 'selected-front';
                        item.classList.remove(otherClass);
                        
                        console.log(`Added class ${selectionClass} to item ${imageId}`);
                    } else {
                        item.classList.remove('selected-front', 'selected-back');
                    }
                    
                    console.log(`Item ${imageId} final classes:`, item.className);
                } else {
                    // Remove all selection classes
                    item.classList.remove('selection-mode', 'selected-front', 'selected-back');
                }
            });
        }

        enterClassificationMode() {
            console.log('üîçüîçüîç enterClassificationMode called');
            
            this.classificationMode = true;
            this.frontImages = [];
            this.backImages = [];
            
            console.log('üîç Classification mode state set:', {
                classificationMode: this.classificationMode,
                frontImages: this.frontImages,
                backImages: this.backImages
            });

            // Show classification UI
            const galleryGrid = document.getElementById('galleryGrid');
            const classificationMode = document.getElementById('classificationMode');
            const downloadOptions = document.getElementById('downloadOptions');
            
            console.log('üîç UI elements found:', {
                galleryGrid: !!galleryGrid,
                classificationMode: !!classificationMode,
                downloadOptions: !!downloadOptions
            });
            
            if (galleryGrid) galleryGrid.style.display = 'none';
            if (classificationMode) classificationMode.style.display = 'block';
            if (downloadOptions) downloadOptions.style.display = 'block';

            // Populate source grid
            console.log('üîç Calling updateSourceGrid from enterClassificationMode...');
            this.updateSourceGrid();
            console.log('üîç Calling updateClassificationPanels from enterClassificationMode...');
            this.updateClassificationPanels();
            console.log('üîç Calling updateDownloadButtons from enterClassificationMode...');
            this.updateDownloadButtons();
            
            console.log('‚úÖ enterClassificationMode completed');
        }

        // Auto-classify images based on filename patterns
        autoClassifyByFilename() {
            console.log('ü§ñ Starting auto-classification by filename...');

            if (!this.galleryImages || this.galleryImages.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ ph√¢n lo·∫°i!', 'warning');
                return;
            }

            // Enter classification mode if not already active
            if (!this.classificationMode) {
                this.enterClassificationMode();
            }

            let frontCount = 0;
            let backCount = 0;
            let unclassified = 0;

            // Reset arrays
            this.frontImages = [];
            this.backImages = [];

            // Process each image
            this.galleryImages.forEach(image => {
                const filename = image.originalName || image.name || '';
                const classification = this.detectFilenamePattern(filename);

                console.log(`üìã File: ${filename} -> ${classification}`);

                if (classification === 'front') {
                    this.frontImages.push(image);
                    frontCount++;
                } else if (classification === 'back') {
                    this.backImages.push(image);
                    backCount++;
                } else {
                    unclassified++;
                }
            });

            // Update UI
            this.updateClassificationPanels();
            this.updateDownloadButtons();

            // Show results
            const message = `ü§ñ Ph√¢n lo·∫°i t·ª± ƒë·ªông ho√†n th√†nh:
                üìÇ M·∫∑t tr∆∞·ªõc: ${frontCount} ·∫£nh
                üìÇ M·∫∑t sau: ${backCount} ·∫£nh
                ‚ùì Kh√¥ng nh·∫≠n di·ªán: ${unclassified} ·∫£nh`;
            
            this.showToast(message, 'success', 4000);
            
            console.log('‚úÖ Auto-classification completed', {
                front: frontCount,
                back: backCount,
                unclassified: unclassified
            });
        }

        // Detect filename pattern for front/back classification
        detectFilenamePattern(filename) {
            if (!filename) return 'unknown';
            
            const lowerName = filename.toLowerCase();
            
            // Front patterns (m·∫∑t tr∆∞·ªõc, front, truoc, mat truoc, etc.)
            const frontPatterns = [
                /m·∫∑t\s*tr∆∞·ªõc/i,
                /mat\s*truoc/i,
                /front/i,
                /truoc/i,
                /ph·∫£i/i,
                /phai/i,
                /tr∆∞·ªõc/i,
                /_mt_/i,        // _mt_ abbreviation
                /_front_/i,     // _front_
                /_f_/i,         // _f_
                /\bm·∫∑t\s*1\b/i, // m·∫∑t 1
                /\bmat\s*1\b/i  // mat 1
            ];

            // Back patterns (m·∫∑t sau, back, sau, mat sau, etc.)  
            const backPatterns = [
                /m·∫∑t\s*sau/i,
                /mat\s*sau/i,
                /back/i,
                /sau/i,
                /tr√°i/i,
                /trai/i,
                /_ms_/i,        // _ms_ abbreviation
                /_back_/i,      // _back_
                /_b_/i,         // _b_
                /\bm·∫∑t\s*2\b/i, // m·∫∑t 2
                /\bmat\s*2\b/i  // mat 2
            ];

            // Check front patterns
            for (const pattern of frontPatterns) {
                if (pattern.test(lowerName)) {
                    return 'front';
                }
            }

            // Check back patterns
            for (const pattern of backPatterns) {
                if (pattern.test(lowerName)) {
                    return 'back';
                }
            }

            return 'unknown';
        }

        exitClassificationMode() {
            this.classificationMode = false;

            // Hide classification UI
            document.getElementById('galleryGrid').style.display = 'grid';
            document.getElementById('classificationMode').style.display = 'none';
            document.getElementById('downloadOptions').style.display = 'none';
        }

        updateSourceGrid() {
            console.log('üîç updateSourceGrid called');
            const sourceGrid = document.getElementById('sourceGrid');
            if (!sourceGrid) {
                console.error('üîç sourceGrid element not found!');
                return;
            }

            console.log('üîç Clearing sourceGrid, galleryImages count:', this.galleryImages?.length);
            sourceGrid.innerHTML = '';
            
            // Clear existing listeners by getting a fresh reference
            const newSourceGrid = sourceGrid;
            
            newSourceGrid.addEventListener('click', (e) => {
                console.log('SourceGrid clicked, target:', e.target.className, 'tagName:', e.target.tagName);
                if (this.selectionMode) {
                    const galleryItem = e.target.closest('.gallery-item');
                    if (galleryItem) {
                        const imageId = galleryItem.dataset.imageId;
                        console.log('Event delegation click:', imageId);
                        this.handleSourceGridItemSelection(e, imageId);
                    } else {
                        console.log('No gallery item found for target:', e.target);
                    }
                } else {
                    console.log('Not in selection mode:', {
                        selectionMode: this.selectionMode
                    });
                }
            }, true); // Use capture phase

            console.log('üîç Creating gallery items for sourceGrid...');
            this.galleryImages.forEach((item, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'gallery-item';
                itemEl.draggable = true;
                itemEl.dataset.imageId = item.id;
                itemEl.dataset.index = index;

                itemEl.innerHTML = `
                    <img src="${item.data}" alt="${item.filename}" class="gallery-item-image">
                    <div class="selection-checkbox">‚úì</div>
                    <div class="gallery-item-info">
                        <div class="gallery-item-name">${item.filename}</div>
                    </div>
                    <!-- Rotation & Duplicate Controls -->
                    <div class="classification-hover-actions">
                        <button class="classification-action-btn rotation-action" onclick="converter.rotateImage('${item.id}', 90)" title="Xoay 90¬∞">
                            <span class="action-icon">üîÑ</span>
                            <span class="action-text">90¬∞</span>
                        </button>
                        <button class="classification-action-btn rotation-action" onclick="converter.rotateImage('${item.id}', 180)" title="Xoay 180¬∞">
                            <span class="action-icon">‚Üª</span>
                            <span class="action-text">180¬∞</span>
                        </button>
                        <button class="classification-action-btn rotation-action" onclick="converter.rotateImage('${item.id}', 270)" title="Xoay 270¬∞">
                            <span class="action-icon">‚Ü∫</span>
                            <span class="action-text">270¬∞</span>
                        </button>
                        <button class="classification-action-btn duplicate-action" onclick="converter.duplicateImage('${item.id}')" title="Nh√¢n b·∫£n ·∫£nh">
                            <span class="action-icon">‚ßâ</span>
                            <span class="action-text">Nh√¢n b·∫£n</span>
                        </button>
                    </div>
                `;

                // Note: Removed direct listener to avoid conflicts - using event delegation only

                newSourceGrid.appendChild(itemEl);
                console.log(`üîç Added item ${index + 1}/${this.galleryImages.length}: ${item.filename}`);
                
                // Debug: Check if hover actions were added
                const hoverActions = itemEl.querySelector('.classification-hover-actions');
                if (hoverActions) {
                    console.log(`‚úÖ Hover actions added to ${item.filename}:`, hoverActions.innerHTML);
                } else {
                    console.log(`‚ùå No hover actions found for ${item.filename}`);
                }
            });
            
            console.log('üîç updateSourceGrid completed, total items added:', this.galleryImages.length);
        }

        setupClassificationDragDrop() {
            const dropZones = ['frontDropZone', 'backDropZone'];
            
            dropZones.forEach(zoneId => {
                const zone = document.getElementById(zoneId);
                if (zone) {
                    zone.addEventListener('dragover', (e) => this.handleDropZoneDragOver(e));
                    zone.addEventListener('dragleave', (e) => this.handleDropZoneDragLeave(e));
                    zone.addEventListener('drop', (e) => this.handleDropZoneDrop(e));
                }
            });
        }

        handleGalleryDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.imageId);
        }

        handleGalleryDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        handleClassificationDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.imageId);
            e.dataTransfer.setData('source', 'gallery');
        }

        handleClassificationDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        handleDropZoneDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        handleDropZoneDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        handleDropZoneDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            const imageId = e.dataTransfer.getData('text/plain');
            const dropType = e.currentTarget.dataset.type;
            const source = e.dataTransfer.getData('source');
            
            console.log('Drop event:', { imageId, dropType, source });

            // Try both source types
            if (source === 'gallery' || imageId) {
                this.moveImageToClassification(imageId, dropType);
            }
        }

        moveImageToClassification(imageId, type) {
            console.log('Moving image:', { imageId, type });
            console.log('Current context:', {
                activeTab: this.getCurrentActiveTab(),
                classificationMode: this.classificationMode,
                printMode: this.printData?.config?.printMode
            });
            console.log('Available gallery images:', this.galleryImages.map(img => ({ id: img.id, filename: img.filename })));
            
            // Try to find image by ID first, then by data (base64) if ID doesn't work
            let image = this.galleryImages.find(img => img.id == imageId);
            
            if (!image && typeof imageId === 'string' && imageId.startsWith('data:')) {
                // If imageId is base64 data, find by data instead
                console.log('ImageId appears to be base64 data, searching by data field');
                image = this.galleryImages.find(img => img.data === imageId);
            }
            
            console.log('Found image:', image);
            if (!image) {
                console.error('Image not found in gallery. ImageId:', imageId?.substring(0, 50) + '...', 'Type:', typeof imageId);
                console.error('Available IDs:', this.galleryImages.map(img => `${img.id} (${typeof img.id})`));
                console.error('Searching by data failed as well');
                return;
            }

            // Determine which classification system to use based on context
            const currentTab = this.getCurrentActiveTab();
            let targetArray;
            
            if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                // Duplex classification in Print tab
                console.log('Using duplex classification system');
                if (!this.printData.frontImages) this.printData.frontImages = [];
                if (!this.printData.backImages) this.printData.backImages = [];
                targetArray = type === 'front' ? this.printData.frontImages : this.printData.backImages;
            } else {
                // Regular classification in Gallery tab
                console.log('Using gallery classification system');
                if (!this.frontImages) this.frontImages = [];
                if (!this.backImages) this.backImages = [];
                targetArray = type === 'front' ? this.frontImages : this.backImages;
            }
            // Check if already classified in the appropriate system
            let alreadyInFront, alreadyInBack;
            
            if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                // Check duplex classification
                alreadyInFront = this.printData.frontImages?.find(img => img.id == imageId);
                alreadyInBack = this.printData.backImages?.find(img => img.id == imageId);
            } else {
                // Check gallery classification
                alreadyInFront = this.frontImages?.find(img => img.id == imageId);
                alreadyInBack = this.backImages?.find(img => img.id == imageId);
            }
            
            // Remove from previous classification in the appropriate system
            if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                if (alreadyInFront) {
                    this.printData.frontImages = this.printData.frontImages.filter(img => img.id != imageId);
                }
                if (alreadyInBack) {
                    this.printData.backImages = this.printData.backImages.filter(img => img.id != imageId);
                }
            } else {
                if (alreadyInFront) {
                    this.frontImages = this.frontImages.filter(img => img.id != imageId);
                }
                if (alreadyInBack) {
                    this.backImages = this.backImages.filter(img => img.id != imageId);
                }
            }

            // Add to target array
            targetArray.push({...image});
            console.log('Added to', type, 'array. Length now:', targetArray.length);
            
            // Update appropriate UI based on context
            if (currentTab === 'print' && this.printData?.config?.printMode === 'duplex') {
                // Update duplex UI
                this.updateClassificationDisplay();
                this.updateDuplexPreview();
                this.updateDuplexStats();
            } else {
                // Update gallery UI
                this.updateClassificationPanels();
                this.updateDownloadButtons();
                this.updateRenamePatterns();
            }
        }

        updateClassificationPanels() {
            this.updatePanel('frontDropZone', this.frontImages, 'front');
            this.updatePanel('backDropZone', this.backImages, 'back');
        }
        
        updateClassificationDisplay() {
            // Update both panels and source grid
            this.updateClassificationPanels();
            this.updateSourceGrid();
            
            // Update download button states
            this.updateDownloadButtons();
        }

        updatePanel(zoneId, images, type) {
            const zone = document.getElementById(zoneId);
            if (!zone) return;

            zone.innerHTML = '';
            
            if (images.length === 0) {
                zone.classList.add('empty');
                zone.innerHTML = '<div class="drop-hint">K√©o ·∫£nh v√†o ƒë√¢y</div>';
                return;
            }

            zone.classList.remove('empty');
            
            // Re-sort images by their order (in case of reordering)
            const sortedImages = [...images];
            
            sortedImages.forEach((image, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'classified-item';
                itemEl.dataset.imageId = image.id;
                itemEl.dataset.index = index;
                itemEl.dataset.type = type;

                const newName = this.generateNewName(type, index);
                
                itemEl.innerHTML = `
                    <img src="${image.data}" alt="${newName}" class="classified-item-image">
                    <div class="classified-item-controls">
                        <button class="item-control-btn" onclick="converter.moveClassifiedImageUp('${image.id}', '${type}')" title="L√™n tr√™n">‚Üë</button>
                        <button class="item-control-btn" onclick="converter.moveClassifiedImageDown('${image.id}', '${type}')" title="Xu·ªëng d∆∞·ªõi">‚Üì</button>
                        <button class="item-control-btn" onclick="converter.duplicateClassifiedImage('${image.id}', '${type}')" title="Nh√¢n b·∫£n">‚ßâ</button>
                        <button class="item-control-btn" onclick="converter.removeClassifiedImage('${image.id}', '${type}')" title="X√≥a">√ó</button>
                    </div>
                    <div class="classified-item-name">${newName}</div>
                `;

                zone.appendChild(itemEl);
            });
            
            console.log(`Updated ${type} panel with ${sortedImages.length} images`);
        }

        generateNewName(type, index) {
            const prefix = type === 'front' 
                ? document.getElementById('frontPrefix')?.value || ''
                : document.getElementById('backPrefix')?.value || '';
            const suffix = type === 'front' ? 'a' : 'b';
            const number = index + 1;
            
            return `${prefix}${number}${suffix}.jpg`;
        }

        removeClassifiedImage(imageId, type) {
            if (type === 'front') {
                this.frontImages = this.frontImages.filter(img => img.id != imageId);
            } else {
                this.backImages = this.backImages.filter(img => img.id != imageId);
            }
            
            this.updateClassificationPanels();
            this.updateDownloadButtons();
            this.updateRenamePatterns();
        }

        duplicateClassifiedImage(imageId, type) {
            const sourceArray = type === 'front' ? this.frontImages : this.backImages;
            const imageIndex = sourceArray.findIndex(img => img.id == imageId);
            
            if (imageIndex !== -1) {
                const image = sourceArray[imageIndex];
                const duplicate = {
                    ...image,
                    id: Date.now() + Math.random()
                };
                // Insert right after the original
                sourceArray.splice(imageIndex + 1, 0, duplicate);
                
                this.updateClassificationPanels();
                this.updateDownloadButtons();
                this.updateRenamePatterns();
                
                const newName = this.generateNewName(type, imageIndex + 1);
                this.showToast(`ƒê√£ nh√¢n b·∫£n ·∫£nh v·ªõi t√™n: ${newName}`);
            }
        }

        moveClassifiedImageUp(imageId, type) {
            const sourceArray = type === 'front' ? this.frontImages : this.backImages;
            const imageIndex = sourceArray.findIndex(img => img.id == imageId);
            
            if (imageIndex > 0) {
                // Swap with previous item
                [sourceArray[imageIndex - 1], sourceArray[imageIndex]] = 
                [sourceArray[imageIndex], sourceArray[imageIndex - 1]];
                
                this.updateClassificationPanels();
                this.updateDownloadButtons();
                this.updateRenamePatterns();
                
                const newName = this.generateNewName(type, imageIndex - 1);
                this.showToast(`ƒê√£ chuy·ªÉn ·∫£nh l√™n v·ªã tr√≠: ${newName}`);
            }
        }

        moveClassifiedImageDown(imageId, type) {
            const sourceArray = type === 'front' ? this.frontImages : this.backImages;
            const imageIndex = sourceArray.findIndex(img => img.id == imageId);
            
            if (imageIndex < sourceArray.length - 1 && imageIndex !== -1) {
                // Swap with next item
                [sourceArray[imageIndex], sourceArray[imageIndex + 1]] = 
                [sourceArray[imageIndex + 1], sourceArray[imageIndex]];
                
                this.updateClassificationPanels();
                this.updateDownloadButtons();
                this.updateRenamePatterns();
                
                const newName = this.generateNewName(type, imageIndex + 1);
                this.showToast(`ƒê√£ chuy·ªÉn ·∫£nh xu·ªëng v·ªã tr√≠: ${newName}`);
            }
        }

        updateRenamePatterns() {
            const frontPattern = document.querySelector('#frontPrefix').closest('.panel-controls').querySelector('.rename-pattern');
            const backPattern = document.querySelector('#backPrefix').closest('.panel-controls').querySelector('.rename-pattern');
            
            const frontPrefix = document.getElementById('frontPrefix')?.value || '';
            const backPrefix = document.getElementById('backPrefix')?.value || '';
            
            if (frontPattern) {
                frontPattern.textContent = `${frontPrefix}1a, ${frontPrefix}2a, ${frontPrefix}3a...`;
            }
            if (backPattern) {
                backPattern.textContent = `${backPrefix}1b, ${backPrefix}2b, ${backPrefix}3b...`;
            }
        }

        updateDownloadButtons() {
            const hasFront = this.frontImages.length > 0;
            const hasBack = this.backImages.length > 0;
            const hasAny = hasFront || hasBack;
            const totalCount = this.frontImages.length + this.backImages.length;
            
            // Update legacy buttons (for backward compatibility)
            const downloadFrontBtn = document.getElementById('downloadFrontBtn');
            const downloadBackBtn = document.getElementById('downloadBackBtn');
            const downloadZipFrontBtn = document.getElementById('downloadZipFrontBtn');
            const downloadZipBackBtn = document.getElementById('downloadZipBackBtn');
            const previewDownloadBtn = document.getElementById('previewDownloadBtn');
            
            if (downloadFrontBtn) downloadFrontBtn.disabled = !hasFront;
            if (downloadBackBtn) downloadBackBtn.disabled = !hasBack;
            if (downloadZipFrontBtn) downloadZipFrontBtn.disabled = !hasFront;
            if (downloadZipBackBtn) downloadZipBackBtn.disabled = !hasBack;
            if (previewDownloadBtn) previewDownloadBtn.disabled = !hasAny;
            
            // Update new individual download buttons
            const downloadFrontIndividualBtn = document.getElementById('downloadFrontIndividualBtn');
            const downloadBackIndividualBtn = document.getElementById('downloadBackIndividualBtn');
            const downloadAllIndividualBtn = document.getElementById('downloadAllIndividualBtn');
            
            if (downloadFrontIndividualBtn) {
                downloadFrontIndividualBtn.disabled = !hasFront;
            }
            if (downloadBackIndividualBtn) {
                downloadBackIndividualBtn.disabled = !hasBack;
            }
            if (downloadAllIndividualBtn) {
                downloadAllIndividualBtn.disabled = !hasAny;
            }
            
            // Update new ZIP download buttons
            const downloadZipAllBtn = document.getElementById('downloadZipAllBtn');
            if (downloadZipAllBtn) {
                downloadZipAllBtn.disabled = !hasAny;
            }
            
            // Update count displays
            const frontCount = document.getElementById('frontCount');
            const backCount = document.getElementById('backCount');
            const allCount = document.getElementById('allCount');
            const frontZipCount = document.getElementById('frontZipCount');
            const backZipCount = document.getElementById('backZipCount');
            const allZipCount = document.getElementById('allZipCount');
            
            if (frontCount) frontCount.textContent = `${this.frontImages.length} file`;
            if (backCount) backCount.textContent = `${this.backImages.length} file`;
            if (allCount) allCount.textContent = `${totalCount} file`;
            if (frontZipCount) frontZipCount.textContent = `${this.frontImages.length} file`;
            if (backZipCount) backZipCount.textContent = `${this.backImages.length} file`;
            if (allZipCount) allZipCount.textContent = `${totalCount} file`;
        }

        showDownloadPreview() {
            const allFiles = [];
            
            this.frontImages.forEach((image, index) => {
                allFiles.push({
                    name: this.generateNewName('front', index),
                    type: 'M·∫∑t tr∆∞·ªõc',
                    data: image.data
                });
            });
            
            this.backImages.forEach((image, index) => {
                allFiles.push({
                    name: this.generateNewName('back', index),
                    type: 'M·∫∑t sau',
                    data: image.data
                });
            });
            
            if (allFiles.length === 0) {
                this.showToast('Ch∆∞a c√≥ file n√†o ƒë·ªÉ t·∫£i xu·ªëng', 'error');
                return;
            }
            
            // Create and show preview modal
            this.showFileListPreview(allFiles);
        }

        showFileListPreview(files) {
            const modal = document.createElement('div');
            modal.className = 'preview-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 24px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            content.innerHTML = `
                <h3 style="margin: 0 0 16px 0;">Danh s√°ch file s·∫Ω t·∫£i xu·ªëng</h3>
                <div style="margin-bottom: 16px;">
                    <strong>T·ªïng c·ªông: ${files.length} file</strong>
                </div>
                <div style="max-height: 400px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 6px;">
                    ${files.map(file => `
                        <div style="padding: 8px 12px; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between;">
                            <span>${file.name}</span>
                            <span style="color: #6b7280; font-size: 0.85rem;">${file.type}</span>
                        </div>
                    `).join('')}
                </div>
                <div style="margin-top: 16px; display: flex; gap: 12px; justify-content: flex-end;">
                    <button id="previewCancelBtn" style="padding: 8px 16px; border: 2px solid #d1d5db; background: #f8fafc; border-radius: 4px; cursor: pointer; transition: all 0.2s ease;">H·ªßy</button>
                    <button id="previewDownloadConfirmBtn" style="padding: 8px 16px; border: none; background: var(--primary-blue); color: white; border-radius: 4px; cursor: pointer;">T·∫£i xu·ªëng</button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Event listeners
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            document.getElementById('previewCancelBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            document.getElementById('previewDownloadConfirmBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
                this.downloadClassifiedImages();
            });
        }

        async downloadClassifiedImages() {
            const files = [];
            
            // Prepare front images
            this.frontImages.forEach((image, index) => {
                files.push({
                    filename: this.generateNewName('front', index),
                    data: image.data
                });
            });
            
            // Prepare back images
            this.backImages.forEach((image, index) => {
                files.push({
                    filename: this.generateNewName('back', index),
                    data: image.data
                });
            });
            
            try {
                const zipBlob = await this.createSafeZip(
                    files,
                    `classified-images-${new Date().toISOString().slice(0, 10)}.zip`,
                    'Safe classified images archive - Created by MEU Layout'
                );
                
                this.downloadSafeZip(
                    zipBlob,
                    `classified-images-${new Date().toISOString().slice(0, 10)}.zip`
                );
                
                this.showToast('ƒê√£ t·∫£i xu·ªëng file ZIP th√†nh c√¥ng!');
            } catch (error) {
                console.error('Error creating safe ZIP:', error);
                this.showToast('L·ªói khi t·∫°o file ZIP: ' + error.message, 'error');
            }
        }


        // Convert image to high quality JPG while preserving original dimensions
        async convertToHighQualityJPG(imageData, originalFilename) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    // Create canvas with original dimensions to preserve exact size
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // Preserve original dimensions - DO NOT scale for DPI
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;

                    // Enable high quality rendering
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';

                    // Draw image at original size to preserve exact dimensions
                    ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);

                    // Convert to high quality JPG blob with maximum quality
                    canvas.toBlob((blob) => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Failed to create high quality JPG blob'));
                        }
                    }, 'image/jpeg', 1.0); // Maximum quality for printing
                };
                
                img.onerror = () => {
                    reject(new Error('Failed to load image for conversion'));
                };
                
                img.src = imageData;
            });
        }

        // Ensure filename has JPG extension
        ensureJPGExtension(filename) {
            const extension = filename.toLowerCase().split('.').pop();
            if (extension === 'jpg' || extension === 'jpeg') {
                return filename;
            }
            
            // Replace extension with .jpg
            const nameWithoutExt = filename.substring(0, filename.lastIndexOf('.')) || filename;
            return `${nameWithoutExt}.jpg`;
        }

        async downloadAllImages() {
            if (this.galleryImages.length === 0) {
                this.showToast('Kh√¥ng c√≥ ·∫£nh ƒë·ªÉ t·∫£i xu·ªëng', 'error');
                return;
            }
            
            // Fast batch download for gallery images
            const batchSize = 6; // Browser parallel limit
            
            for (let i = 0; i < this.galleryImages.length; i += batchSize) {
                const batch = this.galleryImages.slice(i, i + batchSize);
                
                batch.forEach((image, indexInBatch) => {
                    setTimeout(() => {
                        const link = document.createElement('a');
                        link.href = image.data;
                        link.download = image.filename;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }, indexInBatch * 30); // 30ms between files in batch
                });
                
                // Small delay between batches
                if (i + batchSize < this.galleryImages.length) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }
            
            this.showToast('ƒê√£ b·∫Øt ƒë·∫ßu t·∫£i xu·ªëng t·∫•t c·∫£ ·∫£nh!');
        }

        async downloadAllImagesZip() {
            if (this.galleryImages.length === 0) {
                this.showToast('Kh√¥ng c√≥ ·∫£nh ƒë·ªÉ t·∫£i xu·ªëng', 'error');
                return;
            }
            
            const files = this.galleryImages.map(image => ({
                filename: image.filename,
                data: image.data
            }));
            
            try {
                const zipBlob = await this.createSafeZip(
                    files,
                    `all-gallery-images-${new Date().toISOString().slice(0, 10)}.zip`,
                    'Safe gallery images archive - Created by MEU Layout'
                );
                
                this.downloadSafeZip(
                    zipBlob,
                    `all-gallery-images-${new Date().toISOString().slice(0, 10)}.zip`
                );
                
                this.showToast('ƒê√£ t·∫£i xu·ªëng file ZIP th√†nh c√¥ng!');
            } catch (error) {
                console.error('Error creating safe ZIP:', error);
                this.showToast('L·ªói khi t·∫°o file ZIP: ' + error.message, 'error');
            }
        }

        async downloadFrontImages() {
            this.downloadImageArray(this.frontImages, 'front');
        }

        async downloadBackImages() {
            this.downloadImageArray(this.backImages, 'back');
        }

        // High-quality individual downloads for classified images
        async downloadFrontImagesIndividual() {
            await this.downloadClassifiedImagesIndividual(this.frontImages, 'front');
        }

        async downloadBackImagesIndividual() {
            await this.downloadClassifiedImagesIndividual(this.backImages, 'back');
        }

        async downloadAllClassifiedImagesIndividual() {
            const allImages = [...this.frontImages, ...this.backImages];
            await this.downloadClassifiedImagesIndividual(allImages, 'all');
        }

        async downloadClassifiedImagesIndividual(images, type) {
            if (images.length === 0) {
                const typeLabel = type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : (type === 'back' ? 'm·∫∑t sau' : 'ƒë√£ ph√¢n lo·∫°i');
                this.showToast(`Kh√¥ng c√≥ ·∫£nh ${typeLabel} ƒë·ªÉ t·∫£i xu·ªëng`, 'error');
                return;
            }

            const btnId = type === 'front' ? 'downloadFrontIndividualBtn' : 
                         (type === 'back' ? 'downloadBackIndividualBtn' : 'downloadAllIndividualBtn');
            const btn = document.getElementById(btnId);
            
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = `
                    <span class="btn-label">ƒêang t·∫£i...</span>
                    <span class="btn-count">‚è≥</span>
                `;
            }

            try {
                const typeLabel = type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : (type === 'back' ? 'm·∫∑t sau' : 't·∫•t c·∫£');
                this.showToast(`B·∫Øt ƒë·∫ßu t·∫£i ${images.length} ·∫£nh ${typeLabel} (JPG, k√≠ch th∆∞·ªõc g·ªëc)...`, 'success');

                for (let i = 0; i < images.length; i++) {
                    const image = images[i];
                    
                    try {
                        // Convert to high quality JPG with 300 DPI
                        const highQualityBlob = await this.convertToHighQualityJPG(image.data);
                        
                        // Generate filename based on classification with proper pattern
                        let filename;
                        if (type === 'all') {
                            // For "all", determine if image belongs to front or back and generate accordingly  
                            const frontIndex = this.frontImages.findIndex(img => img.id === image.id);
                            const backIndex = this.backImages.findIndex(img => img.id === image.id);
                            
                            if (frontIndex !== -1) {
                                filename = this.generateNewName('front', frontIndex);
                            } else if (backIndex !== -1) {
                                filename = this.generateNewName('back', backIndex);
                            } else {
                                filename = image.filename; // fallback
                            }
                        } else {
                            // For specific type (front/back), use proper index
                            const imageIndex = images.findIndex(img => img.id === image.id);
                            filename = this.generateNewName(type, imageIndex);
                        }
                        const jpgFilename = this.ensureJPGExtension(filename);
                        
                        console.log(`Processing ${type} image ${i + 1}: ${jpgFilename}`);
                        
                        // Create download
                        const url = URL.createObjectURL(highQualityBlob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = jpgFilename;
                        link.style.display = 'none';
                        
                        document.body.appendChild(link);
                        
                        // Staggered download with delay
                        setTimeout(() => {
                            link.click();
                            setTimeout(() => {
                                document.body.removeChild(link);
                                URL.revokeObjectURL(url);
                            }, 100);
                        }, i * 800);
                        
                    } catch (error) {
                        console.error(`Error processing image ${i + 1}:`, error);
                        continue;
                    }
                }
                
                setTimeout(() => {
                    this.showToast(`‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu t·∫£i ${images.length} file ${typeLabel} JPG (300 DPI)!`, 'success');
                }, 1000);

            } catch (error) {
                console.error(`Error in download${type}ImagesIndividual:`, error);
                this.showToast('L·ªói khi t·∫£i file!', 'error');
            } finally {
                setTimeout(() => {
                    if (btn) {
                        btn.disabled = false;
                        const typeLabel = type === 'front' ? 'M·∫∑t tr∆∞·ªõc' : (type === 'back' ? 'M·∫∑t sau' : 'T·∫•t c·∫£');
                        const count = `${images.length} file`;
                        btn.innerHTML = `
                            <span class="btn-label">${typeLabel}</span>
                            <span class="btn-count">${count}</span>
                        `;
                    }
                }, images.length * 800 + 2000);
            }
        }

        downloadImageArray(images, type) {
            if (images.length === 0) {
                this.showToast(`Kh√¥ng c√≥ ·∫£nh ${type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'} ƒë·ªÉ t·∫£i xu·ªëng`, 'error');
                return;
            }
            
            images.forEach((image, index) => {
                const filename = this.generateNewName(type, index);
                const link = document.createElement('a');
                link.href = image.data;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
            
            this.showToast(`ƒê√£ b·∫Øt ƒë·∫ßu t·∫£i xu·ªëng ${images.length} ·∫£nh ${type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'}!`);
        }

        async downloadFrontImagesZip() {
            await this.downloadImageArrayZip(this.frontImages, 'front');
        }

        async downloadBackImagesZip() {
            await this.downloadImageArrayZip(this.backImages, 'back');
        }

        async downloadImageArrayZip(images, type) {
            if (images.length === 0) {
                this.showToast(`Kh√¥ng c√≥ ·∫£nh ${type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'} ƒë·ªÉ t·∫£i xu·ªëng`, 'error');
                return;
            }
            
            const files = images.map((image, index) => ({
                filename: this.generateNewName(type, index),
                data: image.data
            }));
            
            const typeLabel = type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau';
            
            try {
                const zipBlob = await this.createSafeZip(
                    files,
                    `${type}-images-${new Date().toISOString().slice(0, 10)}.zip`,
                    `Safe ${typeLabel} images archive - Created by MEU Layout`
                );
                
                this.downloadSafeZip(
                    zipBlob,
                    `${type}-images-${new Date().toISOString().slice(0, 10)}.zip`
                );
                
                this.showToast(`ƒê√£ t·∫£i xu·ªëng file ZIP ${typeLabel} th√†nh c√¥ng!`);
            } catch (error) {
                console.error('Error creating safe ZIP:', error);
                this.showToast('L·ªói khi t·∫°o file ZIP: ' + error.message, 'error');
            }
        }

        // Image Action Modal Methods
        showImageActionModal(imageId) {
            this.selectedImageForAction = imageId;
            const image = this.galleryImages.find(img => img.id == imageId);
            if (!image) return;

            const modal = document.getElementById('imageActionModal');
            const preview = document.getElementById('selectedImagePreview');
            const name = document.getElementById('selectedImageName');

            if (preview) preview.src = image.data;
            if (name) name.textContent = image.filename;
            if (modal) modal.style.display = 'flex';
        }

        hideImageActionModal() {
            const modal = document.getElementById('imageActionModal');
            if (modal) modal.style.display = 'none';
            this.selectedImageForAction = null;
        }

        // Direct classification without modal (new hover method)
        addImageToClassificationDirect(imageId, type) {
            this.moveImageToClassification(imageId, type);
            
            // Show success message with new position
            const targetArray = type === 'front' ? this.frontImages : this.backImages;
            const position = targetArray.length;
            const newName = this.generateNewName(type, position - 1);
            this.showToast(`‚úÖ ƒê√£ th√™m v√†o ${type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'}: ${newName}`, 'success');
        }

        // Legacy modal method (kept for compatibility)
        addImageToClassification(type) {
            if (!this.selectedImageForAction) return;
            
            this.moveImageToClassification(this.selectedImageForAction, type);
            this.hideImageActionModal();
            
            // Show success message with new position
            const targetArray = type === 'front' ? this.frontImages : this.backImages;
            const position = targetArray.length;
            const newName = this.generateNewName(type, position - 1);
            
            this.showToast(`ƒê√£ th√™m ·∫£nh v√†o ${type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'} v·ªõi t√™n: ${newName}`);
        }

        // Print functionality methods
        initializePrintSection() {
            // Only initialize if printData doesn't exist yet
            if (!this.printData) {
                this.printData = {
                    selectedImages: [],
                    frontImages: {},     // { pageIndex: { slotIndex: imageData } }
                    backImages: {},      // { pageIndex: { slotIndex: imageData } }
                    currentPage: 0,
                    currentSide: 'front', // 'front' or 'back'
                    totalPages: 0,
                    masterCanvas: null,  // Master Canvas for WYSIWYG
                    previewCanvas: null, // Scaled preview canvas
                    context: null,
                    config: {
                        paperSize: { width: 210, height: 297 }, // A4 in mm
                        photoSize: { width: 5.5, height: 8.5 }, // in cm
                        margins: { top: 5, bottom: 5, left: 5, right: 5 }, // in mm
                        gutter: { x: 5, y: 5 }, // in mm
                        dpi: 300,
                        orientation: 'portrait',
                        fitMode: 'fill',
                        printMode: 'single', // 'single' or 'duplex'
                        duplexFlip: 'long-edge', // 'long-edge' or 'short-edge'
                        duplexPhysicalOffset: { x: 0, y: 0 }, // Physical offset in mm for duplex printing
                        backSideBleed: 0.3, // mm - Ph√≥ng to ·∫£nh m·∫∑t sau ƒë·ªÉ tr√°nh l·ªô vi·ªÅn tr·∫Øng
                        backSideBleedEnabled: true, // B·∫≠t/t·∫Øt t√≠nh nƒÉng bleed
                        cuttingGuides: {
                            outerCuttingLines: true,
                            betweenImages: true,
                            cornerMarks: true,
                            gridHelperLines: false,
                            color: '#000000',
                            thickness: 0.5,
                            lineStyle: 'solid'
                        }
                    }
                };

                this.setupPrintEventListeners();
                this.setupCuttingGuidesListeners();
                this.setupPreviewControls();
                this.setupDuplexControls();
            }

            // Always recalculate layout and update preview when switching to print tab
            this.calculateLayout();

            // Initialize preview canvas to show layout even without images
            setTimeout(() => {
                console.log('üöÄ Initializing preview layout...');
                this.updatePreviewLayout();
                console.log('‚úÖ Preview layout initialized');
            }, 100);

            // Ensure gallery images (kho ·∫£nh) are displayed in print section
            this.updateSourceGrid();
        }

        setupPrintEventListeners() {
            // Setup new compact interface event listeners
            this.setupCompactInterface();

            // Setup drag and drop for file upload
            this.setupDragAndDrop();

            // Setup Smart Grid controls
            this.setupSmartGridControls();

            // Paper size selection (Legacy support)
            document.querySelectorAll('.size-preset').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.size-preset').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const size = btn.dataset.size;
                    this.selectPaperSize(size);
                });
            });

            // Photo size selection (Legacy support)
            document.querySelectorAll('.photo-preset').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.photo-preset').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const size = btn.dataset.size;
                    this.selectPhotoSize(size);
                });
            });

            // Orientation selection (Legacy support)
            document.querySelectorAll('.orientation-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.orientation-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const orientation = btn.dataset.orientation;
                    this.printData.config.orientation = orientation;
                    this.calculateLayout();
                });
            });

            // DPI is fixed at 300 for professional printing quality

            // Fit mode selection
            document.querySelectorAll('.fit-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.fit-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const fit = btn.dataset.fit;
                    this.printData.config.fitMode = fit;
                    this.updatePreview();
                });
            });

            // File input
            const printFileInput = document.getElementById('printFileInput');
            if (printFileInput) {
                printFileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handlePrintImages(e.target.files);
                        e.target.value = ''; // Clear ƒë·ªÉ tr√°nh duplicate
                    }
                });
            }

            // Use gallery images button
            const useGalleryBtn = document.getElementById('useGalleryImagesBtn');
            if (useGalleryBtn) {
                useGalleryBtn.addEventListener('click', () => this.useGalleryImages());
            }

            // Clear selected button
            const clearSelectedBtn = document.getElementById('clearSelectedBtn');
            if (clearSelectedBtn) {
                clearSelectedBtn.addEventListener('click', () => this.clearSelectedImages());
            }

            // Image distribution buttons
            const fillAllPagesBtn = document.getElementById('fillAllPagesBtn');
            if (fillAllPagesBtn) {
                fillAllPagesBtn.addEventListener('click', () => {
                    this.fillAllPagesWithFirstImage();
                    this.updateDistributionButtonStates('fill');
                });
            }

            const distributeEvenlyBtn = document.getElementById('distributeEvenlyBtn');
            if (distributeEvenlyBtn) {
                distributeEvenlyBtn.addEventListener('click', () => {
                    this.distributeImagesEvenly();
                    this.updateDistributionButtonStates('distribute');
                });
            }

            const toggleCustomBtn = document.getElementById('toggleCustomBtn');
            if (toggleCustomBtn) {
                toggleCustomBtn.addEventListener('click', () => {
                    const customSection = document.getElementById('customDistributionSection');
                    if (customSection) {
                        const isHidden = customSection.style.display === 'none';
                        customSection.style.display = isHidden ? 'block' : 'none';

                        // Update button states
                        this.updateDistributionButtonStates(isHidden ? 'custom' : null);

                        // Update custom distribution grid when shown
                        if (isHidden) {
                            this.updateCustomDistributionGrid();
                        }
                    }
                });
            }

            // Apply all custom quantities button
            const applyAllBtn = document.getElementById('applyAllBtn');
            if (applyAllBtn) {
                applyAllBtn.addEventListener('click', () => this.applyAllCustomQuantities());
            }

            // ============ DUPLEX DISTRIBUTION EVENT LISTENERS ============
            const fillFrontPagesBtn = document.getElementById('fillFrontPagesBtn');
            if (fillFrontPagesBtn) {
                fillFrontPagesBtn.addEventListener('click', () => this.fillDuplexFrontPages());
            }

            const fillBackPagesBtn = document.getElementById('fillBackPagesBtn');
            if (fillBackPagesBtn) {
                fillBackPagesBtn.addEventListener('click', () => this.fillDuplexBackPages());
            }

            const distributeFrontEvenlyBtn = document.getElementById('distributeFrontEvenlyBtn');
            if (distributeFrontEvenlyBtn) {
                distributeFrontEvenlyBtn.addEventListener('click', () => this.distributeDuplexFrontEvenly());
            }

            const distributeBackEvenlyBtn = document.getElementById('distributeBackEvenlyBtn');
            if (distributeBackEvenlyBtn) {
                distributeBackEvenlyBtn.addEventListener('click', () => this.distributeDuplexBackEvenly());
            }

            const clearFrontBtn = document.getElementById('clearFrontBtn');
            if (clearFrontBtn) {
                clearFrontBtn.addEventListener('click', () => this.clearDuplexFront());
            }

            const clearBackBtn = document.getElementById('clearBackBtn');
            if (clearBackBtn) {
                clearBackBtn.addEventListener('click', () => this.clearDuplexBack());
            }

            const fillAllDuplexBtn = document.getElementById('fillAllDuplexBtn');
            if (fillAllDuplexBtn) {
                fillAllDuplexBtn.addEventListener('click', () => this.fillAllDuplexPages());
            }

            const distributeAllDuplexBtn = document.getElementById('distributeAllDuplexBtn');
            if (distributeAllDuplexBtn) {
                distributeAllDuplexBtn.addEventListener('click', () => this.distributeAllDuplexEvenly());
            }

            // Toggle custom distribution sections
            const toggleCustomFrontBtn = document.getElementById('toggleCustomFrontBtn');
            if (toggleCustomFrontBtn) {
                toggleCustomFrontBtn.addEventListener('click', () => {
                    const section = document.getElementById('customDistFrontSection');
                    if (section) {
                        const isHidden = section.style.display === 'none';
                        section.style.display = isHidden ? 'block' : 'none';
                        toggleCustomFrontBtn.classList.toggle('active', isHidden);
                        if (isHidden) {
                            this.updateDuplexCustomDistributionGrid('front');
                        }
                    }
                });
            }

            const toggleCustomBackBtn = document.getElementById('toggleCustomBackBtn');
            if (toggleCustomBackBtn) {
                toggleCustomBackBtn.addEventListener('click', () => {
                    const section = document.getElementById('customDistBackSection');
                    if (section) {
                        const isHidden = section.style.display === 'none';
                        section.style.display = isHidden ? 'block' : 'none';
                        toggleCustomBackBtn.classList.toggle('active', isHidden);
                        if (isHidden) {
                            this.updateDuplexCustomDistributionGrid('back');
                        }
                    }
                });
            }

            // Apply all custom quantities
            const applyAllFrontBtn = document.getElementById('applyAllFrontBtn');
            if (applyAllFrontBtn) {
                applyAllFrontBtn.addEventListener('click', () => this.applyAllDuplexCustomQuantity('front'));
            }

            const applyAllBackBtn = document.getElementById('applyAllBackBtn');
            if (applyAllBackBtn) {
                applyAllBackBtn.addEventListener('click', () => this.applyAllDuplexCustomQuantity('back'));
            }

            // Copy between sides
            const copyFrontToBackBtn = document.getElementById('copyFrontToBackBtn');
            if (copyFrontToBackBtn) {
                copyFrontToBackBtn.addEventListener('click', () => this.copyFrontToBack());
            }

            const copyBackToFrontBtn = document.getElementById('copyBackToFrontBtn');
            if (copyBackToFrontBtn) {
                copyBackToFrontBtn.addEventListener('click', () => this.copyBackToFront());
            }

            // Preview navigation
            const prevPageBtn = document.getElementById('prevPageBtn');
            const nextPageBtn = document.getElementById('nextPageBtn');
            if (prevPageBtn) {
                prevPageBtn.addEventListener('click', () => this.showPreviousPage());
            }
            if (nextPageBtn) {
                nextPageBtn.addEventListener('click', () => this.showNextPage());
            }

            // Export buttons
            const generatePrintBtn = document.getElementById('generatePrintBtn');
            if (generatePrintBtn) {
                generatePrintBtn.addEventListener('click', () => this.generatePrintFiles());
            }
            
            const generatePrintBtnNew = document.getElementById('generatePrintBtnNew');
            if (generatePrintBtnNew) {
                generatePrintBtnNew.addEventListener('click', () => this.generatePrintFiles());
            }

            // Input change listeners for real-time updates
            const inputs = [
                'paperWidth', 'paperHeight', 'photoWidth', 'photoHeight',
                'marginTop', 'marginBottom', 'marginLeft', 'marginRight',
                'gutterX', 'gutterY'
            ];
            
            inputs.forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('input', () => {
                        console.log(`üîß Input changed: ${id} = ${input.value}`);
                        this.updateConfigFromInputs();
                    });
                } else {
                    console.error(`‚ùå Input not found: ${id}`);
                }
            });
        }

        setupCompactInterface() {
            // Setup preset cards
            // Preset pills click handler
            document.querySelectorAll('.preset-pill[data-preset]').forEach(pill => {
                pill.addEventListener('click', () => {
                    document.querySelectorAll('.preset-pill').forEach(p => p.classList.remove('active'));
                    pill.classList.add('active');

                    const preset = pill.dataset.preset;
                    this.applyPreset(preset);
                });
            });

            // More presets button
            const moreBtn = document.getElementById('morePresetsBtn');
            const expandedPresets = document.getElementById('expandedPresets');
            if (moreBtn && expandedPresets) {
                moreBtn.addEventListener('click', () => {
                    const isExpanded = expandedPresets.style.display !== 'none';
                    expandedPresets.style.display = isExpanded ? 'none' : 'flex';
                    moreBtn.querySelector('.pill-text').textContent = isExpanded ? 'Th√™m' : '·∫®n';
                });
            }

            // Custom presets
            this.loadCustomPresets();
            this.renderCustomPresets();
            const saveCustomPresetBtn = document.getElementById('saveCustomPresetBtn');
            if (saveCustomPresetBtn) {
                saveCustomPresetBtn.addEventListener('click', () => this.saveCurrentCustomPreset());
            }

            // Setup Saved Presets Section
            this.setupSavedPresetsSection();

            // Setup card toggles
            document.querySelectorAll('.card-toggle').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const targetId = toggle.dataset.target;
                    const content = document.getElementById(targetId);
                    if (content) {
                        const isCollapsed = content.classList.contains('collapsed');
                        if (isCollapsed) {
                            content.classList.remove('collapsed');
                            toggle.textContent = '‚ñ≤';
                            toggle.classList.add('expanded');
                        } else {
                            content.classList.add('collapsed');
                            toggle.textContent = '‚ñº';
                            toggle.classList.remove('expanded');
                        }
                    }
                });
            });

            // Setup compact selects
            const paperSizeSelect = document.getElementById('paperSizeSelect');
            if (paperSizeSelect) {
                paperSizeSelect.addEventListener('change', () => {
                    const size = paperSizeSelect.value;
                    this.selectPaperSize(size);
                });
            }

            const photoSizeSelect = document.getElementById('photoSizeSelect');
            if (photoSizeSelect) {
                photoSizeSelect.addEventListener('change', () => {
                    // Prevent infinite loop during sync
                    if (this._syncingDropdowns) {
                        console.log('üîÑ Skipping photoSizeSelect handler during sync');
                        return;
                    }

                    const size = photoSizeSelect.value;
                    this.selectPhotoSize(size);
                });
            }

            const printModeSelect = document.getElementById('printModeSelect');
            if (printModeSelect) {
                printModeSelect.addEventListener('change', () => {
                    const mode = printModeSelect.value;
                    this.printData.config.printMode = mode;
                    this.toggleDuplexInterface(mode === 'duplex');
                    this.calculateLayout();
                });
            }

            // Setup inline duplex flip buttons
            document.querySelectorAll('.flip-btn-inline').forEach(btn => {
                btn.addEventListener('click', () => {
                    console.log('üìñ Flip button inline clicked:', btn.dataset.flip);
                    // Update active state
                    document.querySelectorAll('.flip-btn-inline').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Update config
                    const flip = btn.dataset.flip;
                    this.printData.config.duplexFlip = flip;

                    // Sync with old duplex flip buttons
                    document.querySelectorAll('.flip-btn').forEach(b => {
                        if (b.dataset.flip === flip) {
                            document.querySelectorAll('.flip-btn').forEach(x => x.classList.remove('active'));
                            b.classList.add('active');
                        }
                    });

                    // Update instructions
                    const instructionsInline = document.getElementById('duplexInstructionsInline');
                    if (instructionsInline) {
                        const text = flip === 'long-edge'
                            ? 'In trang l·∫ª ‚Üí L·∫≠t theo c·∫°nh d√†i ‚Üí In trang ch·∫µn'
                            : 'In trang l·∫ª ‚Üí L·∫≠t theo c·∫°nh ng·∫Øn ‚Üí In trang ch·∫µn';
                        instructionsInline.textContent = text;
                    }

                    this.updateMasterCanvas();
                    this.updatePreviewStatus(`ƒê√£ ƒë·ªïi h∆∞·ªõng l·∫≠t: ${flip === 'long-edge' ? 'C·∫°nh d√†i' : 'C·∫°nh ng·∫Øn'}`, 'success');
                });
            });

            // Setup inline bleed toggle
            const backSideBleedToggleInline = document.getElementById('backSideBleedToggleInline');
            const bleedValueInline = document.getElementById('bleedValueInline');
            if (backSideBleedToggleInline && bleedValueInline) {
                backSideBleedToggleInline.addEventListener('change', () => {
                    const enabled = backSideBleedToggleInline.checked;
                    this.printData.config.backSideBleedEnabled = enabled;

                    // Toggle slider visibility/opacity
                    if (enabled) {
                        bleedValueInline.classList.remove('disabled');
                    } else {
                        bleedValueInline.classList.add('disabled');
                    }

                    // Sync with old toggle
                    const oldToggle = document.getElementById('backSideBleedToggle');
                    if (oldToggle) oldToggle.checked = enabled;

                    this.updateMasterCanvas();
                    console.log('üîç Back side bleed enabled:', enabled);
                });
            }

            // Setup inline bleed slider
            const backSideBleedSliderInline = document.getElementById('backSideBleedSliderInline');
            const backSideBleedValueInline = document.getElementById('backSideBleedValueInline');
            if (backSideBleedSliderInline && backSideBleedValueInline) {
                backSideBleedSliderInline.addEventListener('input', () => {
                    const value = parseFloat(backSideBleedSliderInline.value);
                    this.printData.config.backSideBleed = value;
                    backSideBleedValueInline.textContent = `${value.toFixed(2)}mm`;

                    // Sync with old slider
                    const oldSlider = document.getElementById('backSideBleedSlider');
                    const oldValue = document.querySelector('.slider-value');
                    if (oldSlider) oldSlider.value = value;
                    if (oldValue) oldValue.textContent = `${value.toFixed(2)}mm`;

                    this.updateMasterCanvas();
                    console.log('üîç Back side bleed:', value, 'mm');
                });
            }

            // Setup orientation buttons (h·ªó tr·ª£ c·∫£ compact v√† elite)
            document.querySelectorAll('.orient-btn, .orient-btn-elite').forEach(btn => {
                btn.addEventListener('click', () => {
                    console.log('üìê Orientation button clicked:', btn.dataset.orientation);
                    document.querySelectorAll('.orient-btn, .orient-btn-elite').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    const orientation = btn.dataset.orientation;
                    this.printData.config.orientation = orientation;
                    this.calculateLayout();
                    this.updateMasterCanvas();

                    const orientationText = orientation === 'portrait' ? 'D·ªçc' : 'Ngang';
                    this.updatePreviewStatus(`ƒê·ªïi h∆∞·ªõng: ${orientationText}`, 'success');
                });
            });

            // Setup fit buttons
            document.querySelectorAll('.fit-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.fit-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const fit = btn.dataset.fit;
                    this.printData.config.fitMode = fit;
                    this.updatePreview();
                });
            });

            // Setup margin expand button
            const marginExpandBtn = document.getElementById('marginExpandBtn');
            const marginDetailed = document.getElementById('marginDetailed');
            const marginAll = document.getElementById('marginAll');
            
            if (marginExpandBtn && marginDetailed) {
                marginExpandBtn.addEventListener('click', () => {
                    const isVisible = marginDetailed.style.display !== 'none';
                    marginDetailed.style.display = isVisible ? 'none' : 'block';
                    marginExpandBtn.textContent = isVisible ? '‚öô' : '‚úï';
                });
            }

            if (marginAll) {
                marginAll.addEventListener('input', () => {
                    const value = parseInt(marginAll.value);
                    if (!isNaN(value)) {
                        ['marginTop', 'marginBottom', 'marginLeft', 'marginRight'].forEach(id => {
                            const input = document.getElementById(id);
                            if (input) input.value = value;
                        });
                        this.printData.config.margins = { 
                            top: value, bottom: value, left: value, right: value 
                        };
                        this.calculateLayout();
                    }
                });
            }

            // Setup cutting presets
            document.querySelectorAll('.cutting-preset').forEach(preset => {
                preset.addEventListener('click', () => {
                    document.querySelectorAll('.cutting-preset').forEach(p => p.classList.remove('active'));
                    preset.classList.add('active');

                    const cutting = preset.dataset.cutting;
                    this.applyCuttingPreset(cutting);

                    // Sync with preview controls dropdown
                    const cuttingPresetSelect = document.getElementById('cuttingPresetSelect');
                    if (cuttingPresetSelect) {
                        cuttingPresetSelect.value = cutting;
                    }
                });
            });

            // Setup color dots (new compact version)
            document.querySelectorAll('.color-dot').forEach(dot => {
                dot.addEventListener('click', () => {
                    document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
                    dot.classList.add('active');
                    this.printData.config.cuttingGuides.color = dot.dataset.color;
                    this.updateMasterCanvas();
                });
            });

            // Setup export format tabs
            document.querySelectorAll('.format-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.format-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    this.selectedExportFormat = tab.dataset.format;
                });
            });

            // Setup action buttons
            const generatePreviewBtn = document.getElementById('generatePreviewBtn');
            if (generatePreviewBtn) {
                generatePreviewBtn.addEventListener('click', () => {
                    this.generatePreview();
                });
            }

            const resetConfigBtn = document.getElementById('resetConfigBtn');
            if (resetConfigBtn) {
                resetConfigBtn.addEventListener('click', () => {
                    this.resetToDefaults();
                });
            }

            // Setup format tab selection
            document.querySelectorAll('.format-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.format-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                });
            });

            // Setup images toggle button
            const toggleImagesView = document.getElementById('toggleImagesView');
            if (toggleImagesView) {
                toggleImagesView.addEventListener('click', () => {
                    const imagesGrid = document.getElementById('selectedImagesGrid');
                    if (imagesGrid) {
                        const isCollapsed = imagesGrid.style.display === 'none';
                        if (isCollapsed) {
                            imagesGrid.style.display = 'grid';
                            toggleImagesView.textContent = '‚ñº';
                            toggleImagesView.title = 'Thu g·ªçn';
                        } else {
                            imagesGrid.style.display = 'none';
                            toggleImagesView.textContent = '‚ñ∂';
                            toggleImagesView.title = 'M·ªü r·ªông';
                        }
                    }
                });
            }

            // Setup Offset rNcM Controls
            const enableOffsetRncm = document.getElementById('enableOffsetRncm');
            const offsetTableContainer = document.getElementById('offsetTableContainer');

            if (enableOffsetRncm && offsetTableContainer) {
                // Toggle offset table visibility
                enableOffsetRncm.addEventListener('change', () => {
                    const enabled = enableOffsetRncm.checked;
                    offsetTableContainer.style.display = enabled ? 'block' : 'none';

                    // Update print data config
                    if (!this.printData.config.offsetRncm) {
                        this.printData.config.offsetRncm = {
                            enabled: false,
                            data: {}
                        };
                    }
                    this.printData.config.offsetRncm.enabled = enabled;

                    // Save offset data to localStorage
                    this.saveOffsetRncmData();

                    // Re-calculate layout if enabled
                    if (enabled) {
                        this.updatePreviewStatus('ƒê√£ b·∫≠t offset rNcM', 'success');
                    } else {
                        this.updatePreviewStatus('ƒê√£ t·∫Øt offset rNcM', 'info');
                    }
                });

                // Load saved offset data
                this.loadOffsetRncmData();
            }

            // Setup offset input listeners
            document.querySelectorAll('.offset-input-rncm').forEach(input => {
                input.addEventListener('input', () => {
                    const cell = input.dataset.cell;
                    const axis = input.dataset.axis;
                    let value = parseFloat(input.value) || 0;

                    // SK316 VALIDATION: Offset must be in [-1.0mm, +1.0mm]
                    const SK316_MAX_OFFSET = 1.0;
                    const SK316_MIN_OFFSET = -1.0;

                    if (value > SK316_MAX_OFFSET) {
                        value = SK316_MAX_OFFSET;
                        input.value = value;
                        this.updatePreviewStatus(`‚ö†Ô∏è Offset ${cell} ${axis} gi·ªõi h·∫°n t·ªëi ƒëa +1.0mm (SK316 rule)`, 'warning');
                        console.warn(`‚ö†Ô∏è Offset ${cell} ${axis} clamped to +1.0mm`);
                    } else if (value < SK316_MIN_OFFSET) {
                        value = SK316_MIN_OFFSET;
                        input.value = value;
                        this.updatePreviewStatus(`‚ö†Ô∏è Offset ${cell} ${axis} gi·ªõi h·∫°n t·ªëi thi·ªÉu -1.0mm (SK316 rule)`, 'warning');
                        console.warn(`‚ö†Ô∏è Offset ${cell} ${axis} clamped to -1.0mm`);
                    }

                    // Initialize offset data structure if needed
                    if (!this.printData.config.offsetRncm) {
                        this.printData.config.offsetRncm = {
                            enabled: enableOffsetRncm ? enableOffsetRncm.checked : false,
                            data: {}
                        };
                    }

                    if (!this.printData.config.offsetRncm.data[cell]) {
                        this.printData.config.offsetRncm.data[cell] = { x: 0, y: 0 };
                    }

                    this.printData.config.offsetRncm.data[cell][axis] = value;

                    // Validate blade gap (3mm spacing between cards)
                    const isValid = this.validateSK316BladeGap();
                    if (!isValid) {
                        this.updatePreviewStatus(`‚ùå L·ªói: Offset vi ph·∫°m 3mm blade gap! H√£y gi·∫£m offset.`, 'error');
                        input.style.borderColor = '#dc2626';
                        input.style.backgroundColor = '#fef2f2';
                    } else {
                        input.style.borderColor = '';
                        input.style.backgroundColor = '';
                    }

                    // Save to localStorage
                    this.saveOffsetRncmData();

                    console.log(`üìê Offset ${cell} ${axis}: ${value}mm ${isValid ? '‚úì' : '‚úó GAP VIOLATION'}`);
                });
            });

            // Reset button
            const offsetResetBtn = document.getElementById('offsetResetBtn');
            if (offsetResetBtn) {
                offsetResetBtn.addEventListener('click', () => {
                    if (confirm('Reset t·∫•t c·∫£ offset v·ªÅ 0?')) {
                        document.querySelectorAll('.offset-input-rncm').forEach(input => {
                            input.value = 0;
                        });

                        if (this.printData.config.offsetRncm) {
                            this.printData.config.offsetRncm.data = {};
                        }

                        this.saveOffsetRncmData();
                        this.updatePreviewStatus('ƒê√£ reset offset v·ªÅ 0', 'success');
                    }
                });
            }

            // Fill zero button
            const offsetFillZeroBtn = document.getElementById('offsetFillZeroBtn');
            if (offsetFillZeroBtn) {
                offsetFillZeroBtn.addEventListener('click', () => {
                    document.querySelectorAll('.offset-input-rncm').forEach(input => {
                        input.value = 0;
                    });

                    if (this.printData.config.offsetRncm) {
                        this.printData.config.offsetRncm.data = {};
                    }

                    this.saveOffsetRncmData();
                    this.updatePreviewStatus('ƒê√£ ƒëi·ªÅn 0 cho t·∫•t c·∫£ offset', 'success');
                });
            }

            console.log('‚úÖ Compact interface event listeners setup complete');
        }

        setupCuttingGuidesListeners() {
            // Cutting guide checkboxes
            const checkboxes = ['outerCuttingLines', 'betweenImages', 'cornerMarks', 'gridHelperLines'];
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', () => {
                        this.printData.config.cuttingGuides[id] = checkbox.checked;

                        // Sync v·ªõi preview buttons
                        if (id === 'cornerMarks') {
                            const previewBtn = document.getElementById('previewCornerMarks');
                            if (previewBtn) {
                                previewBtn.classList.toggle('active', checkbox.checked);
                            }
                        }

                        this.updateMasterCanvas();
                    });
                }
            });

            // Color selection
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.printData.config.cuttingGuides.color = btn.dataset.color;
                    this.updateMasterCanvas();
                });
            });

            // Thickness selection
            document.querySelectorAll('.thickness-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.thickness-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.printData.config.cuttingGuides.thickness = parseFloat(btn.dataset.thickness);
                    this.updateMasterCanvas();
                });
            });

            // Line style selection
            document.querySelectorAll('.line-style-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.line-style-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.printData.config.cuttingGuides.lineStyle = btn.dataset.style;
                    this.updateMasterCanvas();
                });
            });
        }

        setupPreviewControls() {
            this.previewState = {
                scale: 1,
                showGuides: true,
                showRuler: false,
                showGrid: false,
                viewMode: 'fitWidth'
            };

            // View controls
            const fitToWidthBtn = document.getElementById('fitToWidthBtn');
            const actualSizeBtn = document.getElementById('actualSizeBtn');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');

            if (fitToWidthBtn) fitToWidthBtn.addEventListener('click', () => this.setViewMode('fitWidth'));
            if (actualSizeBtn) actualSizeBtn.addEventListener('click', () => this.setViewMode('actualSize'));
            if (zoomInBtn) zoomInBtn.addEventListener('click', () => this.zoomPreview(1.2));
            if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => this.zoomPreview(0.8));

            // Guide toggles
            const toggleGuides = document.getElementById('toggleGuides');
            const toggleRuler = document.getElementById('toggleRuler');
            const toggleGrid = document.getElementById('toggleGrid');

            if (toggleGuides) {
                toggleGuides.addEventListener('click', () => {
                    this.previewState.showGuides = !this.previewState.showGuides;
                    toggleGuides.classList.toggle('active', this.previewState.showGuides);
                    toggleGuides.textContent = this.previewState.showGuides ? 'ƒê∆∞·ªùng c·∫Øt' : 'T·∫Øt c·∫Øt';
                    this.updateMasterCanvas();
                });
            }

            // Zoom controls (h·ªó tr·ª£ c·∫£ compact v√† elite)
            document.querySelectorAll('.zoom-btn, .zoom-btn-elite').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.zoom-btn, .zoom-btn-elite').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    const zoom = btn.dataset.zoom;
                    if (zoom === 'fit') {
                        this.setViewMode('fitToWidth');
                        this.updatePreviewStatus('ƒêi·ªÅu ch·ªânh v·ª´a m√†n h√¨nh', 'success');
                    } else {
                        this.previewState.scale = parseFloat(zoom);
                        this.updateMasterCanvas();
                        this.updatePreviewStatus(`Thu phong ${Math.round(parseFloat(zoom) * 100)}%`, 'success');
                    }
                });
            });

            // Orientation buttons - ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi event handler chung cho t·∫•t c·∫£ .orient-btn ·ªü tr√™n
            console.log('‚úÖ Orientation buttons s·∫Ω s·ª≠ d·ª•ng event handler chung');

            // Cutting guides toggle (h·ªó tr·ª£ c·∫£ compact v√† elite)
            const cutToggle = document.getElementById('toggleGuides');
            if (cutToggle) {
                cutToggle.addEventListener('click', () => {
                    this.previewState.showGuides = !this.previewState.showGuides;
                    cutToggle.classList.toggle('active', this.previewState.showGuides);

                    // C·∫≠p nh·∫≠t text cho elite toggle
                    if (cutToggle.classList.contains('cut-toggle-elite')) {
                        cutToggle.textContent = this.previewState.showGuides ? 'ON' : 'OFF';
                    }

                    this.updateMasterCanvas();
                    this.updatePreviewStatus(`ƒê∆∞·ªùng c·∫Øt: ${this.previewState.showGuides ? 'B·∫≠t' : 'T·∫Øt'}`, 'success');
                });
            }

            // Cutting types (individual guide controls - h·ªó tr·ª£ c·∫£ compact v√† elite)
            document.querySelectorAll('.cut-type, .cut-type-elite').forEach(btn => {
                btn.addEventListener('click', () => {
                    btn.classList.toggle('active');
                    const type = btn.dataset.type;
                    const isActive = btn.classList.contains('active');

                    switch(type) {
                        case 'outer':
                            this.printData.config.cuttingGuides.outerCuttingLines = isActive;
                            break;
                        case 'between':
                            this.printData.config.cuttingGuides.betweenImages = isActive;
                            break;
                        case 'corner':
                            this.printData.config.cuttingGuides.cornerMarks = isActive;
                            // Sync v·ªõi settings checkbox
                            const settingsCornerMarks = document.getElementById('cornerMarks');
                            if (settingsCornerMarks) {
                                settingsCornerMarks.checked = isActive;
                            }
                            break;
                        case 'grid':
                            this.printData.config.cuttingGuides.gridHelperLines = isActive;
                            break;
                    }
                    this.updateMasterCanvas();

                    const typeNames = {
                        'outer': 'ƒê∆∞·ªùng c·∫Øt ngo√†i',
                        'between': 'ƒê∆∞·ªùng c·∫Øt gi·ªØa',
                        'corner': 'ƒê√°nh d·∫•u g√≥c',
                        'grid': 'L∆∞·ªõi h·ªó tr·ª£'
                    };
                    this.updatePreviewStatus(`${typeNames[type]}: ${isActive ? 'B·∫≠t' : 'T·∫Øt'}`, 'success');
                });
            });

            // Line thickness - g·∫Øn cho c·∫£ hai elements
            const lineThickness = document.getElementById('lineThickness');
            const previewLineThickness = document.getElementById('previewLineThickness');

            [lineThickness, previewLineThickness].forEach(element => {
                if (element) {
                    element.addEventListener('change', (e) => {
                        console.log('üîß Line thickness changed:', e.target.value);
                        this.printData.config.cuttingGuides.thickness = parseFloat(e.target.value);
                        this.updateMasterCanvas();
                        this.updatePreviewStatus(`ƒê·ªô d√†y: ${e.target.value}pt`, 'success');
                    });
                }
            });

            // Paper size - g·∫Øn cho c·∫£ hai elements
            const paperSizeSelect = document.getElementById('paperSizeSelect');
            const previewPaperSize = document.getElementById('previewPaperSize');

            [paperSizeSelect, previewPaperSize].forEach(element => {
                if (element) {
                    element.addEventListener('change', (e) => {
                        console.log('üìÑ Paper size changed:', e.target.value);
                        const size = e.target.value;
                        switch(size) {
                            case 'a4':
                                this.printData.config.paperSize = { width: 210, height: 297 };
                                break;
                            case 'a3':
                                this.printData.config.paperSize = { width: 297, height: 420 };
                                break;
                            case 'letter':
                                this.printData.config.paperSize = { width: 216, height: 279 };
                                break;
                            case '5x7':
                                this.printData.config.paperSize = { width: 127, height: 178 };
                                break;
                            case '4x6':
                                this.printData.config.paperSize = { width: 102, height: 152 };
                                break;
                        }
                        this.calculateLayout();
                        this.updateMasterCanvas();
                        this.updatePreviewStatus(`Kh·ªï gi·∫•y: ${e.target.options[e.target.selectedIndex].text}`, 'success');
                    });
                }
            });

            // Photo size - g·∫Øn cho c·∫£ hai elements
            const photoSizeSelect = document.getElementById('photoSizeSelect');
            const previewPhotoSize = document.getElementById('previewPhotoSize');

            [photoSizeSelect, previewPhotoSize].forEach(element => {
                if (element) {
                    element.addEventListener('change', (e) => {
                        console.log('üñºÔ∏è Photo size changed:', e.target.value);
                        const size = e.target.value;

                        // Prevent infinite loop - check if this is a sync operation
                        if (this._syncingDropdowns) {
                            console.log('üîÑ Skipping previewPhotoSize handler during sync');
                            return;
                        }

                        // Hide/Show custom inputs
                        const customInputs = document.getElementById('previewCustomSizeInputs');

                        if (size === 'custom') {
                            if (customInputs) customInputs.style.display = 'block';
                            // Use custom input values
                            const customWidth = parseFloat(document.getElementById('previewCustomWidth').value) || 5;
                            const customHeight = parseFloat(document.getElementById('previewCustomHeight').value) || 15;
                            this.printData.config.photoSize = { width: customWidth, height: customHeight };
                            this.updatePreviewStatus(`T√πy ch·ªânh: ${customWidth}√ó${customHeight}cm`, 'success');
                        } else {
                            if (customInputs) customInputs.style.display = 'none';

                            switch(size) {
                                case '5.5x8.5':
                                    this.printData.config.photoSize = { width: 5.5, height: 8.5 };
                                    break;
                                case '4.74x6.6':
                                    this.printData.config.photoSize = { width: 4.74, height: 6.6 };
                                    break;
                                case '6x9':
                                    this.printData.config.photoSize = { width: 6, height: 9 };
                                    break;
                                case '9.5x9.5':
                                    this.printData.config.photoSize = { width: 9.5, height: 9.5 };
                                    break;
                                case '5x15':
                                    this.printData.config.photoSize = { width: 5, height: 15 };
                                    break;
                                case '5x7.5':
                                    this.printData.config.photoSize = { width: 5, height: 7.5 };
                                    break;
                                case '4x6':
                                    this.printData.config.photoSize = { width: 4, height: 6 };
                                    break;
                            }
                            this.updatePreviewStatus(`K√≠ch th∆∞·ªõc ·∫£nh: ${e.target.options[e.target.selectedIndex].text}`, 'success');
                        }

                        // Sync v·ªõi photoSizeSelect dropdown
                        const photoSizeSelect = document.getElementById('photoSizeSelect');
                        if (photoSizeSelect && photoSizeSelect.value !== size) {
                            this._syncingDropdowns = true;
                            photoSizeSelect.value = size;
                            console.log('üîÑ Synced photoSizeSelect to:', size);
                            setTimeout(() => {
                                this._syncingDropdowns = false;
                            }, 100);
                        }

                        console.log('üìè Photo size updated:', this.printData.config.photoSize);
                        this.calculateLayout();
                        this.updateMasterCanvas();
                    });
                }
            });

            // Preview custom size input handlers
            const previewCustomWidth = document.getElementById('previewCustomWidth');
            const previewCustomHeight = document.getElementById('previewCustomHeight');

            [previewCustomWidth, previewCustomHeight].forEach(element => {
                if (element) {
                    element.addEventListener('input', (e) => {
                        const previewPhotoSize = document.getElementById('previewPhotoSize');
                        if (previewPhotoSize && previewPhotoSize.value === 'custom') {
                            const customWidth = parseFloat(document.getElementById('previewCustomWidth').value) || 5;
                            const customHeight = parseFloat(document.getElementById('previewCustomHeight').value) || 15;

                            // Sync v·ªõi photoWidth v√† photoHeight
                            const photoWidth = document.getElementById('photoWidth');
                            const photoHeight = document.getElementById('photoHeight');
                            if (photoWidth) photoWidth.value = customWidth;
                            if (photoHeight) photoHeight.value = customHeight;

                            console.log('üìè Custom size updated:', customWidth, 'x', customHeight);
                            this.printData.config.photoSize = { width: customWidth, height: customHeight };
                            this.calculateLayout();
                            this.updateMasterCanvas();
                            this.updatePreviewStatus(`T√πy ch·ªânh: ${customWidth}√ó${customHeight}cm`, 'success');
                        }
                    });
                }
            });

            // Header action buttons
            const previewRefresh = document.getElementById('previewRefresh');
            if (previewRefresh) {
                previewRefresh.addEventListener('click', () => {
                    this.updateMasterCanvas();
                    this.updatePreviewStatus('ƒê√£ l√†m m·ªõi', 'success');
                });
            }

            const quickExport = document.getElementById('quickExport');
            if (quickExport) {
                quickExport.addEventListener('click', () => {
                    this.generateJPGPagesZip();
                });
            }

            const previewSettings = document.getElementById('previewSettings');
            if (previewSettings) {
                previewSettings.addEventListener('click', () => {
                    // Toggle advanced settings
                    const advancedSettings = document.getElementById('advanced-settings');
                    if (advancedSettings) {
                        const isCollapsed = advancedSettings.classList.contains('collapsed');
                        advancedSettings.classList.toggle('collapsed');
                        const toggleBtn = document.querySelector('[data-target="advanced-settings"]');
                        if (toggleBtn) {
                            toggleBtn.textContent = isCollapsed ? '‚ñ≤' : '‚ñº';
                        }
                    }
                });
            }

            if (toggleRuler) {
                toggleRuler.addEventListener('click', () => {
                    this.previewState.showRuler = !this.previewState.showRuler;
                    toggleRuler.classList.toggle('active', this.previewState.showRuler);
                    this.updateRulerDisplay();
                });
            }

            if (toggleGrid) {
                toggleGrid.addEventListener('click', () => {
                    this.previewState.showGrid = !this.previewState.showGrid;
                    toggleGrid.classList.toggle('active', this.previewState.showGrid);
                    this.updateGridDisplay();
                });
            }
        }

        setViewMode(mode) {
            // Update active button
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            
            this.previewState.viewMode = mode;
            
            switch(mode) {
                case 'fitWidth':
                    document.getElementById('fitToWidthBtn').classList.add('active');
                    this.fitPreviewToWidth();
                    break;
                case 'actualSize':
                    document.getElementById('actualSizeBtn').classList.add('active');
                    this.setPreviewScale(1);
                    break;
            }
        }

        fitPreviewToWidth() {
            const container = document.getElementById('canvasContainer');
            const canvas = document.getElementById('printCanvas');
            if (!container || !canvas) return;

            const containerWidth = container.parentElement.clientWidth - 40; // Padding

            // Use master canvas width if available, otherwise calculate from config
            let canvasWidth;
            if (this.printData.masterCanvas) {
                canvasWidth = this.printData.masterCanvas.width;
            } else {
                // Calculate width from current paper size and orientation
                const config = this.printData.config;
                const dpi = 96; // Standard web DPI
                const mmToPx = dpi / 25.4;
                const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
                canvasWidth = Math.round(paperWidthMm * mmToPx);
            }

            const scale = Math.min(containerWidth / canvasWidth, 1);
            this.setPreviewScale(scale);
        }

        setPreviewScale(scale) {
            this.previewState.scale = Math.max(0.1, Math.min(scale, 3)); // Limit scale between 10% and 300%

            // Update preview - use master canvas if available, otherwise layout preview
            if (this.printData.masterCanvas) {
                this.updatePreviewFromMaster();
            } else {
                this.updatePreviewLayout();
            }
            this.updatePreviewInfo();
        }

        zoomPreview(factor) {
            const newScale = this.previewState.scale * factor;
            this.setPreviewScale(newScale);
        }

        updatePreviewInfo() {
            const config = this.printData.config;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            // Update preview stats
            const dimensionsEl = document.getElementById('previewDimensions');
            const dpiEl = document.getElementById('previewDPI');
            const imageCountEl = document.getElementById('previewImageCount');
            const scaleEl = document.getElementById('previewScale');

            if (dimensionsEl) dimensionsEl.textContent = `${paperWidthMm}√ó${paperHeightMm}mm`;
            if (dpiEl) dpiEl.textContent = `${config.dpi} DPI`;
            if (imageCountEl) {
                const imagesOnPage = Math.min(
                    this.printData.selectedImages.length - this.printData.currentPage * this.printData.maxPhotosPerPage,
                    this.printData.maxPhotosPerPage
                );
                imageCountEl.textContent = `${imagesOnPage} ·∫£nh`;
            }
            if (scaleEl) scaleEl.textContent = `${Math.round(this.previewState.scale * 100)}%`;
        }

        updateRulerDisplay() {
            const rulerH = document.getElementById('rulerHorizontal');
            const rulerV = document.getElementById('rulerVertical');
            
            if (rulerH && rulerV) {
                const display = this.previewState.showRuler ? 'block' : 'none';
                rulerH.style.display = display;
                rulerV.style.display = display;
                
                if (this.previewState.showRuler) {
                    this.drawRulers();
                }
            }
        }

        updateGridDisplay() {
            // Grid will be drawn on canvas overlay
            this.updateCanvasOverlay();
        }

        drawRulers() {
            const config = this.printData.config;
            const canvas = document.getElementById('printCanvas');
            if (!canvas) return;

            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            // Create ruler markings based on canvas size and scale
            const rulerH = document.getElementById('rulerHorizontal');
            const rulerV = document.getElementById('rulerVertical');
            
            if (rulerH && rulerV) {
                rulerH.innerHTML = this.generateRulerMarks(paperWidthMm, canvas.width, 'horizontal');
                rulerV.innerHTML = this.generateRulerMarks(paperHeightMm, canvas.height, 'vertical');
            }
        }

        generateRulerMarks(sizeMm, sizePx, orientation) {
            const stepMm = 10; // 10mm increments
            const steps = Math.ceil(sizeMm / stepMm);
            let html = '';
            
            for (let i = 0; i <= steps; i++) {
                const mm = i * stepMm;
                const position = (mm / sizeMm) * 100;
                
                if (orientation === 'horizontal') {
                    html += `<div style="position: absolute; left: ${position}%; top: 0; height: 100%; border-left: 1px solid #9ca3af; font-size: 8px; padding-left: 2px;">${mm}</div>`;
                } else {
                    html += `<div style="position: absolute; top: ${position}%; left: 0; width: 100%; border-top: 1px solid #9ca3af; font-size: 8px; padding-top: 1px; writing-mode: vertical-rl;">${mm}</div>`;
                }
            }
            
            return html;
        }

        updateCanvasOverlay() {
            const overlay = document.getElementById('canvasOverlay');
            if (!overlay || !this.previewState.showGrid) {
                if (overlay) overlay.innerHTML = '';
                return;
            }

            // Draw grid pattern
            const canvas = document.getElementById('printCanvas');
            if (!canvas) return;

            const gridSize = 20; // 20px grid
            let html = '';
            
            for (let x = 0; x < canvas.width; x += gridSize) {
                html += `<div style="position: absolute; left: ${x}px; top: 0; bottom: 0; width: 1px; background: rgba(156, 163, 175, 0.3);"></div>`;
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                html += `<div style="position: absolute; top: ${y}px; left: 0; right: 0; height: 1px; background: rgba(156, 163, 175, 0.3);"></div>`;
            }
            
            overlay.innerHTML = html;
        }

        setupDuplexControls() {
            // Print mode radio buttons
            const singleSide = document.getElementById('singleSide');
            const duplexManual = document.getElementById('duplexManual');
            const duplexOptions = document.getElementById('duplexOptions');

            if (singleSide) {
                singleSide.addEventListener('change', () => {
                    if (singleSide.checked) {
                        this.printData.config.printMode = 'single';
                        if (duplexOptions) duplexOptions.style.display = 'none';
                        this.hideDuplexMode();
                        this.updateDuplexInstructions();
                    }
                });
            }

            if (duplexManual) {
                duplexManual.addEventListener('change', () => {
                    if (duplexManual.checked) {
                        this.printData.config.printMode = 'duplex';
                        if (duplexOptions) duplexOptions.style.display = 'block';
                        this.showDuplexMode();
                        this.updateDuplexInstructions();
                    }
                });
            }

            // Flip direction buttons
            document.querySelectorAll('.flip-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.flip-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.printData.config.duplexFlip = btn.dataset.flip;
                    this.updateDuplexInstructions();
                });
            });

            // Back Side Bleed Controls
            this.setupBackSideBleedControls();

            // Side toggle buttons for duplex preview
            const frontSideBtn = document.getElementById('frontSideBtn');
            const backSideBtn = document.getElementById('backSideBtn');

            if (frontSideBtn) {
                frontSideBtn.addEventListener('click', () => {
                    this.switchSide('front');
                });
            }

            if (backSideBtn) {
                backSideBtn.addEventListener('click', () => {
                    this.switchSide('back');
                });
            }

            // ‚öôÔ∏è Duplex Physical Offset Controls
            this.setupDuplexOffsetControls();
        }

        setupDuplexOffsetControls() {
            const offsetXInput = document.getElementById('duplexOffsetX');
            const offsetYInput = document.getElementById('duplexOffsetY');
            const calibrationBtn = document.getElementById('calibrationTestBtn');

            // Load saved offset from localStorage
            const savedOffsetX = localStorage.getItem('duplexPhysicalOffsetX');
            const savedOffsetY = localStorage.getItem('duplexPhysicalOffsetY');

            if (savedOffsetX !== null) {
                this.printData.config.duplexPhysicalOffset.x = parseFloat(savedOffsetX);
                if (offsetXInput) offsetXInput.value = savedOffsetX;
            }
            if (savedOffsetY !== null) {
                this.printData.config.duplexPhysicalOffset.y = parseFloat(savedOffsetY);
                if (offsetYInput) offsetYInput.value = savedOffsetY;
            }

            // Offset X input
            if (offsetXInput) {
                offsetXInput.addEventListener('input', () => {
                    const value = parseFloat(offsetXInput.value) || 0;
                    this.printData.config.duplexPhysicalOffset.x = value;
                    localStorage.setItem('duplexPhysicalOffsetX', value);

                    // Re-render duplex canvases
                    if (this.printData.config.printMode === 'duplex') {
                        this.renderDuplexCanvas('back');
                        this.showToast(`üìè Offset X: ${value.toFixed(1)}mm`, 'info');
                    }
                });
            }

            // Offset Y input
            if (offsetYInput) {
                offsetYInput.addEventListener('input', () => {
                    const value = parseFloat(offsetYInput.value) || 0;
                    this.printData.config.duplexPhysicalOffset.y = value;
                    localStorage.setItem('duplexPhysicalOffsetY', value);

                    // Re-render duplex canvases
                    if (this.printData.config.printMode === 'duplex') {
                        this.renderDuplexCanvas('back');
                        this.showToast(`üìè Offset Y: ${value.toFixed(1)}mm`, 'info');
                    }
                });
            }

            // Calibration test button
            if (calibrationBtn) {
                calibrationBtn.addEventListener('click', () => {
                    this.generateCalibrationTest();
                });
            }

        }

        setupBackSideBleedControls() {
            const toggle = document.getElementById('backSideBleedToggle');
            const slider = document.getElementById('backSideBleedSlider');
            const valueDisplay = document.getElementById('backSideBleedValue');
            const sliderContainer = document.getElementById('bleedSliderContainer');

            if (!toggle || !slider || !valueDisplay) return;

            // Load saved settings from localStorage
            const savedEnabled = localStorage.getItem('backSideBleedEnabled');
            const savedValue = localStorage.getItem('backSideBleedValue');

            if (savedEnabled !== null) {
                const enabled = savedEnabled === 'true';
                toggle.checked = enabled;
                this.printData.config.backSideBleedEnabled = enabled;
                if (sliderContainer) {
                    sliderContainer.classList.toggle('disabled', !enabled);
                }
            }

            if (savedValue !== null) {
                const value = parseFloat(savedValue);
                slider.value = value;
                this.printData.config.backSideBleed = value;
                valueDisplay.textContent = `${value}mm`;
            }

            // Toggle event
            toggle.addEventListener('change', () => {
                const enabled = toggle.checked;
                this.printData.config.backSideBleedEnabled = enabled;

                // Save to localStorage
                localStorage.setItem('backSideBleedEnabled', enabled);

                // Toggle slider container
                if (sliderContainer) {
                    sliderContainer.classList.toggle('disabled', !enabled);
                }

                // Show notification
                if (enabled) {
                    this.showToast('‚úÖ ƒê√£ b·∫≠t bleed m·∫∑t sau - Tr√°nh l·ªô vi·ªÅn tr·∫Øng', 'success');
                } else {
                    this.showToast('‚ö†Ô∏è ƒê√£ t·∫Øt bleed - ·∫¢nh m·∫∑t sau kh√¥ng ph√≥ng to', 'info');
                }

                // Update preview if in duplex mode
                if (this.printData.config.printMode === 'duplex') {
                    this.updatePreview();
                }
            });

            // Slider event
            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                this.printData.config.backSideBleed = value;
                valueDisplay.textContent = `${value}mm`;

                // Save to localStorage
                localStorage.setItem('backSideBleedValue', value);

                // Update preview in real-time
                if (this.printData.config.printMode === 'duplex' && this.printData.config.backSideBleedEnabled) {
                    this.updatePreview();
                }
            });

            // Show value tooltip on hover
            slider.addEventListener('mouseenter', () => {
                const value = parseFloat(slider.value);
                const percentage = ((value - 0.1) / 0.9 * 100).toFixed(0);
                const description = value < 0.25 ? '√çt' : value < 0.4 ? 'Trung b√¨nh' : value < 0.7 ? 'Nhi·ªÅu' : 'R·∫•t nhi·ªÅu';
                this.showToast(`üìè Bleed: ${value}mm (${description})`, 'info', 2000);
            });
        }

        updateDuplexInstructions() {
            const instructionsEl = document.getElementById('duplexInstructions');
            if (!instructionsEl) return;

            const config = this.printData.config;
            
            if (config.printMode === 'single') {
                instructionsEl.innerHTML = 'In th√¥ng th∆∞·ªùng tr√™n 1 m·∫∑t gi·∫•y';
                return;
            }

            const isPortrait = config.orientation === 'portrait';
            const isLongEdge = config.duplexFlip === 'long-edge';
            
            let instructions = '';
            
            if (isPortrait) {
                if (isLongEdge) {
                    instructions = `
                        1. In t·∫•t c·∫£ trang l·∫ª (m·∫∑t tr∆∞·ªõc)<br>
                        2. L·∫≠t gi·∫•y theo c·∫°nh d√†i (tr√°i-ph·∫£i)<br>
                        3. ƒê·∫∑t l·∫°i v√†o khay in v·ªõi m·∫∑t tr·ªëng h∆∞·ªõng xu·ªëng<br>
                        4. In t·∫•t c·∫£ trang ch·∫µn (m·∫∑t sau)
                    `;
                } else {
                    instructions = `
                        1. In t·∫•t c·∫£ trang l·∫ª (m·∫∑t tr∆∞·ªõc)<br>
                        2. L·∫≠t gi·∫•y theo c·∫°nh ng·∫Øn (tr√™n-d∆∞·ªõi)<br>
                        3. ƒê·∫∑t l·∫°i v√†o khay in v·ªõi m·∫∑t tr·ªëng h∆∞·ªõng xu·ªëng<br>
                        4. In t·∫•t c·∫£ trang ch·∫µn (m·∫∑t sau)
                    `;
                }
            } else {
                if (isLongEdge) {
                    instructions = `
                        1. In t·∫•t c·∫£ trang l·∫ª (m·∫∑t tr∆∞·ªõc)<br>
                        2. L·∫≠t gi·∫•y theo c·∫°nh d√†i (tr√™n-d∆∞·ªõi)<br>
                        3. ƒê·∫∑t l·∫°i v√†o khay in v·ªõi m·∫∑t tr·ªëng h∆∞·ªõng xu·ªëng<br>
                        4. In t·∫•t c·∫£ trang ch·∫µn (m·∫∑t sau)
                    `;
                } else {
                    instructions = `
                        1. In t·∫•t c·∫£ trang l·∫ª (m·∫∑t tr∆∞·ªõc)<br>
                        2. L·∫≠t gi·∫•y theo c·∫°nh ng·∫Øn (tr√°i-ph·∫£i)<br>
                        3. ƒê·∫∑t l·∫°i v√†o khay in v·ªõi m·∫∑t tr·ªëng h∆∞·ªõng xu·ªëng<br>
                        4. In t·∫•t c·∫£ trang ch·∫µn (m·∫∑t sau)
                    `;
                }
            }
            
            // Add coordinate mirroring information
            instructions += `<br><br><strong>üîÑ T·ªça ƒë·ªô ngh·ªãch ƒë·∫£o:</strong> M·∫∑t sau mirror ho√†n to√†n qua ${isLongEdge ? 'tr·ª•c d·ªçc' : 'tr·ª•c ngang'}`;
            
            instructionsEl.innerHTML = instructions;
        }

        // Duplex Mode Management
        async showDuplexMode() {
            console.log('üîç showDuplexMode called');

            // Prevent duplicate calls
            if (this._duplexModeInitialized) {
                console.log('‚ö†Ô∏è Duplex mode already initialized, skipping...');
                return;
            }
            this._duplexModeInitialized = true;

            // === NEW: Use Unified Workspace instead of legacy duplex section ===
            const unifiedWorkspace = document.getElementById('duplexUnifiedWorkspace');
            const duplexControls = document.getElementById('duplexPreviewControls');
            const duplexSection = document.getElementById('duplexClassificationSection'); // Legacy section
            const singleCanvasContainer = document.getElementById('canvasContainer');
            const duplexCanvasContainer = document.getElementById('duplexCanvasContainer');

            console.log('üîç Duplex elements found:', {
                unifiedWorkspace: !!unifiedWorkspace,
                duplexControls: !!duplexControls,
                duplexSection: !!duplexSection,
                singleCanvasContainer: !!singleCanvasContainer,
                duplexCanvasContainer: !!duplexCanvasContainer
            });

            console.log('üîç Gallery images available:', this.galleryImages ? this.galleryImages.length : 'undefined');

            // === SHOW UNIFIED WORKSPACE instead of legacy ===
            if (unifiedWorkspace) {
                unifiedWorkspace.style.display = 'block';
                console.log('‚úÖ Unified Workspace displayed');
            } else {
                console.error('‚ùå unifiedWorkspace not found!');
            }

            // Hide legacy duplex section
            if (duplexSection) {
                duplexSection.style.display = 'none';
                console.log('‚úÖ Legacy duplexSection hidden');
            }

            if (duplexControls) {
                duplexControls.style.display = 'none'; // Hide old controls, use unified controls
                console.log('‚úÖ Legacy duplexControls hidden');
            }

            // Hide legacy duplex distribution section
            const duplexDistSection = document.getElementById('duplexDistributionSection');
            if (duplexDistSection) {
                duplexDistSection.style.display = 'none';
                console.log('‚úÖ Legacy duplexDistributionSection hidden');
            }

            // Switch to dual canvas layout
            if (singleCanvasContainer) {
                singleCanvasContainer.style.display = 'none';
                console.log('‚úÖ singleCanvasContainer hidden');
            }
            if (duplexCanvasContainer) {
                duplexCanvasContainer.style.display = 'flex';
                console.log('‚úÖ duplexCanvasContainer displayed with flex');
                console.log('üîç duplexCanvasContainer computed style:', window.getComputedStyle(duplexCanvasContainer).display);
            } else {
                console.error('‚ùå duplexCanvasContainer not found!');
            }

            // === Initialize Unified Workspace ===
            this.initUnifiedDuplexWorkspace();

            // Keep legacy functions for compatibility
            this.initializeDuplexClassification();
            this.setupDuplexClassificationListeners();

            // Hide old selectedImages section and show gallery grid for duplex
            const selectedImagesContainer = document.getElementById('selectedImagesContainer');
            if (selectedImagesContainer) selectedImagesContainer.style.display = 'none';

            // ‚úÖ FIX: ·∫®n dragDropZone (single-side) v√† hi·ªán duplexUploadZone
            const dragDropZone = document.getElementById('dragDropZone');
            const duplexUploadZone = document.getElementById('duplexUploadZone');
            if (dragDropZone) {
                dragDropZone.style.display = 'none';
                console.log('‚úÖ dragDropZone hidden (duplex mode)');
            }
            if (duplexUploadZone) {
                duplexUploadZone.style.display = 'flex';
                console.log('‚úÖ duplexUploadZone shown (duplex mode)');
            }

            // === V2: Initialize duplex mode ===
            // === FIX: Auto-sync files to gallery if gallery is empty ===
            if (this.galleryImages.length === 0 && this.files && this.files.length > 0) {
                console.log('üîÑ Auto-syncing files to gallery:', this.files.length, 'files');
                this.files.forEach(fileData => {
                    if (fileData.file && fileData.file.type && fileData.file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const galleryItem = {
                                id: fileData.id || (Date.now() + Math.random()),
                                data: e.target.result,
                                filename: fileData.name || fileData.file.name,
                                timestamp: new Date().toISOString(),
                                size: fileData.size || fileData.file.size,
                                type: 'uploaded'
                            };
                            this.galleryImages.push(galleryItem);
                            console.log('‚úÖ Added to gallery:', galleryItem.filename);
                        };
                        reader.readAsDataURL(fileData.file);
                    }
                });

                // Wait a bit for all files to be processed
                await new Promise(resolve => setTimeout(resolve, 500));
                console.log('‚úÖ Gallery now has', this.galleryImages.length, 'images');
            }

            // Set mode FIRST before doing anything else
            this.duplexCurrentMode = 'front';
            this.selectionType = 'front';
            this.selectionMode = true;

            console.log('üéØ Initialized duplex mode state:', {
                duplexCurrentMode: this.duplexCurrentMode,
                selectionType: this.selectionType,
                selectionMode: this.selectionMode,
                galleryCount: this.galleryImages.length
            });

            // Populate gallery grid and update UI (wait longer for auto-sync)
            setTimeout(() => {
                // Setup toggle buttons FIRST
                const toggleBtns = document.querySelectorAll('.toggle-switch-btn');
                toggleBtns.forEach(btn => {
                    if (btn.dataset.mode === 'front') {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });

                // Update hint
                const hintEl = document.getElementById('toggleHint');
                if (hintEl) {
                    hintEl.textContent = 'Click ·∫£nh b√™n tr√°i ƒë·ªÉ th√™m v√†o m·∫∑t tr∆∞·ªõc';
                }

                // Update gallery and classification
                this.updateGalleryGridDuplexV2();
                this.updateClassificationDisplay();
                this.updateDuplexValidation();

                // Save initial state AFTER everything is ready
                this.saveDuplexHistory();

                console.log('‚úÖ Duplex UI initialized');
            }, 700); // Wait for auto-sync to complete (500ms + buffer)

            this.updateDuplexPreview();

            console.log('‚úÖ showDuplexMode V2 completed');
        }

        hideDuplexMode() {
            console.log('üö™ hideDuplexMode called');

            // Reset initialization flag
            this._duplexModeInitialized = false;

            const unifiedWorkspace = document.getElementById('duplexUnifiedWorkspace');
            const duplexControls = document.getElementById('duplexPreviewControls');
            const duplexSection = document.getElementById('duplexClassificationSection');
            const singleCanvasContainer = document.getElementById('canvasContainer');
            const duplexCanvasContainer = document.getElementById('duplexCanvasContainer');

            // Hide Unified Workspace
            if (unifiedWorkspace) {
                unifiedWorkspace.style.display = 'none';
                console.log('‚úÖ Unified Workspace hidden');
            }

            if (duplexControls) duplexControls.style.display = 'none';
            if (duplexSection) duplexSection.style.display = 'none';

            // Switch back to single canvas layout
            if (singleCanvasContainer) singleCanvasContainer.style.display = 'flex';
            if (duplexCanvasContainer) duplexCanvasContainer.style.display = 'none';

            // Show back selectedImages section and clear gallery grid duplex
            const selectedImagesContainer = document.getElementById('selectedImagesContainer');
            if (selectedImagesContainer) selectedImagesContainer.style.display = 'block';

            // ‚úÖ FIX: Hi·ªán dragDropZone (single-side) v√† ·∫©n duplexUploadZone
            const dragDropZone = document.getElementById('dragDropZone');
            const duplexUploadZone = document.getElementById('duplexUploadZone');
            if (dragDropZone) {
                dragDropZone.style.display = 'flex';
                console.log('‚úÖ dragDropZone shown (single mode)');
            }
            if (duplexUploadZone) {
                duplexUploadZone.style.display = 'none';
                console.log('‚úÖ duplexUploadZone hidden (single mode)');
            }

            // Clear gallery grid duplex
            this.clearGalleryGridDuplex();

            this.printData.config.printMode = 'single';
            this.exitDuplexClassification();
        }

        initializeDuplexClassification() {
            // Initialize classification arrays if not exists or if they are objects
            if (!this.printData.frontImages || !Array.isArray(this.printData.frontImages)) {
                this.printData.frontImages = [];
            }
            if (!this.printData.backImages || !Array.isArray(this.printData.backImages)) {
                this.printData.backImages = [];
            }
            
            console.log('Duplex classification initialized:', {
                frontImages: this.printData.frontImages,
                backImages: this.printData.backImages
            });
            
            this.updateDuplexStats();
            this.updateClassificationDisplay();
        }

        setupDuplexClassificationListeners() {
            console.log('üéØ setupDuplexClassificationListeners V2 called');

            // === V2: Toggle Mode Switch (replaces 3 buttons) ===
            const toggleBtns = document.querySelectorAll('.toggle-switch-btn');
            toggleBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    this.switchDuplexMode(mode);
                });
            });

            // === V2: Quick Actions ===
            // Undo
            const undoBtn = document.getElementById('undoDuplexBtn');
            if (undoBtn) {
                undoBtn.addEventListener('click', () => this.undoDuplexAction());
            }

            // Redo
            const redoBtn = document.getElementById('redoDuplexBtn');
            if (redoBtn) {
                redoBtn.addEventListener('click', () => this.redoDuplexAction());
            }

            // Swap
            const swapBtn = document.getElementById('swapDuplexBtn');
            if (swapBtn) {
                swapBtn.addEventListener('click', () => this.swapDuplexSides());
            }

            // Clear All
            const clearAllBtn = document.getElementById('clearAllDuplexBtn');
            if (clearAllBtn) {
                clearAllBtn.addEventListener('click', () => this.clearAllDuplex());
            }

            // Balance
            const balanceBtn = document.getElementById('balanceDuplexBtn');
            if (balanceBtn) {
                balanceBtn.addEventListener('click', () => this.balanceDuplexImages());
            }

            // Clear Side Buttons
            const clearFrontBtn = document.getElementById('clearFrontBtn');
            const clearBackBtn = document.getElementById('clearBackBtn');

            if (clearFrontBtn) {
                clearFrontBtn.addEventListener('click', () => {
                    this.saveDuplexHistory();
                    this.clearClassifiedImages('front');
                });
            }

            if (clearBackBtn) {
                clearBackBtn.addEventListener('click', () => {
                    this.saveDuplexHistory();
                    this.clearClassifiedImages('back');
                });
            }

            console.log('‚úÖ setupDuplexClassificationListeners V2 completed');
        }

        // === V2: Switch Duplex Mode (Toggle) ===
        switchDuplexMode(mode) {
            console.log('üîÑ switchDuplexMode called - Switching to:', mode);

            this.duplexCurrentMode = mode;
            this.selectionType = mode;
            this.selectionMode = true; // Enable selection mode

            console.log('üìç Mode state:', {
                duplexCurrentMode: this.duplexCurrentMode,
                selectionType: this.selectionType,
                selectionMode: this.selectionMode
            });

            // Update toggle buttons UI
            const toggleBtns = document.querySelectorAll('.toggle-switch-btn');
            console.log('üéõÔ∏è Found toggle buttons:', toggleBtns.length);

            toggleBtns.forEach(btn => {
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update hint
            const hintEl = document.getElementById('toggleHint');
            if (hintEl) {
                const hints = {
                    front: 'Click ·∫£nh b√™n tr√°i ƒë·ªÉ th√™m v√†o m·∫∑t tr∆∞·ªõc',
                    back: 'Click ·∫£nh b√™n tr√°i ƒë·ªÉ th√™m v√†o m·∫∑t sau'
                };
                hintEl.textContent = hints[mode];
                console.log('üí¨ Hint updated:', hints[mode]);
            }

            // Update gallery grid
            this.updateGalleryGridDuplexV2();

            console.log('‚úÖ switchDuplexMode completed');
        }

        // === V2: Undo/Redo Functions ===
        saveDuplexHistory() {
            // Ensure printData exists
            if (!this.printData) {
                console.warn('‚ö†Ô∏è Cannot save history: printData not initialized');
                return;
            }

            // Ensure arrays exist
            if (!this.printData.frontImages) this.printData.frontImages = [];
            if (!this.printData.backImages) this.printData.backImages = [];

            // Save current state to history
            const state = {
                frontImages: JSON.parse(JSON.stringify(this.printData.frontImages)),
                backImages: JSON.parse(JSON.stringify(this.printData.backImages))
            };

            // Remove any future history if we're not at the end
            if (this.duplexHistoryIndex < this.duplexHistory.length - 1) {
                this.duplexHistory = this.duplexHistory.slice(0, this.duplexHistoryIndex + 1);
            }

            // Add new state
            this.duplexHistory.push(state);
            this.duplexHistoryIndex++;

            // Limit history size
            if (this.duplexHistory.length > this.maxHistorySize) {
                this.duplexHistory.shift();
                this.duplexHistoryIndex--;
            }

            this.updateUndoRedoButtons();
            console.log('üíæ Saved duplex history', this.duplexHistoryIndex, '/', this.duplexHistory.length);
        }

        undoDuplexAction() {
            if (this.duplexHistoryIndex > 0) {
                this.duplexHistoryIndex--;
                const state = this.duplexHistory[this.duplexHistoryIndex];
                this.printData.frontImages = JSON.parse(JSON.stringify(state.frontImages));
                this.printData.backImages = JSON.parse(JSON.stringify(state.backImages));
                this.updateDuplexStats();
                this.updateClassificationDisplay();
                this.updateGalleryGridDuplexV2();
                this.updateUndoRedoButtons();
                this.showToast('‚Ü©Ô∏è ƒê√£ ho√†n t√°c', 'success');
                console.log('‚Ü©Ô∏è Undo to', this.duplexHistoryIndex);
            }
        }

        redoDuplexAction() {
            if (this.duplexHistoryIndex < this.duplexHistory.length - 1) {
                this.duplexHistoryIndex++;
                const state = this.duplexHistory[this.duplexHistoryIndex];
                this.printData.frontImages = JSON.parse(JSON.stringify(state.frontImages));
                this.printData.backImages = JSON.parse(JSON.stringify(state.backImages));
                this.updateDuplexStats();
                this.updateClassificationDisplay();
                this.updateGalleryGridDuplexV2();
                this.updateUndoRedoButtons();
                this.showToast('‚Ü™Ô∏è ƒê√£ l√†m l·∫°i', 'success');
                console.log('‚Ü™Ô∏è Redo to', this.duplexHistoryIndex);
            }
        }

        updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoDuplexBtn');
            const redoBtn = document.getElementById('redoDuplexBtn');

            if (undoBtn) {
                undoBtn.disabled = this.duplexHistoryIndex <= 0;
            }
            if (redoBtn) {
                redoBtn.disabled = this.duplexHistoryIndex >= this.duplexHistory.length - 1;
            }
        }

        // === V2: Quick Actions ===
        swapDuplexSides() {
            if (!this.printData.frontImages && !this.printData.backImages) {
                this.showToast('‚ö†Ô∏è Ch∆∞a c√≥ ·∫£nh n√†o ƒë·ªÉ swap!', 'error');
                return;
            }

            this.saveDuplexHistory();

            // Swap
            const temp = this.printData.frontImages;
            this.printData.frontImages = this.printData.backImages;
            this.printData.backImages = temp;

            this.updateDuplexStats();
            this.updateClassificationDisplay();
            this.updateGalleryGridDuplexV2();
            this.showToast('üîÑ ƒê√£ ƒë·ªïi m·∫∑t tr∆∞·ªõc ‚Üî m·∫∑t sau', 'success');
        }

        clearAllDuplex() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ ·∫£nh ƒë√£ ph√¢n lo·∫°i?')) {
                return;
            }

            this.saveDuplexHistory();

            this.printData.frontImages = [];
            this.printData.backImages = [];

            this.updateDuplexStats();
            this.updateClassificationDisplay();
            this.updateGalleryGridDuplexV2();
            this.showToast('üßπ ƒê√£ x√≥a t·∫•t c·∫£', 'success');
        }

        balanceDuplexImages() {
            const frontCount = this.printData.frontImages?.length || 0;
            const backCount = this.printData.backImages?.length || 0;

            if (frontCount === 0 && backCount === 0) {
                this.showToast('‚ö†Ô∏è Ch∆∞a c√≥ ·∫£nh n√†o ƒë·ªÉ c√¢n b·∫±ng!', 'error');
                return;
            }

            let message = '';
            if (frontCount === backCount) {
                message = `‚úÖ ƒê√£ c√¢n b·∫±ng! ${frontCount} ·∫£nh m·ªói m·∫∑t.`;
            } else if (frontCount > backCount) {
                message = `‚ö†Ô∏è M·∫∑t tr∆∞·ªõc c√≥ ${frontCount - backCount} ·∫£nh nhi·ªÅu h∆°n. G·ª£i √Ω: Th√™m ${frontCount - backCount} ·∫£nh v√†o m·∫∑t sau.`;
            } else {
                message = `‚ö†Ô∏è M·∫∑t sau c√≥ ${backCount - frontCount} ·∫£nh nhi·ªÅu h∆°n. G·ª£i √Ω: Th√™m ${backCount - frontCount} ·∫£nh v√†o m·∫∑t tr∆∞·ªõc.`;
            }

            this.showToast(message, frontCount === backCount ? 'success' : 'warning');
            this.updateDuplexValidation();
        }

        // === V2: Update Gallery Grid v·ªõi Visual Feedback ===
        updateGalleryGridDuplexV2() {
            console.log('üé® updateGalleryGridDuplexV2 called');
            const galleryGrid = document.getElementById('galleryGridDuplex');
            const availableCountEl = document.getElementById('galleryAvailableCount');

            if (!galleryGrid) {
                console.error('‚ùå galleryGridDuplex not found!');
                return;
            }

            if (!this.galleryImages || this.galleryImages.length === 0) {
                console.warn('‚ö†Ô∏è No gallery images available');
                galleryGrid.innerHTML = '<div class="empty-state">Ch∆∞a c√≥ ·∫£nh trong kho</div>';
                return;
            }

            console.log('üì∏ Gallery images:', this.galleryImages.length);
            console.log('üéØ Current mode:', this.duplexCurrentMode);

            // Clear grid
            galleryGrid.innerHTML = '';

            // Update available count
            if (availableCountEl) {
                availableCountEl.textContent = this.galleryImages.length;
            }

            // Ensure printData exists
            if (!this.printData) {
                console.error('‚ùå printData not initialized!');
                return;
            }

            // Render gallery items with V2 classes
            this.galleryImages.forEach((item) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'gallery-item-v2 available';
                itemEl.dataset.imageId = item.id;
                itemEl.draggable = true;

                // Check if image is already in front or back
                const inFront = this.printData.frontImages?.some(img => img.id === item.id);
                const inBack = this.printData.backImages?.some(img => img.id === item.id);

                if (inFront) {
                    itemEl.classList.remove('available');
                    itemEl.classList.add('in-front');
                } else if (inBack) {
                    itemEl.classList.remove('available');
                    itemEl.classList.add('in-back');
                }

                // Create badge
                let badge = '';
                if (inFront) {
                    badge = '<span class="item-badge">Tr∆∞·ªõc</span>';
                } else if (inBack) {
                    badge = '<span class="item-badge">Sau</span>';
                }

                itemEl.innerHTML = `
                    <img src="${item.data}" alt="${item.filename}">
                    ${badge}
                `;

                // Click handler - add to current mode
                itemEl.addEventListener('click', (e) => {
                    console.log('üñ±Ô∏è Gallery item clicked:', item.filename);
                    console.log('üìç State:', {inFront, inBack, currentMode: this.duplexCurrentMode});

                    if (!inFront && !inBack) {
                        console.log('‚úÖ Adding to duplex side');
                        this.addToDuplexSide(item, this.duplexCurrentMode);
                    } else {
                        console.log('‚ö†Ô∏è Image already in front or back');
                    }
                });

                // === Drag & Drop Handlers ===
                itemEl.addEventListener('dragstart', (e) => {
                    if (!inFront && !inBack) {
                        e.dataTransfer.setData('imageId', item.id);
                        e.dataTransfer.effectAllowed = 'copy';
                        itemEl.classList.add('dragging');
                        console.log('üéØ Drag started:', item.filename);
                    } else {
                        e.preventDefault();
                    }
                });

                itemEl.addEventListener('dragend', () => {
                    itemEl.classList.remove('dragging');
                });

                galleryGrid.appendChild(itemEl);
            });

            console.log('‚úÖ Gallery grid rendered with', this.galleryImages.length, 'items');

            // Setup drop zones
            this.setupDragDropZones();
        }

        // === V2: Add Image to Duplex Side ===
        addToDuplexSide(imageItem, side) {
            console.log('‚ûï addToDuplexSide called:', {
                filename: imageItem.filename,
                side: side,
                printDataExists: !!this.printData
            });

            // Ensure printData and arrays exist
            if (!this.printData) {
                console.error('‚ùå printData not initialized!');
                this.showToast('‚ö†Ô∏è L·ªói: printData ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o!', 'error');
                return;
            }

            // Initialize arrays if needed
            if (!this.printData.frontImages) {
                this.printData.frontImages = [];
                console.log('üîß Initialized frontImages array');
            }
            if (!this.printData.backImages) {
                this.printData.backImages = [];
                console.log('üîß Initialized backImages array');
            }

            // Save history before modifying
            this.saveDuplexHistory();

            const targetArray = side === 'front' ? 'frontImages' : 'backImages';

            // Check if already exists
            const exists = this.printData[targetArray].some(img => img.id === imageItem.id);
            if (exists) {
                console.log('‚ö†Ô∏è Image already in list');
                this.showToast('‚ö†Ô∏è ·∫¢nh n√†y ƒë√£ c√≥ trong danh s√°ch!', 'warning');
                return;
            }

            // Add image
            console.log('üîç DEBUG imageItem before push:', imageItem);
            console.log('üîç DEBUG imageItem keys:', Object.keys(imageItem));
            this.printData[targetArray].push(imageItem);
            console.log('‚úÖ Image added to', targetArray, '- Total:', this.printData[targetArray].length);

            // Update UI
            this.updateDuplexStats();
            this.updateClassificationDisplay();
            this.updateGalleryGridDuplexV2();
            this.updateDuplexValidation();

            // üîß FIX: Render canvas preview sau khi th√™m ·∫£nh
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            console.log('üé® Rendered duplex canvas after adding image');

            const sideText = side === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau';
            this.showToast(`‚úÖ ƒê√£ th√™m v√†o ${sideText}`, 'success');
        }

        // === V2: Setup Drag & Drop Zones ===
        setupDragDropZones() {
            const frontZone = document.querySelector('#frontImagesList');
            const backZone = document.querySelector('#backImagesList');

            [frontZone, backZone].forEach((zone) => {
                if (!zone) return;

                const side = zone.dataset.side;

                // Prevent default drag over
                zone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    zone.classList.add('drag-over');
                });

                zone.addEventListener('dragleave', () => {
                    zone.classList.remove('drag-over');
                });

                zone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    zone.classList.remove('drag-over');

                    const imageId = e.dataTransfer.getData('imageId');
                    const imageItem = this.galleryImages.find(img => img.id === imageId);

                    if (imageItem) {
                        this.addToDuplexSide(imageItem, side);
                    }
                });
            });
        }

        // === V2: Update Duplex Validation Messages ===
        updateDuplexValidation() {
            const validationEl = document.getElementById('duplexValidation');
            if (!validationEl) return;

            const frontCount = this.printData.frontImages?.length || 0;
            const backCount = this.printData.backImages?.length || 0;

            validationEl.classList.remove('show', 'success', 'warning', 'error');

            if (frontCount === 0 && backCount === 0) {
                // No images - hide
                return;
            }

            validationEl.classList.add('show');

            if (frontCount === backCount) {
                validationEl.classList.add('success');
                validationEl.innerHTML = `‚úÖ C√¢n b·∫±ng ho√†n h·∫£o! ${frontCount} ·∫£nh m·ªói m·∫∑t = ${frontCount} trang in 2 m·∫∑t.`;
            } else if (Math.abs(frontCount - backCount) <= 2) {
                validationEl.classList.add('warning');
                const diff = Math.abs(frontCount - backCount);
                validationEl.innerHTML = `‚ö†Ô∏è Ch√™nh l·ªách ${diff} ·∫£nh. G·ª£i √Ω: Th√™m ${diff} ·∫£nh v√†o ${frontCount < backCount ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'}.`;
            } else {
                validationEl.classList.add('error');
                const diff = Math.abs(frontCount - backCount);
                validationEl.innerHTML = `‚ùå Ch√™nh l·ªách qu√° l·ªõn (${diff} ·∫£nh)! Vui l√≤ng c√¢n b·∫±ng l·∫°i ƒë·ªÉ in 2 m·∫∑t ƒë√∫ng.`;
            }
        }

        startDuplexClassification(type) {
            console.log('üîç DUPLEX startDuplexClassification called with type:', type);
            
            // Check if we have images to work with
            if (!this.galleryImages || this.galleryImages.length === 0) {
                this.showToast('‚ö†Ô∏è Ch∆∞a c√≥ ·∫£nh n√†o trong kho ƒë·ªÉ ph√¢n lo·∫°i!', 'error');
                return;
            }
            
            // AUTO-ENTER classification mode if not already in it (unified workflow)
            if (!this.classificationMode) {
                console.log('üîç DUPLEX Auto-entering classification mode for duplex selection');
                this.classificationMode = true;
                
                // Show classification UI (reuse Gallery's classification UI)
                const classificationModeEl = document.getElementById('classificationMode');
                console.log('üîç DUPLEX classificationMode element found:', !!classificationModeEl);
                if (classificationModeEl) {
                    classificationModeEl.style.display = 'block';
                    console.log('üîç DUPLEX classificationMode displayed');
                }
            }
            
            // For duplex mode, we work with the gallery images (kho ·∫£nh)
            this.selectionMode = true;
            this.selectionType = type;
            this.selectedImages = [];
            
            console.log('üîç DUPLEX Selection state set:', {
                selectionMode: this.selectionMode,
                selectionType: this.selectionType,
                classificationMode: this.classificationMode,
                printMode: this.printData?.config?.printMode,
                galleryImagesCount: this.galleryImages.length
            });
            
            // USE UNIFIED WORKFLOW: Reuse existing gallery classification system
            // Make sure source grid is updated with current images
            console.log('üîç DUPLEX Updating source grid...');
            this.updateSourceGrid();
            
            // Update UI 
            this.updateClassificationUI();
            this.updateSourceGridSelectionMode();
            this.updateSelectionUI(); // CRITICAL: Show Apply/Cancel buttons
            
            // Show instructions similar to gallery classification
            const typeText = type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau';
            this.showToast(`üéØ üñ®Ô∏è FILE IN: Ch·∫ø ƒë·ªô ch·ªçn ${typeText}. Click ·∫£nh trong khu v·ª±c "T·∫•t c·∫£ ·∫£nh ƒë√£ crop" (${this.galleryImages.length} ·∫£nh)!`, 'info');
            
            // Update hint text
            const hintEl = document.getElementById('sourceGridHint');
            if (hintEl) {
                hintEl.textContent = `üéØ Click ·∫£nh ƒë·ªÉ ch·ªçn l√†m ${typeText} (${this.galleryImages.length} ·∫£nh c√≥ s·∫µn)`;
                hintEl.style.color = type === 'front' ? '#10b981' : '#f59e0b';
                hintEl.style.fontWeight = 'bold';
            }
            
            console.log('Duplex classification mode started successfully');
        }

        exitDuplexClassification() {
            // Auto-apply any selected images before exiting
            if (this.selectedImages.length > 0) {
                console.log('Auto-applying selected images before exit');
                this.applySelection();
            }
            
            this.selectionMode = false;
            this.selectionType = null;
            this.selectedImages = [];
            
            // Hide classification mode (unified workflow)
            this.classificationMode = false;
            const classificationModeEl = document.getElementById('classificationMode');
            if (classificationModeEl) classificationModeEl.style.display = 'none';
            
            this.updateClassificationUI();
            this.updateSourceGridSelectionMode();
            
            // ƒê·∫£m b·∫£o selectedImages ƒë∆∞·ª£c c·∫≠p nh·∫≠t t·ª´ classified images
            this.updatePrintDataSelectedImages();
            
            console.log('üö™ Exited duplex classification mode');
            this.showToast('‚úÖ ƒê√£ ho√†n t·∫•t ph√¢n lo·∫°i! C√≥ th·ªÉ t·∫°o file in ngay.', 'success');
        }

        updateClassificationUI() {
            const frontBtn = document.getElementById('classifyFrontBtn');
            const backBtn = document.getElementById('classifyBackBtn');
            const exitBtn = document.getElementById('exitClassifyBtn');
            
            if (frontBtn) frontBtn.classList.toggle('active', this.selectionType === 'front');
            if (backBtn) backBtn.classList.toggle('active', this.selectionType === 'back');
            if (exitBtn) exitBtn.style.display = this.selectionMode ? 'flex' : 'none';
        }

        updateDuplexPreview() {
            if (this.printData.config.printMode !== 'duplex') return;
            
            // Render both canvases asynchronously
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
        }

        updateGalleryGridDuplex() {
            // === REDIRECT TO V2 ===
            console.log('üîÑ updateGalleryGridDuplex called, redirecting to V2...');
            this.updateGalleryGridDuplexV2();
        }
        
        updateDuplexGridSelectionMode() {
            console.log('updateDuplexGridSelectionMode called', {
                selectionMode: this.selectionMode,
                selectionType: this.selectionType
            });
            
            const galleryGrid = document.getElementById('galleryGridDuplex');
            if (!galleryGrid) {
                console.error('galleryGridDuplex not found');
                return;
            }
            
            const galleryItems = galleryGrid.querySelectorAll('.gallery-item-duplex');
            console.log('Found duplex gallery items:', galleryItems.length);
            
            galleryItems.forEach((item, index) => {
                const imageId = item.dataset.imageId;
                
                if (this.selectionMode) {
                    // Add selection mode class
                    item.classList.add('selection-mode');
                    
                    // Check if selected (for duplex mode, selectedImages contains objects)
                    const isSelected = this.selectedImages.some(img => 
                        (typeof img === 'object' ? img.id : img) == imageId
                    );
                    
                    console.log(`Duplex item ${imageId} is selected:`, isSelected);
                    
                    if (isSelected) {
                        const selectionClass = this.selectionType === 'front' ? 'selected-front' : 'selected-back';
                        item.classList.add(selectionClass);
                        
                        // Remove other selection class
                        const otherClass = this.selectionType === 'front' ? 'selected-back' : 'selected-front';
                        item.classList.remove(otherClass);
                    } else {
                        item.classList.remove('selected-front', 'selected-back');
                    }
                } else {
                    // Remove selection mode classes
                    item.classList.remove('selection-mode', 'selected-front', 'selected-back');
                }
            });
        }

        clearGalleryGridDuplex() {
            const galleryGrid = document.getElementById('galleryGridDuplex');
            if (galleryGrid) {
                galleryGrid.innerHTML = '';
            }
        }

        async renderDuplexCanvas(side) {
            console.log(`renderDuplexCanvas called for side: ${side}`);
            const canvasId = side === 'front' ? 'frontCanvas' : 'backCanvas';
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas not found: ${canvasId}`);
                return;
            }
            console.log(`Canvas found: ${canvasId}`);
            
            const ctx = canvas.getContext('2d');
            
            // Draw loading placeholder first
            canvas.width = 400;
            canvas.height = 600;
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            // Create master canvas for this side using WYSIWYG system
            let masterCanvas;
            if (side === 'back') {
                // For back side preview, use mirrored canvas
                masterCanvas = await this.createDuplexBackCanvasClassified();
            } else {
                // For front side preview, use normal canvas
                masterCanvas = await this.createDuplexMasterCanvas(side, 0);
            }
            
            if (!masterCanvas) {
                // Draw placeholder if no master canvas
                ctx.fillStyle = '#9ca3af';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `Ch∆∞a c√≥ ·∫£nh ${side === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'}`,
                    canvas.width / 2,
                    canvas.height / 2
                );
                return;
            }
            
            // Scale down master canvas for preview display
            const scale = Math.min(400 / masterCanvas.width, 500 / masterCanvas.height);
            canvas.width = masterCanvas.width * scale;
            canvas.height = masterCanvas.height * scale;
            
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // Draw scaled master canvas to preview
            ctx.drawImage(masterCanvas, 0, 0, canvas.width, canvas.height);
        }

        createDuplexMasterCanvas(side, pageIndex) {
            console.log(`üé® createDuplexMasterCanvas called for side: ${side}`);

            // === FIX: Ensure printData and arrays exist ===
            if (!this.printData) {
                console.error('‚ùå printData not initialized!');
                return Promise.resolve(null);
            }

            // Initialize arrays if they don't exist
            if (!this.printData.frontImages) {
                this.printData.frontImages = [];
                console.log('üîß Initialized empty frontImages array');
            }
            if (!this.printData.backImages) {
                this.printData.backImages = [];
                console.log('üîß Initialized empty backImages array');
            }

            const images = side === 'front' ? this.printData.frontImages : this.printData.backImages;
            console.log(`üì∏ Images for ${side}:`, images.length);

            if (!images || images.length === 0) {
                console.log(`‚ö†Ô∏è No images for ${side}, returning null`);
                return Promise.resolve(null);
            }

            return new Promise((resolve) => {
                // Temporarily replace selectedImages with side-specific images
                const originalSelectedImages = this.printData.selectedImages;

                // Create proper img objects for each image
                const processedImages = [];
                let loadedCount = 0;

                if (images.length === 0) {
                    resolve(null);
                    return;
                }

                images.forEach((imgData, index) => {
                    const img = new Image();
                    img.onload = () => {
                        processedImages[index] = {
                            src: imgData.data || imgData.src,  // üîß FIX: Gallery item uses 'data', not 'src'
                            img: img,
                            name: imgData.filename || imgData.name,  // üîß FIX: Gallery item uses 'filename', not 'name'
                            file: imgData.file
                        };
                        
                        loadedCount++;
                        if (loadedCount === images.length) {
                            // All images loaded, create canvas
                            this.printData.selectedImages = processedImages;
                            
                            const config = this.printData.config;
                            const dpi = config.dpi;
                            
                            // Calculate exact dimensions at full DPI  
                            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
                            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
                            const paperWidthInches = paperWidthMm / 25.4;
                            const paperHeightInches = paperHeightMm / 25.4;
                            const exactWidthPx = Math.round(paperWidthInches * dpi);
                            const exactHeightPx = Math.round(paperHeightInches * dpi);

                            // Create temporary master canvas
                            const masterCanvas = document.createElement('canvas');
                            masterCanvas.width = exactWidthPx;
                            masterCanvas.height = exactHeightPx;
                            
                            const ctx = masterCanvas.getContext('2d');
                            
                            // Render page content using existing system
                            console.log(`üñºÔ∏è FRONT Canvas: ${masterCanvas.width}x${masterCanvas.height}px at ${config.dpi}DPI`);
                            this.renderPageToCanvas(masterCanvas, ctx, pageIndex, config);
                            
                            // Add cutting guides if enabled
                            this.drawCuttingGuides(ctx, masterCanvas, config);
                            
                            // Restore original selectedImages
                            this.printData.selectedImages = originalSelectedImages;
                            
                            resolve(masterCanvas);
                        }
                    };
                    img.onerror = () => {
                        console.error('Failed to load image:', imgData.data || imgData.src);
                        loadedCount++;
                        if (loadedCount === images.length) {
                            this.printData.selectedImages = originalSelectedImages;
                            resolve(null);
                        }
                    };
                    img.src = imgData.data || imgData.src;  // üîß FIX: Use 'data' field from gallery
                });
            });
        }

        switchSide(side) {
            this.printData.currentSide = side;
            
            // Update UI
            const frontBtn = document.getElementById('frontSideBtn');
            const backBtn = document.getElementById('backSideBtn');
            const sideDisplay = document.getElementById('currentSideDisplay');
            const indicator = document.getElementById('pageSideIndicator');
            
            if (frontBtn && backBtn) {
                frontBtn.classList.toggle('active', side === 'front');
                backBtn.classList.toggle('active', side === 'back');
            }
            
            if (sideDisplay) {
                sideDisplay.textContent = side === 'front' ? 'M·∫∑t tr∆∞·ªõc' : 'M·∫∑t sau';
            }
            
            if (indicator) {
                indicator.textContent = `Trang ${this.printData.currentPage + 1} - ${side === 'front' ? 'M·∫∑t tr∆∞·ªõc' : 'M·∫∑t sau'}`;
            }
            
            this.updateSlotDisplay();
            this.updatePreview();
            
            // Update duplex preview for both sides
            if (this.printData.config.printMode === 'duplex') {
                this.updateDuplexPreview();
            }
        }

        updateSlotDisplay() {
            const slotGrid = document.getElementById('slotGrid');
            if (!slotGrid) return;
            
            const currentPage = this.printData.currentPage;
            const currentSide = this.printData.currentSide;
            const images = currentSide === 'front' ? this.printData.frontImages : this.printData.backImages;
            const pageImages = images[currentPage] || {};
            
            const slots = slotGrid.querySelectorAll('.slot-item');
            slots.forEach((slot, index) => {
                const imageData = pageImages[index];
                
                if (imageData) {
                    slot.classList.add('filled');
                    slot.innerHTML = `
                        <div class="slot-number">${index + 1}</div>
                        <img src="${imageData.data || imageData.src || ''}" alt="${imageData.name}" class="slot-image">
                        <button class="slot-remove-btn" onclick="converter.removeSlotImage(${currentPage}, '${currentSide}', ${index})">√ó</button>
                    `;
                } else {
                    slot.classList.remove('filled');
                    slot.innerHTML = `
                        <div class="slot-number">${index + 1}</div>
                        <div class="slot-empty-icon">üì∑</div>
                        <button class="slot-remove-btn" onclick="converter.removeSlotImage(${currentPage}, '${currentSide}', ${index})" style="display: none;">√ó</button>
                    `;
                }
            });
        }

        // Drag & Drop handlers for slots
        handleSlotDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        handleSlotDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        handleSlotDrop(e, slotIndex) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            const imageId = e.dataTransfer.getData('image-id');
            const source = e.dataTransfer.getData('source');
            
            if (source === 'gallery' && imageId) {
                const image = this.galleryImages.find(img => img.id == imageId);
                if (image) {
                    this.assignImageToSlot(slotIndex, {
                        src: image.data,
                        name: image.filename,
                        id: image.id
                    });
                }
            }
        }

        handleSlotClick(slotIndex) {
            // Open gallery selection modal for this slot
            this.openSlotGalleryModal(slotIndex);
        }

        assignImageToSlot(slotIndex, imageData) {
            const currentPage = this.printData.currentPage;
            const currentSide = this.printData.currentSide;
            
            // Initialize page data if not exists
            if (currentSide === 'front') {
                if (!this.printData.frontImages[currentPage]) {
                    this.printData.frontImages[currentPage] = {};
                }
                this.printData.frontImages[currentPage][slotIndex] = imageData;
            } else {
                if (!this.printData.backImages[currentPage]) {
                    this.printData.backImages[currentPage] = {};
                }
                this.printData.backImages[currentPage][slotIndex] = imageData;
            }
            
            this.updateSlotDisplay();
            this.updatePreview();
            this.showToast(`‚úÖ ƒê√£ g√°n ·∫£nh "${imageData.name}" v√†o slot ${slotIndex + 1} - ${currentSide === 'front' ? 'M·∫∑t tr∆∞·ªõc' : 'M·∫∑t sau'}`, 'success');
        }

        removeSlotImage(pageIndex, side, slotIndex) {
            if (side === 'front' && this.printData.frontImages[pageIndex]) {
                delete this.printData.frontImages[pageIndex][slotIndex];
            } else if (side === 'back' && this.printData.backImages[pageIndex]) {
                delete this.printData.backImages[pageIndex][slotIndex];
            }
            
            this.updateSlotDisplay();
            this.updatePreview();
            this.showToast(`üóëÔ∏è ƒê√£ x√≥a ·∫£nh kh·ªèi slot ${slotIndex + 1}`, 'info');
        }

        clearCurrentSide() {
            const currentPage = this.printData.currentPage;
            const currentSide = this.printData.currentSide;
            
            if (currentSide === 'front') {
                this.printData.frontImages[currentPage] = {};
            } else {
                this.printData.backImages[currentPage] = {};
            }
            
            this.updateSlotDisplay();
            this.updatePreview();
            this.showToast(`üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ ·∫£nh ${currentSide === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'} trang ${currentPage + 1}`, 'info');
        }

        fillFromGallery() {
            if (this.galleryImages.length === 0) {
                this.showToast('Kho ·∫£nh tr·ªëng. H√£y th√™m ·∫£nh v√†o kho tr∆∞·ªõc.', 'warning');
                return;
            }
            
            const currentPage = this.printData.currentPage;
            const currentSide = this.printData.currentSide;
            const maxSlots = this.printData.maxPhotosPerPage;
            
            // Fill slots with gallery images
            for (let i = 0; i < Math.min(maxSlots, this.galleryImages.length); i++) {
                const image = this.galleryImages[i];
                this.assignImageToSlot(i, {
                    src: image.data,
                    name: image.filename,
                    id: image.id
                });
            }
            
            this.showToast(`üì∑ ƒê√£ ƒëi·ªÅn ${Math.min(maxSlots, this.galleryImages.length)} ·∫£nh t·ª´ kho v√†o ${currentSide === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'}`, 'success');
        }

        openSlotGalleryModal(slotIndex) {
            // Create a simple selection modal
            if (this.galleryImages.length === 0) {
                this.showToast('Kho ·∫£nh tr·ªëng. H√£y th√™m ·∫£nh v√†o kho tr∆∞·ªõc.', 'warning');
                return;
            }
            
            const modal = document.createElement('div');
            modal.className = 'slot-selection-modal';
            modal.innerHTML = `
                <div class="slot-modal-content">
                    <div class="slot-modal-header">
                        <h3>Ch·ªçn ·∫£nh cho Slot ${slotIndex + 1}</h3>
                        <button class="close-slot-modal">√ó</button>
                    </div>
                    <div class="slot-modal-body">
                        <div class="slot-gallery-grid">
                            ${this.galleryImages.map(image => `
                                <div class="slot-gallery-item" data-image-id="${image.id}">
                                    <img src="${image.data}" alt="${image.filename}">
                                    <div class="slot-image-name">${image.filename}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Event listeners
            modal.querySelector('.close-slot-modal').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            modal.querySelectorAll('.slot-gallery-item').forEach(item => {
                item.addEventListener('click', () => {
                    const imageId = item.dataset.imageId;
                    const image = this.galleryImages.find(img => img.id == imageId);
                    if (image) {
                        this.assignImageToSlot(slotIndex, {
                            src: image.data,
                            name: image.filename,
                            id: image.id
                        });
                    }
                    document.body.removeChild(modal);
                });
            });
            
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }

        updateDuplexStats() {
            const frontCount = this.printData.frontImages?.length || 0;
            const backCount = this.printData.backImages?.length || 0;
            const maxPages = Math.max(
                Math.ceil(frontCount / (this.printData.maxPhotosPerPage || 1)),
                Math.ceil(backCount / (this.printData.maxPhotosPerPage || 1))
            );

            const frontCountEl = document.getElementById('frontImageCount');
            const backCountEl = document.getElementById('backImageCount');
            const maxPagesEl = document.getElementById('maxDuplexPages');
            const frontCountHeader = document.getElementById('frontCount');
            const backCountHeader = document.getElementById('printBackCount');

            if (frontCountEl) frontCountEl.textContent = frontCount;
            if (backCountEl) backCountEl.textContent = backCount;
            if (maxPagesEl) maxPagesEl.textContent = maxPages;
            if (frontCountHeader) frontCountHeader.textContent = frontCount;
            if (backCountHeader) backCountHeader.textContent = backCount;
        }

        updateClassificationDisplay() {
            this.updateFrontImagesList();
            this.updateBackImagesList();
        }

        updateFrontImagesList() {
            const container = document.getElementById('frontImagesList');
            if (!container) return;

            // Use the correct frontImages based on context
            const frontImages = this.printData?.frontImages || this.frontImages || [];

            // Remove empty state if exists
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            if (!frontImages || frontImages.length === 0) {
                container.innerHTML = '<div class="empty-state">Ch∆∞a c√≥ ·∫£nh n√†o</div>';
                return;
            }

            // === V2: Render with .classified-thumb class ===
            container.innerHTML = frontImages.map((image, index) => `
                <div class="classified-thumb" draggable="true" data-index="${index}" data-side="front">
                    <img src="${image.data || image.src}" alt="${image.filename || image.name}">
                    <span class="thumb-order">${index + 1}</span>
                    <button class="thumb-remove" onclick="converter.removeClassifiedImageV2('front', ${index})" title="X√≥a">√ó</button>
                </div>
            `).join('');
        }

        updateBackImagesList() {
            const container = document.getElementById('backImagesList');
            if (!container) return;

            // Use the correct backImages based on context
            const backImages = this.printData?.backImages || this.backImages || [];

            // Remove empty state if exists
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();

            if (!backImages || backImages.length === 0) {
                container.innerHTML = '<div class="empty-state">Ch∆∞a c√≥ ·∫£nh n√†o</div>';
                return;
            }

            // === V2: Render with .classified-thumb class ===
            container.innerHTML = backImages.map((image, index) => `
                <div class="classified-thumb" draggable="true" data-index="${index}" data-side="back">
                    <img src="${image.data || image.src}" alt="${image.filename || image.name}">
                    <span class="thumb-order">${index + 1}</span>
                    <button class="thumb-remove" onclick="converter.removeClassifiedImageV2('back', ${index})" title="X√≥a">√ó</button>
                </div>
            `).join('');
        }

        // === V2: Remove with history ===
        removeClassifiedImageV2(type, index) {
            this.saveDuplexHistory();

            if (type === 'front') {
                this.printData.frontImages.splice(index, 1);
            } else {
                this.printData.backImages.splice(index, 1);
            }

            this.updateDuplexStats();
            this.updateClassificationDisplay();
            this.updateGalleryGridDuplexV2();
            this.updateDuplexValidation();
            this.showToast(`üóëÔ∏è ƒê√£ x√≥a ·∫£nh kh·ªèi ${type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'}`, 'info');
        }

        // Old function for compatibility
        removeClassifiedImage(type, index) {
            this.removeClassifiedImageV2(type, index);
        }

        clearClassifiedImages(type) {
            const typeText = type === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau';
            if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ ·∫£nh ${typeText}?`)) return;

            if (type === 'front') {
                this.printData.frontImages = [];
            } else {
                this.printData.backImages = [];
            }

            this.updateDuplexStats();
            this.updateClassificationDisplay();
            this.updateGalleryGridDuplexV2();
            this.updateDuplexValidation();
            this.showToast(`üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ ·∫£nh ${typeText}`, 'info');
        }

        setupSmartGridControls() {
            // Select All Checkbox
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', (e) => {
                    const checked = e.target.checked;
                    if (checked) {
                        // Select all images
                        this.printData.selectedImages.forEach((img, idx) => {
                            this.selectedImageIndices.add(idx);
                        });
                    } else {
                        // Deselect all
                        this.selectedImageIndices.clear();
                    }
                    this.updateSelectedImagesDisplay();
                });
            }

            // Sort Images Select
            const sortImagesSelect = document.getElementById('sortImagesSelect');
            if (sortImagesSelect) {
                sortImagesSelect.addEventListener('change', () => {
                    this.updateSelectedImagesDisplay();
                });
            }

            // Grid Size Select
            const gridSizeSelect = document.getElementById('gridSizeSelect');
            if (gridSizeSelect) {
                gridSizeSelect.addEventListener('change', (e) => {
                    const grid = document.getElementById('selectedImagesGrid');
                    if (grid) {
                        grid.dataset.gridSize = e.target.value;
                    }
                });
            }

            // Toggle Images View
            const toggleBtn = document.getElementById('toggleImagesView');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    const grid = document.getElementById('selectedImagesGrid');
                    if (grid) {
                        if (grid.style.display === 'none') {
                            grid.style.display = 'grid';
                            toggleBtn.textContent = '‚ñº';
                        } else {
                            grid.style.display = 'none';
                            toggleBtn.textContent = '‚ñ≤';
                        }
                    }
                });
            }

            // Bulk Actions - Rotate
            const bulkRotateBtn = document.getElementById('bulkRotateBtn');
            if (bulkRotateBtn) {
                bulkRotateBtn.addEventListener('click', () => {
                    if (this.selectedImageIndices.size === 0) return;

                    const indices = Array.from(this.selectedImageIndices);
                    indices.forEach(index => {
                        this.rotateImage(index);
                    });

                    this.showToast(`‚úÖ ƒê√£ xoay ${indices.length} ·∫£nh`, 'success');
                });
            }

            // Bulk Actions - Delete
            const bulkDeleteBtn = document.getElementById('bulkDeleteBtn');
            if (bulkDeleteBtn) {
                bulkDeleteBtn.addEventListener('click', () => {
                    if (this.selectedImageIndices.size === 0) return;

                    if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${this.selectedImageIndices.size} ·∫£nh ƒë√£ ch·ªçn?`)) {
                        return;
                    }

                    // Sort indices in descending order to delete from end
                    const indices = Array.from(this.selectedImageIndices).sort((a, b) => b - a);
                    indices.forEach(index => {
                        this.printData.selectedImages.splice(index, 1);
                    });

                    // Clear selection
                    this.selectedImageIndices.clear();

                    this.updateSelectedImagesDisplay();
                    this.updateTotalPages();
                    this.updatePreview();
                    this.showToast(`üóëÔ∏è ƒê√£ x√≥a ${indices.length} ·∫£nh`, 'info');
                });
            }

            // Bulk Actions - Cancel
            const bulkCancelBtn = document.getElementById('bulkCancelBtn');
            if (bulkCancelBtn) {
                bulkCancelBtn.addEventListener('click', () => {
                    this.selectedImageIndices.clear();
                    this.updateSelectedImagesDisplay();
                });
            }
        }

        setupDragAndDrop() {
            const dropArea = document.getElementById('dropAreaMain');
            const fileInput = document.getElementById('printFileInput');

            if (!dropArea || !fileInput) return;

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            // Highlight drop area when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, () => {
                    dropArea.classList.add('drag-over');
                });
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, () => {
                    dropArea.classList.remove('drag-over');
                });
            });

            // Handle dropped files
            dropArea.addEventListener('drop', (e) => {
                const dt = e.dataTransfer;
                const files = dt.files;
                this.handleFiles(files);
            });

            // Handle file input change
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                this.handleFiles(files);
            });
        }

        handleFiles(files) {
            const dropContent = document.getElementById('dropContent');
            const progressContainer = document.getElementById('uploadProgressContainer');
            const successContainer = document.getElementById('uploadSuccess');

            // Hide drop content, show progress
            dropContent.style.display = 'none';
            successContainer.style.display = 'none';
            progressContainer.style.display = 'block';

            const fileList = document.getElementById('uploadFileList');
            const progressFill = document.getElementById('uploadProgressFill');
            const progressText = document.getElementById('progressText');

            fileList.innerHTML = '';

            const validFiles = [];
            const invalidFiles = [];

            // Validate files
            Array.from(files).forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';

                const isImage = file.type.startsWith('image/');
                const isValidType = ['image/jpeg', 'image/png', 'image/webp', 'image/jpg'].includes(file.type);
                const isValidSize = file.size <= 10 * 1024 * 1024; // 10MB

                const sizeText = (file.size / 1024 / 1024).toFixed(2) + ' MB';

                if (isImage && isValidType && isValidSize) {
                    validFiles.push(file);
                    fileItem.innerHTML = `
                        <span class="file-item-icon">‚è≥</span>
                        <span class="file-item-name">${file.name}</span>
                        <span class="file-item-size">${sizeText}</span>
                    `;
                } else {
                    invalidFiles.push(file);
                    let reason = '';
                    if (!isImage || !isValidType) reason = 'ƒê·ªãnh d·∫°ng kh√¥ng h·ªó tr·ª£';
                    else if (!isValidSize) reason = 'Qu√° l·ªõn (>10MB)';

                    fileItem.className = 'file-item error';
                    fileItem.innerHTML = `
                        <span class="file-item-icon">‚ùå</span>
                        <span class="file-item-name">${file.name}</span>
                        <span class="file-item-size">${reason}</span>
                    `;
                }

                fileList.appendChild(fileItem);
            });

            if (validFiles.length === 0) {
                // No valid files
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                    dropContent.style.display = 'block';
                    this.showToast('‚ö†Ô∏è Kh√¥ng c√≥ file h·ª£p l·ªá ƒë·ªÉ t·∫£i l√™n', 'error');
                }, 1500);
                return;
            }

            // Simulate upload progress
            let progress = 0;
            const interval = setInterval(() => {
                progress += 5;
                if (progress > 100) progress = 100;

                progressFill.style.width = progress + '%';
                progressText.textContent = progress + '%';

                // Update file icons as they "upload"
                const items = fileList.querySelectorAll('.file-item:not(.error)');
                const uploadedCount = Math.floor((progress / 100) * items.length);
                items.forEach((item, index) => {
                    if (index < uploadedCount) {
                        item.classList.add('success');
                        item.querySelector('.file-item-icon').textContent = '‚úÖ';
                    } else if (index === uploadedCount) {
                        item.querySelector('.file-item-icon').textContent = '‚è´';
                    }
                });

                if (progress === 100) {
                    clearInterval(interval);

                    // Add files to print queue
                    setTimeout(() => {
                        this.addFilesToPrintQueue(validFiles);

                        // Show success
                        progressContainer.style.display = 'none';
                        successContainer.style.display = 'block';
                        document.getElementById('successTitle').textContent =
                            `ƒê√£ t·∫£i l√™n ${validFiles.length} ·∫£nh th√†nh c√¥ng`;

                        // Reset after 3 seconds
                        setTimeout(() => {
                            successContainer.style.display = 'none';
                            dropContent.style.display = 'block';
                        }, 3000);
                    }, 500);
                }
            }, 50);
        }

        addFilesToPrintQueue(files) {
            // üéØ FIX: N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô duplex, th√™m v√†o gallery thay v√¨ print queue
            const isDuplexMode = this.printData?.duplexEnabled;

            if (isDuplexMode) {
                console.log('üì∏ Duplex mode - Adding files to gallery from drag & drop');
                files.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        await this.addImageToGallery(e.target.result, file.name, false);
                    };
                    reader.readAsDataURL(file);
                });
                return; // D·ª´ng l·∫°i, kh√¥ng th√™m v√†o print queue
            }

            // Ch·∫ø ƒë·ªô th∆∞·ªùng - th√™m v√†o selected images nh∆∞ c≈©
            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.printData.selectedImages.push({
                        file: file,
                        dataUrl: e.target.result,
                        name: file.name
                    });

                    // Update UI after all files loaded
                    if (this.printData.selectedImages.length >= files.length) {
                        this.updateSelectedImagesDisplay();
                        this.updateTotalPages();
                        // Enable print buttons (if function exists)
                        if (typeof this.enablePrintButtons === 'function') {
                            this.enablePrintButtons();
                        }
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        selectPaperSize(size) {
            const customInput = document.getElementById('customPaperInputs');
            const customInputsSection = document.getElementById('customInputsSection');
            
            switch(size) {
                case 'a4':
                    this.printData.config.paperSize = { width: 210, height: 297 };
                    customInput.style.display = 'none';
                    break;
                case 'a3':
                    this.printData.config.paperSize = { width: 297, height: 420 };
                    customInput.style.display = 'none';
                    break;
                case 'letter':
                    this.printData.config.paperSize = { width: 216, height: 279 };
                    customInput.style.display = 'none';
                    break;
                case 'custom':
                    // Show both the main custom inputs section and paper inputs
                    if (customInputsSection) customInputsSection.style.display = 'block';
                    customInput.style.display = 'block';
                    this.updateConfigFromInputs();
                    return;
            }
            
            // Hide custom inputs section when not using custom
            if (customInputsSection) customInputsSection.style.display = 'none';
            
            this.calculateLayout();
        }

        selectPhotoSize(size) {
            console.log('üîß selectPhotoSize called with:', size);

            const customInput = document.getElementById('customPhotoInputs');
            const customInputsSection = document.getElementById('customInputsSection');

            // Sync v·ªõi previewPhotoSize dropdown
            const previewPhotoSize = document.getElementById('previewPhotoSize');
            if (previewPhotoSize && previewPhotoSize.value !== size) {
                this._syncingDropdowns = true;
                previewPhotoSize.value = size;
                console.log('üîÑ Synced previewPhotoSize to:', size);
                setTimeout(() => {
                    this._syncingDropdowns = false;
                }, 100);
            }

            switch(size) {
                case '5.5x8.5':
                    this.printData.config.photoSize = { width: 5.5, height: 8.5 };
                    customInput.style.display = 'none';
                    break;
                case '4.74x6.6':
                    this.printData.config.photoSize = { width: 4.74, height: 6.6 };
                    customInput.style.display = 'none';
                    break;
                case '4x6':
                    this.printData.config.photoSize = { width: 4, height: 6 };
                    customInput.style.display = 'none';
                    break;
                case '5x7':
                    this.printData.config.photoSize = { width: 5, height: 7 };
                    customInput.style.display = 'none';
                    break;
                case '6x9':
                    this.printData.config.photoSize = { width: 6, height: 9 };
                    customInput.style.display = 'none';
                    break;
                case '5x15':
                    this.printData.config.photoSize = { width: 5, height: 15 };
                    customInput.style.display = 'none';
                    break;
                case '7x10':
                    this.printData.config.photoSize = { width: 7, height: 10 };
                    customInput.style.display = 'none';
                    break;
                case 'polaroid':
                    this.printData.config.photoSize = { width: 5.4, height: 6.7 };
                    customInput.style.display = 'none';
                    break;
                case 'custom':
                    // Show both the main custom inputs section and photo inputs
                    if (customInputsSection) customInputsSection.style.display = 'block';
                    customInput.style.display = 'block';

                    // C≈©ng hi·ªÉn th·ªã preview custom inputs (elite controls)
                    const previewCustomSizeInputs = document.getElementById('previewCustomSizeInputs');
                    if (previewCustomSizeInputs) previewCustomSizeInputs.style.display = 'block';

                    this.updateConfigFromInputs();
                    return;
            }
            
            // Hide custom inputs section when not using custom
            if (customInputsSection) customInputsSection.style.display = 'none';

            // C≈©ng ·∫©n preview custom inputs (elite controls)
            const previewCustomSizeInputs = document.getElementById('previewCustomSizeInputs');
            if (previewCustomSizeInputs) previewCustomSizeInputs.style.display = 'none';

            console.log('üîß selectPhotoSize completed. Final config.photoSize:', this.printData.config.photoSize);
            this.calculateLayout();
            this.updateMasterCanvas(); // C·∫≠p nh·∫≠t canvas ƒë·ªÉ hi·ªÉn th·ªã k√≠ch th∆∞·ªõc m·ªõi
        }

        updateConfigFromInputs() {
            console.log('üîÑ updateConfigFromInputs called');
            const paperWidth = document.getElementById('paperWidth');
            const paperHeight = document.getElementById('paperHeight');
            const photoWidth = document.getElementById('photoWidth');
            const photoHeight = document.getElementById('photoHeight');
            const marginTop = document.getElementById('marginTop');
            const marginBottom = document.getElementById('marginBottom');
            const marginLeft = document.getElementById('marginLeft');
            const marginRight = document.getElementById('marginRight');
            const gutterX = document.getElementById('gutterX');
            const gutterY = document.getElementById('gutterY');
            
            console.log('üîß Current gutter values:', {
                gutterX: gutterX ? gutterX.value : 'not found',
                gutterY: gutterY ? gutterY.value : 'not found'
            });

            if (paperWidth && paperHeight) {
                this.printData.config.paperSize.width = parseFloat(paperWidth.value) || 210;
                this.printData.config.paperSize.height = parseFloat(paperHeight.value) || 297;
            }

            // Ch·ªâ c·∫≠p nh·∫≠t photoSize n·∫øu user th·ª±c s·ª± ƒëang ·ªü custom mode v√† ƒë√£ nh·∫≠p gi√° tr·ªã
            const customInput = document.querySelector('.custom-size-input');
            const isCustomMode = customInput && customInput.style.display !== 'none';

            if (isCustomMode && photoWidth && photoHeight && photoWidth.value.trim() && photoHeight.value.trim()) {
                const newWidth = parseFloat(photoWidth.value);
                const newHeight = parseFloat(photoHeight.value);
                if (!isNaN(newWidth) && !isNaN(newHeight)) {
                    console.log('üìù Updating photoSize from custom inputs:', newWidth, 'x', newHeight);
                    this.printData.config.photoSize.width = newWidth;
                    this.printData.config.photoSize.height = newHeight;

                    // Sync v·ªõi previewCustomWidth v√† previewCustomHeight
                    const previewCustomWidth = document.getElementById('previewCustomWidth');
                    const previewCustomHeight = document.getElementById('previewCustomHeight');
                    if (previewCustomWidth) previewCustomWidth.value = newWidth;
                    if (previewCustomHeight) previewCustomHeight.value = newHeight;
                } else {
                    console.log('‚ö†Ô∏è Invalid photo size inputs, keeping current config');
                }
            } else {
                console.log('üîí Preserving current photoSize config (not in custom mode or no inputs):',
                    this.printData.config.photoSize.width, 'x', this.printData.config.photoSize.height);
            }

            if (marginTop && marginBottom && marginLeft && marginRight) {
                this.printData.config.margins.top = parseFloat(marginTop.value) || 10;
                this.printData.config.margins.bottom = parseFloat(marginBottom.value) || 10;
                this.printData.config.margins.left = parseFloat(marginLeft.value) || 10;
                this.printData.config.margins.right = parseFloat(marginRight.value) || 10;
            }

            if (gutterX && gutterY) {
                this.printData.config.gutter.x = parseFloat(gutterX.value) || 5;
                this.printData.config.gutter.y = parseFloat(gutterY.value) || 5;
                console.log('‚úÖ Updated gutter config:', this.printData.config.gutter);
            } else {
                console.error('‚ùå gutterX or gutterY not found!');
            }

            console.log('üîÑ Calling calculateLayout...');
            this.calculateLayout();
            this.updateMasterCanvas(); // C·∫≠p nh·∫≠t canvas ƒë·ªÉ hi·ªÉn th·ªã k√≠ch th∆∞·ªõc m·ªõi
        }

        calculateLayout() {
            console.log('üìê calculateLayout called with config:', {
                gutter: this.printData.config.gutter,
                photoSize: this.printData.config.photoSize,
                paperSize: this.printData.config.paperSize
            });
            
            const config = this.printData.config;
            
            // Convert dimensions to mm
            const paperWidth = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeight = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            const photoWidthMm = config.photoSize.width * 10; // cm to mm
            const photoHeightMm = config.photoSize.height * 10; // cm to mm

            console.log('üêõ DEBUG - Current config.photoSize:', config.photoSize);
            console.log('üêõ DEBUG - photoWidthMm x photoHeightMm:', photoWidthMm, 'x', photoHeightMm);

            // Calculate available space
            const availableWidth = paperWidth - config.margins.left - config.margins.right;
            const availableHeight = paperHeight - config.margins.top - config.margins.bottom;

            // Check if SK316 mode (gutter 3mm = blade spacing)
            const isSK316Mode = (config.gutter.x === 3 && config.gutter.y === 3);

            // Try both orientations of photos to find optimal layout
            const layouts = [
                this.calculateLayoutForOrientation(availableWidth, availableHeight, photoWidthMm, photoHeightMm, config.gutter)
            ];

            // SK316: KH√îNG rotate card (card ph·∫£i n·∫±m ngang 90√ó54mm)
            if (!isSK316Mode) {
                layouts.push(this.calculateLayoutForOrientation(availableWidth, availableHeight, photoHeightMm, photoWidthMm, config.gutter));
                console.log('üîÑ Normal mode: Trying both orientations');
            } else {
                console.log('üîí SK316 MODE: Card locked at 90√ó54mm (landscape), NO rotation allowed');
            }

            // NEW: Try smart mixed layout (k·∫øt h·ª£p 2 h∆∞·ªõng) - ch·ªâ khi kh√¥ng ph·∫£i SK316
            if (!isSK316Mode) {
                const totalImages = this.printData.selectedImages ? this.printData.selectedImages.length : 0;
                console.log('üìä Total images for layout calculation:', totalImages);

                const mixedLayout = this.calculateMixedOrientationLayout(availableWidth, availableHeight, photoWidthMm, photoHeightMm, config.gutter, totalImages);
                layouts.push(mixedLayout);
            }

            // Debug: log t·∫•t c·∫£ layouts ƒë·ªÉ ki·ªÉm tra
            console.log('üìä All layouts generated:');
            layouts.forEach((layout, index) => {
                console.log(`Layout ${index}:`, {
                    totalPhotos: layout.totalPhotos,
                    priority: layout.priority || 'no priority',
                    isMixed: layout.isMixed,
                    type: layout.exactPositions ? 'exact' : 'grid'
                });
            });

            // Choose the layout - ∆∞u ti√™n TUY·ªÜT ƒê·ªêI theo priority, sau ƒë√≥ totalPhotos
            const optimalLayout = layouts.reduce((best, current) => {
                const bestPriority = best.priority || 0;
                const currentPriority = current.priority || 0;

                // ∆Øu ti√™n tuy·ªát ƒë·ªëi theo priority cao nh·∫•t
                if (currentPriority > bestPriority) {
                    console.log('üéØ Ch·ªçn layout c√≥ priority cao h∆°n:', currentPriority, 'vs', bestPriority);
                    return current;
                }
                // N·∫øu c√πng priority, ch·ªçn layout c√≥ nhi·ªÅu ·∫£nh h∆°n
                if (currentPriority === bestPriority && current.totalPhotos > best.totalPhotos) {
                    console.log('üìä C√πng priority, ch·ªçn layout nhi·ªÅu ·∫£nh h∆°n:', current.totalPhotos, 'vs', best.totalPhotos);
                    return current;
                }
                return best;
            });
            
            // X√°c ƒë·ªãnh lo·∫°i layout ƒë∆∞·ª£c ch·ªçn
            if (optimalLayout === layouts[0]) {
                this.printData.rotatePhotos = false;
                this.printData.layoutType = 'portrait';
            } else if (optimalLayout === layouts[1]) {
                this.printData.rotatePhotos = true;
                this.printData.layoutType = 'landscape';
            } else {
                this.printData.rotatePhotos = false;
                this.printData.layoutType = 'mixed';
            }

            // Update UI
            document.getElementById('maxPhotosCount').textContent = optimalLayout.totalPhotos;
            document.getElementById('gridLayout').textContent = `${optimalLayout.cols}√ó${optimalLayout.rows}`;

            // Calculate and update efficiency
            const totalPaperArea = paperWidth * paperHeight;
            const totalPhotoArea = optimalLayout.totalPhotos * (optimalLayout.photoWidth * optimalLayout.photoHeight);
            const efficiency = Math.round((totalPhotoArea / totalPaperArea) * 100);
            document.getElementById('efficiencyRate').textContent = `${efficiency}%`;
            const efficiencyFill = document.getElementById('efficiencyFill');
            if (efficiencyFill) {
                efficiencyFill.style.width = `${efficiency}%`;
            }

            // Update paper grid visualization
            this.updatePaperGridVisualization(optimalLayout.cols, optimalLayout.rows, config.orientation);

            // Update paper dimensions label
            const paperDimensions = document.getElementById('paperDimensions');
            if (paperDimensions) {
                const orientText = config.orientation === 'portrait' ? 'd·ªçc' : 'ngang';
                paperDimensions.textContent = `A4 ${orientText}`;
            }

            // Show optimization info
            let layoutInfo = '';
            if (this.printData.layoutType === 'mixed') {
                layoutInfo = ' (üîÑ Layout th√¥ng minh)';
            } else {
                layoutInfo = this.printData.rotatePhotos ? ' (üîÑ xoay)' : '';
            }

            const actualSizeInfo = `${(optimalLayout.photoWidth/10).toFixed(1)}√ó${(optimalLayout.photoHeight/10).toFixed(1)}cm`;
            const spacingInfo = `${optimalLayout.actualSpacing.x.toFixed(1)}√ó${optimalLayout.actualSpacing.y.toFixed(1)}mm spacing`;

            // Update grid layout text with more details
            document.getElementById('gridLayout').textContent = `${optimalLayout.cols}√ó${optimalLayout.rows}${layoutInfo}`;

            // Update layout suggestion
            const layoutSuggestion = document.getElementById('layoutSuggestion');
            if (layoutSuggestion) {
                const suggestionText = layoutSuggestion.querySelector('.suggestion-text');
                if (suggestionText) {
                    if (efficiency >= 80) {
                        suggestionText.textContent = `T·ªëi ∆∞u! Hi·ªáu su·∫•t s·ª≠ d·ª•ng gi·∫•y ${efficiency}% - Layout r·∫•t hi·ªáu qu·∫£`;
                    } else if (efficiency >= 60) {
                        suggestionText.textContent = `T·ªët! Hi·ªáu su·∫•t ${efficiency}% - C√≥ th·ªÉ c·∫£i thi·ªán b·∫±ng c√°ch ƒëi·ªÅu ch·ªânh l·ªÅ ho·∫∑c k√≠ch th∆∞·ªõc ·∫£nh`;
                    } else {
                        suggestionText.textContent = `Hi·ªáu su·∫•t ${efficiency}% - N√™n ƒëi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc ·∫£nh ho·∫∑c gi·∫•y ƒë·ªÉ t·ªëi ∆∞u h∆°n`;
                    }
                }
            }
            
            // Show debug info
            const debugInfo = document.getElementById('layoutDebugInfo');
            if (debugInfo) {
                debugInfo.innerHTML = `
                    <div style="margin-bottom: 8px;">
                        <strong>‚óº Th√¥ng tin gi·∫•y:</strong><br>
                        ‚Ä¢ K√≠ch th∆∞·ªõc gi·∫•y: ${paperWidth} √ó ${paperHeight} mm<br>
                        ‚Ä¢ V√πng in kh·∫£ d·ª•ng: ${availableWidth.toFixed(1)} √ó ${availableHeight.toFixed(1)} mm
                    </div>
                    <div style="margin-bottom: 8px;">
                        <strong>‚óª Th√¥ng tin ·∫£nh:</strong><br>
                        ‚Ä¢ K√≠ch th∆∞·ªõc ·∫£nh: ${actualSizeInfo}${rotationInfo}<br>
                        ‚Ä¢ Kho·∫£ng c√°ch gi·ªØa ·∫£nh: ${spacingInfo}
                    </div>
                    <div>
                        <strong>‚äû T√πy ch·ªçn b·ªë tr√≠ t·ªëi ∆∞u:</strong><br>
                        ‚Ä¢ B·ªë tr√≠ 1: ${layouts[0].totalPhotos} ·∫£nh (${layouts[0].cols} c·ªôt √ó ${layouts[0].rows} h√†ng)<br>
                        ‚Ä¢ B·ªë tr√≠ 2: ${layouts[1].totalPhotos} ·∫£nh (${layouts[1].cols} c·ªôt √ó ${layouts[1].rows} h√†ng)<br>
                        ‚Ä¢ <span style="color: #059669; font-weight: bold;">‚úì ƒê√£ ch·ªçn b·ªë tr√≠ t·ªëi ∆∞u: ${optimalLayout.totalPhotos} ·∫£nh (${optimalLayout.cols}√ó${optimalLayout.rows})</span>
                    </div>
                `;
            }
            
            this.printData.maxPhotosPerPage = optimalLayout.totalPhotos;

            // üêõ DEBUG: Log layout ƒë∆∞·ª£c ch·ªçn
            console.log('üìê calculateLayoutInfo: Layout ƒë∆∞·ª£c ch·ªçn:', {
                cols: optimalLayout.cols,
                rows: optimalLayout.rows,
                maxPhotosPerPage: optimalLayout.totalPhotos,
                paperSize: `${paperWidth}√ó${paperHeight}mm`,
                photoSize: `${optimalLayout.photoWidth}√ó${optimalLayout.photoHeight}mm`,
                gutter: `${optimalLayout.actualSpacing.x}√ó${optimalLayout.actualSpacing.y}mm`
            });

            this.printData.gridLayout = {
                rows: optimalLayout.rows,
                cols: optimalLayout.cols,
                photoWidth: optimalLayout.photoWidth,
                photoHeight: optimalLayout.photoHeight,
                actualSpacing: optimalLayout.actualSpacing
            };
            
            this.updateTotalPages();
            this.updatePreview();
            
            // Update duplex preview if in duplex mode
            if (this.printData.config.printMode === 'duplex') {
                this.updateDuplexPreview();
            }
        }

        calculateLayoutForOrientation(availableWidth, availableHeight, photoW, photoH, gutter) {
            // Thu·∫≠t to√°n t·ªëi ∆∞u h√≥a layout - C√îNG TH·ª®C CH√çNH X√ÅC
            // S·ªë l∆∞·ª£ng = floor((kho·∫£ng_tr·ªëng + gutter) / (k√≠ch_th∆∞·ªõc_·∫£nh + gutter))
            // V√≠ d·ª•: ·∫£nh 6x9cm tr√™n A4 d·ªçc c√≥ th·ªÉ d√†n 3x3 = 9 ·∫£nh

            // QUAN TR·ªåNG: N·∫øu gutter = 3mm (SK316 blade spacing), FORCE d√πng gutter ƒë√≥, kh√¥ng t·ªëi ∆∞u h√≥a!
            const isSK316Mode = (gutter.x === 3 && gutter.y === 3);

            // Method 1: T√≠nh to√°n chu·∫©n v·ªõi gutter hi·ªán t·∫°i
            let cols = Math.floor((availableWidth + gutter.x) / (photoW + gutter.x));
            let rows = Math.floor((availableHeight + gutter.y) / (photoH + gutter.y));

            // ƒê·∫£m b·∫£o √≠t nh·∫•t 1 ·∫£nh v·ª´a
            cols = Math.max(1, cols);
            rows = Math.max(1, rows);

            let finalCols, finalRows, bestLayout;

            if (isSK316Mode) {
                // SK316: FORCE d√πng gutter 3mm, kh√¥ng th·ª≠ method kh√°c
                console.log('üîß SK316 MODE: Force using 3mm gutter');
                console.log(`   üìä SK316 calculated: ${cols} cols √ó ${rows} rows = ${cols * rows} photos`);
                finalCols = cols;
                finalRows = rows;
                bestLayout = { cols: cols, rows: rows, photos: cols * rows, gutterX: gutter.x, gutterY: gutter.y };
            } else {
                // Normal mode: Th·ª≠ c√°c method kh√°c nhau ƒë·ªÉ t·ªëi ∆∞u

                // Method 2: Th·ª≠ v·ªõi gutter t·ªëi thi·ªÉu 1mm
                const minGutter = 1;
                let cols2 = Math.floor((availableWidth + minGutter) / (photoW + minGutter));
                let rows2 = Math.floor((availableHeight + minGutter) / (photoH + minGutter));
                cols2 = Math.max(1, cols2);
                rows2 = Math.max(1, rows2);

                // Method 3: Th·ª≠ v·ªõi gutter si√™u ch·∫∑t 0.5mm
                const tightGutter = 0.5;
                let cols3 = Math.floor((availableWidth + tightGutter) / (photoW + tightGutter));
                let rows3 = Math.floor((availableHeight + tightGutter) / (photoH + tightGutter));
                cols3 = Math.max(1, cols3);
                rows3 = Math.max(1, rows3);

                // Method 4: Th·ª≠ kh√¥ng c√≥ gutter (d√†n s√°t nhau) - t·ªëi ƒëa h√≥a s·ªë ·∫£nh
                let cols4 = Math.floor(availableWidth / photoW);
                let rows4 = Math.floor(availableHeight / photoH);
                cols4 = Math.max(1, cols4);
                rows4 = Math.max(1, rows4);

                // So s√°nh t·∫•t c·∫£ c√°c ph∆∞∆°ng ph√°p
                const layouts = [
                    { cols: cols, rows: rows, photos: cols * rows, gutterX: gutter.x, gutterY: gutter.y },
                    { cols: cols2, rows: rows2, photos: cols2 * rows2, gutterX: minGutter, gutterY: minGutter },
                    { cols: cols3, rows: rows3, photos: cols3 * rows3, gutterX: tightGutter, gutterY: tightGutter },
                    { cols: cols4, rows: rows4, photos: cols4 * rows4, gutterX: 0, gutterY: 0 }
                ];

                // Ch·ªçn layout c√≥ nhi·ªÅu ·∫£nh nh·∫•t
                bestLayout = layouts.reduce((best, current) =>
                    current.photos > best.photos ? current : best
                );

                finalCols = bestLayout.cols;
                finalRows = bestLayout.rows;
            }

            // Log chi ti·∫øt c√°c ph∆∞∆°ng ph√°p t√≠nh to√°n
            console.log('üîç Layout calculation details:');
            console.log(`   Available: ${availableWidth.toFixed(1)} √ó ${availableHeight.toFixed(1)} mm`);
            console.log(`   Photo: ${photoW} √ó ${photoH} mm`);
            console.log(`   Method 1 (current gutter ${gutter.x}√ó${gutter.y}mm): ${cols}√ó${rows} = ${cols*rows} ·∫£nh`);
            if (isSK316Mode) {
                console.log(`   üîß SK316 MODE: Using fixed 3mm gutter`);
            }
            console.log(`   ‚úÖ Best: ${finalCols}√ó${finalRows} = ${finalCols*finalRows} ·∫£nh`);

            // Calculate actual spacing for chosen layout
            let actualGutterX = bestLayout.gutterX;
            let actualGutterY = bestLayout.gutterY;

            // SK316: FORCE gi·ªØ nguy√™n 3mm gutter, kh√¥ng redistribute
            if (isSK316Mode) {
                actualGutterX = 3;
                actualGutterY = 3;
                console.log(`   üîí SK316: Locked gutter at 3mm √ó 3mm (blade spacing)`);
            } else {
                // Normal mode: If we have extra space, distribute it evenly
                if (finalCols > 1) {
                    const totalPhotoWidth = finalCols * photoW;
                    const availableGutterSpace = availableWidth - totalPhotoWidth;
                    actualGutterX = Math.max(0.5, availableGutterSpace / (finalCols - 1));
                }

                if (finalRows > 1) {
                    const totalPhotoHeight = finalRows * photoH;
                    const availableGutterSpace = availableHeight - totalPhotoHeight;
                    actualGutterY = Math.max(0.5, availableGutterSpace / (finalRows - 1));
                }
            }

            const layout = {
                cols: finalCols,
                rows: finalRows,
                totalPhotos: finalCols * finalRows,
                photoWidth: photoW,
                photoHeight: photoH,
                actualSpacing: {
                    x: actualGutterX,
                    y: actualGutterY
                }
            };
            
            // Store layout for use in other functions
            this.printData.gridLayout = layout;
            this.printData.maxPhotosPerPage = layout.totalPhotos;
            this.printData.totalPages = Math.ceil(this.printData.selectedImages.length / this.printData.maxPhotosPerPage);
            
            console.log('üìä Print data status:', {
                selectedImages: this.printData.selectedImages.length,
                maxPhotosPerPage: this.printData.maxPhotosPerPage,
                totalPages: this.printData.totalPages
            });
            
            console.log('üìê Layout calculated:', layout);
            console.log('üîÑ Calling updatePreview...');
            this.updatePreview();
            
            return layout;
        }

        // NEW METHOD: Layout th√¥ng minh k·∫øt h·ª£p 2 h∆∞·ªõng ƒë·∫∑t ·∫£nh
        calculateMixedOrientationLayout(availableWidth, availableHeight, photoW, photoH, gutter, totalImages = 0) {
            console.log('üîß Mixed orientation layout calculation for photo size:', photoW, 'x', photoH);
            console.log('üîß Available space:', availableWidth, 'x', availableHeight, 'mm');
            console.log('üîß Gutter:', gutter);
            console.log('üîß Total images:', totalImages);

            // ƒê·∫∑c bi·ªát cho ·∫£nh 5x15cm tr√™n A4
            const aspectRatio = Math.max(photoW, photoH) / Math.min(photoW, photoH);
            const isLongPhoto = aspectRatio >= 2.5;

            console.log('üìê Photo aspect analysis:', {
                photoW, photoH, aspectRatio,
                isLongPhoto,
                threshold: 2.5
            });

            if (!isLongPhoto) {
                console.log('‚ùå Kh√¥ng ph·∫£i ·∫£nh d√†i, d√πng thu·∫≠t to√°n th√¥ng th∆∞·ªùng');
                return this.calculateLayoutForOrientation(availableWidth, availableHeight, photoW, photoH, gutter);
            }

            console.log('‚úÖ ·∫¢nh d√†i detected, s·ª≠ d·ª•ng mixed layout algorithm');

            // üéØ FORCE exact layout cho 5√ó15cm (lu√¥n d√πng exact layout)
            console.log('üéØ FORCE exact layout cho size 5√ó15cm v·ªõi totalImages:', totalImages);
            const exactLayout = this.calculateExactLayout6Photos(availableWidth, availableHeight, gutter);
            if (exactLayout && exactLayout.totalPhotos === 6) {
                console.log('‚úÖ FORCED exact layout th√†nh c√¥ng cho 5√ó15cm!');
                return exactLayout; // Return ngay l·∫≠p t·ª©c - b·ªè qua t·∫•t c·∫£ combo kh√°c
            } else {
                console.log('‚ùå FORCED exact layout th·∫•t b·∫°i, ti·∫øp t·ª•c v·ªõi combo kh√°c');
            }

            // Th·ª≠ nhi·ªÅu combo kh√°c nhau cho ·∫£nh d√†i - ∆∞u ti√™n combo 4+2
            const combos = [];

            // Combo PRIORITY: 6 ·∫£nh 5√ó15cm theo t·ªça ƒë·ªô c·ª• th·ªÉ tr√™n A4
            // ‚≠ê ∆ØU TI√äN CAO NH·∫§T - theo ƒë√∫ng t·ªça ƒë·ªô user cung c·∫•p
            console.log('üîç ƒêang th·ª≠ t·∫°o exact layout cho 6 ·∫£nh...');
            const comboPriority = this.calculateExactLayout6Photos(availableWidth, availableHeight, gutter);
            if (comboPriority && comboPriority.totalPhotos === 6) {
                comboPriority.priority = 100; // ∆Øu ti√™n cao nh·∫•t
                combos.push(comboPriority);
                console.log('‚úÖ ƒê√£ th√™m exact layout v·ªõi priority 100');
            } else {
                console.log('‚ùå Kh√¥ng t·∫°o ƒë∆∞·ª£c exact layout, fallback to other combos');
            }

            // Combo 1: 6 ·∫£nh smart - 4 d·ªçc + 2 ngang (backup cho combo priority)
            // H√†ng 1: 4 ·∫£nh d·ªçc 4√ó12cm (40√ó120mm): 4√ó40=160mm ‚úÖ
            // H√†ng 2: 2 ·∫£nh ngang 10√ó4cm (100√ó40mm): 2√ó100=200mm ‚úÖ
            const bookmarkW = 40; // 4cm
            const bookmarkH = 120; // 12cm
            const bookmarkNgangW = 100; // 10cm
            const bookmarkNgangH = 40; // 4cm
            const combo1 = this.calculateComboLayout(availableWidth, availableHeight, [
                { count: 4, width: bookmarkW, height: bookmarkH, arrangement: 'horizontal' },
                { count: 2, width: bookmarkNgangW, height: bookmarkNgangH, arrangement: 'horizontal' }
            ], gutter);
            if (combo1.totalPhotos === 6) {
                combo1.priority = 90;
                combos.push(combo1);
            }

            // Combo 2: 6 ·∫£nh - 3 d·ªçc + 3 d·ªçc (2 h√†ng) - ch·ªâ d√πng khi combo 4+2 kh√¥ng kh·∫£ thi
            // H√†ng 1: 3 ·∫£nh d·ªçc 4.8√ó14cm (48√ó140mm): 3√ó48=144mm ‚úÖ
            // H√†ng 2: 3 ·∫£nh d·ªçc 4.8√ó14cm (48√ó140mm): 3√ó48=144mm ‚úÖ
            const optimal6W = 48; // 4.8cm
            const optimal6H = 140; // 14cm
            const combo2 = this.calculateComboLayout(availableWidth, availableHeight, [
                { count: 3, width: optimal6W, height: optimal6H, arrangement: 'horizontal' },
                { count: 3, width: optimal6W, height: optimal6H, arrangement: 'horizontal' }
            ], gutter);
            if (combo2.totalPhotos === 6) {
                combo2.priority = 70; // Th·∫•p h∆°n combo 4+2
                combos.push(combo2);
            }

            // Combo 3: 5 ·∫£nh - 4 d·ªçc + 1 ngang
            const smartPhotoW = 45; // 4.5cm
            const smartPhotoH = 135; // 13.5cm
            const combo3 = this.calculateComboLayout(availableWidth, availableHeight, [
                { count: 4, width: smartPhotoW, height: smartPhotoH, arrangement: 'horizontal' },
                { count: 1, width: smartPhotoH, height: smartPhotoW, arrangement: 'horizontal' }
            ], gutter);
            if (combo3.totalPhotos > 0) {
                combo3.priority = 50;
                combos.push(combo3);
            }

            // Combo 4: 4 ·∫£nh - 3 ·∫£nh d·ªçc + 1 ·∫£nh ngang
            const combo4 = this.calculateComboLayout(availableWidth, availableHeight, [
                { count: 3, width: photoW, height: photoH, arrangement: 'horizontal' }, // 3 ·∫£nh d·ªçc: 3√ó50=150mm
                { count: 1, width: photoH, height: photoW, arrangement: 'horizontal' }  // 1 ·∫£nh ngang: 150mm
            ], gutter);
            if (combo4.totalPhotos > 0) {
                combo4.priority = 40;
                combos.push(combo4);
            }

            // Combo 5: 4 ·∫£nh - 2 ·∫£nh d·ªçc + 2 ·∫£nh ngang
            const combo5 = this.calculateComboLayout(availableWidth, availableHeight, [
                { count: 2, width: photoW, height: photoH, arrangement: 'horizontal' }, // 2√ó50=100mm
                { count: 2, width: photoH, height: photoW, arrangement: 'horizontal' }  // 2√ó150=300mm - s·∫Ω kh√¥ng v·ª´a
            ], gutter);
            if (combo5.totalPhotos > 0) {
                combo5.priority = 35;
                combos.push(combo5);
            }

            // Combo 6: 3 ·∫£nh d·ªçc tr√™n 1 h√†ng
            const combo6 = this.calculateComboLayout(availableWidth, availableHeight, [
                { count: 3, width: photoW, height: photoH, arrangement: 'horizontal' } // 3√ó50=150mm
            ], gutter);
            if (combo6.totalPhotos > 0) {
                combo6.priority = 30;
                combos.push(combo6);
            }

            // Combo 7: 2 ·∫£nh ngang
            const combo7 = this.calculateComboLayout(availableWidth, availableHeight, [
                { count: 1, width: photoH, height: photoW, arrangement: 'horizontal' }, // 150mm
                { count: 1, width: photoH, height: photoW, arrangement: 'horizontal' }  // 150mm
            ], gutter);
            if (combo7.totalPhotos > 0) {
                combo7.priority = 20;
                combos.push(combo7);
            }

            // Ch·ªçn combo t·ªët nh·∫•t - ∆∞u ti√™n priority tr∆∞·ªõc, sau ƒë√≥ ƒë·∫øn s·ªë ·∫£nh
            let bestCombo = { totalPhotos: 0, rows: 0, cols: 0, photoWidth: photoW, photoHeight: photoH, actualSpacing: { x: gutter.x, y: gutter.y }, isMixed: false, priority: 0 };

            for (const combo of combos) {
                // ∆Øu ti√™n combo c√≥ priority cao h∆°n
                if (combo.priority > bestCombo.priority) {
                    bestCombo = combo;
                }
                // N·∫øu priority b·∫±ng nhau, ch·ªçn combo c√≥ nhi·ªÅu ·∫£nh h∆°n
                else if (combo.priority === bestCombo.priority && combo.totalPhotos > bestCombo.totalPhotos) {
                    bestCombo = combo;
                }
            }

            // N·∫øu kh√¥ng c√≥ combo n√†o t·ªët h∆°n, fallback v·ªÅ layout th√¥ng th∆∞·ªùng
            if (bestCombo.totalPhotos === 0) {
                return this.calculateLayoutForOrientation(availableWidth, availableHeight, photoW, photoH, gutter);
            }

            console.log('üîç Available combos:', combos.map(c => ({ totalPhotos: c.totalPhotos, priority: c.priority })));
            console.log('üéØ Best mixed layout:', bestCombo);
            return bestCombo;
        }

        // Helper method ƒë·ªÉ t√≠nh layout ch√≠nh x√°c cho 6 ·∫£nh 5√ó15cm tr√™n A4
        calculateExactLayout6Photos(availableWidth, availableHeight, gutter) {
            console.log('üéØ calculateExactLayout6Photos called with:', { availableWidth, availableHeight, gutter });

            // Ki·ªÉm tra orientation d·ª±a tr√™n available space
            const isPortrait = availableHeight > availableWidth;
            console.log('üìê Orientation detected:', isPortrait ? 'Portrait' : 'Landscape');

            if (isPortrait) {
                // Portrait mode: 4 ·∫£nh d·ªçc tr√™n + 2 ·∫£nh ngang d∆∞·ªõi
                return this.createPortraitExactLayout();
            } else {
                // Landscape mode: 2 ·∫£nh d·ªçc tr√°i + 4 ·∫£nh ngang ph·∫£i
                return this.createLandscapeExactLayout();
            }
        }

        // T·∫°o exact layout cho Portrait orientation
        createPortraitExactLayout() {
            // D√πng k√≠ch th∆∞·ªõc th·ª±c 5√ó15cm nh∆∞ y√™u c·∫ßu
            const photoW = 50; // 5cm = 50mm (·∫£nh d·ªçc)
            const photoH = 150; // 15cm = 150mm (·∫£nh d·ªçc)
            const photoNgangW = 150; // 15cm = 150mm (·∫£nh ngang)
            const photoNgangH = 50; // 5cm = 50mm (·∫£nh ngang)

            // Portrait layout: 4 ·∫£nh d·ªçc tr√™n + 2 ·∫£nh ngang d∆∞·ªõi
            const layout = {
                totalPhotos: 6,
                rows: 2,
                cols: 4,
                photoWidth: 50,
                photoHeight: 150,
                actualSpacing: { x: 0, y: 0 },
                isMixed: true,
                priority: 100,
                exactPositions: [
                    // H√†ng tr√™n: 4 ·∫£nh ƒë·∫∑t d·ªçc (50√ó150mm)
                    { x: 1, y: 3, width: 50, height: 150, rotation: 0 },
                    { x: 52, y: 3, width: 50, height: 150, rotation: 0 },
                    { x: 103, y: 3, width: 50, height: 150, rotation: 0 },
                    { x: 154, y: 3, width: 50, height: 150, rotation: 0 },
                    // H√†ng d∆∞·ªõi: 2 ·∫£nh ngang (150√ó50mm v·ªõi rotation=90¬∞)
                    { x: 1, y: 155, width: 150, height: 50, rotation: 90 },
                    { x: 1, y: 207, width: 150, height: 50, rotation: 90 }
                ]
            };
            console.log('‚úÖ Portrait exact layout created');
            return layout;
        }

        // T·∫°o exact layout cho Landscape orientation
        createLandscapeExactLayout() {
            // Landscape layout: 2 ·∫£nh d·ªçc tr√°i + 4 ·∫£nh ngang ph·∫£i
            const layout = {
                totalPhotos: 6,
                rows: 4,
                cols: 2,
                photoWidth: 150,
                photoHeight: 50,
                actualSpacing: { x: 0, y: 0 },
                isMixed: true,
                priority: 100,
                exactPositions: [
                    // C·ªôt tr√°i: 2 ·∫£nh d·ªçc (50√ó150mm v·ªõi rotation=0)
                    { x: 3, y: 1, width: 50, height: 150, rotation: 0 },
                    { x: 3, y: 152, width: 50, height: 150, rotation: 0 },
                    // C·ªôt ph·∫£i: 4 ·∫£nh ngang (150√ó50mm v·ªõi rotation=90¬∞)
                    { x: 60, y: 1, width: 150, height: 50, rotation: 90 },
                    { x: 60, y: 52, width: 150, height: 50, rotation: 90 },
                    { x: 60, y: 103, width: 150, height: 50, rotation: 90 },
                    { x: 60, y: 154, width: 150, height: 50, rotation: 90 }
                ]
            };
            console.log('‚úÖ Landscape exact layout created');
            return layout;
        }

        // T·∫°o layout v·ªõi t·ªça ƒë·ªô ch√≠nh x√°c theo y√™u c·∫ßu user
        createExactLayoutWithCoordinates() {
            const layout = {
                totalPhotos: 6,
                rows: 2,
                cols: 4,
                photoWidth: 50,
                photoHeight: 150,
                actualSpacing: { x: 0, y: 0 }, // Kh√¥ng c·∫ßn spacing v√¨ ƒë√£ c√≥ t·ªça ƒë·ªô c·ªë ƒë·ªãnh
                isMixed: true,
                priority: 100,
                exactPositions: [
                    // H√†ng tr√™n: 4 ·∫£nh ƒë·∫∑t d·ªçc (50√ó150mm) - ƒëi·ªÅu ch·ªânh ƒë·ªÉ v·ª´a 204mm
                    { x: 1, y: 3, width: 50, height: 150, rotation: 0 },    // ·∫¢nh 1
                    { x: 52, y: 3, width: 50, height: 150, rotation: 0 },   // ·∫¢nh 2
                    { x: 103, y: 3, width: 50, height: 150, rotation: 0 },  // ·∫¢nh 3
                    { x: 154, y: 3, width: 50, height: 150, rotation: 0 },  // ·∫¢nh 4 (154+50=204mm)
                    // H√†ng d∆∞·ªõi: 2 ·∫£nh xoay ngang (150√ó50mm v·ªõi rotation=90¬∞)
                    { x: 1, y: 155, width: 150, height: 50, rotation: 90 }, // ·∫¢nh 5
                    { x: 1, y: 207, width: 150, height: 50, rotation: 90 }  // ·∫¢nh 6
                ]
            };

            console.log('‚úÖ Exact layout v·ªõi t·ªça ƒë·ªô ch√≠nh x√°c:', layout);
            return layout;
        }

        // Helper method t·∫°o exact layout v·ªõi c√°c k√≠ch th∆∞·ªõc cho tr∆∞·ªõc
        createExactLayout(photoW, photoH, photoNgangW, photoNgangH, spacing) {
            const layout = {
                totalPhotos: 6,
                rows: 2,
                cols: 4, // max cols
                photoWidth: photoW,
                photoHeight: photoH,
                actualSpacing: { x: spacing, y: spacing },
                isMixed: true,
                priority: 100,
                exactPositions: [
                    // H√†ng 1: 4 ·∫£nh d·ªçc
                    { x: 0, y: 0, width: photoW, height: photoH }, // ·∫¢nh 1
                    { x: photoW + spacing, y: 0, width: photoW, height: photoH }, // ·∫¢nh 2
                    { x: 2 * (photoW + spacing), y: 0, width: photoW, height: photoH }, // ·∫¢nh 3
                    { x: 3 * (photoW + spacing), y: 0, width: photoW, height: photoH }, // ·∫¢nh 4
                    // H√†ng 2: 2 ·∫£nh ngang
                    { x: 0, y: photoH + spacing, width: photoNgangW, height: photoNgangH }, // ·∫¢nh 5
                    { x: photoNgangW + spacing, y: photoH + spacing, width: photoNgangW, height: photoNgangH } // ·∫¢nh 6
                ]
            };

            console.log('‚úÖ Exact layout created:', {
                photoW, photoH, photoNgangW, photoNgangH,
                totalWidth: Math.max(4 * photoW + 3 * spacing, 2 * photoNgangW + spacing),
                totalHeight: photoH + spacing + photoNgangH,
                layout
            });
            return layout;
        }

        // Helper method ƒë·ªÉ t√≠nh combo layout
        calculateComboLayout(availableWidth, availableHeight, rows, gutter) {
            console.log('üßÆ calculateComboLayout called with:', { availableWidth, availableHeight, rows, gutter });
            let currentY = 0;
            let totalPhotos = 0;
            let maxRowWidth = 0;
            const layoutRows = [];

            for (const row of rows) {
                // T√≠nh width c·∫ßn thi·∫øt cho row n√†y
                const rowWidth = row.count * row.width + (row.count - 1) * gutter.x;
                const rowHeight = row.height;

                console.log(`üßÆ Row ${layoutRows.length + 1}:`, {
                    count: row.count,
                    width: row.width,
                    height: row.height,
                    rowWidth,
                    rowHeight,
                    currentY,
                    fits: rowWidth <= availableWidth && currentY + rowHeight <= availableHeight
                });

                // Ki·ªÉm tra c√≥ v·ª´a kh√¥ng
                if (rowWidth > availableWidth || currentY + rowHeight > availableHeight) {
                    console.log('üö´ Row kh√¥ng v·ª´a, d·ª´ng');
                    break; // Kh√¥ng v·ª´a, d·ª´ng
                }

                layoutRows.push(row);
                totalPhotos += row.count;
                maxRowWidth = Math.max(maxRowWidth, rowWidth);
                currentY += rowHeight;

                // Ch·ªâ c·ªông gutter n·∫øu kh√¥ng ph·∫£i row cu·ªëi
                if (layoutRows.length < rows.length) {
                    currentY += gutter.y;
                }
            }

            if (layoutRows.length === 0) {
                return { totalPhotos: 0, rows: 0, cols: 0, photoWidth: 0, photoHeight: 0, actualSpacing: { x: 0, y: 0 }, isMixed: false };
            }

            // T√≠nh cols v√† rows ƒë·∫°i di·ªán
            const avgCols = Math.round(totalPhotos / layoutRows.length);
            const rowsCount = layoutRows.length;

            return {
                totalPhotos,
                rows: rowsCount,
                cols: avgCols,
                photoWidth: layoutRows[0].width, // D√πng k√≠ch th∆∞·ªõc ·∫£nh ƒë·∫ßu ti√™n l√†m ƒë·∫°i di·ªán
                photoHeight: layoutRows[0].height,
                actualSpacing: { x: gutter.x, y: gutter.y },
                isMixed: layoutRows.length > 1, // True n·∫øu c√≥ nhi·ªÅu h∆°n 1 lo·∫°i row
                layoutRows // L∆∞u th√¥ng tin chi ti·∫øt c√°c rows
            };
        }

        updatePaperGridVisualization(cols, rows, orientation) {
            const paperGrid = document.getElementById('paperGrid');
            if (!paperGrid) return;

            // Clear existing cells
            paperGrid.innerHTML = '';

            // Set grid template
            paperGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            paperGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

            // Create cells
            const totalCells = cols * rows;
            for (let i = 0; i < totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'paper-grid-cell';
                cell.innerHTML = 'üì∑';
                cell.title = `V·ªã tr√≠ ${i + 1}`;
                paperGrid.appendChild(cell);
            }

            // Update paper frame aspect ratio based on orientation
            const paperFrame = document.getElementById('paperFrame');
            if (paperFrame) {
                if (orientation === 'portrait') {
                    paperFrame.style.aspectRatio = '210/297';
                } else {
                    paperFrame.style.aspectRatio = '297/210';
                }
            }
        }

        updateTotalPages() {
            const totalImages = this.printData.selectedImages.length;
            const maxPerPage = this.printData.maxPhotosPerPage || 1;
            this.printData.totalPages = Math.ceil(totalImages / maxPerPage);

            // üêõ DEBUG: Log ƒë·ªÉ ki·ªÉm tra s·ªë trang
            console.log('üìä updateTotalPages:', {
                totalImages,
                maxPerPage,
                totalPages: this.printData.totalPages,
                currentPage: this.printData.currentPage
            });

            document.getElementById('totalPages').textContent = this.printData.totalPages;
            
            // Update preview controls
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            const pageIndicator = document.getElementById('pageIndicator');
            
            if (prevBtn) prevBtn.disabled = this.printData.currentPage <= 0;
            if (nextBtn) nextBtn.disabled = this.printData.currentPage >= this.printData.totalPages - 1;
            if (pageIndicator) pageIndicator.textContent = `Trang ${this.printData.currentPage + 1}/${this.printData.totalPages}`;
        }

        handlePrintImages(files) {
            // üéØ FIX: N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô duplex, th√™m v√†o gallery thay v√¨ print list
            const isDuplexMode = this.printData?.duplexEnabled;

            if (isDuplexMode) {
                console.log('üì∏ Duplex mode detected - Adding images to gallery instead of print list');
                Array.from(files).forEach(file => {
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            await this.addImageToGallery(e.target.result, file.name, false);
                        };
                        reader.readAsDataURL(file);
                    }
                });
                this.showToast(`‚úÖ ƒê√£ th√™m ${files.length} ·∫£nh v√†o kho!`, 'success');
            } else {
                // Ch·∫ø ƒë·ªô th∆∞·ªùng - th√™m v√†o print list nh∆∞ c≈©
                Array.from(files).forEach(file => {
                    if (file.type.startsWith('image/')) {
                        this.addImageToPrintList(file);
                    }
                });
            }
        }

        // H√†m x·ª≠ l√Ω files t·ª´ File System
        handlePrintFiles(files) {
            // üéØ FIX: N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô duplex, th√™m v√†o gallery thay v√¨ print list
            const isDuplexMode = this.printData?.duplexEnabled;

            if (isDuplexMode) {
                console.log('üì∏ Duplex mode detected - Adding files to gallery instead of print list');
                Array.from(files).forEach(file => {
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            await this.addImageToGallery(e.target.result, file.name, false);
                        };
                        reader.readAsDataURL(file);
                    }
                });
                this.showToast(`‚úÖ ƒê√£ th√™m ${files.length} ·∫£nh v√†o kho!`, 'success');
            } else {
                // Ch·∫ø ƒë·ªô th∆∞·ªùng - th√™m v√†o print list nh∆∞ c≈©
                Array.from(files).forEach(file => {
                    if (file.type.startsWith('image/')) {
                        this.addImageToPrintList(file);
                    }
                });
            }
        }

        addImageToPrintList(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    this.printData.selectedImages.push({
                        file: file,
                        src: e.target.result,
                        img: img,
                        name: file.name
                    });

                    // üêõ DEBUG: Log m·ªói khi th√™m ·∫£nh
                    console.log(`‚ûï addImageToPrintList: ƒê√£ th√™m "${file.name}". T·ªïng ·∫£nh hi·ªán t·∫°i: ${this.printData.selectedImages.length}`);

                    this.updateSelectedImagesDisplay();
                    this.updateTotalPages();
                    this.updatePreview();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        updateSelectedImagesDisplay() {
            const container = document.getElementById('selectedImagesContainer');
            const grid = document.getElementById('selectedImagesGrid');
            const countSpan = document.getElementById('selectedCount');

            if (!container || !grid || !countSpan) return;

            // Initialize selection tracking if not exists
            if (!this.selectedImageIndices) {
                this.selectedImageIndices = new Set();
            }

            countSpan.textContent = this.printData.selectedImages.length;

            if (this.printData.selectedImages.length === 0) {
                container.style.display = 'none';
                this.updateImageDistributionDisplay();
                return;
            }

            container.style.display = 'block';
            grid.innerHTML = '';

            // Get current sort order
            const images = this.getSortedImages();

            images.forEach((imageData, index) => {
                const item = document.createElement('div');
                item.className = 'grid-image-item';
                item.dataset.index = imageData.originalIndex;

                // Image number badge
                const numberBadge = document.createElement('div');
                numberBadge.className = 'grid-image-number';
                numberBadge.textContent = index + 1;

                // Checkbox for selection
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'grid-image-checkbox';
                checkbox.dataset.index = imageData.originalIndex;
                checkbox.checked = this.selectedImageIndices.has(imageData.originalIndex);
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    this.handleImageCheckboxChange(imageData.originalIndex, checkbox.checked);
                });

                // Main image
                const img = document.createElement('img');
                img.className = 'grid-image-img';
                img.src = imageData.dataUrl || imageData.data || imageData.src || '';
                img.alt = imageData.name || `Image ${index + 1}`;

                img.onerror = () => {
                    console.warn('Failed to load image:', imageData.name);
                };

                // Hover actions
                const actions = document.createElement('div');
                actions.className = 'grid-image-actions';

                const rotateBtn = document.createElement('button');
                rotateBtn.className = 'grid-action-icon';
                rotateBtn.innerHTML = 'üîÑ';
                rotateBtn.title = 'Xoay 90¬∞';
                rotateBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.rotateImage(imageData.originalIndex);
                });

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'grid-action-icon delete';
                deleteBtn.innerHTML = 'üóëÔ∏è';
                deleteBtn.title = 'X√≥a';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removeImageFromPrintList(imageData.originalIndex);
                });

                actions.appendChild(rotateBtn);
                actions.appendChild(deleteBtn);

                // Mark as selected if in set
                if (this.selectedImageIndices.has(imageData.originalIndex)) {
                    item.classList.add('selected');
                }

                item.appendChild(numberBadge);
                item.appendChild(checkbox);
                item.appendChild(img);
                item.appendChild(actions);
                grid.appendChild(item);
            });

            // Show other sections
            const previewContainer = document.getElementById('printPreviewContainer');
            const exportSection = document.getElementById('exportSection');
            if (previewContainer) previewContainer.style.display = 'block';
            if (exportSection) exportSection.style.display = 'block';

            // Enable export buttons
            const generateBtn = document.getElementById('generatePrintBtn');
            if (generateBtn) generateBtn.disabled = false;

            const generateBtnNew = document.getElementById('generatePrintBtnNew');
            if (generateBtnNew) generateBtnNew.disabled = false;

            const generatePreviewBtn = document.getElementById('generatePreviewBtn');
            if (generatePreviewBtn) generatePreviewBtn.disabled = false;

            // Update bulk toolbar visibility
            this.updateBulkToolbar();

            // Update image distribution display
            this.updateImageDistributionDisplay();
        }

        getSortedImages() {
            const sortSelect = document.getElementById('sortImagesSelect');
            const sortType = sortSelect ? sortSelect.value : 'order';

            // Create array with original indices
            const images = this.printData.selectedImages.map((img, idx) => ({
                ...img,
                originalIndex: idx
            }));

            switch(sortType) {
                case 'name-asc':
                    return images.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
                case 'name-desc':
                    return images.sort((a, b) => (b.name || '').localeCompare(a.name || ''));
                case 'size-asc':
                    return images.sort((a, b) => (a.file?.size || 0) - (b.file?.size || 0));
                case 'size-desc':
                    return images.sort((a, b) => (b.file?.size || 0) - (a.file?.size || 0));
                default: // 'order'
                    return images;
            }
        }

        handleImageCheckboxChange(index, checked) {
            if (checked) {
                this.selectedImageIndices.add(index);
            } else {
                this.selectedImageIndices.delete(index);
            }

            // Update visual state
            const item = document.querySelector(`.grid-image-item[data-index="${index}"]`);
            if (item) {
                if (checked) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            }

            // Update select all checkbox
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (selectAllCheckbox) {
                const allSelected = this.selectedImageIndices.size === this.printData.selectedImages.length;
                selectAllCheckbox.checked = allSelected;
                selectAllCheckbox.indeterminate = this.selectedImageIndices.size > 0 && !allSelected;
            }

            this.updateBulkToolbar();
        }

        updateBulkToolbar() {
            const toolbar = document.getElementById('bulkActionsToolbar');
            const countSpan = document.getElementById('bulkSelectionCount');

            if (!toolbar || !countSpan) return;

            const selectedCount = this.selectedImageIndices.size;

            if (selectedCount > 0) {
                toolbar.style.display = 'flex';
                countSpan.textContent = `${selectedCount} ·∫£nh ƒë√£ ch·ªçn`;
            } else {
                toolbar.style.display = 'none';
            }
        }

        // ============ DUPLEX DISTRIBUTION FUNCTIONS ============

        updateDuplexDistributionStats() {
            const maxPhotosPerPage = this.printData.maxPhotosPerPage || 1;

            // Front stats
            const frontCount = this.printData.frontImages?.length || 0;
            const frontPages = Math.ceil(frontCount / maxPhotosPerPage);
            const frontPositions = frontPages * maxPhotosPerPage;

            document.getElementById('frontDistImageCount').textContent = frontCount;
            document.getElementById('frontDistPageCount').textContent = frontPages;
            document.getElementById('frontDistPositions').textContent = frontPositions;

            // Back stats
            const backCount = this.printData.backImages?.length || 0;
            const backPages = Math.ceil(backCount / maxPhotosPerPage);
            const backPositions = backPages * maxPhotosPerPage;

            document.getElementById('backDistImageCount').textContent = backCount;
            document.getElementById('backDistPageCount').textContent = backPages;
            document.getElementById('backDistPositions').textContent = backPositions;

            console.log('üìä Duplex distribution stats updated:', {
                front: { count: frontCount, pages: frontPages, positions: frontPositions },
                back: { count: backCount, pages: backPages, positions: backPositions }
            });
        }

        fillDuplexFrontPages() {
            if (!this.printData.frontImages || this.printData.frontImages.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh m·∫∑t tr∆∞·ªõc ƒë·ªÉ d√†n!', 'error');
                return;
            }

            const maxPhotosPerPage = this.printData.maxPhotosPerPage || 1;
            const firstImage = this.printData.frontImages[0];
            const totalPages = Math.max(1, Math.ceil(this.printData.frontImages.length / maxPhotosPerPage));
            const totalPositionsNeeded = totalPages * maxPhotosPerPage;

            // Clear and fill with first image
            this.printData.frontImages = [];
            for (let i = 0; i < totalPositionsNeeded; i++) {
                this.printData.frontImages.push({
                    ...firstImage,
                    name: `${firstImage.name || firstImage.filename}_front_${i + 1}`
                });
            }

            this.updateDuplexDistributionStats();
            this.updateGalleryGridDuplexV2();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.showToast(`üîÑ ƒê√£ d√†n ·∫£nh "${firstImage.name || firstImage.filename}" cho ${totalPages} trang m·∫∑t tr∆∞·ªõc (${totalPositionsNeeded} v·ªã tr√≠)!`, 'success');
        }

        fillDuplexBackPages() {
            if (!this.printData.backImages || this.printData.backImages.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh m·∫∑t sau ƒë·ªÉ d√†n!', 'error');
                return;
            }

            const maxPhotosPerPage = this.printData.maxPhotosPerPage || 1;
            const firstImage = this.printData.backImages[0];
            const totalPages = Math.max(1, Math.ceil(this.printData.backImages.length / maxPhotosPerPage));
            const totalPositionsNeeded = totalPages * maxPhotosPerPage;

            // Clear and fill with first image
            this.printData.backImages = [];
            for (let i = 0; i < totalPositionsNeeded; i++) {
                this.printData.backImages.push({
                    ...firstImage,
                    name: `${firstImage.name || firstImage.filename}_back_${i + 1}`
                });
            }

            this.updateDuplexDistributionStats();
            this.updateGalleryGridDuplexV2();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.showToast(`üîÑ ƒê√£ d√†n ·∫£nh "${firstImage.name || firstImage.filename}" cho ${totalPages} trang m·∫∑t sau (${totalPositionsNeeded} v·ªã tr√≠)!`, 'success');
        }

        distributeDuplexFrontEvenly() {
            if (!this.printData.frontImages || this.printData.frontImages.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh m·∫∑t tr∆∞·ªõc ƒë·ªÉ ph√¢n b·ªï!', 'error');
                return;
            }

            const maxPhotosPerPage = this.printData.maxPhotosPerPage || 1;
            const originalImages = [...this.printData.frontImages];
            const totalPages = Math.max(1, Math.ceil(originalImages.length / maxPhotosPerPage));
            const totalPositionsNeeded = totalPages * maxPhotosPerPage;

            // Clear and distribute evenly
            this.printData.frontImages = [];
            for (let i = 0; i < totalPositionsNeeded; i++) {
                const imageIndex = i % originalImages.length;
                const copyNumber = Math.floor(i / originalImages.length) + 1;
                const sourceImage = originalImages[imageIndex];

                this.printData.frontImages.push({
                    ...sourceImage,
                    name: copyNumber > 1 ? `${sourceImage.name || sourceImage.filename}_front_${copyNumber}` : (sourceImage.name || sourceImage.filename)
                });
            }

            this.updateDuplexDistributionStats();
            this.updateGalleryGridDuplexV2();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.showToast(`‚öñÔ∏è ƒê√£ ph√¢n b·ªï ƒë·ªÅu ${originalImages.length} ·∫£nh m·∫∑t tr∆∞·ªõc cho ${totalPages} trang!`, 'success');
        }

        distributeDuplexBackEvenly() {
            if (!this.printData.backImages || this.printData.backImages.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh m·∫∑t sau ƒë·ªÉ ph√¢n b·ªï!', 'error');
                return;
            }

            const maxPhotosPerPage = this.printData.maxPhotosPerPage || 1;
            const originalImages = [...this.printData.backImages];
            const totalPages = Math.max(1, Math.ceil(originalImages.length / maxPhotosPerPage));
            const totalPositionsNeeded = totalPages * maxPhotosPerPage;

            // Clear and distribute evenly
            this.printData.backImages = [];
            for (let i = 0; i < totalPositionsNeeded; i++) {
                const imageIndex = i % originalImages.length;
                const copyNumber = Math.floor(i / originalImages.length) + 1;
                const sourceImage = originalImages[imageIndex];

                this.printData.backImages.push({
                    ...sourceImage,
                    name: copyNumber > 1 ? `${sourceImage.name || sourceImage.filename}_back_${copyNumber}` : (sourceImage.name || sourceImage.filename)
                });
            }

            this.updateDuplexDistributionStats();
            this.updateGalleryGridDuplexV2();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.showToast(`‚öñÔ∏è ƒê√£ ph√¢n b·ªï ƒë·ªÅu ${originalImages.length} ·∫£nh m·∫∑t sau cho ${totalPages} trang!`, 'success');
        }

        clearDuplexFront() {
            if (confirm('‚ö†Ô∏è X√°c nh·∫≠n x√≥a t·∫•t c·∫£ ·∫£nh m·∫∑t tr∆∞·ªõc?')) {
                this.printData.frontImages = [];
                this.updateDuplexDistributionStats();
                this.updateGalleryGridDuplexV2();
                this.renderDuplexCanvas('front');
                this.renderDuplexCanvas('back');
                this.showToast('üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ ·∫£nh m·∫∑t tr∆∞·ªõc!', 'info');
            }
        }

        clearDuplexBack() {
            if (confirm('‚ö†Ô∏è X√°c nh·∫≠n x√≥a t·∫•t c·∫£ ·∫£nh m·∫∑t sau?')) {
                this.printData.backImages = [];
                this.updateDuplexDistributionStats();
                this.updateGalleryGridDuplexV2();
                this.renderDuplexCanvas('front');
                this.renderDuplexCanvas('back');
                this.showToast('üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ ·∫£nh m·∫∑t sau!', 'info');
            }
        }

        fillAllDuplexPages() {
            const hasFront = this.printData.frontImages && this.printData.frontImages.length > 0;
            const hasBack = this.printData.backImages && this.printData.backImages.length > 0;

            if (!hasFront && !hasBack) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ d√†n!', 'error');
                return;
            }

            if (hasFront) this.fillDuplexFrontPages();
            if (hasBack) this.fillDuplexBackPages();

            this.showToast('üîÑ ƒê√£ d√†n ·∫£nh cho c·∫£ 2 m·∫∑t!', 'success');
        }

        distributeAllDuplexEvenly() {
            const hasFront = this.printData.frontImages && this.printData.frontImages.length > 0;
            const hasBack = this.printData.backImages && this.printData.backImages.length > 0;

            if (!hasFront && !hasBack) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ ph√¢n b·ªï!', 'error');
                return;
            }

            if (hasFront) this.distributeDuplexFrontEvenly();
            if (hasBack) this.distributeDuplexBackEvenly();

            this.showToast('‚ö° ƒê√£ ph√¢n b·ªï ƒë·ªÅu ·∫£nh cho c·∫£ 2 m·∫∑t!', 'success');
        }

        // ============ CUSTOM DISTRIBUTION FUNCTIONS ============

        updateDuplexCustomDistributionGrid(side) {
            const grid = document.getElementById(side === 'front' ? 'frontDistributionGrid' : 'backDistributionGrid');
            if (!grid) return;

            const images = side === 'front' ? this.printData.frontImages : this.printData.backImages;
            if (!images || images.length === 0) {
                grid.innerHTML = '<div style="text-align: center; padding: 20px; color: #9ca3af;">Ch∆∞a c√≥ ·∫£nh n√†o</div>';
                return;
            }

            // Nh√≥m ·∫£nh theo imageKey ƒë·ªÉ lo·∫°i b·ªè duplicate
            const uniqueImagesMap = new Map();

            images.forEach((imageData) => {
                const imageKey = imageData.id?.split('_')[0] || imageData.data || imageData.src || imageData.name;

                if (!uniqueImagesMap.has(imageKey)) {
                    uniqueImagesMap.set(imageKey, {
                        data: imageData,
                        count: 1,
                        originalName: imageData.name?.replace(/_front_\d+$/, '').replace(/_back_\d+$/, '') || imageData.name
                    });
                } else {
                    uniqueImagesMap.get(imageKey).count++;
                }
            });

            // Render grid items
            grid.innerHTML = '';
            let displayIndex = 0;

            uniqueImagesMap.forEach((imageInfo, imageKey) => {
                const item = document.createElement('div');
                item.className = 'dist-grid-item';
                item.dataset.imageKey = imageKey;
                item.dataset.side = side;

                // Header
                const header = document.createElement('div');
                header.className = 'dist-item-header';

                const thumb = document.createElement('img');
                thumb.src = imageInfo.data.data || imageInfo.data.src || '';
                thumb.className = 'dist-item-thumb';
                thumb.alt = imageInfo.originalName;

                const info = document.createElement('div');
                info.className = 'dist-item-info';

                const name = document.createElement('div');
                name.className = 'dist-item-name';
                name.textContent = imageInfo.originalName || `·∫¢nh ${displayIndex + 1}`;
                name.title = imageInfo.originalName;

                const meta = document.createElement('div');
                meta.className = 'dist-item-meta';
                meta.innerHTML = `#${displayIndex + 1}`;

                if (imageInfo.count > 1) {
                    const badge = document.createElement('span');
                    badge.className = 'dist-quantity-badge';
                    badge.textContent = `√ó${imageInfo.count}`;
                    meta.appendChild(badge);
                }

                info.appendChild(name);
                info.appendChild(meta);
                header.appendChild(thumb);
                header.appendChild(info);

                // Controls
                const controls = document.createElement('div');
                controls.className = 'dist-item-controls';

                const label = document.createElement('span');
                label.className = 'dist-quantity-label';
                label.textContent = 'S·ªë l∆∞·ª£ng:';

                const input = document.createElement('input');
                input.type = 'number';
                input.min = '1';
                input.max = '999';
                input.value = imageInfo.count.toString();
                input.className = 'dist-quantity-input';
                input.dataset.imageKey = imageKey;
                input.dataset.side = side;

                input.addEventListener('change', (e) => {
                    const value = Math.max(1, Math.min(999, parseInt(e.target.value) || 1));
                    e.target.value = value;
                });

                const applyBtn = document.createElement('button');
                applyBtn.className = 'dist-apply-btn';
                applyBtn.textContent = '√Åp d·ª•ng';
                applyBtn.title = '√Åp d·ª•ng s·ªë l∆∞·ª£ng cho ·∫£nh n√†y';
                applyBtn.onclick = () => {
                    const quantity = parseInt(input.value) || 1;
                    this.applyDuplexCustomQuantity(side, imageKey, quantity);
                };

                controls.appendChild(label);
                controls.appendChild(input);
                controls.appendChild(applyBtn);

                item.appendChild(header);
                item.appendChild(controls);
                grid.appendChild(item);
                displayIndex++;
            });
        }

        applyDuplexCustomQuantity(side, imageKey, quantity) {
            const images = side === 'front' ? this.printData.frontImages : this.printData.backImages;
            if (!images || images.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh!', 'error');
                return;
            }

            // T√¨m t·∫•t c·∫£ ·∫£nh c√≥ c√πng imageKey
            const imagesToRemove = [];
            let originalImage = null;

            images.forEach((img, index) => {
                const currentKey = img.id?.split('_')[0] || img.data || img.src || img.name;
                if (currentKey === imageKey) {
                    imagesToRemove.push(index);
                    if (!originalImage) {
                        originalImage = { ...img };
                        originalImage.name = img.name?.replace(/_front_\d+$/, '').replace(/_back_\d+$/, '') || img.name;
                    }
                }
            });

            if (!originalImage) {
                this.showToast('‚ùå Kh√¥ng t√¨m th·∫•y ·∫£nh!', 'error');
                return;
            }

            // T·∫°o c√°c b·∫£n copy m·ªõi
            const newCopies = [];
            const suffix = side === 'front' ? 'front' : 'back';

            for (let i = 0; i < quantity; i++) {
                newCopies.push({
                    ...originalImage,
                    name: `${originalImage.name}_${suffix}_${i + 1}`,
                    id: `${imageKey}_${suffix}_${i}`
                });
            }

            // X√≥a ·∫£nh c≈©
            for (let i = imagesToRemove.length - 1; i >= 0; i--) {
                images.splice(imagesToRemove[i], 1);
            }

            // Th√™m ·∫£nh m·ªõi
            const insertPosition = imagesToRemove[0] || images.length;
            images.splice(insertPosition, 0, ...newCopies);

            // C·∫≠p nh·∫≠t UI
            this.updateDuplexDistributionStats();
            this.updateDuplexCustomDistributionGrid(side);
            this.updateGalleryGridDuplexV2();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');

            this.showToast(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t "${originalImage.name}" th√†nh ${quantity} b·∫£n!`, 'success');
        }

        applyAllDuplexCustomQuantity(side) {
            const input = document.getElementById(side === 'front' ? 'applyAllFrontInput' : 'applyAllBackInput');
            const quantity = parseInt(input.value);

            if (!quantity || quantity < 1 || quantity > 999) {
                this.showToast('‚ùå Vui l√≤ng nh·∫≠p s·ªë l∆∞·ª£ng t·ª´ 1-999!', 'error');
                return;
            }

            const images = side === 'front' ? this.printData.frontImages : this.printData.backImages;
            if (!images || images.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh!', 'error');
                return;
            }

            // Nh√≥m ·∫£nh unique
            const uniqueImagesMap = new Map();
            images.forEach((img) => {
                const imageKey = img.id?.split('_')[0] || img.data || img.src || img.name;
                if (!uniqueImagesMap.has(imageKey)) {
                    uniqueImagesMap.set(imageKey, { ...img });
                }
            });

            // X√≥a t·∫•t c·∫£ ·∫£nh hi·ªán t·∫°i
            if (side === 'front') {
                this.printData.frontImages = [];
            } else {
                this.printData.backImages = [];
            }

            // T·∫°o l·∫°i v·ªõi s·ªë l∆∞·ª£ng m·ªõi
            const suffix = side === 'front' ? 'front' : 'back';
            const targetArray = side === 'front' ? this.printData.frontImages : this.printData.backImages;

            uniqueImagesMap.forEach((originalImage, imageKey) => {
                const cleanName = originalImage.name?.replace(/_front_\d+$/, '').replace(/_back_\d+$/, '') || originalImage.name;

                for (let i = 0; i < quantity; i++) {
                    targetArray.push({
                        ...originalImage,
                        name: `${cleanName}_${suffix}_${i + 1}`,
                        id: `${imageKey}_${suffix}_${i}`
                    });
                }
            });

            // C·∫≠p nh·∫≠t UI
            this.updateDuplexDistributionStats();
            this.updateDuplexCustomDistributionGrid(side);
            this.updateGalleryGridDuplexV2();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');

            this.showToast(`‚úÖ ƒê√£ √°p d·ª•ng s·ªë l∆∞·ª£ng ${quantity} cho t·∫•t c·∫£ ${uniqueImagesMap.size} ·∫£nh ${side === 'front' ? 'm·∫∑t tr∆∞·ªõc' : 'm·∫∑t sau'}!`, 'success');
        }

        copyFrontToBack() {
            if (!this.printData.frontImages || this.printData.frontImages.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh m·∫∑t tr∆∞·ªõc ƒë·ªÉ sao ch√©p!', 'error');
                return;
            }

            // Copy t·∫•t c·∫£ ·∫£nh t·ª´ front sang back
            this.printData.backImages = this.printData.frontImages.map(img => ({
                ...img,
                name: img.name.replace(/_front_/g, '_back_'),
                id: img.id?.replace(/_front_/g, '_back_')
            }));

            this.updateDuplexDistributionStats();
            this.updateGalleryGridDuplexV2();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');

            this.showToast(`üìÑ‚ÜíüìÉ ƒê√£ sao ch√©p ${this.printData.frontImages.length} ·∫£nh t·ª´ m·∫∑t tr∆∞·ªõc sang m·∫∑t sau!`, 'success');
        }

        copyBackToFront() {
            if (!this.printData.backImages || this.printData.backImages.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh m·∫∑t sau ƒë·ªÉ sao ch√©p!', 'error');
                return;
            }

            // Copy t·∫•t c·∫£ ·∫£nh t·ª´ back sang front
            this.printData.frontImages = this.printData.backImages.map(img => ({
                ...img,
                name: img.name.replace(/_back_/g, '_front_'),
                id: img.id?.replace(/_back_/g, '_front_')
            }));

            this.updateDuplexDistributionStats();
            this.updateGalleryGridDuplexV2();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');

            this.showToast(`üìÉ‚ÜíüìÑ ƒê√£ sao ch√©p ${this.printData.backImages.length} ·∫£nh t·ª´ m·∫∑t sau sang m·∫∑t tr∆∞·ªõc!`, 'success');
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UNIFIED DUPLEX WORKSPACE - JAVASCRIPT FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        initUnifiedDuplexWorkspace() {
            console.log('üöÄ Initializing Unified Duplex Workspace...');

            // Initialize state
            this.unifiedState = {
                currentMode: 'front', // 'front' or 'back'
                galleryImages: [],
                frontImages: [],
                backImages: [],
                history: [],
                historyIndex: -1,
                maxHistory: 50,
                selectedImageId: null,
                contextMenuImage: null
            };

            // Setup event listeners
            this.setupUnifiedEventListeners();

            // Setup drag & drop
            this.setupUnifiedDragDrop();

            // Setup keyboard shortcuts
            this.setupUnifiedKeyboardShortcuts();

            // Move canvas to preview placeholder
            this.moveCanvasToUnified();

            // Render canvas immediately after moving
            setTimeout(() => {
                this.renderDuplexCanvas('front');
                this.renderDuplexCanvas('back');
                console.log('‚úÖ Canvas rendered in unified workspace');
            }, 100);

            console.log('‚úÖ Unified Duplex Workspace initialized');
        }

        setupUnifiedEventListeners() {
            // Collapsible column headers
            document.querySelectorAll('.col-header.collapsible').forEach(header => {
                header.addEventListener('click', (e) => {
                    const targetId = header.dataset.target;
                    const content = document.getElementById(targetId);
                    if (content) {
                        content.classList.toggle('collapsed');
                        header.classList.toggle('collapsed');
                    }
                });
            });

            // Upload zone
            const uploadZone = document.querySelector('.unified-upload-zone');
            const fileInput = document.getElementById('unifiedDuplexFileInput');

            if (uploadZone && fileInput) {
                uploadZone.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => this.handleUnifiedUpload(e.target.files));
            }

            // Quick Presets
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.preset;
                    this.applyQuickPreset(preset);
                });
            });

            // Global Actions
            const actions = {
                'unifiedAutoClassifyBtn': () => this.unifiedAutoClassify(),
                'unifiedSwapBtn': () => this.unifiedSwapFrontBack(),
                'unifiedBalanceBtn': () => this.unifiedBalance(),
                'unifiedClearAllBtn': () => this.unifiedClearAll(),
                'unifiedUndoBtn': () => this.unifiedUndo(),
                'unifiedRedoBtn': () => this.unifiedRedo()
            };

            Object.entries(actions).forEach(([id, handler]) => {
                const btn = document.getElementById(id);
                if (btn) btn.addEventListener('click', handler);
            });

            // Mode switch
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.unifiedState.currentMode = btn.dataset.mode;
                    this.updateUnifiedUI();
                });
            });

            // Clear buttons
            const clearFront = document.getElementById('unifiedClearFrontBtn');
            const clearBack = document.getElementById('unifiedClearBackBtn');

            if (clearFront) clearFront.addEventListener('click', () => this.unifiedClearSide('front'));
            if (clearBack) clearBack.addEventListener('click', () => this.unifiedClearSide('back'));

            // Distribution buttons
            document.querySelectorAll('[data-action]').forEach(btn => {
                const action = btn.dataset.action;
                btn.addEventListener('click', () => this.handleUnifiedDistributionAction(action));
            });

            // Export buttons
            const exportJPG = document.getElementById('unifiedExportJPG');
            const exportPDF = document.getElementById('unifiedExportPDF');
            const exportFolder = document.getElementById('unifiedExportFolder');

            if (exportJPG) exportJPG.addEventListener('click', () => this.generateDuplexJPGIndividual());
            if (exportPDF) exportPDF.addEventListener('click', () => this.generateDuplexPDF());
            if (exportFolder) exportFolder.addEventListener('click', () => this.saveToFileSystem());

            // Context menu
            document.addEventListener('click', () => this.hideContextMenu());

            // Stats collapse button
            const collapseBtn = document.getElementById('statsCollapseBtn');
            if (collapseBtn) {
                collapseBtn.addEventListener('click', () => {
                    const columns = document.getElementById('duplexThreeColumns');
                    if (columns) {
                        columns.classList.toggle('collapsed');
                        const icon = collapseBtn.querySelector('.collapse-icon');
                        if (icon) icon.textContent = columns.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
                    }
                });
            }
        }

        setupUnifiedDragDrop() {
            // Upload zone drag & drop
            const uploadZone = document.querySelector('.unified-upload-zone');

            if (uploadZone) {
                uploadZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadZone.style.borderColor = '#f59e0b';
                    uploadZone.style.background = '#fffbeb';
                });

                uploadZone.addEventListener('dragleave', () => {
                    uploadZone.style.borderColor = '#fbbf24';
                    uploadZone.style.background = 'white';
                });

                uploadZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadZone.style.borderColor = '#fbbf24';
                    uploadZone.style.background = 'white';

                    const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                    if (files.length > 0) {
                        this.handleUnifiedUpload(files);
                    }
                });
            }

            // Gallery to classification drag & drop
            // Will be setup when gallery items are rendered
        }

        setupUnifiedKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                const ctrl = e.ctrlKey || e.metaKey;

                if (ctrl && e.key === 'a') {
                    e.preventDefault();
                    this.unifiedAutoClassify();
                } else if (ctrl && e.key === 's') {
                    e.preventDefault();
                    this.unifiedSwapFrontBack();
                } else if (ctrl && e.key === 'b') {
                    e.preventDefault();
                    this.unifiedBalance();
                } else if (ctrl && e.key === 'z') {
                    e.preventDefault();
                    this.unifiedUndo();
                } else if (ctrl && e.key === 'y') {
                    e.preventDefault();
                    this.unifiedRedo();
                } else if (ctrl && e.key === 'u') {
                    e.preventDefault();
                    document.getElementById('unifiedDuplexFileInput')?.click();
                } else if (ctrl && e.key === 'e') {
                    e.preventDefault();
                    this.generateDuplexJPGIndividual();
                } else if (e.key === 'f' || e.key === 'F') {
                    this.switchUnifiedMode('front');
                } else if (e.key === 'b' || e.key === 'B') {
                    this.switchUnifiedMode('back');
                } else if (e.key === 'Delete' && this.unifiedState.selectedImageId) {
                    this.deleteUnifiedImage(this.unifiedState.selectedImageId);
                }
            });
        }

        moveCanvasToUnified() {
            const placeholder = document.getElementById('unifiedPreviewPlaceholder');
            const canvasContainer = document.getElementById('duplexCanvasContainer');

            if (placeholder && canvasContainer) {
                placeholder.appendChild(canvasContainer);
                canvasContainer.style.display = 'flex';
                console.log('‚úÖ Moved canvas to unified preview placeholder');
            }
        }

        async handleUnifiedUpload(files) {
            console.log(`üìÅ Uploading ${files.length} files to unified workspace...`);

            const fileArray = Array.isArray(files) ? files : Array.from(files);

            for (const file of fileArray) {
                try {
                    const dataUrl = await this.readFileAsDataURL(file);
                    const imageId = `unified_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                    const imageData = {
                        id: imageId,
                        name: file.name,
                        filename: file.name,
                        data: dataUrl,
                        src: dataUrl,
                        file: file
                    };

                    this.unifiedState.galleryImages.push(imageData);

                } catch (error) {
                    console.error(`Error uploading ${file.name}:`, error);
                }
            }

            // Update upload count badge
            const countEl = document.getElementById('uploadedCountValue');
            const countContainer = document.getElementById('uploadedCount');
            if (countEl && countContainer) {
                countEl.textContent = this.unifiedState.galleryImages.length;
                countContainer.style.display = this.unifiedState.galleryImages.length > 0 ? 'block' : 'none';
            }

            this.updateUnifiedGallery();
            this.updateUnifiedStats();
            this.saveUnifiedHistory('upload');

            this.showToast(`‚úÖ ƒê√£ t·∫£i ${fileArray.length} ·∫£nh v√†o Unified Workspace`, 'success');
        }

        readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        updateUnifiedGallery() {
            const grid = document.getElementById('unifiedGalleryGrid');
            if (!grid) return;

            const countEl = document.getElementById('unifiedGalleryCount');
            if (countEl) countEl.textContent = this.unifiedState.galleryImages.length;

            if (this.unifiedState.galleryImages.length === 0) {
                grid.innerHTML = '<div class="gallery-empty">Ch∆∞a c√≥ ·∫£nh n√†o</div>';
                return;
            }

            grid.innerHTML = '';

            this.unifiedState.galleryImages.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'gallery-item-unified';
                item.dataset.imageId = img.id;
                item.draggable = true;

                const imgEl = document.createElement('img');
                imgEl.src = img.data || img.src;
                imgEl.alt = img.name;
                imgEl.style.width = '100%';
                imgEl.style.height = '100px';
                imgEl.style.objectFit = 'cover';
                imgEl.style.borderRadius = '6px';
                imgEl.style.cursor = 'pointer';
                imgEl.style.border = '2px solid #e5e7eb';
                imgEl.style.transition = 'all 0.2s ease';

                // Hover effect
                imgEl.addEventListener('mouseenter', () => {
                    imgEl.style.border = '2px solid #3b82f6';
                    imgEl.style.transform = 'scale(1.05)';
                });
                imgEl.addEventListener('mouseleave', () => {
                    imgEl.style.border = '2px solid #e5e7eb';
                    imgEl.style.transform = 'scale(1)';
                });

                // Click to add to current mode
                imgEl.addEventListener('click', () => {
                    this.addImageToSide(img, this.unifiedState.currentMode);
                });

                // Right-click context menu
                imgEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.showContextMenu(e, img, 'gallery');
                });

                // Drag start
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('imageId', img.id);
                    e.dataTransfer.setData('source', 'gallery');
                });

                item.appendChild(imgEl);
                grid.appendChild(item);
            });
        }

        addImageToSide(imageData, side) {
            const targetArray = side === 'front' ? this.unifiedState.frontImages : this.unifiedState.backImages;

            // Clone image data with new ID
            const newImage = {
                ...imageData,
                id: `${imageData.id}_${side}_${Date.now()}`,
                name: `${imageData.name}_${side}`
            };

            targetArray.push(newImage);

            // Sync with printData for compatibility
            if (side === 'front') {
                this.printData.frontImages = [...this.unifiedState.frontImages];
            } else {
                this.printData.backImages = [...this.unifiedState.backImages];
            }

            this.updateUnifiedClassificationLists();
            this.updateUnifiedStats();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.saveUnifiedHistory('add');
        }

        updateUnifiedClassificationLists() {
            this.updateUnifiedList('front');
            this.updateUnifiedList('back');
        }

        updateUnifiedList(side) {
            const listId = side === 'front' ? 'unifiedFrontList' : 'unifiedBackList';
            const countId = side === 'front' ? 'unifiedFrontListCount' : 'unifiedBackListCount';
            const images = side === 'front' ? this.unifiedState.frontImages : this.unifiedState.backImages;

            const list = document.getElementById(listId);
            const countEl = document.getElementById(countId);

            if (!list) return;

            if (countEl) countEl.textContent = images.length;

            if (images.length === 0) {
                list.innerHTML = '<div class="list-empty">Ch∆∞a c√≥ ·∫£nh</div>';
                return;
            }

            list.innerHTML = '';

            images.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'classified-item-unified';
                item.dataset.imageId = img.id;
                item.dataset.side = side;
                item.draggable = true;

                const imgEl = document.createElement('img');
                imgEl.src = img.data || img.src;
                imgEl.alt = img.name;
                imgEl.style.width = '100%';
                imgEl.style.height = '80px';
                imgEl.style.objectFit = 'cover';
                imgEl.style.borderRadius = '4px';
                imgEl.style.cursor = 'move';
                imgEl.style.border = '2px solid ' + (side === 'front' ? '#3b82f6' : '#f59e0b');

                // Click to select
                imgEl.addEventListener('click', () => {
                    this.unifiedState.selectedImageId = img.id;
                    document.querySelectorAll('.classified-item-unified img').forEach(el => {
                        el.style.boxShadow = 'none';
                    });
                    imgEl.style.boxShadow = '0 0 0 3px rgba(59, 130, 246, 0.5)';
                });

                // Right-click context menu
                imgEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.showContextMenu(e, img, side);
                });

                // Drag events
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('imageId', img.id);
                    e.dataTransfer.setData('source', side);
                });

                item.appendChild(imgEl);
                list.appendChild(item);
            });

            // Drop zone handling
            list.addEventListener('dragover', (e) => {
                e.preventDefault();
                list.style.background = side === 'front' ? '#dbeafe' : '#fed7aa';
            });

            list.addEventListener('dragleave', () => {
                list.style.background = '';
            });

            list.addEventListener('drop', (e) => {
                e.preventDefault();
                list.style.background = '';

                const imageId = e.dataTransfer.getData('imageId');
                const source = e.dataTransfer.getData('source');

                if (source === 'gallery') {
                    const img = this.unifiedState.galleryImages.find(i => i.id === imageId);
                    if (img) this.addImageToSide(img, side);
                } else if (source !== side) {
                    // Move from other side
                    this.moveImageBetweenSides(imageId, source, side);
                }
            });
        }

        moveImageBetweenSides(imageId, fromSide, toSide) {
            const fromArray = fromSide === 'front' ? this.unifiedState.frontImages : this.unifiedState.backImages;
            const toArray = toSide === 'front' ? this.unifiedState.frontImages : this.unifiedState.backImages;

            const index = fromArray.findIndex(img => img.id === imageId);
            if (index === -1) return;

            const [img] = fromArray.splice(index, 1);
            img.id = img.id.replace(`_${fromSide}_`, `_${toSide}_`);
            img.name = img.name.replace(`_${fromSide}`, `_${toSide}`);
            toArray.push(img);

            // Sync with printData
            this.printData.frontImages = [...this.unifiedState.frontImages];
            this.printData.backImages = [...this.unifiedState.backImages];

            this.updateUnifiedClassificationLists();
            this.updateUnifiedStats();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.saveUnifiedHistory('move');
        }

        updateUnifiedStats() {
            const frontCount = this.unifiedState.frontImages.length;
            const backCount = this.unifiedState.backImages.length;
            const maxPerPage = this.printData.maxPhotosPerPage || 10;

            const frontPages = Math.ceil(frontCount / maxPerPage);
            const backPages = Math.ceil(backCount / maxPerPage);
            const totalPages = Math.max(frontPages, backPages);

            // Update global stats
            document.getElementById('unifiedFrontCount').textContent = frontCount;
            document.getElementById('unifiedBackCount').textContent = backCount;
            document.getElementById('unifiedTotalPages').textContent = totalPages;
            document.getElementById('unifiedMaxPositions').textContent = maxPerPage;

            // Update distribution stats
            const frontTotal = frontPages * maxPerPage;
            const backTotal = backPages * maxPerPage;
            const frontPercent = frontTotal > 0 ? Math.round((frontCount / frontTotal) * 100) : 0;
            const backPercent = backTotal > 0 ? Math.round((backCount / backTotal) * 100) : 0;

            document.getElementById('unifiedFrontFilled').textContent = frontCount;
            document.getElementById('unifiedFrontTotal').textContent = frontTotal;
            document.getElementById('unifiedFrontPercent').textContent = frontPercent + '%';
            document.getElementById('unifiedFrontProgressBar').style.width = frontPercent + '%';

            document.getElementById('unifiedBackFilled').textContent = backCount;
            document.getElementById('unifiedBackTotal').textContent = backTotal;
            document.getElementById('unifiedBackPercent').textContent = backPercent + '%';
            document.getElementById('unifiedBackProgressBar').style.width = backPercent + '%';

            // Update undo/redo buttons
            const undoBtn = document.getElementById('unifiedUndoBtn');
            const redoBtn = document.getElementById('unifiedRedoBtn');
            if (undoBtn) undoBtn.disabled = this.unifiedState.historyIndex <= 0;
            if (redoBtn) redoBtn.disabled = this.unifiedState.historyIndex >= this.unifiedState.history.length - 1;
        }

        updateUnifiedUI() {
            this.updateUnifiedGallery();
            this.updateUnifiedClassificationLists();
            this.updateUnifiedStats();
        }

        // Quick Preset Functions
        applyQuickPreset(preset) {
            console.log(`‚ö° Applying preset: ${preset}`);

            switch (preset) {
                case '1x1':
                    this.preset_1x1();
                    break;
                case 'nx1':
                    this.preset_nx1();
                    break;
                case '1xn':
                    this.preset_1xn();
                    break;
                case 'nxn':
                    this.preset_nxn();
                    break;
            }
        }

        preset_1x1() {
            if (this.unifiedState.frontImages.length === 0 && this.unifiedState.backImages.length === 0) {
                this.showToast('‚ùå Ch∆∞a c√≥ ·∫£nh n√†o ƒë·ªÉ √°p d·ª•ng preset!', 'error');
                return;
            }

            // Fill all positions with first image on each side
            if (this.unifiedState.frontImages.length > 0) {
                this.fillDuplexFrontPages();
            }
            if (this.unifiedState.backImages.length > 0) {
                this.fillDuplexBackPages();
            }

            this.showToast('‚úÖ ƒê√£ √°p d·ª•ng preset 1√ó1: M·ªói m·∫∑t 1 ·∫£nh fill t·∫•t c·∫£', 'success');
        }

        preset_nx1() {
            if (this.unifiedState.frontImages.length === 0 && this.unifiedState.backImages.length === 0) {
                this.showToast('‚ùå Ch∆∞a c√≥ ·∫£nh n√†o ƒë·ªÉ √°p d·ª•ng preset!', 'error');
                return;
            }

            // Distribute front evenly, fill back with first
            if (this.unifiedState.frontImages.length > 0) {
                this.distributeDuplexFrontEvenly();
            }
            if (this.unifiedState.backImages.length > 0) {
                this.fillDuplexBackPages();
            }

            this.showToast('‚úÖ ƒê√£ √°p d·ª•ng preset N√ó1: Nhi·ªÅu front ph√¢n b·ªï ƒë·ªÅu + 1 back fill', 'success');
        }

        preset_1xn() {
            if (this.unifiedState.frontImages.length === 0 && this.unifiedState.backImages.length === 0) {
                this.showToast('‚ùå Ch∆∞a c√≥ ·∫£nh n√†o ƒë·ªÉ √°p d·ª•ng preset!', 'error');
                return;
            }

            // Fill front with first, distribute back evenly
            if (this.unifiedState.frontImages.length > 0) {
                this.fillDuplexFrontPages();
            }
            if (this.unifiedState.backImages.length > 0) {
                this.distributeDuplexBackEvenly();
            }

            this.showToast('‚úÖ ƒê√£ √°p d·ª•ng preset 1√óN: 1 front fill + nhi·ªÅu back ph√¢n b·ªï ƒë·ªÅu', 'success');
        }

        preset_nxn() {
            if (this.unifiedState.frontImages.length === 0 && this.unifiedState.backImages.length === 0) {
                this.showToast('‚ùå Ch∆∞a c√≥ ·∫£nh n√†o ƒë·ªÉ √°p d·ª•ng preset!', 'error');
                return;
            }

            // Distribute both sides evenly
            if (this.unifiedState.frontImages.length > 0) {
                this.distributeDuplexFrontEvenly();
            }
            if (this.unifiedState.backImages.length > 0) {
                this.distributeDuplexBackEvenly();
            }

            this.showToast('‚úÖ ƒê√£ √°p d·ª•ng preset N√óN: C·∫£ 2 m·∫∑t ph√¢n b·ªï ƒë·ªÅu', 'success');
        }

        // Global Actions
        unifiedAutoClassify() {
            console.log('ü§ñ Auto-classifying images...');

            const patterns = {
                front: [/m[·∫∑a]t\s*tr[∆∞∆°u][·ªõo]c/i, /front/i, /f_/i],
                back: [/m[·∫∑a]t\s*sau/i, /back/i, /b_/i]
            };

            let frontCount = 0;
            let backCount = 0;

            this.unifiedState.galleryImages.forEach(img => {
                const name = img.name || img.filename;
                let matched = false;

                // Check front patterns
                for (const pattern of patterns.front) {
                    if (pattern.test(name)) {
                        this.addImageToSide(img, 'front');
                        frontCount++;
                        matched = true;
                        break;
                    }
                }

                // Check back patterns
                if (!matched) {
                    for (const pattern of patterns.back) {
                        if (pattern.test(name)) {
                            this.addImageToSide(img, 'back');
                            backCount++;
                            matched = true;
                            break;
                        }
                    }
                }
            });

            // Clear gallery after classification
            this.unifiedState.galleryImages = [];
            this.updateUnifiedGallery();

            this.showToast(`ü§ñ T·ª± ƒë·ªông ph√¢n lo·∫°i: ${frontCount} m·∫∑t tr∆∞·ªõc, ${backCount} m·∫∑t sau`, 'success');
        }

        unifiedSwapFrontBack() {
            const temp = this.unifiedState.frontImages;
            this.unifiedState.frontImages = this.unifiedState.backImages.map(img => ({
                ...img,
                id: img.id.replace('_back_', '_front_'),
                name: img.name.replace('_back', '_front')
            }));
            this.unifiedState.backImages = temp.map(img => ({
                ...img,
                id: img.id.replace('_front_', '_back_'),
                name: img.name.replace('_front', '_back')
            }));

            // Sync with printData
            this.printData.frontImages = [...this.unifiedState.frontImages];
            this.printData.backImages = [...this.unifiedState.backImages];

            this.updateUnifiedUI();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.saveUnifiedHistory('swap');

            this.showToast('üîÑ ƒê√£ swap m·∫∑t tr∆∞·ªõc ‚Üî m·∫∑t sau!', 'success');
        }

        unifiedBalance() {
            const frontCount = this.unifiedState.frontImages.length;
            const backCount = this.unifiedState.backImages.length;

            if (frontCount === 0 && backCount === 0) {
                this.showToast('‚ùå Ch∆∞a c√≥ ·∫£nh n√†o ƒë·ªÉ c√¢n b·∫±ng!', 'error');
                return;
            }

            const maxPerPage = this.printData.maxPhotosPerPage || 10;
            const targetPages = Math.max(
                Math.ceil(frontCount / maxPerPage),
                Math.ceil(backCount / maxPerPage)
            );

            const targetCount = targetPages * maxPerPage;

            // Balance front
            if (frontCount < targetCount && frontCount > 0) {
                const needed = targetCount - frontCount;
                for (let i = 0; i < needed; i++) {
                    const sourceIndex = i % frontCount;
                    const sourceImg = this.unifiedState.frontImages[sourceIndex];
                    this.unifiedState.frontImages.push({
                        ...sourceImg,
                        id: `${sourceImg.id}_balanced_${i}`,
                        name: `${sourceImg.name}_balanced_${i}`
                    });
                }
            }

            // Balance back
            if (backCount < targetCount && backCount > 0) {
                const needed = targetCount - backCount;
                for (let i = 0; i < needed; i++) {
                    const sourceIndex = i % backCount;
                    const sourceImg = this.unifiedState.backImages[sourceIndex];
                    this.unifiedState.backImages.push({
                        ...sourceImg,
                        id: `${sourceImg.id}_balanced_${i}`,
                        name: `${sourceImg.name}_balanced_${i}`
                    });
                }
            }

            // Sync with printData
            this.printData.frontImages = [...this.unifiedState.frontImages];
            this.printData.backImages = [...this.unifiedState.backImages];

            this.updateUnifiedUI();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.saveUnifiedHistory('balance');

            this.showToast(`‚öñÔ∏è ƒê√£ c√¢n b·∫±ng: ${this.unifiedState.frontImages.length} front, ${this.unifiedState.backImages.length} back`, 'success');
        }

        unifiedClearAll() {
            if (!confirm('‚ö†Ô∏è X√°c nh·∫≠n x√≥a T·∫§T C·∫¢ ·∫£nh (kho + front + back)?')) return;

            this.unifiedState.galleryImages = [];
            this.unifiedState.frontImages = [];
            this.unifiedState.backImages = [];
            this.printData.frontImages = [];
            this.printData.backImages = [];

            this.updateUnifiedUI();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.saveUnifiedHistory('clear_all');

            this.showToast('üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ ·∫£nh!', 'info');
        }

        unifiedClearSide(side) {
            if (!confirm(`‚ö†Ô∏è X√°c nh·∫≠n x√≥a t·∫•t c·∫£ ·∫£nh m·∫∑t ${side === 'front' ? 'tr∆∞·ªõc' : 'sau'}?`)) return;

            if (side === 'front') {
                this.unifiedState.frontImages = [];
                this.printData.frontImages = [];
            } else {
                this.unifiedState.backImages = [];
                this.printData.backImages = [];
            }

            this.updateUnifiedUI();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.saveUnifiedHistory(`clear_${side}`);

            this.showToast(`üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ ·∫£nh m·∫∑t ${side === 'front' ? 'tr∆∞·ªõc' : 'sau'}!`, 'info');
        }

        switchUnifiedMode(mode) {
            this.unifiedState.currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
        }

        // Distribution Actions
        handleUnifiedDistributionAction(action) {
            console.log(`‚ö° Distribution action: ${action}`);

            switch (action) {
                case 'fill-front':
                    this.fillDuplexFrontPages();
                    break;
                case 'fill-back':
                    this.fillDuplexBackPages();
                    break;
                case 'distribute-front':
                    this.distributeDuplexFrontEvenly();
                    break;
                case 'distribute-back':
                    this.distributeDuplexBackEvenly();
                    break;
                case 'custom-front':
                    this.updateDuplexCustomDistributionGrid('front');
                    // Show old custom distribution section
                    const frontSection = document.getElementById('customDistFrontSection');
                    if (frontSection) frontSection.style.display = 'block';
                    break;
                case 'custom-back':
                    this.updateDuplexCustomDistributionGrid('back');
                    // Show old custom distribution section
                    const backSection = document.getElementById('customDistBackSection');
                    if (backSection) backSection.style.display = 'block';
                    break;
                case 'fill-all':
                    this.fillAllDuplexPages();
                    break;
                case 'distribute-all':
                    this.distributeAllDuplexEvenly();
                    break;
                case 'copy-front-to-back':
                    this.copyFrontToBack();
                    break;
                case 'copy-back-to-front':
                    this.copyBackToFront();
                    break;
            }

            // Sync unified state after distribution
            this.unifiedState.frontImages = [...(this.printData.frontImages || [])];
            this.unifiedState.backImages = [...(this.printData.backImages || [])];
            this.updateUnifiedUI();
        }

        // Context Menu
        showContextMenu(event, imageData, source) {
            const menu = document.getElementById('unifiedContextMenu');
            if (!menu) return;

            this.unifiedState.contextMenuImage = { imageData, source };

            menu.style.display = 'block';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';

            // Setup context menu item handlers
            menu.querySelectorAll('.context-menu-item').forEach(item => {
                item.onclick = () => {
                    const action = item.dataset.action;
                    this.handleContextMenuAction(action);
                };
            });
        }

        hideContextMenu() {
            const menu = document.getElementById('unifiedContextMenu');
            if (menu) menu.style.display = 'none';
        }

        handleContextMenuAction(action) {
            const { imageData, source } = this.unifiedState.contextMenuImage || {};
            if (!imageData) return;

            switch (action) {
                case 'cut':
                    // TODO: Implement cut
                    break;
                case 'copy':
                    // TODO: Implement copy
                    break;
                case 'delete':
                    this.deleteUnifiedImage(imageData.id);
                    break;
                case 'move-to-front':
                    if (source === 'back') {
                        this.moveImageBetweenSides(imageData.id, 'back', 'front');
                    } else if (source === 'gallery') {
                        this.addImageToSide(imageData, 'front');
                    }
                    break;
                case 'move-to-back':
                    if (source === 'front') {
                        this.moveImageBetweenSides(imageData.id, 'front', 'back');
                    } else if (source === 'gallery') {
                        this.addImageToSide(imageData, 'back');
                    }
                    break;
                case 'duplicate-2':
                    this.duplicateUnifiedImage(imageData.id, source, 2);
                    break;
                case 'duplicate-5':
                    this.duplicateUnifiedImage(imageData.id, source, 5);
                    break;
                case 'duplicate-10':
                    this.duplicateUnifiedImage(imageData.id, source, 10);
                    break;
                case 'duplicate-custom':
                    const qty = prompt('Nh·∫≠p s·ªë l∆∞·ª£ng nh√¢n b·∫£n:', '1');
                    if (qty) {
                        this.duplicateUnifiedImage(imageData.id, source, parseInt(qty));
                    }
                    break;
            }

            this.hideContextMenu();
        }

        deleteUnifiedImage(imageId) {
            // Remove from gallery
            let index = this.unifiedState.galleryImages.findIndex(img => img.id === imageId);
            if (index !== -1) {
                this.unifiedState.galleryImages.splice(index, 1);
            }

            // Remove from front
            index = this.unifiedState.frontImages.findIndex(img => img.id === imageId);
            if (index !== -1) {
                this.unifiedState.frontImages.splice(index, 1);
                this.printData.frontImages = [...this.unifiedState.frontImages];
            }

            // Remove from back
            index = this.unifiedState.backImages.findIndex(img => img.id === imageId);
            if (index !== -1) {
                this.unifiedState.backImages.splice(index, 1);
                this.printData.backImages = [...this.unifiedState.backImages];
            }

            this.updateUnifiedUI();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.saveUnifiedHistory('delete');
        }

        duplicateUnifiedImage(imageId, source, quantity) {
            let sourceArray;
            if (source === 'gallery') {
                sourceArray = this.unifiedState.galleryImages;
            } else if (source === 'front') {
                sourceArray = this.unifiedState.frontImages;
            } else if (source === 'back') {
                sourceArray = this.unifiedState.backImages;
            }

            if (!sourceArray) return;

            const index = sourceArray.findIndex(img => img.id === imageId);
            if (index === -1) return;

            const original = sourceArray[index];

            for (let i = 1; i < quantity; i++) {
                const duplicate = {
                    ...original,
                    id: `${original.id}_dup_${i}_${Date.now()}`,
                    name: `${original.name}_dup_${i}`
                };
                sourceArray.splice(index + i, 0, duplicate);
            }

            // Sync with printData
            if (source === 'front') {
                this.printData.frontImages = [...this.unifiedState.frontImages];
            } else if (source === 'back') {
                this.printData.backImages = [...this.unifiedState.backImages];
            }

            this.updateUnifiedUI();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
            this.saveUnifiedHistory('duplicate');

            this.showToast(`üîÑ ƒê√£ nh√¢n b·∫£n √ó${quantity}`, 'success');
        }

        // History & Undo/Redo
        saveUnifiedHistory(action) {
            const state = {
                action,
                timestamp: Date.now(),
                galleryImages: JSON.parse(JSON.stringify(this.unifiedState.galleryImages)),
                frontImages: JSON.parse(JSON.stringify(this.unifiedState.frontImages)),
                backImages: JSON.parse(JSON.stringify(this.unifiedState.backImages))
            };

            // Remove future history if we're not at the end
            if (this.unifiedState.historyIndex < this.unifiedState.history.length - 1) {
                this.unifiedState.history = this.unifiedState.history.slice(0, this.unifiedState.historyIndex + 1);
            }

            this.unifiedState.history.push(state);
            this.unifiedState.historyIndex = this.unifiedState.history.length - 1;

            // Limit history size
            if (this.unifiedState.history.length > this.unifiedState.maxHistory) {
                this.unifiedState.history.shift();
                this.unifiedState.historyIndex--;
            }

            this.updateUnifiedStats(); // Update undo/redo button states
        }

        unifiedUndo() {
            if (this.unifiedState.historyIndex <= 0) return;

            this.unifiedState.historyIndex--;
            this.restoreUnifiedHistory();
            this.showToast('‚Ü∂ Undo', 'info');
        }

        unifiedRedo() {
            if (this.unifiedState.historyIndex >= this.unifiedState.history.length - 1) return;

            this.unifiedState.historyIndex++;
            this.restoreUnifiedHistory();
            this.showToast('‚Ü∑ Redo', 'info');
        }

        restoreUnifiedHistory() {
            const state = this.unifiedState.history[this.unifiedState.historyIndex];
            if (!state) return;

            this.unifiedState.galleryImages = JSON.parse(JSON.stringify(state.galleryImages));
            this.unifiedState.frontImages = JSON.parse(JSON.stringify(state.frontImages));
            this.unifiedState.backImages = JSON.parse(JSON.stringify(state.backImages));

            // Sync with printData
            this.printData.frontImages = [...this.unifiedState.frontImages];
            this.printData.backImages = [...this.unifiedState.backImages];

            this.updateUnifiedUI();
            this.renderDuplexCanvas('front');
            this.renderDuplexCanvas('back');
        }

        rotateImage(index) {
            const imageData = this.printData.selectedImages[index];
            if (!imageData) return;

            // Create a canvas to rotate the image
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.height;
                canvas.height = img.width;
                const ctx = canvas.getContext('2d');

                // Rotate 90 degrees
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(90 * Math.PI / 180);
                ctx.drawImage(img, -img.width / 2, -img.height / 2);

                // Update image data
                imageData.dataUrl = canvas.toDataURL('image/jpeg', 0.95);
                imageData.data = imageData.dataUrl;

                this.updateSelectedImagesDisplay();
                this.showToast('‚úÖ ƒê√£ xoay ·∫£nh 90¬∞', 'success');
            };
            img.src = imageData.dataUrl || imageData.data || imageData.src;
        }

        // handleSelectedImageSelection removed - only use gallery images for duplex classification

        removeImageFromPrintList(index) {
            this.printData.selectedImages.splice(index, 1);

            // Update selection indices after removal
            if (this.selectedImageIndices) {
                // Remove the deleted index
                this.selectedImageIndices.delete(index);

                // Shift down all indices greater than deleted index
                const newSet = new Set();
                this.selectedImageIndices.forEach(idx => {
                    if (idx > index) {
                        newSet.add(idx - 1);
                    } else if (idx < index) {
                        newSet.add(idx);
                    }
                });
                this.selectedImageIndices = newSet;
            }

            this.updateSelectedImagesDisplay();
            this.updateTotalPages();
            this.updatePreview();
        }

        updateImageDistributionDisplay() {
            const section = document.getElementById('imageDistributionSection');
            const imageCountSpan = document.getElementById('distributionImageCount');
            const pageNeedsSpan = document.getElementById('distributionPageNeeds');

            if (!section || !imageCountSpan || !pageNeedsSpan) return;

            const selectedImages = this.printData.selectedImages.length;
            const maxPhotosPerPage = parseInt(document.getElementById('maxPhotosCount').textContent) || 0;
            const totalPagesNeeded = Math.ceil(selectedImages / Math.max(maxPhotosPerPage, 1));
            const totalPositionsNeeded = totalPagesNeeded * maxPhotosPerPage;

            imageCountSpan.textContent = selectedImages;
            pageNeedsSpan.textContent = totalPositionsNeeded;

            // Show section only if there are images
            if (selectedImages > 0 && maxPhotosPerPage > 0) {
                section.style.display = 'block';
                this.updateCustomDistributionGrid();
            } else {
                section.style.display = 'none';
            }
        }

        updateCustomDistributionGrid() {
            const grid = document.getElementById('distributionGrid');
            if (!grid) return;

            grid.innerHTML = '';

            // Nh√≥m ·∫£nh theo ID/data ƒë·ªÉ lo·∫°i b·ªè duplicate, ch·ªâ hi·ªÉn th·ªã unique
            const uniqueImagesMap = new Map();

            this.printData.selectedImages.forEach((imageData) => {
                // S·ª≠ d·ª•ng ID ho·∫∑c data l√†m key ƒë·ªÉ nh·∫≠n di·ªán ·∫£nh g·ªëc
                const imageKey = imageData.id?.split('_')[0] || imageData.data || imageData.src;

                if (!uniqueImagesMap.has(imageKey)) {
                    // L∆∞u ·∫£nh g·ªëc v√† ƒë·∫øm s·ªë l∆∞·ª£ng
                    uniqueImagesMap.set(imageKey, {
                        data: imageData,
                        count: 1,
                        originalName: imageData.name?.replace(/_copy_\d+$/, '') || imageData.name
                    });
                } else {
                    // TƒÉng s·ªë l∆∞·ª£ng cho ·∫£nh ƒë√£ t·ªìn t·∫°i
                    uniqueImagesMap.get(imageKey).count++;
                }
            });

            // Render ch·ªâ c√°c ·∫£nh unique
            let displayIndex = 0;
            uniqueImagesMap.forEach((imageInfo, imageKey) => {
                const imageData = imageInfo.data;
                const currentCount = imageInfo.count;

                const item = document.createElement('div');
                item.className = 'distribution-item';
                item.dataset.imageKey = imageKey;

                // Header with image and info
                const headerDiv = document.createElement('div');
                headerDiv.className = 'item-header';

                const img = document.createElement('img');
                img.src = imageData.data || imageData.src || '';
                img.className = 'image-thumb';
                img.alt = imageInfo.originalName;

                const infoDiv = document.createElement('div');
                infoDiv.className = 'image-info';

                const nameDiv = document.createElement('div');
                nameDiv.className = 'image-name';
                nameDiv.textContent = imageInfo.originalName || `·∫¢nh ${displayIndex + 1}`;
                nameDiv.title = imageInfo.originalName; // Tooltip cho t√™n d√†i

                const sizeDiv = document.createElement('div');
                sizeDiv.className = 'image-size';
                sizeDiv.textContent = `#${displayIndex + 1}`;

                // Badge hi·ªÉn th·ªã s·ªë l∆∞·ª£ng hi·ªán t·∫°i
                if (currentCount > 1) {
                    const badge = document.createElement('span');
                    badge.className = 'quantity-badge';
                    badge.textContent = `√ó${currentCount}`;
                    badge.title = `Hi·ªán c√≥ ${currentCount} b·∫£n`;
                    sizeDiv.appendChild(badge);
                }

                infoDiv.appendChild(nameDiv);
                infoDiv.appendChild(sizeDiv);
                headerDiv.appendChild(img);
                headerDiv.appendChild(infoDiv);

                // Quantity controls - ƒê∆°n gi·∫£n h√≥a
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'quantity-controls';

                const label = document.createElement('span');
                label.className = 'quantity-label';
                label.textContent = 'S·ªë l∆∞·ª£ng:';

                // Input ƒë∆°n gi·∫£n, kh√¥ng c·∫ßn n√∫t +/-
                const input = document.createElement('input');
                input.type = 'number';
                input.min = '1';
                input.max = '999';
                input.value = currentCount.toString();
                input.className = 'quantity-input-simple';
                input.dataset.imageKey = imageKey;
                input.placeholder = '1-999';

                input.addEventListener('change', (e) => {
                    const value = Math.max(1, Math.min(999, parseInt(e.target.value) || 1));
                    e.target.value = value;
                });

                // N√∫t Apply cho t·ª´ng ·∫£nh
                const applyBtn = document.createElement('button');
                applyBtn.className = 'apply-btn-single';
                applyBtn.textContent = '√Åp d·ª•ng';
                applyBtn.title = '√Åp d·ª•ng s·ªë l∆∞·ª£ng cho ·∫£nh n√†y';
                applyBtn.onclick = (e) => {
                    e.preventDefault();
                    const quantity = parseInt(input.value) || 1;
                    this.applyCustomQuantityByKey(imageKey, quantity);
                };

                controlsDiv.appendChild(label);
                controlsDiv.appendChild(input);
                controlsDiv.appendChild(applyBtn);

                item.appendChild(headerDiv);
                item.appendChild(controlsDiv);

                grid.appendChild(item);
                displayIndex++;
            });

            // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng ·∫£nh unique trong UI
            const uniqueCount = uniqueImagesMap.size;
            const totalCount = this.printData.selectedImages.length;

            // Th√™m th√¥ng tin t·ªïng quan v√†o header n·∫øu c·∫ßn
            const customHeader = document.querySelector('.custom-header span');
            if (customHeader && uniqueCount > 0) {
                customHeader.textContent = `Ch·ªâ ƒë·ªãnh s·ªë l∆∞·ª£ng (${uniqueCount} ·∫£nh g·ªëc, ${totalCount} t·ªïng)`;
            }
        }

        fillAllPagesWithFirstImage() {
            if (this.printData.selectedImages.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ d√†n!', 'error');
                return;
            }

            const maxPhotosPerPage = parseInt(document.getElementById('maxPhotosCount').textContent) || 0;
            if (maxPhotosPerPage === 0) {
                this.showToast('‚ùå Ch∆∞a x√°c ƒë·ªãnh ƒë∆∞·ª£c s·ªë ·∫£nh t·ªëi ƒëa m·ªói trang!', 'error');
                return;
            }

            const firstImage = this.printData.selectedImages[0];
            const totalPages = Math.max(1, Math.ceil(this.printData.selectedImages.length / maxPhotosPerPage));
            const totalPositionsNeeded = totalPages * maxPhotosPerPage;

            // Clear current images and duplicate first image
            this.printData.selectedImages = [];

            for (let i = 0; i < totalPositionsNeeded; i++) {
                this.printData.selectedImages.push({
                    ...firstImage,
                    name: `${firstImage.name}_copy_${i + 1}`
                });
            }

            this.updateSelectedImagesDisplay();
            this.updateTotalPages();
            this.updatePreview();
            this.showToast(`üîÑ ƒê√£ d√†n ·∫£nh "${firstImage.name}" cho ${totalPages} trang (${totalPositionsNeeded} v·ªã tr√≠)!`, 'success');
        }

        distributeImagesEvenly() {
            if (this.printData.selectedImages.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ ph√¢n b·ªï!', 'error');
                return;
            }

            const maxPhotosPerPage = parseInt(document.getElementById('maxPhotosCount').textContent) || 0;
            if (maxPhotosPerPage === 0) {
                this.showToast('‚ùå Ch∆∞a x√°c ƒë·ªãnh ƒë∆∞·ª£c s·ªë ·∫£nh t·ªëi ƒëa m·ªói trang!', 'error');
                return;
            }

            const originalImages = [...this.printData.selectedImages];
            const totalPages = Math.max(1, Math.ceil(originalImages.length / maxPhotosPerPage));
            const totalPositionsNeeded = totalPages * maxPhotosPerPage;

            // Clear current images
            this.printData.selectedImages = [];

            // Distribute images evenly across all positions
            for (let i = 0; i < totalPositionsNeeded; i++) {
                const imageIndex = i % originalImages.length;
                const copyNumber = Math.floor(i / originalImages.length) + 1;
                const sourceImage = originalImages[imageIndex];

                this.printData.selectedImages.push({
                    ...sourceImage,
                    name: copyNumber > 1 ? `${sourceImage.name}_copy_${copyNumber}` : sourceImage.name
                });
            }

            this.updateSelectedImagesDisplay();
            this.updateTotalPages();
            this.updatePreview();
            this.showToast(`‚öñÔ∏è ƒê√£ ph√¢n b·ªï ${originalImages.length} ·∫£nh ƒë·ªÅu cho ${totalPages} trang!`, 'success');
        }

        updateQuantityPreview(imageIndex, quantity) {
            // Update preview to show what the quantity change would look like
            const imageData = this.printData.selectedImages[imageIndex];
            if (!imageData) return;

            // For now, just show a subtle indicator
            const item = document.querySelector(`[data-image-index="${imageIndex}"]`)?.closest('.distribution-item');
            if (item) {
                const thumb = item.querySelector('.image-thumb');
                if (thumb) {
                    thumb.style.borderColor = quantity > 1 ? '#667eea' : '#e5e7eb';
                    thumb.style.borderWidth = quantity > 1 ? '3px' : '2px';
                }
            }
        }

        applyCustomQuantity(imageIndex, quantity) {
            if (this.printData.selectedImages.length === 0 || imageIndex >= this.printData.selectedImages.length) {
                this.showToast('‚ùå ·∫¢nh kh√¥ng t·ªìn t·∫°i!', 'error');
                return;
            }

            const originalImage = this.printData.selectedImages[imageIndex];
            const copies = [];

            // Create specified number of copies
            for (let i = 0; i < quantity; i++) {
                copies.push({
                    ...originalImage,
                    name: i === 0 ? originalImage.name : `${originalImage.name}_copy_${i}`,
                    id: originalImage.id + '_' + i
                });
            }

            // Replace the original image with its copies
            this.printData.selectedImages.splice(imageIndex, 1, ...copies);

            this.updateSelectedImagesDisplay();
            this.updateTotalPages();
            this.updatePreview();
            this.showToast(`‚úÖ ƒê√£ t·∫°o ${quantity} b·∫£n sao c·ªßa "${originalImage.name}"!`, 'success');
        }

        // H√†m m·ªõi: √Åp d·ª•ng s·ªë l∆∞·ª£ng theo imageKey thay v√¨ index
        applyCustomQuantityByKey(imageKey, quantity) {
            if (this.printData.selectedImages.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh n√†o!', 'error');
                return;
            }

            // T√¨m t·∫•t c·∫£ ·∫£nh c√≥ c√πng imageKey
            const imagesToRemove = [];
            let originalImage = null;

            this.printData.selectedImages.forEach((img, index) => {
                const currentKey = img.id?.split('_')[0] || img.data || img.src;
                if (currentKey === imageKey) {
                    imagesToRemove.push(index);
                    if (!originalImage) {
                        originalImage = { ...img };
                        // Lo·∫°i b·ªè suffix _copy_X n·∫øu c√≥
                        originalImage.name = img.name?.replace(/_copy_\d+$/, '') || img.name;
                    }
                }
            });

            if (!originalImage) {
                this.showToast('‚ùå Kh√¥ng t√¨m th·∫•y ·∫£nh!', 'error');
                return;
            }

            // T·∫°o c√°c b·∫£n copy m·ªõi v·ªõi s·ªë l∆∞·ª£ng ch·ªâ ƒë·ªãnh
            const newCopies = [];
            for (let i = 0; i < quantity; i++) {
                newCopies.push({
                    ...originalImage,
                    name: i === 0 ? originalImage.name : `${originalImage.name}_copy_${i}`,
                    id: `${imageKey}_${i}`
                });
            }

            // X√≥a t·∫•t c·∫£ ·∫£nh c≈© (theo th·ª© t·ª± ng∆∞·ª£c ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng index)
            for (let i = imagesToRemove.length - 1; i >= 0; i--) {
                this.printData.selectedImages.splice(imagesToRemove[i], 1);
            }

            // Th√™m ·∫£nh m·ªõi v√†o v·ªã tr√≠ ƒë·∫ßu ti√™n c·ªßa ·∫£nh c≈©
            const insertPosition = imagesToRemove[0] || this.printData.selectedImages.length;
            this.printData.selectedImages.splice(insertPosition, 0, ...newCopies);

            // C·∫≠p nh·∫≠t UI
            this.updateSelectedImagesDisplay();
            this.updateTotalPages();
            this.updatePreview();
            this.updateCustomDistributionGrid(); // C·∫≠p nh·∫≠t l·∫°i grid

            this.showToast(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t "${originalImage.name}" th√†nh ${quantity} b·∫£n!`, 'success');
        }

        applyAllCustomQuantities() {
            // Hi·ªÉn th·ªã popup ƒë·ªÉ nh·∫≠p s·ªë l∆∞·ª£ng chung cho t·∫•t c·∫£ ·∫£nh
            const quantity = prompt('Nh·∫≠p s·ªë l∆∞·ª£ng √°p d·ª•ng cho T·∫§T C·∫¢ ·∫£nh:', '1');

            // Ng∆∞·ªùi d√πng h·ªßy ho·∫∑c kh√¥ng nh·∫≠p g√¨
            if (quantity === null || quantity.trim() === '') {
                return;
            }

            const quantityNum = parseInt(quantity);

            // Validate s·ªë l∆∞·ª£ng
            if (isNaN(quantityNum) || quantityNum < 1 || quantityNum > 999) {
                this.showToast('‚ùå S·ªë l∆∞·ª£ng ph·∫£i t·ª´ 1 ƒë·∫øn 999!', 'error');
                return;
            }

            // L·∫•y t·∫•t c·∫£ unique images t·ª´ grid
            const uniqueImagesMap = new Map();

            this.printData.selectedImages.forEach((imageData) => {
                const imageKey = imageData.id?.split('_')[0] || imageData.data || imageData.src;

                if (!uniqueImagesMap.has(imageKey)) {
                    uniqueImagesMap.set(imageKey, {
                        data: { ...imageData },
                        originalName: imageData.name?.replace(/_copy_\d+$/, '') || imageData.name
                    });
                }
            });

            if (uniqueImagesMap.size === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh n√†o ƒë·ªÉ √°p d·ª•ng!', 'error');
                return;
            }

            // X√≥a t·∫•t c·∫£ ·∫£nh hi·ªán t·∫°i v√† t·∫°o l·∫°i v·ªõi s·ªë l∆∞·ª£ng m·ªõi
            this.printData.selectedImages = [];

            let totalImages = 0;
            uniqueImagesMap.forEach((imageInfo, imageKey) => {
                const originalImage = imageInfo.data;
                originalImage.name = imageInfo.originalName;

                for (let i = 0; i < quantityNum; i++) {
                    this.printData.selectedImages.push({
                        ...originalImage,
                        name: i === 0 ? originalImage.name : `${originalImage.name}_copy_${i}`,
                        id: `${imageKey}_${i}`
                    });
                    totalImages++;
                }
            });

            // C·∫≠p nh·∫≠t UI
            this.updateSelectedImagesDisplay();
            this.updateTotalPages();
            this.updatePreview();
            this.updateCustomDistributionGrid();

            this.showToast(
                `‚úÖ ƒê√£ √°p d·ª•ng s·ªë l∆∞·ª£ng ${quantityNum} cho ${uniqueImagesMap.size} ·∫£nh (t·ªïng ${totalImages} ·∫£nh)!`,
                'success'
            );
        }

        updateDistributionButtonStates(activeAction) {
            const buttons = ['fillAllPagesBtn', 'distributeEvenlyBtn', 'toggleCustomBtn'];
            const actions = ['fill', 'distribute', 'custom'];

            buttons.forEach((btnId, index) => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    const isActive = actions[index] === activeAction;
                    btn.classList.toggle('active', isActive);
                }
            });

            // Hide custom section if not active
            const customSection = document.getElementById('customDistributionSection');
            if (customSection && activeAction !== 'custom') {
                customSection.style.display = 'none';
            }
        }

        validateSK316BladeGap() {
            // Validate that offsets don't break the 3mm blade gap rule for SK316
            // Grid: 2 cols √ó 5 rows
            // Card size: 90mm √ó 54mm
            // Blade gap: 3mm (fixed)

            const offsetData = this.printData.config.offsetRncm?.data || {};
            const BLADE_GAP = 3.0; // mm
            const CARD_WIDTH = 90; // mm
            const CARD_HEIGHT = 54; // mm

            // Check horizontal gaps (between columns)
            // r1c1 ‚Üê‚Üí r1c2, r2c1 ‚Üê‚Üí r2c2, etc.
            for (let row = 1; row <= 5; row++) {
                const leftCell = `r${row}c1`;
                const rightCell = `r${row}c2`;

                const leftOffset = offsetData[leftCell] || { x: 0, y: 0 };
                const rightOffset = offsetData[rightCell] || { x: 0, y: 0 };

                // Left card's right edge position (relative)
                const leftEdge = CARD_WIDTH + leftOffset.x;

                // Right card's left edge position (starts at CARD_WIDTH + BLADE_GAP)
                const rightEdge = (CARD_WIDTH + BLADE_GAP) + rightOffset.x;

                // Gap between them
                const actualGap = rightEdge - leftEdge;

                if (actualGap < BLADE_GAP) {
                    console.error(`‚ùå Horizontal gap violation at row ${row}: ${actualGap.toFixed(2)}mm < 3mm`);
                    console.error(`   Left (${leftCell}): offset.x = ${leftOffset.x}mm`);
                    console.error(`   Right (${rightCell}): offset.x = ${rightOffset.x}mm`);
                    return false;
                }
            }

            // Check vertical gaps (between rows)
            // r1 ‚Üï r2, r2 ‚Üï r3, r3 ‚Üï r4, r4 ‚Üï r5
            for (let col = 1; col <= 2; col++) {
                for (let row = 1; row <= 4; row++) {
                    const topCell = `r${row}c${col}`;
                    const bottomCell = `r${row + 1}c${col}`;

                    const topOffset = offsetData[topCell] || { x: 0, y: 0 };
                    const bottomOffset = offsetData[bottomCell] || { x: 0, y: 0 };

                    // Top card's bottom edge
                    const topEdge = CARD_HEIGHT + topOffset.y;

                    // Bottom card's top edge (starts at CARD_HEIGHT + BLADE_GAP)
                    const bottomEdge = (CARD_HEIGHT + BLADE_GAP) + bottomOffset.y;

                    // Gap between them
                    const actualGap = bottomEdge - topEdge;

                    if (actualGap < BLADE_GAP) {
                        console.error(`‚ùå Vertical gap violation between ${topCell} and ${bottomCell}: ${actualGap.toFixed(2)}mm < 3mm`);
                        console.error(`   Top (${topCell}): offset.y = ${topOffset.y}mm`);
                        console.error(`   Bottom (${bottomCell}): offset.y = ${bottomOffset.y}mm`);
                        return false;
                    }
                }
            }

            console.log('‚úÖ All SK316 blade gaps validated: >= 3mm');
            return true;
        }

        updatePreviewStatus(message, type = 'ready') {
            const statusBadge = document.getElementById('previewStatus');
            const statusText = statusBadge?.querySelector('.status-text');
            const statusDot = statusBadge?.querySelector('.status-dot');

            if (statusText) {
                statusText.textContent = message;
            }

            if (statusBadge && statusDot) {
                // Remove previous type classes
                statusBadge.className = 'status-badge';

                switch(type) {
                    case 'success':
                        statusBadge.style.background = 'rgba(34, 197, 94, 0.1)';
                        statusBadge.style.borderColor = 'rgba(34, 197, 94, 0.2)';
                        statusDot.style.background = '#22c55e';
                        statusText.style.color = '#16a34a';
                        break;
                    case 'error':
                        statusBadge.style.background = 'rgba(239, 68, 68, 0.1)';
                        statusBadge.style.borderColor = 'rgba(239, 68, 68, 0.2)';
                        statusDot.style.background = '#ef4444';
                        statusText.style.color = '#dc2626';
                        break;
                    case 'warning':
                        statusBadge.style.background = 'rgba(245, 158, 11, 0.1)';
                        statusBadge.style.borderColor = 'rgba(245, 158, 11, 0.2)';
                        statusDot.style.background = '#f59e0b';
                        statusText.style.color = '#d97706';
                        break;
                    case 'processing':
                        statusBadge.style.background = 'rgba(59, 130, 246, 0.1)';
                        statusBadge.style.borderColor = 'rgba(59, 130, 246, 0.2)';
                        statusDot.style.background = '#3b82f6';
                        statusText.style.color = '#2563eb';
                        break;
                    default: // ready
                        statusBadge.style.background = 'rgba(34, 197, 94, 0.1)';
                        statusBadge.style.borderColor = 'rgba(34, 197, 94, 0.2)';
                        statusDot.style.background = '#22c55e';
                        statusText.style.color = '#16a34a';
                }
            }

            // Auto-reset to ready after 3 seconds for success/error messages
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    this.updatePreviewStatus('S·∫µn s√†ng', 'ready');
                }, 3000);
            }
        }

        saveOffsetRncmData() {
            try {
                const offsetData = {
                    enabled: this.printData.config.offsetRncm?.enabled || false,
                    data: this.printData.config.offsetRncm?.data || {}
                };
                localStorage.setItem('offsetRncmData', JSON.stringify(offsetData));
                console.log('üíæ ƒê√£ l∆∞u offset rNcM data:', offsetData);
            } catch (err) {
                console.error('‚ùå L·ªói l∆∞u offset rNcM:', err);
            }
        }

        loadOffsetRncmData() {
            try {
                const saved = localStorage.getItem('offsetRncmData');
                if (saved) {
                    const offsetData = JSON.parse(saved);

                    // Initialize offsetRncm in config
                    if (!this.printData.config.offsetRncm) {
                        this.printData.config.offsetRncm = {
                            enabled: false,
                            data: {}
                        };
                    }

                    this.printData.config.offsetRncm.enabled = offsetData.enabled || false;
                    this.printData.config.offsetRncm.data = offsetData.data || {};

                    // Update UI
                    const enableOffsetRncm = document.getElementById('enableOffsetRncm');
                    const offsetTableContainer = document.getElementById('offsetTableContainer');

                    if (enableOffsetRncm) {
                        enableOffsetRncm.checked = offsetData.enabled;
                    }

                    if (offsetTableContainer) {
                        offsetTableContainer.style.display = offsetData.enabled ? 'block' : 'none';
                    }

                    // Populate inputs
                    Object.keys(offsetData.data).forEach(cell => {
                        const xInput = document.querySelector(`input[data-cell="${cell}"][data-axis="x"]`);
                        const yInput = document.querySelector(`input[data-cell="${cell}"][data-axis="y"]`);

                        if (xInput) xInput.value = offsetData.data[cell].x || 0;
                        if (yInput) yInput.value = offsetData.data[cell].y || 0;
                    });

                    console.log('üìÇ ƒê√£ load offset rNcM data:', offsetData);
                }
            } catch (err) {
                console.error('‚ùå L·ªói load offset rNcM:', err);
            }
        }

        updateCustomDistribution() {
            // Legacy function - now using individual apply buttons
            this.showToast('üí° S·ª≠ d·ª•ng n√∫t "OK" cho t·ª´ng ·∫£nh ho·∫∑c "√Åp d·ª•ng t·∫•t c·∫£"!', 'info');
        }

        clearSelectedImages() {
            this.printData.selectedImages = [];
            this.updateSelectedImagesDisplay();
            this.updateTotalPages();
            this.updatePreview();
        }

        // Master Canvas System - Single Source of Truth
        createMasterCanvas(pageIndex) {
            const config = this.printData.config;
            const dpi = config.dpi;
            
            // Calculate exact dimensions at full DPI
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            const paperWidthInches = paperWidthMm / 25.4;
            const paperHeightInches = paperHeightMm / 25.4;
            const exactWidthPx = Math.round(paperWidthInches * dpi);
            const exactHeightPx = Math.round(paperHeightInches * dpi);

            // Create or update master canvas
            if (!this.printData.masterCanvas) {
                this.printData.masterCanvas = document.createElement('canvas');
            }
            
            const masterCanvas = this.printData.masterCanvas;
            masterCanvas.width = exactWidthPx;
            masterCanvas.height = exactHeightPx;
            
            const ctx = masterCanvas.getContext('2d');
            
            // Render page content at full resolution
            this.renderPageToCanvas(masterCanvas, ctx, pageIndex, config);
            
            // Add cutting guides if enabled
            this.drawCuttingGuides(ctx, masterCanvas, config);
            
            return masterCanvas;
        }

        updateMasterCanvas() {
            if (this.printData.selectedImages.length === 0) {
                // If no images, still update preview to show layout changes
                this.updatePreviewLayout();
                return;
            }

            // Update master canvas
            this.createMasterCanvas(this.printData.currentPage);

            // Update preview from master canvas
            this.updatePreviewFromMaster();
        }

        updatePreviewLayout() {
            // Update preview canvas even when no images are loaded to show layout changes
            console.log('üîÑ updatePreviewLayout called');
            const previewCanvas = document.getElementById('printCanvas');
            if (!previewCanvas) {
                console.log('‚ùå printCanvas not found');
                return;
            }

            const previewCtx = previewCanvas.getContext('2d');
            const config = this.printData.config;
            console.log('üìã Current config:', config);

            // Calculate canvas size based on current paper size and orientation
            const dpi = 96; // Standard web DPI
            const mmToPx = dpi / 25.4;

            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;

            const canvasWidth = Math.round(paperWidthMm * mmToPx);
            const canvasHeight = Math.round(paperHeightMm * mmToPx);

            // Apply current zoom scale
            let scale = this.previewState?.scale || 1;
            if (this.previewState?.viewMode === 'fitWidth') {
                const container = document.getElementById('canvasContainer');
                if (container) {
                    const containerWidth = container.parentElement.clientWidth - 40;
                    scale = Math.min(containerWidth / canvasWidth, 1);
                    this.previewState.scale = scale;
                }
            }

            previewCanvas.width = Math.round(canvasWidth * scale);
            previewCanvas.height = Math.round(canvasHeight * scale);

            // Clear canvas and draw background
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.fillStyle = '#ffffff';
            previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

            // Draw layout grid or guides if enabled
            if (this.previewState?.showGuides) {
                this.drawLayoutGuides(previewCtx, previewCanvas, scale);
            }

            // Update display size
            previewCanvas.style.width = previewCanvas.width + 'px';
            previewCanvas.style.height = previewCanvas.height + 'px';

            // Update additional preview elements
            if (this.previewState) {
                this.updateRulerDisplay();
                this.updateCanvasOverlay();
            }
        }

        drawLayoutGuides(ctx, canvas, scale) {
            const config = this.printData.config;

            // V·∫Ω ƒë∆∞·ªùng c·∫Øt ngo√†i n·∫øu ƒë∆∞·ª£c b·∫≠t
            if (config.cuttingGuides?.outerCuttingLines) {
                ctx.strokeStyle = '#374151';
                ctx.lineWidth = Math.max(0.5, (config.cuttingGuides?.thickness || 0.5) * scale);
                ctx.setLineDash([]);
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
            }

            // V·∫Ω l∆∞·ªõi h·ªó tr·ª£ n·∫øu ƒë∆∞·ª£c b·∫≠t
            if (config.cuttingGuides?.gridHelperLines) {
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = Math.max(0.25, (config.cuttingGuides?.thickness || 0.5) * scale * 0.5);
                ctx.setLineDash([]);

                const gridSize = 20 * scale;
                for (let x = gridSize; x < canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }

                for (let y = gridSize; y < canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }

            // V·∫Ω ƒë∆∞·ªùng c·∫Øt gi·ªØa ·∫£nh (gi·∫£ l·∫≠p layout ·∫£nh)
            if (config.cuttingGuides?.betweenImages) {
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = Math.max(0.5, (config.cuttingGuides?.thickness || 0.5) * scale);
                ctx.setLineDash([2 * scale, 2 * scale]);

                // Gi·∫£ l·∫≠p v·ªã tr√≠ ·∫£nh d·ª±a tr√™n photoSize
                const photoWidthPx = (config.photoSize?.width || 10) * scale * 2;
                const photoHeightPx = (config.photoSize?.height || 15) * scale * 2;

                // V·∫Ω ƒë∆∞·ªùng d·ªçc
                for (let x = photoWidthPx; x < canvas.width; x += photoWidthPx) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }

                // V·∫Ω ƒë∆∞·ªùng ngang
                for (let y = photoHeightPx; y < canvas.height; y += photoHeightPx) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }

            // V·∫Ω ƒë√°nh d·∫•u g√≥c n·∫øu ƒë∆∞·ª£c b·∫≠t
            if (config.cuttingGuides?.cornerMarks) {
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = Math.max(0.5, (config.cuttingGuides?.thickness || 0.5) * scale);
                ctx.setLineDash([]);

                const markSize = 8 * scale;

                // G√≥c tr√™n-tr√°i
                ctx.beginPath();
                ctx.moveTo(0, markSize);
                ctx.lineTo(0, 0);
                ctx.lineTo(markSize, 0);
                ctx.stroke();

                // G√≥c tr√™n-ph·∫£i
                ctx.beginPath();
                ctx.moveTo(canvas.width - markSize, 0);
                ctx.lineTo(canvas.width, 0);
                ctx.lineTo(canvas.width, markSize);
                ctx.stroke();

                // G√≥c d∆∞·ªõi-tr√°i
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - markSize);
                ctx.lineTo(0, canvas.height);
                ctx.lineTo(markSize, canvas.height);
                ctx.stroke();

                // G√≥c d∆∞·ªõi-ph·∫£i
                ctx.beginPath();
                ctx.moveTo(canvas.width - markSize, canvas.height);
                ctx.lineTo(canvas.width, canvas.height);
                ctx.lineTo(canvas.width, canvas.height - markSize);
                ctx.stroke();
            }

            // Hi·ªÉn th·ªã th√¥ng tin k√≠ch th∆∞·ªõc gi·∫•y
            ctx.fillStyle = '#374151';
            ctx.font = `bold ${Math.max(12, 14 * scale)}px system-ui`;
            ctx.textAlign = 'center';

            const paperInfo = `${config.paperSize?.width || 210}√ó${config.paperSize?.height || 297}mm (${config.orientation === 'portrait' ? 'D·ªçc' : 'Ngang'})`;
            const photoInfo = `·∫¢nh: ${config.photoSize?.width || 5.5}√ó${config.photoSize?.height || 8.5}cm`;
            const thicknessInfo = `ƒê·ªô d√†y: ${config.cuttingGuides?.thickness || 0.5}pt`;

            // V·∫Ω background cho text
            const textY = canvas.height - 40 * scale;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, textY - 10, canvas.width, 35 * scale);

            // V·∫Ω text th√¥ng tin
            ctx.fillStyle = '#374151';
            ctx.fillText(paperInfo, canvas.width / 2, textY);
            ctx.font = `${Math.max(10, 12 * scale)}px system-ui`;
            ctx.fillText(photoInfo, canvas.width / 2, textY + 15 * scale);
            ctx.fillText(thicknessInfo, canvas.width / 2, textY + 25 * scale);
        }

        updatePreviewFromMaster() {
            const previewCanvas = document.getElementById('printCanvas');
            if (!previewCanvas || !this.printData.masterCanvas) return;

            this.printData.previewCanvas = previewCanvas;
            const previewCtx = previewCanvas.getContext('2d');
            
            // Use custom scale if set, otherwise auto-fit
            let scale = this.previewState?.scale || 1;
            
            if (this.previewState?.viewMode === 'fitWidth') {
                const container = document.getElementById('canvasContainer');
                if (container) {
                    const containerWidth = container.parentElement.clientWidth - 40;
                    scale = Math.min(containerWidth / this.printData.masterCanvas.width, 1);
                    this.previewState.scale = scale;
                }
            }
            
            // Set preview canvas size
            previewCanvas.width = Math.round(this.printData.masterCanvas.width * scale);
            previewCanvas.height = Math.round(this.printData.masterCanvas.height * scale);
            
            // Draw scaled master canvas to preview
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(this.printData.masterCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
            
            // Update display size
            previewCanvas.style.width = previewCanvas.width + 'px';
            previewCanvas.style.height = previewCanvas.height + 'px';
            
            // Update additional preview elements
            if (this.previewState) {
                this.updatePreviewInfo();
                this.updateRulerDisplay();
                this.updateCanvasOverlay();
            }
        }

        updatePreview() {
            console.log('üñºÔ∏è updatePreview called');
            this.updateMasterCanvas();
        }

        renderPage(pageIndex) {
            const canvas = this.printData.canvas;
            const ctx = this.printData.context;
            const config = this.printData.config;

            if (!canvas || !ctx) return;

            // Convert dimensions to pixels for canvas
            const dpi = config.dpi;
            const paperWidthPx = Math.round((config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height) / 25.4 * dpi);
            const paperHeightPx = Math.round((config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width) / 25.4 * dpi);

            canvas.width = paperWidthPx;
            canvas.height = paperHeightPx;

            // Clear canvas with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, paperWidthPx, paperHeightPx);

            // Use optimized layout dimensions
            const layout = this.printData.gridLayout;
            const photoWidthPx = Math.round(layout.photoWidth / 25.4 * dpi);
            const photoHeightPx = Math.round(layout.photoHeight / 25.4 * dpi);

            // Calculate positions with optimized spacing
            const marginLeftPx = Math.round(config.margins.left / 25.4 * dpi);
            const marginTopPx = Math.round(config.margins.top / 25.4 * dpi);
            const gutterXPx = Math.round(layout.actualSpacing.x / 25.4 * dpi);
            const gutterYPx = Math.round(layout.actualSpacing.y / 25.4 * dpi);

            // Calculate available area and center the grid
            const availableWidthPx = paperWidthPx - 2 * marginLeftPx;
            const availableHeightPx = paperHeightPx - 2 * marginTopPx;
            
            const totalGridWidth = layout.cols * photoWidthPx + (layout.cols - 1) * gutterXPx;
            const totalGridHeight = layout.rows * photoHeightPx + (layout.rows - 1) * gutterYPx;
            
            const startXPx = marginLeftPx + (availableWidthPx - totalGridWidth) / 2;
            const startYPx = marginTopPx + (availableHeightPx - totalGridHeight) / 2;

            const startIndex = pageIndex * this.printData.maxPhotosPerPage;
            const endIndex = Math.min(startIndex + this.printData.maxPhotosPerPage, this.printData.selectedImages.length);

            // üêõ DEBUG: Log render range
            console.log(`üñºÔ∏è Rendering page ${pageIndex}:`, {
                startIndex,
                endIndex,
                imagesInRange: endIndex - startIndex,
                maxPhotosPerPage: this.printData.maxPhotosPerPage,
                totalImages: this.printData.selectedImages.length
            });

            let imageIndex = 0;
            for (let i = startIndex; i < endIndex; i++) {
                const imageData = this.printData.selectedImages[i];
                if (!imageData || !imageData.img) continue;

                const row = Math.floor(imageIndex / layout.cols);
                const col = imageIndex % layout.cols;

                // Calculate base position (margin + gutter)
                const baseX = startXPx + col * (photoWidthPx + gutterXPx);
                const baseY = startYPx + row * (photoHeightPx + gutterYPx);

                // Apply offset (prioritize offsetRncm from printConfigCompact, then SK316)
                let finalX = baseX;
                let finalY = baseY;

                // Check if offsetRncm is enabled in printConfigCompact
                if (this.printData.config.offsetRncm?.enabled) {
                    // SK316 VALIDATION: Check blade gap before applying offsets
                    if (!this.validateSK316BladeGap()) {
                        console.error('‚ùå EXPORT BLOCKED: SK316 blade gap violation detected!');
                        ctx.fillStyle = 'rgba(220, 38, 38, 0.1)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#dc2626';
                        ctx.font = 'bold 48px system-ui';
                        ctx.textAlign = 'center';
                        ctx.fillText('‚ö†Ô∏è EXPORT BLOCKED', canvas.width / 2, canvas.height / 2 - 40);
                        ctx.font = '24px system-ui';
                        ctx.fillText('SK316 blade gap violation!', canvas.width / 2, canvas.height / 2);
                        ctx.font = '18px system-ui';
                        ctx.fillText('Offset vi ph·∫°m kho·∫£ng c√°ch 3mm. H√£y gi·∫£m offset.', canvas.width / 2, canvas.height / 2 + 40);
                        return; // Stop rendering
                    }

                    const cellKey = `r${row + 1}c${col + 1}`;
                    const offsetMm = this.printData.config.offsetRncm.data[cellKey];

                    if (offsetMm) {
                        // Convert mm to px
                        const offsetPx = {
                            x: (offsetMm.x / 25.4) * dpi,
                            y: (offsetMm.y / 25.4) * dpi
                        };
                        finalX = baseX + offsetPx.x;
                        finalY = baseY + offsetPx.y;
                        console.log(`üéØ Offset rNcM applied: ${cellKey} (${offsetMm.x}, ${offsetMm.y}) mm`);
                    }
                }
                // Fallback to SK316 system if offsetRncm not enabled
                else if (window.sk316System && window.sk316System.getActiveProfile()) {
                    const adjusted = window.sk316System.applyOffsetToLayout(row, col, baseX, baseY, dpi);
                    finalX = adjusted.x;
                    finalY = adjusted.y;
                    console.log(`üéØ SK316 offset applied: r${row + 1}c${col + 1}`);
                }

                this.drawImageOnCanvas(ctx, imageData.img, finalX, finalY, photoWidthPx, photoHeightPx, config.fitMode);
                imageIndex++;
            }

            // Scale canvas for display
            const maxDisplayWidth = 800;
            const maxDisplayHeight = 600;
            const scale = Math.min(maxDisplayWidth / paperWidthPx, maxDisplayHeight / paperHeightPx, 1);
            
            canvas.style.width = (paperWidthPx * scale) + 'px';
            canvas.style.height = (paperHeightPx * scale) + 'px';
        }

        drawImageOnCanvas(ctx, img, x, y, width, height, fitMode) {
            const imgAspect = img.width / img.height;
            const targetAspect = width / height;

            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

            if (fitMode === 'fill') {
                // Fill the entire area, crop if necessary
                if (imgAspect > targetAspect) {
                    drawHeight = height;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (width - drawWidth) / 2;
                } else {
                    drawWidth = width;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (height - drawHeight) / 2;
                }
            } else {
                // Fit inside the area, add padding if necessary
                if (imgAspect > targetAspect) {
                    drawWidth = width;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (height - drawHeight) / 2;
                } else {
                    drawHeight = height;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (width - drawWidth) / 2;
                }
            }

            // Draw image
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, width, height);
            ctx.clip();
            ctx.drawImage(img, x + offsetX, y + offsetY, drawWidth, drawHeight);
            ctx.restore();

            // Draw border
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, width, height);
        }

        // V·∫Ω ·∫£nh v·ªõi rotation
        drawImageOnCanvasWithRotation(ctx, img, x, y, width, height, rotation, fitMode) {
            ctx.save();

            // T√≠nh to√°n center point ƒë·ªÉ xoay quanh
            const centerX = x + width / 2;
            const centerY = y + height / 2;

            // Di chuy·ªÉn canvas origin ƒë·∫øn center point
            ctx.translate(centerX, centerY);

            // Xoay canvas
            ctx.rotate((rotation * Math.PI) / 180);

            // Di chuy·ªÉn l·∫°i ƒë·ªÉ v·∫Ω t·ª´ g√≥c tr√°i tr√™n
            ctx.translate(-width / 2, -height / 2);

            // T√≠nh to√°n k√≠ch th∆∞·ªõc ·∫£nh v√† v·ªã tr√≠
            const imgAspect = img.width / img.height;
            const targetAspect = width / height;
            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

            if (fitMode === 'fill') {
                if (imgAspect > targetAspect) {
                    drawHeight = height;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (width - drawWidth) / 2;
                } else {
                    drawWidth = width;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (height - drawHeight) / 2;
                }
            } else {
                if (imgAspect > targetAspect) {
                    drawWidth = width;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (height - drawHeight) / 2;
                } else {
                    drawHeight = height;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (width - drawWidth) / 2;
                }
            }

            // Clip ƒë·ªÉ ·∫£nh kh√¥ng v∆∞·ª£t ra ngo√†i
            ctx.beginPath();
            ctx.rect(0, 0, width, height);
            ctx.clip();

            // V·∫Ω ·∫£nh
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

            // V·∫Ω border
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, width, height);

            ctx.restore();

            console.log(`üîÑ V·∫Ω ·∫£nh xoay ${rotation}¬∞ t·∫°i (${x}, ${y}) k√≠ch th∆∞·ªõc ${width}√ó${height}`);
        }

        showPreviousPage() {
            if (this.printData.currentPage > 0) {
                this.printData.currentPage--;
                this.updateTotalPages();
                this.renderPage(this.printData.currentPage);
            }
        }

        showNextPage() {
            if (this.printData.currentPage < this.printData.totalPages - 1) {
                this.printData.currentPage++;
                this.updateTotalPages();
                this.updateMasterCanvas();
            }
        }

        showPreviousPage() {
            if (this.printData.currentPage > 0) {
                this.printData.currentPage--;
                this.updateTotalPages();
                this.updateMasterCanvas();
            }
        }

        drawCuttingGuides(ctx, canvas, config) {
            const guides = config.cuttingGuides;
            
            // Check if guides are disabled in preview
            if (!this.previewState?.showGuides) {
                return; // Guides disabled in preview
            }
            
            if (!guides.outerCuttingLines && !guides.betweenImages && !guides.cornerMarks && !guides.gridHelperLines) {
                return; // No guides enabled
            }

            const dpi = config.dpi;
            const layout = this.printData.gridLayout;
            
            // Use EXACT same calculations as renderPageToCanvas for perfect alignment
            const marginLeftPx = Math.round(config.margins.left / 25.4 * dpi);
            const marginTopPx = Math.round(config.margins.top / 25.4 * dpi);
            const gutterXPx = Math.round(layout.actualSpacing.x / 25.4 * dpi);
            const gutterYPx = Math.round(layout.actualSpacing.y / 25.4 * dpi);
            const photoWidthPx = Math.round(layout.photoWidth / 25.4 * dpi);
            const photoHeightPx = Math.round(layout.photoHeight / 25.4 * dpi);

            // Calculate grid start position - EXACT same as renderPageToCanvas
            const availableWidthPx = canvas.width - 2 * marginLeftPx;
            const availableHeightPx = canvas.height - 2 * marginTopPx;
            const totalGridWidth = layout.cols * photoWidthPx + (layout.cols - 1) * gutterXPx;
            const totalGridHeight = layout.rows * photoHeightPx + (layout.rows - 1) * gutterYPx;
            const startXPx = marginLeftPx + (availableWidthPx - totalGridWidth) / 2;
            const startYPx = marginTopPx + (availableHeightPx - totalGridHeight) / 2;

            // Set line style
            ctx.strokeStyle = guides.color;
            ctx.lineWidth = guides.thickness * (dpi / 72); // Convert to canvas units
            
            // Set line dash pattern
            if (guides.lineStyle === 'dashed') {
                ctx.setLineDash([5, 5]);
            } else if (guides.lineStyle === 'dotted') {
                ctx.setLineDash([2, 2]);
            } else {
                ctx.setLineDash([]);
            }

            ctx.save();

            // Create array of actual image positions for perfect alignment
            const imagePositions = [];

            // üéØ H·ªó tr·ª£ exact positions cho layout ƒë·∫∑c bi·ªát
            if (layout.exactPositions && layout.exactPositions.length > 0) {
                console.log('üìç T·∫°o cutting guides cho exact positions');

                for (let i = 0; i < layout.exactPositions.length; i++) {
                    const position = layout.exactPositions[i];
                    const x = startXPx + Math.round(position.x / 25.4 * dpi);
                    const y = startYPx + Math.round(position.y / 25.4 * dpi);
                    const width = Math.round(position.width / 25.4 * dpi);
                    const height = Math.round(position.height / 25.4 * dpi);

                    imagePositions.push({ x, y, width, height, row: Math.floor(i/4), col: i%4 });
                }
            } else {
                // Grid layout th√¥ng th∆∞·ªùng
                for (let row = 0; row < layout.rows; row++) {
                    for (let col = 0; col < layout.cols; col++) {
                        const x = startXPx + col * (photoWidthPx + gutterXPx);
                        const y = startYPx + row * (photoHeightPx + gutterYPx);
                        imagePositions.push({ x, y, width: photoWidthPx, height: photoHeightPx, row, col });
                    }
                }
            }

            // 1. Outer cutting lines (around actual image area)
            if (guides.outerCuttingLines) {
                this.drawOuterCuttingLinesAligned(ctx, imagePositions, canvas);
            }

            // 2. Between images cutting lines (exactly between actual images)
            if (guides.betweenImages) {
                this.drawBetweenImageLinesAligned(ctx, imagePositions, layout, canvas);
            }

            // 3. Corner marks (at exact image corners)
            if (guides.cornerMarks) {
                this.drawCornerMarksAligned(ctx, imagePositions, dpi);
            }

            // 4. Grid helper lines (around exact image boundaries)
            if (guides.gridHelperLines) {
                this.drawGridHelperLinesAligned(ctx, imagePositions);
            }

            ctx.restore();
        }

        drawOuterCuttingLines(ctx, startX, startY, totalWidth, totalHeight, canvas) {
            ctx.beginPath();
            
            // Draw lines that extend to paper edges
            // Top edge of print area - extend full width
            ctx.moveTo(0, startY);
            ctx.lineTo(canvas.width, startY);
            
            // Bottom edge of print area - extend full width  
            ctx.moveTo(0, startY + totalHeight);
            ctx.lineTo(canvas.width, startY + totalHeight);
            
            // Left edge of print area - extend full height
            ctx.moveTo(startX, 0);
            ctx.lineTo(startX, canvas.height);
            
            // Right edge of print area - extend full height
            ctx.moveTo(startX + totalWidth, 0);
            ctx.lineTo(startX + totalWidth, canvas.height);
            
            ctx.stroke();
        }

        drawBetweenImageLines(ctx, layout, startX, startY, photoWidth, photoHeight, gutterX, gutterY, canvas) {
            ctx.beginPath();
            
            // Vertical lines between columns - extend full height of paper
            for (let col = 1; col < layout.cols; col++) {
                const x = startX + col * photoWidth + (col - 0.5) * gutterX;
                ctx.moveTo(x, 0);  // From top of paper
                ctx.lineTo(x, canvas.height);  // To bottom of paper
            }
            
            // Horizontal lines between rows - extend full width of paper
            for (let row = 1; row < layout.rows; row++) {
                const y = startY + row * photoHeight + (row - 0.5) * gutterY;
                ctx.moveTo(0, y);  // From left edge of paper
                ctx.lineTo(canvas.width, y);  // To right edge of paper
            }
            
            ctx.stroke();
        }

        drawCornerMarks(ctx, layout, startX, startY, photoWidth, photoHeight, gutterX, gutterY, dpi) {
            const markLength = Math.round(3 / 25.4 * dpi); // 3mm marks
            
            ctx.beginPath();
            
            for (let row = 0; row < layout.rows; row++) {
                for (let col = 0; col < layout.cols; col++) {
                    const photoX = startX + col * (photoWidth + gutterX);
                    const photoY = startY + row * (photoHeight + gutterY);
                    
                    // Top-left corner
                    ctx.moveTo(photoX - markLength, photoY);
                    ctx.lineTo(photoX + markLength, photoY);
                    ctx.moveTo(photoX, photoY - markLength);
                    ctx.lineTo(photoX, photoY + markLength);
                    
                    // Top-right corner
                    const topRightX = photoX + photoWidth;
                    ctx.moveTo(topRightX - markLength, photoY);
                    ctx.lineTo(topRightX + markLength, photoY);
                    ctx.moveTo(topRightX, photoY - markLength);
                    ctx.lineTo(topRightX, photoY + markLength);
                    
                    // Bottom-left corner
                    const bottomLeftY = photoY + photoHeight;
                    ctx.moveTo(photoX - markLength, bottomLeftY);
                    ctx.lineTo(photoX + markLength, bottomLeftY);
                    ctx.moveTo(photoX, bottomLeftY - markLength);
                    ctx.lineTo(photoX, bottomLeftY + markLength);
                    
                    // Bottom-right corner
                    const bottomRightX = photoX + photoWidth;
                    const bottomRightY = photoY + photoHeight;
                    ctx.moveTo(bottomRightX - markLength, bottomRightY);
                    ctx.lineTo(bottomRightX + markLength, bottomRightY);
                    ctx.moveTo(bottomRightX, bottomRightY - markLength);
                    ctx.lineTo(bottomRightX, bottomRightY + markLength);
                }
            }
            
            ctx.stroke();
        }

        drawGridHelperLines(ctx, layout, startX, startY, photoWidth, photoHeight, gutterX, gutterY) {
            ctx.save();
            ctx.strokeStyle = ctx.strokeStyle + '40'; // Make semi-transparent
            ctx.beginPath();
            
            // Draw grid around each photo
            for (let row = 0; row < layout.rows; row++) {
                for (let col = 0; col < layout.cols; col++) {
                    const photoX = startX + col * (photoWidth + gutterX);
                    const photoY = startY + row * (photoHeight + gutterY);
                    
                    ctx.rect(photoX, photoY, photoWidth, photoHeight);
                }
            }
            
            ctx.stroke();
            ctx.restore();
        }

        // New aligned cutting guide functions
        drawOuterCuttingLinesAligned(ctx, imagePositions, canvas) {
            if (imagePositions.length === 0) return;
            
            ctx.beginPath();
            
            // Find bounds of all images
            const leftmostX = Math.min(...imagePositions.map(pos => pos.x));
            const rightmostX = Math.max(...imagePositions.map(pos => pos.x + pos.width));
            const topmostY = Math.min(...imagePositions.map(pos => pos.y));
            const bottommostY = Math.max(...imagePositions.map(pos => pos.y + pos.height));
            
            // Calculate offset to push cutting lines outside image area
            // Use half line width to ensure cutting line doesn't overlap image
            const lineOffset = ctx.lineWidth / 2;
            
            // Draw lines that extend to paper edges but positioned OUTSIDE image boundaries
            // Top edge - positioned ABOVE the topmost image
            const topCutY = topmostY - lineOffset;
            ctx.moveTo(0, topCutY);
            ctx.lineTo(canvas.width, topCutY);
            
            // Bottom edge - positioned BELOW the bottommost image
            const bottomCutY = bottommostY + lineOffset;
            ctx.moveTo(0, bottomCutY);
            ctx.lineTo(canvas.width, bottomCutY);
            
            // Left edge - positioned LEFT of the leftmost image
            const leftCutX = leftmostX - lineOffset;
            ctx.moveTo(leftCutX, 0);
            ctx.lineTo(leftCutX, canvas.height);
            
            // Right edge - positioned RIGHT of the rightmost image
            const rightCutX = rightmostX + lineOffset;
            ctx.moveTo(rightCutX, 0);
            ctx.lineTo(rightCutX, canvas.height);
            
            ctx.stroke();
        }

        drawBetweenImageLinesAligned(ctx, imagePositions, layout, canvas) {
            ctx.beginPath();
            
            // Group images by row and column for precise cutting lines
            const imagesByRow = [];
            const imagesByCol = [];
            
            for (let i = 0; i < layout.rows; i++) imagesByRow[i] = [];
            for (let i = 0; i < layout.cols; i++) imagesByCol[i] = [];
            
            imagePositions.forEach(pos => {
                imagesByRow[pos.row].push(pos);
                imagesByCol[pos.col].push(pos);
            });
            
            // Vertical lines between columns - exactly in the middle of the gap
            for (let col = 0; col < layout.cols - 1; col++) {
                const currentColImages = imagesByCol[col];
                const nextColImages = imagesByCol[col + 1];
                
                if (currentColImages.length > 0 && nextColImages.length > 0) {
                    const rightEdge = currentColImages[0].x + currentColImages[0].width;
                    const leftEdge = nextColImages[0].x;
                    const cutLineX = (rightEdge + leftEdge) / 2;
                    
                    ctx.moveTo(cutLineX, 0);
                    ctx.lineTo(cutLineX, canvas.height);
                }
            }
            
            // Horizontal lines between rows - exactly in the middle of the gap
            for (let row = 0; row < layout.rows - 1; row++) {
                const currentRowImages = imagesByRow[row];
                const nextRowImages = imagesByRow[row + 1];
                
                if (currentRowImages.length > 0 && nextRowImages.length > 0) {
                    const bottomEdge = currentRowImages[0].y + currentRowImages[0].height;
                    const topEdge = nextRowImages[0].y;
                    const cutLineY = (bottomEdge + topEdge) / 2;
                    
                    ctx.moveTo(0, cutLineY);
                    ctx.lineTo(canvas.width, cutLineY);
                }
            }
            
            ctx.stroke();
        }

        drawCornerMarksAligned(ctx, imagePositions, dpi) {
            const markLength = Math.round(3 / 25.4 * dpi); // 3mm marks
            const offset = ctx.lineWidth / 2; // Offset to push marks outside image area
            
            ctx.beginPath();
            
            imagePositions.forEach(pos => {
                // Top-left corner - positioned outside the image
                const tlX = pos.x - offset;
                const tlY = pos.y - offset;
                ctx.moveTo(tlX - markLength, tlY);
                ctx.lineTo(tlX + markLength, tlY);
                ctx.moveTo(tlX, tlY - markLength);
                ctx.lineTo(tlX, tlY + markLength);
                
                // Top-right corner - positioned outside the image
                const trX = pos.x + pos.width + offset;
                const trY = pos.y - offset;
                ctx.moveTo(trX - markLength, trY);
                ctx.lineTo(trX + markLength, trY);
                ctx.moveTo(trX, trY - markLength);
                ctx.lineTo(trX, trY + markLength);
                
                // Bottom-left corner - positioned outside the image
                const blX = pos.x - offset;
                const blY = pos.y + pos.height + offset;
                ctx.moveTo(blX - markLength, blY);
                ctx.lineTo(blX + markLength, blY);
                ctx.moveTo(blX, blY - markLength);
                ctx.lineTo(blX, blY + markLength);
                
                // Bottom-right corner - positioned outside the image
                const brX = pos.x + pos.width + offset;
                const brY = pos.y + pos.height + offset;
                ctx.moveTo(brX - markLength, brY);
                ctx.lineTo(brX + markLength, brY);
                ctx.moveTo(brX, brY - markLength);
                ctx.lineTo(brX, brY + markLength);
            });
            
            ctx.stroke();
        }

        drawGridHelperLinesAligned(ctx, imagePositions) {
            ctx.save();
            ctx.strokeStyle = ctx.strokeStyle + '40'; // Make semi-transparent
            ctx.beginPath();
            
            // Calculate offset to position grid lines outside image area
            const offset = ctx.lineWidth / 2;
            
            // Draw rectangles positioned outside each image boundary
            imagePositions.forEach(pos => {
                const rectX = pos.x - offset;
                const rectY = pos.y - offset;
                const rectWidth = pos.width + (2 * offset);
                const rectHeight = pos.height + (2 * offset);
                ctx.rect(rectX, rectY, rectWidth, rectHeight);
            });
            
            ctx.stroke();
            ctx.restore();
        }

        async useGalleryImages() {
            let allImages = [];

            // Th√™m ·∫£nh t·ª´ gallery
            if (this.galleryImages && this.galleryImages.length > 0) {
                allImages.push(...this.galleryImages);
            }

            // Th√™m ·∫£nh t·ª´ File System (ƒë√£ convert)
            if (window.converter && window.converter.files) {
                const fileSystemImages = window.converter.files
                    .filter(f => f.status === 'success' && f.convertedBlob)
                    .map(f => ({
                        data: f.convertedBlob,
                        filename: f.name
                    }));
                allImages.push(...fileSystemImages);
            }

            if (allImages.length > 0) {
                let addedCount = 0;

                for (const imageData of allImages) {
                    try {
                        // Convert data URL to File object
                        const file = await this.dataURLToFile(imageData.data, imageData.filename);
                        if (file) {
                            this.addImageToPrintList(file);
                            addedCount++;
                        }
                    } catch (error) {
                        console.error('Error converting gallery image:', error);
                    }
                }

                if (addedCount > 0) {
                    this.showToast(`‚úÖ ƒê√£ th√™m ${addedCount} ·∫£nh t·ª´ kho v√†o danh s√°ch in`, 'success');
                    // Switch to print tab to show added images
                    this.switchToTab('print');
                } else {
                    this.showToast('Kh√¥ng th·ªÉ th√™m ·∫£nh t·ª´ kho. C√≥ l·ªói x·∫£y ra.', 'error');
                }
            } else {
                this.showToast('Kho ·∫£nh tr·ªëng. H√£y th√™m ·∫£nh v√†o kho ho·∫∑c convert ·∫£nh t·ª´ File System tr∆∞·ªõc.', 'warning');
            }
        }

        // Helper function to convert data URL to File object
        async dataURLToFile(dataURL, filename) {
            try {
                const response = await fetch(dataURL);
                const blob = await response.blob();
                
                // Create file with proper MIME type
                const mimeType = dataURL.split(',')[0].split(':')[1].split(';')[0];
                const file = new File([blob], filename, { 
                    type: mimeType,
                    lastModified: Date.now()
                });
                
                return file;
            } catch (error) {
                console.error('Error converting data URL to file:', error);
                return null;
            }
        }

        // Template Polaroid functionality
        initializeTemplateMode() {
            console.log('üîß Initializing Template Mode...');

            // Define Polaroid 2 template configurations for different sizes
            this.polaroid2Templates = {
                '5.5x8.5': {
                    name: 'Tr∆°n 5.5√ó8.5',
                    overlayPath: 'TEMPLATE/template_polaroid_5.5x8.5cm.png',
                    canvasSize: { width: 650, height: 1004 },
                    imageArea: { x: 36, y: 63, width: 576, height: 785 }
                },
                '6x9': {
                    name: 'Tr∆°n 6√ó9',
                    overlayPath: 'TEMPLATE/template_polaroid_6x9cm.png',
                    canvasSize: { width: 709, height: 1063 },
                    imageArea: { x: 45, y: 64, width: 614, height: 831 }
                },
                '7x10': {
                    name: 'Tr∆°n 7√ó10',
                    overlayPath: 'TEMPLATE/template_polaroid_7x10cm.png',
                    canvasSize: { width: 827, height: 1181 },
                    imageArea: { x: 50, y: 64, width: 725, height: 915 }
                },
                '6x9-art-music': {
                    name: 'C√∫n √¢m nh·∫°c 6√ó9',
                    overlayPath: 'TEMPLATE/template_polaroid_6x9cm_art_music.png',
                    canvasSize: { width: 709, height: 1063 },
                    imageArea: { x: 54, y: 72, width: 602, height: 777 },
                    isArt: true // Mark as art template
                }
            };

            // Current selected art template key
            this.currentArtTemplate = null;

            // Initialize template data with configuration
            this.templateData = {
                images: [],
                currentIndex: 0,
                config: {
                    templateType: 'type1', // 'type1' (Polaroid 1 - Chu·∫©n) or 'type2' (Polaroid 2 - M·ªõi)
                    dpi: 300,
                    polaroidSizeCm: { width: 5.5, height: 8.5 },
                    border: {
                        topPx: 50,
                        leftPx: 45,
                        rightPx: 45,
                        bottomCaptionPx: 175
                    },
                    fitMode: 'cover', // 'contain' or 'cover'
                    safeAreaPx: 0,
                    bgColor: '#FFFFFF',
                    overlayFrame: false,
                    overlayPath: null,
                    imageArea: null, // For Polaroid 2: {x, y, width, height}
                    caption: {
                        text: '',
                        fontFamily: 'Arial',
                        fontSizePx: 16,
                        color: '#000000',
                        align: 'center', // 'center', 'left', 'right'
                        marginTopPx: 10
                    }
                }
            };
            
            // Setup event listeners
            this.setupTemplateEventListeners();
            
            // Update UI
            this.updateTemplateUI();
            this.updateTemplateSpecs();
            this.updateTemplateUIVisibility(); // Set initial UI state
        }

        setupTemplateEventListeners() {
            // File input
            const templateFileInput = document.getElementById('templateFileInput');
            if (templateFileInput) {
                // X√≥a event listener c≈© n·∫øu c√≥ ƒë·ªÉ tr√°nh duplicate
                templateFileInput.removeEventListener('change', this._templateFileInputHandler);

                // T·∫°o handler m·ªõi
                this._templateFileInputHandler = async (e) => {
                    await this.handleTemplateFileSelect(e.target.files);
                    // Reset input value ƒë·ªÉ c√≥ th·ªÉ upload l·∫°i c√πng file n·∫øu c·∫ßn
                    e.target.value = '';
                };

                templateFileInput.addEventListener('change', this._templateFileInputHandler);
            }

            // Setup compact tabs functionality
            this.setupCompactTemplateTabs();

            // Configuration controls
            this.setupTemplateConfigListeners();

            // Navigation buttons
            const templatePrevBtn = document.getElementById('templatePrevBtn');
            const templateNextBtn = document.getElementById('templateNextBtn');
            if (templatePrevBtn) {
                templatePrevBtn.addEventListener('click', () => this.navigateTemplate(-1));
            }
            if (templateNextBtn) {
                templateNextBtn.addEventListener('click', () => this.navigateTemplate(1));
            }

            // Crop controls
            const templateCropReset = document.getElementById('templateCropReset');
            const templateCropCenter = document.getElementById('templateCropCenter');
            const templateCropFit = document.getElementById('templateCropFit');
            
            if (templateCropReset) {
                templateCropReset.addEventListener('click', () => this.resetTemplateCrop());
            }
            if (templateCropCenter) {
                templateCropCenter.addEventListener('click', () => this.centerTemplateCrop());
            }
            if (templateCropFit) {
                templateCropFit.addEventListener('click', () => this.fitTemplateCrop());
            }
            
            // Crop edit button
            const templateCropEdit = document.getElementById('templateCropEdit');
            console.log('üîç Looking for templateCropEdit button:', templateCropEdit);
            if (templateCropEdit) {
                templateCropEdit.addEventListener('click', (e) => {
                    console.log('‚úÇÔ∏è Template Crop Edit button clicked!', e);
                    console.log('Current templateData:', this.templateData);
                    console.log('Images length:', this.templateData?.images?.length);
                    this.openTemplateCropEditor();
                });
                console.log('‚úÖ templateCropEdit event listener added successfully');
            } else {
                console.error('‚ùå templateCropEdit button not found!');
            }

            // Quick to Print button
            const quickToPrintBtn = document.getElementById('quickToPrintBtn');
            if (quickToPrintBtn) {
                quickToPrintBtn.addEventListener('click', () => {
                    this.quickTransferToPrint();
                });
            }

            // Export buttons
            const savePolaroidBtn = document.getElementById('savePolaroidToFileSystem');
            const exportCurrentPolaroid = document.getElementById('exportCurrentPolaroid');
            const exportAllPolaroids = document.getElementById('exportAllPolaroids');
            const exportAllIndividual = document.getElementById('exportAllIndividual');

            if (savePolaroidBtn) {
                savePolaroidBtn.addEventListener('click', () => this.savePolaroidToFileSystem());
            }
            if (exportCurrentPolaroid) {
                exportCurrentPolaroid.addEventListener('click', () => this.exportCurrentPolaroid());
            }
            if (exportAllPolaroids) {
                exportAllPolaroids.addEventListener('click', () => this.exportAllPolaroids());
            }
            if (exportAllIndividual) {
                exportAllIndividual.addEventListener('click', () => this.exportAllIndividualFiles());
            }

            // Reset button
            const resetTemplateDefaults = document.getElementById('resetTemplateDefaults');
            if (resetTemplateDefaults) {
                resetTemplateDefaults.addEventListener('click', () => this.resetTemplateDefaults());
            }
        }

        setupCompactTemplateTabs() {
            console.log('üè∑Ô∏è Setting up compact template tabs...');
            
            // Get tab buttons and content ONLY from settings-tabs section
            const tabButtons = document.querySelectorAll('.settings-tabs .tab-btn');
            const tabContents = document.querySelectorAll('.settings-tabs .tab-content');
            
            if (tabButtons.length === 0 || tabContents.length === 0) {
                console.warn('‚ö†Ô∏è Tab elements not found, skipping tab setup');
                return;
            }
            
            // Add click listeners to tab buttons
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.dataset.tab;
                    console.log('üè∑Ô∏è Switching to tab:', targetTab);
                    
                    // Remove active class from all buttons and contents
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    // Add active class to clicked button and corresponding content
                    button.classList.add('active');
                    const targetContent = document.querySelector(`.settings-tabs [data-tab="${targetTab}"].tab-content`);
                    if (targetContent) {
                        targetContent.classList.add('active');
                        console.log('‚úÖ Activated tab content:', targetTab);
                    } else {
                        console.error('‚ùå Target content not found for tab:', targetTab);
                    }
                    
                    // Update quick specs when switching tabs
                    this.updateQuickSpecs();
                });
            });
            
            console.log('‚úÖ Compact tabs setup complete');
        }

        initializeBorderTemplateMode() {
            console.log('üîß Initializing Border Template Mode...');
            console.log('üîç Checking for filesystem controls...');
            const saveBorderBtn = document.getElementById('saveBorderToFileSystem');
            const exportOptions = document.getElementById('borderExportOptions');
            console.log('Save button found:', saveBorderBtn ? 'YES' : 'NO');
            console.log('Export options found:', exportOptions ? 'YES' : 'NO');

            // Setup event listeners for border template export buttons
            const exportCurrentBorderTemplate = document.getElementById('exportCurrentBorderTemplate');
            const exportAllBorderTemplates = document.getElementById('exportAllBorderTemplates');
            const exportAllBorderIndividual = document.getElementById('exportAllBorderIndividual');

            if (exportCurrentBorderTemplate) {
                exportCurrentBorderTemplate.addEventListener('click', () => this.exportCurrentBorderTemplate());
            }
            if (exportAllBorderTemplates) {
                exportAllBorderTemplates.addEventListener('click', () => this.exportAllBorderTemplates());
            }
            if (exportAllBorderIndividual) {
                exportAllBorderIndividual.addEventListener('click', () => this.exportAllBorderIndividual());
            }

            // Setup File System controls
            this.setupBorderFileSystemControls();

            console.log('‚úÖ Border Template Mode initialized');
        }

        initializeStripTemplateMode() {
            console.log('üîß Initializing Strip Template Mode...');

            // Setup event listeners for strip template export buttons
            const exportCurrentStripTemplate = document.getElementById('exportCurrentStripTemplate');
            const exportAllStripTemplates = document.getElementById('exportAllStripTemplates');
            const exportAllStripIndividual = document.getElementById('exportAllStripIndividual');

            if (exportCurrentStripTemplate) {
                exportCurrentStripTemplate.addEventListener('click', () => this.exportCurrentStripTemplate());
            }
            if (exportAllStripTemplates) {
                exportAllStripTemplates.addEventListener('click', () => this.exportAllStripTemplates());
            }
            if (exportAllStripIndividual) {
                exportAllStripIndividual.addEventListener('click', () => this.exportAllStripIndividual());
            }

            // Setup File System controls
            this.setupStripFileSystemControls();

            console.log('‚úÖ Strip Template Mode initialized');
        }

        updateQuickSpecs() {
            const quickSpecs = document.getElementById('quickSpecs');
            if (!quickSpecs) return;

            const config = this.templateData.config;
            const dimensions = this.calculatePolaroidDimensions();

            if (dimensions.isValid && config) {
                const aspectRatio = (config.polaroidSizeCm.width / config.polaroidSizeCm.height).toFixed(2);
                quickSpecs.textContent = `${config.polaroidSizeCm.width}√ó${config.polaroidSizeCm.height}cm ‚Ä¢ ${config.dpi} DPI ‚Ä¢ 1:${aspectRatio}`;
            }
        }

        // Get Polaroid 2 template config based on current size and art selection
        getPolaroid2TemplateConfig() {
            // If art template is selected, use it
            if (this.currentArtTemplate && this.polaroid2Templates[this.currentArtTemplate]) {
                return this.polaroid2Templates[this.currentArtTemplate];
            }

            // Otherwise, use default template for current size
            const size = this.templateData.config.polaroidSizeCm;
            const sizeKey = `${size.width}x${size.height}`;

            // Check if we have a template for this size
            if (this.polaroid2Templates[sizeKey]) {
                return this.polaroid2Templates[sizeKey];
            }

            // Default to 5.5x8.5 if size not found
            console.warn(`No Polaroid 2 template for size ${sizeKey}, using default 5.5x8.5`);
            return this.polaroid2Templates['5.5x8.5'];
        }

        // Update Polaroid 2 config when size changes
        updatePolaroid2Config() {
            if (this.templateData.config.templateType !== 'type2') return;

            const templateConfig = this.getPolaroid2TemplateConfig();
            this.templateData.config.overlayFrame = true; // Enable overlay mode
            this.templateData.config.overlayPath = templateConfig.overlayPath;
            this.templateData.config.imageArea = templateConfig.imageArea;

            console.log(`üìê Updated Polaroid 2 template:`, templateConfig);
        }

        // Show template frame preview
        showTemplateFramePreview() {
            const isPolaroid2 = this.templateData.config.templateType === 'type2';
            const hasImages = this.templateData?.images?.length > 0;

            const framePreview = document.getElementById('templateFramePreview');
            const frameImg = document.getElementById('templateFrameImg');
            const placeholder = document.getElementById('placeholderText');
            const polaroidFrame = document.querySelector('.polaroid-frame');

            // Toggle class for Polaroid 2 to hide decorative frame
            // Polaroid 2 always uses overlay mode (with or without images)
            if (polaroidFrame) {
                if (isPolaroid2) {
                    polaroidFrame.classList.add('template-overlay-mode');
                } else {
                    polaroidFrame.classList.remove('template-overlay-mode');
                }
            }

            if (!framePreview || !frameImg || !placeholder) return;

            // If Polaroid 2 and no images yet, show template preview
            if (isPolaroid2 && !hasImages) {
                const templateConfig = this.getPolaroid2TemplateConfig();
                if (templateConfig && templateConfig.overlayPath) {
                    frameImg.src = templateConfig.overlayPath;

                    // Scale preview based on actual size ratio
                    const baseHeight = 300; // Base height for 5.5x8.5
                    const actualRatio = templateConfig.canvasSize.height / 1004; // 1004 is 5.5x8.5 height
                    const previewHeight = baseHeight * actualRatio;

                    frameImg.style.height = `${previewHeight}px`;
                    frameImg.style.width = 'auto';

                    framePreview.style.display = 'block';
                    placeholder.style.display = 'none';
                    console.log(`üì∏ Showing template preview: ${templateConfig.name} (${previewHeight}px)`);
                    return;
                }
            }

            // Hide template preview if has images or Polaroid 1
            if (hasImages) {
                framePreview.style.display = 'none';
                placeholder.style.display = 'none';
            } else {
                framePreview.style.display = 'none';
                placeholder.style.display = 'block';
                placeholder.textContent = isPolaroid2 ? 'Upload ·∫£nh v√†o khung...' : 'Ch·ªçn khung v√† upload ·∫£nh...';
            }
        }

        // Update UI visibility based on template type
        updateTemplateUIVisibility() {
            const isPolaroid2 = this.templateData.config.templateType === 'type2';
            const isArtTemplate = this.currentArtTemplate !== null;

            // Show/hide art template selection
            const artSection = document.querySelector('.polaroid2-only-section');
            if (artSection) {
                artSection.style.display = isPolaroid2 ? 'block' : 'none';
            }

            // Check if "Tr∆°n" template is available for current size
            if (isPolaroid2 && !isArtTemplate) {
                // For "Tr∆°n" template, only show supported sizes
                const size = this.templateData.config.polaroidSizeCm;
                const sizeKey = `${size.width}x${size.height}`;
                const hasPlainTemplate = this.polaroid2Templates[sizeKey] !== undefined;

                // Disable/enable size buttons based on availability
                const sizeButtons = document.querySelectorAll('.size-preset-btn');
                sizeButtons.forEach(btn => {
                    const btnWidth = parseFloat(btn.dataset.width);
                    const btnHeight = parseFloat(btn.dataset.height);
                    const btnSizeKey = `${btnWidth}x${btnHeight}`;
                    const hasSizeTemplate = this.polaroid2Templates[btnSizeKey] !== undefined;

                    if (!hasSizeTemplate) {
                        btn.style.opacity = '0.5';
                        btn.style.pointerEvents = 'none';
                        btn.title = 'Template tr∆°n ch·ªâ h·ªó tr·ª£ 5.5√ó8.5cm v√† 6√ó9cm';
                    } else {
                        btn.style.opacity = '1';
                        btn.style.pointerEvents = 'auto';
                        btn.title = '';
                    }
                });

                // Also disable manual size inputs if current size not supported
                const plainCard = document.querySelector('.art-template-card input[value="default"]')?.closest('.art-template-card');
                if (plainCard && !hasPlainTemplate) {
                    // Auto-switch to art template if currently on "Tr∆°n"
                    const artInput = document.querySelector('.art-template-card input[value="6x9-art-music"]');
                    if (artInput) {
                        artInput.checked = true;
                        artInput.closest('.art-template-card').classList.add('active');
                        plainCard.classList.remove('active');
                        this.currentArtTemplate = '6x9-art-music';
                        this.updatePolaroid2Config();
                    }
                }
            } else {
                // For Polaroid 1 or art templates, enable all size buttons
                const sizeButtons = document.querySelectorAll('.size-preset-btn');
                sizeButtons.forEach(btn => {
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                    btn.title = '';
                });
            }

            // Show template frame preview
            this.showTemplateFramePreview();

            // Hide size controls when Art template is selected (fixed size, cannot change)
            const allSections = document.querySelectorAll('.settings-section');
            allSections.forEach(section => {
                const title = section.querySelector('.section-title');
                if (title && title.textContent.includes('K√≠ch th∆∞·ªõc Polaroid')) {
                    // Hide size section for art templates (they have fixed size)
                    section.style.display = isArtTemplate ? 'none' : 'block';
                }
            });

            // Find all sections that should be hidden for Polaroid 2
            const bgColorControl = document.getElementById('templateBgColor')?.closest('.setting-row');
            const safeAreaControl = document.getElementById('templateSafeArea')?.closest('.setting-row');
            const overlayControl = document.getElementById('templateOverlay')?.closest('.setting-row');

            // Hide/show border controls (vi·ªÅn)
            const borderItems = document.querySelectorAll('.border-item');
            borderItems.forEach(item => {
                if (isPolaroid2) {
                    item.style.opacity = '0.5';
                    item.style.pointerEvents = 'none';
                    const inputs = item.querySelectorAll('input');
                    inputs.forEach(input => input.disabled = true);
                } else {
                    item.style.opacity = '1';
                    item.style.pointerEvents = 'auto';
                    const inputs = item.querySelectorAll('input');
                    inputs.forEach(input => input.disabled = false);
                }
            });

            // Hide/show size input controls (Polaroid 2 only supports specific sizes)
            const sizeInputs = document.querySelectorAll('#templateWidth, #templateHeight');
            sizeInputs.forEach(input => {
                if (isPolaroid2) {
                    input.style.opacity = '0.5';
                    input.disabled = true;
                } else {
                    input.style.opacity = '1';
                    input.disabled = false;
                }
            });

            // Hide/show other controls
            if (bgColorControl) {
                bgColorControl.style.display = isPolaroid2 ? 'none' : 'flex';
            }
            if (safeAreaControl) {
                safeAreaControl.style.display = isPolaroid2 ? 'none' : 'flex';
            }
            if (overlayControl) {
                overlayControl.style.display = isPolaroid2 ? 'none' : 'flex';
            }

            // Add helpful message for Polaroid 2
            const borderGrid = document.querySelector('.border-grid');
            if (borderGrid) {
                let messageDiv = borderGrid.querySelector('.polaroid2-message');
                if (isPolaroid2) {
                    if (!messageDiv) {
                        messageDiv = document.createElement('div');
                        messageDiv.className = 'polaroid2-message';
                        messageDiv.style.cssText = `
                            grid-column: 1/-1;
                            padding: 12px;
                            background: #fffbeb;
                            border: 1px solid #fbbf24;
                            border-radius: 6px;
                            color: #92400e;
                            font-size: 0.85rem;
                            text-align: center;
                            margin-top: 10px;
                        `;
                        messageDiv.innerHTML = `
                            <strong>‚ÑπÔ∏è Polaroid 2:</strong> Vi·ªÅn c·ªë ƒë·ªãnh theo template PNG.
                            Ch·ªâ c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh zoom/pan ·∫£nh b√™n trong.
                        `;
                        borderGrid.appendChild(messageDiv);
                    }
                } else {
                    if (messageDiv) {
                        messageDiv.remove();
                    }
                }
            }

            console.log(`üé® UI updated for ${isPolaroid2 ? 'Polaroid 2' : 'Polaroid 1'}`);
        }

        setupTemplateConfigListeners() {
            // Art Template Selection (for Polaroid 2)
            const artTemplateCards = document.querySelectorAll('.art-template-card');
            artTemplateCards.forEach(card => {
                card.addEventListener('click', () => {
                    // Remove active class from all cards
                    artTemplateCards.forEach(c => c.classList.remove('active'));
                    // Add active class to clicked card
                    card.classList.add('active');

                    // Get art template type from radio input
                    const radio = card.querySelector('input[type="radio"]');
                    const artType = radio.value;

                    // Update current art template
                    this.currentArtTemplate = artType === 'default' ? null : artType;

                    // Update Polaroid 2 config with selected art template
                    if (this.templateData.config.templateType === 'type2') {
                        this.updatePolaroid2Config();
                        this.reprocessAllTemplateImages();
                        this.updateTemplateSpecs();
                        this.updateTemplateUIVisibility(); // Update preview
                    }

                    console.log(`üé® Art template changed to: ${artType}`);
                });
            });

            // Template Type Selection (Polaroid 1 vs Polaroid 2)
            const templateTypeCards = document.querySelectorAll('.template-type-card');
            templateTypeCards.forEach(card => {
                card.addEventListener('click', () => {
                    // Remove active class from all cards
                    templateTypeCards.forEach(c => c.classList.remove('active'));
                    // Add active class to clicked card
                    card.classList.add('active');

                    // Get template type from radio input
                    const radio = card.querySelector('input[type="radio"]');
                    const templateType = radio.value;

                    // Update template configuration
                    this.templateData.config.templateType = templateType;

                    // Update template overlay path and coordinates
                    if (templateType === 'type2') {
                        // Polaroid 2 - New template with overlay
                        this.templateData.config.overlayFrame = true;
                        // Get template config based on current size
                        const templateConfig = this.getPolaroid2TemplateConfig();
                        this.templateData.config.overlayPath = templateConfig.overlayPath;
                        this.templateData.config.imageArea = templateConfig.imageArea;
                        console.log('üñºÔ∏è ƒê√£ chuy·ªÉn sang Polaroid 2 (M·ªõi) - Overlay mode');
                        console.log('üìê Template config:', templateConfig);
                    } else {
                        // Polaroid 1 - Standard template with borders
                        this.templateData.config.overlayFrame = false;
                        this.templateData.config.overlayPath = null;
                        this.templateData.config.imageArea = null;
                        console.log('üìê ƒê√£ chuy·ªÉn sang Polaroid 1 (Chu·∫©n) - Border mode');
                    }

                    // Reprocess all images with new template
                    this.reprocessAllTemplateImages();
                    this.updateTemplateSpecs();

                    // Update UI visibility based on template type
                    this.updateTemplateUIVisibility();

                    console.log(`‚úÖ Template type changed to: ${templateType}`);
                });
            });

            // DPI and size controls
            const templateDPI = document.getElementById('templateDPI');
            const templateWidth = document.getElementById('templateWidth');
            const templateHeight = document.getElementById('templateHeight');

            if (templateDPI) {
                // C·ªë ƒë·ªãnh DPI = 300, kh√¥ng cho ph√©p thay ƒë·ªïi
                templateDPI.value = 300;
                templateDPI.disabled = true;
                this.templateData.config.dpi = 300;

                templateDPI.addEventListener('change', (e) => {
                    // Lu√¥n gi·ªØ DPI = 300
                    e.target.value = 300;
                    this.templateData.config.dpi = 300;
                    this.updateTemplateSpecs();
                    this.updateQuickSpecs();
                    this.reprocessAllTemplateImages();
                });
            }

            if (templateWidth) {
                templateWidth.addEventListener('input', (e) => {
                    this.templateData.config.polaroidSizeCm.width = parseFloat(e.target.value);
                    this.updatePolaroid2Config(); // Update Polaroid 2 template if needed
                    this.updateTemplateSpecs();
                    this.updateQuickSpecs();
                    this.reprocessAllTemplateImages();
                    this.showTemplateFramePreview(); // Update preview
                });
            }

            if (templateHeight) {
                templateHeight.addEventListener('input', (e) => {
                    this.templateData.config.polaroidSizeCm.height = parseFloat(e.target.value);
                    this.updatePolaroid2Config(); // Update Polaroid 2 template if needed
                    this.updateTemplateSpecs();
                    this.updateQuickSpecs();
                    this.reprocessAllTemplateImages();
                    this.showTemplateFramePreview(); // Update preview
                });
            }

            // Quick Size Preset Buttons
            const sizePresetButtons = document.querySelectorAll('.size-preset-btn');
            sizePresetButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove active class from all buttons
                    sizePresetButtons.forEach(b => b.classList.remove('active'));
                    // Add active class to clicked button
                    btn.classList.add('active');

                    // Get size from data attributes
                    const width = parseFloat(btn.dataset.width);
                    const height = parseFloat(btn.dataset.height);

                    // Update config and inputs
                    this.templateData.config.polaroidSizeCm.width = width;
                    this.templateData.config.polaroidSizeCm.height = height;

                    if (templateWidth) templateWidth.value = width;
                    if (templateHeight) templateHeight.value = height;

                    this.updatePolaroid2Config(); // Update Polaroid 2 template if needed
                    this.updateTemplateSpecs();
                    this.updateQuickSpecs();
                    this.reprocessAllTemplateImages();
                    this.showTemplateFramePreview(); // Update preview

                    console.log(`üìê ƒê√£ ch·ªçn k√≠ch th∆∞·ªõc: ${width}√ó${height} cm`);
                });
            });

            // Border controls - sliders sync with number inputs
            this.setupBorderControls();

            // Advanced settings
            const templateFitMode = document.getElementById('templateFitMode');
            const templateSafeArea = document.getElementById('templateSafeArea');
            const templateBgColor = document.getElementById('templateBgColor');
            const templateOverlay = document.getElementById('templateOverlay');

            if (templateFitMode) {
                templateFitMode.addEventListener('change', (e) => {
                    this.templateData.config.fitMode = e.target.value;
                    this.reprocessAllTemplateImages();
                    this.updateTemplatePreview();
                });
            }

            if (templateSafeArea) {
                templateSafeArea.addEventListener('input', (e) => {
                    this.templateData.config.safeAreaPx = parseInt(e.target.value);
                    this.updateTemplateSpecs();
                    this.reprocessAllTemplateImages();
                    this.updateTemplatePreview();
                });
            }

            if (templateBgColor) {
                templateBgColor.addEventListener('change', (e) => {
                    this.templateData.config.bgColor = e.target.value;
                    this.reprocessAllTemplateImages();
                    this.updateTemplatePreview();
                });
            }

            if (templateOverlay) {
                templateOverlay.addEventListener('change', (e) => {
                    this.templateData.config.overlayFrame = e.target.checked;
                    this.reprocessAllTemplateImages();
                    this.updateTemplatePreview();
                });
            }

            // Caption controls
            this.setupCaptionControls();
        }

        setupBorderControls() {
            const borderControls = [
                { slider: 'borderTop', number: 'borderTopValue', key: 'topPx' },
                { slider: 'borderLeft', number: 'borderLeftValue', key: 'leftPx' },
                { slider: 'borderRight', number: 'borderRightValue', key: 'rightPx' },
                { slider: 'borderBottom', number: 'borderBottomValue', key: 'bottomCaptionPx' }
            ];

            borderControls.forEach(control => {
                const slider = document.getElementById(control.slider);
                const numberInput = document.getElementById(control.number);

                if (slider && numberInput) {
                    // Sync slider to number input
                    slider.addEventListener('input', (e) => {
                        const value = parseInt(e.target.value);
                        numberInput.value = value;
                        this.templateData.config.border[control.key] = value;
                        this.updateTemplateSpecs();
                        this.reprocessAllTemplateImages();
                        this.updateTemplatePreview(); // Update main preview
                    });

                    // Sync number input to slider
                    numberInput.addEventListener('input', (e) => {
                        const value = parseInt(e.target.value);
                        slider.value = value;
                        this.templateData.config.border[control.key] = value;
                        this.updateTemplateSpecs();
                        this.reprocessAllTemplateImages();
                        this.updateTemplatePreview(); // Update main preview
                    });
                }
            });
        }

        setupCaptionControls() {
            const captionText = document.getElementById('captionText');
            const captionFont = document.getElementById('captionFont');
            const captionFontSize = document.getElementById('captionFontSize');
            const captionColor = document.getElementById('captionColor');
            const captionAlign = document.getElementById('captionAlign');
            const captionMarginTop = document.getElementById('captionMarginTop');

            if (captionText) {
                captionText.addEventListener('input', (e) => {
                    this.templateData.config.caption.text = e.target.value;
                    this.reprocessAllTemplateImages();
                    this.updateTemplatePreview();
                });
            }

            if (captionFont) {
                captionFont.addEventListener('change', (e) => {
                    this.templateData.config.caption.fontFamily = e.target.value;
                    this.reprocessAllTemplateImages();
                    this.updateTemplatePreview();
                });
            }

            if (captionFontSize) {
                captionFontSize.addEventListener('input', (e) => {
                    this.templateData.config.caption.fontSizePx = parseInt(e.target.value);
                    this.reprocessAllTemplateImages();
                    this.updateTemplatePreview();
                });
            }

            if (captionColor) {
                captionColor.addEventListener('change', (e) => {
                    this.templateData.config.caption.color = e.target.value;
                    this.reprocessAllTemplateImages();
                    this.updateTemplatePreview();
                });
            }

            if (captionAlign) {
                captionAlign.addEventListener('change', (e) => {
                    this.templateData.config.caption.align = e.target.value;
                    this.reprocessAllTemplateImages();
                    this.updateTemplatePreview();
                });
            }

            if (captionMarginTop) {
                captionMarginTop.addEventListener('input', (e) => {
                    this.templateData.config.caption.marginTopPx = parseInt(e.target.value);
                    this.reprocessAllTemplateImages();
                    this.updateTemplatePreview();
                });
            }
        }

        calculatePolaroidDimensions() {
            const config = this.templateData.config;
            // C√îNG TH·ª®C CH√çNH X√ÅC: (k√≠ch_th∆∞·ªõc_cm √∑ 2.54) √ó 300
            // C·ªë ƒë·ªãnh DPI = 300 (KH√îNG BAO GI·ªú thay ƒë·ªïi)
            const DPI = 300;
            const sizeCm = config.polaroidSizeCm;
            const border = config.border;

            // LU√îN s·ª≠ d·ª•ng Math.round() cho pixel cu·ªëi c√πng
            const canvasW = Math.round((sizeCm.width / 2.54) * DPI);
            const canvasH = Math.round((sizeCm.height / 2.54) * DPI);

            // Calculate image area
            const imageW = canvasW - (border.leftPx + border.rightPx);
            const imageH = canvasH - (border.topPx + border.bottomCaptionPx);

            // Apply safe area
            const safeImageW = Math.max(0, imageW - (config.safeAreaPx * 2));
            const safeImageH = Math.max(0, imageH - (config.safeAreaPx * 2));

            return {
                canvasW,
                canvasH,
                imageW,
                imageH,
                safeImageW,
                safeImageH,
                isValid: safeImageW > 0 && safeImageH > 0
            };
        }

        updateTemplateSpecs() {
            const dimensions = this.calculatePolaroidDimensions();
            const config = this.templateData.config;

            // Update crop modal specs if open
            this.updateTemplateCropModalSpecs();

            const specsDisplay = document.getElementById('currentSpecsDisplay');
            if (!specsDisplay) return;

            // For Polaroid 2, use imageArea dimensions
            let imageAreaCmW, imageAreaCmH, imageAreaPxW, imageAreaPxH;

            if (config.templateType === 'type2' && config.imageArea) {
                // Polaroid 2: Use imageArea from config
                imageAreaPxW = config.imageArea.width;
                imageAreaPxH = config.imageArea.height;
                imageAreaCmW = (imageAreaPxW / 300 * 2.54).toFixed(2);
                imageAreaCmH = (imageAreaPxH / 300 * 2.54).toFixed(2);
            } else {
                // Polaroid 1: Calculate from border settings
                imageAreaPxW = dimensions.safeImageW;
                imageAreaPxH = dimensions.safeImageH;
                imageAreaCmW = (imageAreaPxW / 300 * 2.54).toFixed(2);
                imageAreaCmH = (imageAreaPxH / 300 * 2.54).toFixed(2);
            }

            const bgColorName = config.bgColor === '#FFFFFF' ? 'Tr·∫Øng' : 
                               config.bgColor === '#000000' ? 'ƒêen' : 
                               config.bgColor === '#FF0000' ? 'ƒê·ªè' : 
                               config.bgColor === '#00FF00' ? 'Xanh l√°' : 
                               config.bgColor === '#0000FF' ? 'Xanh d∆∞∆°ng' : config.bgColor;
            
            const fitModeText = config.fitMode === 'cover' ? 'Cover (c·∫Øt ·∫£nh)' : 'Contain (v·ª´a khung)';
            
            specsDisplay.innerHTML = `
                <table class="specs-table">
                    <tbody>
                        <tr>
                            <td class="spec-key">‚ñ¶ Canvas</td>
                            <td class="spec-value highlight">${dimensions.canvasW} √ó ${dimensions.canvasH}<span class="spec-unit">px</span></td>
                        </tr>
                        <tr>
                            <td class="spec-key">‚ñ° V√πng ·∫£nh</td>
                            <td class="spec-value ${!dimensions.isValid ? 'error' : 'highlight'}">
                                ${imageAreaCmW} √ó ${imageAreaCmH}<span class="spec-unit">cm</span>
                                <span class="spec-detail">(${imageAreaPxW} √ó ${imageAreaPxH} px t·∫°i 300 DPI)</span>
                                <button class="quick-crop-btn" onclick="window.converter.quickCropToSize(${imageAreaCmW}, ${imageAreaCmH})">
                                    <span class="btn-icon">‚úÇ</span>
                                    <span>C·∫Øt ·∫£nh nhanh</span>
                                </button>
                            </td>
                        </tr>
                        <tr>
                            <td class="spec-key">‚§¢ Fit Mode</td>
                            <td class="spec-value">${fitModeText}</td>
                        </tr>
                        <tr>
                            <td class="spec-key">‚óà M√†u n·ªÅn</td>
                            <td class="spec-value">
                                <span class="spec-color-indicator" style="background: ${config.bgColor};"></span>${bgColorName}
                            </td>
                        </tr>
                    </tbody>
                </table>
                ${!dimensions.isValid ? '<div style="color: #dc2626; font-weight: 600; margin: 12px 16px; padding: 8px 12px; background: #fef2f2; border-left: 3px solid #dc2626;">‚Äª Vi·ªÅn qu√° l·ªõn, kh√¥ng c√≤n v√πng ·∫£nh kh·∫£ d·ª•ng!</div>' : ''}
            `;
        }

        resetTemplateDefaults() {
            // Reset to default values
            const defaults = {
                dpi: 300,
                polaroidSizeCm: { width: 6, height: 9 },
                border: { topPx: 20, leftPx: 20, rightPx: 20, bottomCaptionPx: 178 },
                fitMode: 'cover',
                safeAreaPx: 0,
                bgColor: '#FFFFFF',
                overlayFrame: false,
                caption: {
                    text: '',
                    fontFamily: 'Arial',
                    fontSizePx: 16,
                    color: '#000000',
                    align: 'center',
                    marginTopPx: 10
                }
            };

            this.templateData.config = { ...defaults };

            // Update UI controls
            this.updateTemplateConfigUI();
            this.updateTemplateSpecs();
            this.reprocessAllTemplateImages();
            
            this.showToast('‚Ü∫ ƒê√£ kh√¥i ph·ª•c c√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh', 'info');
        }

        quickCropToSize(width, height) {
            console.log(`‚úÇÔ∏è Quick crop to size: ${width} √ó ${height} cm`);
            
            // 1. Switch to crop tab
            this.switchToTab('crop');
            
            // 2. Wait a bit for tab to load
            setTimeout(() => {
                // 3. Select custom size option
                this.selectCropTemplate('custom');
                
                // 4. Set width and height inputs
                const widthInput = document.getElementById('cropWidthPage');
                const heightInput = document.getElementById('cropHeightPage');
                
                if (widthInput && heightInput) {
                    widthInput.value = width;
                    heightInput.value = height;
                    
                    // 5. Update size details display
                    this.validateCustomSizeInputs();
                    this.updateSizeDetailsPage();
                    
                    // 6. Show success message
                    this.showToast(`‚úÇÔ∏è ƒê√£ chuy·ªÉn sang c·∫Øt ·∫£nh ${width}√ó${height} cm`, 'success');
                    
                    console.log(`‚úÖ Quick crop setup complete: ${width} √ó ${height} cm`);
                } else {
                    console.error('‚ùå Could not find crop input fields');
                    this.showToast('‚ùå Kh√¥ng th·ªÉ thi·∫øt l·∫≠p k√≠ch th∆∞·ªõc c·∫Øt', 'error');
                }
            }, 300);
        }
        
        setupTemplateCropModalListeners() {
            console.log('üîß Setting up enhanced template crop modal listeners...');
            
            // Close button
            const closeBtn = document.getElementById('closeTemplateCrop');
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    console.log('üî≤ Close button clicked');
                    document.getElementById('templateCropModal').style.display = 'none';
                    this.templateCropData = null;
                });
                console.log('‚úÖ Close button listener added');
            }
            
            // Cancel button
            const cancelBtn = document.getElementById('cancelTemplateCrop');
            if (cancelBtn) {
                const newCancelBtn = cancelBtn.cloneNode(true);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                
                newCancelBtn.addEventListener('click', () => {
                    console.log('‚ùå Cancel button clicked');
                    document.getElementById('templateCropModal').style.display = 'none';
                    this.templateCropData = null;
                });
                console.log('‚úÖ Cancel button listener added');
            }
            
            // Skip button
            const skipBtn = document.getElementById('skipTemplateImage');
            if (skipBtn) {
                const newSkipBtn = skipBtn.cloneNode(true);
                skipBtn.parentNode.replaceChild(newSkipBtn, skipBtn);
                
                newSkipBtn.addEventListener('click', () => {
                    console.log('‚è≠Ô∏è Skip button clicked');
                    document.getElementById('templateCropModal').style.display = 'none';
                    this.templateCropData = null;
                });
                console.log('‚úÖ Skip button listener added');
            }
            
            // Crop button
            const cropBtn = document.getElementById('cropTemplateImage');
            if (cropBtn) {
                const newCropBtn = cropBtn.cloneNode(true);
                cropBtn.parentNode.replaceChild(newCropBtn, cropBtn);
                
                newCropBtn.addEventListener('click', () => {
                    console.log('‚úÇÔ∏è Crop button clicked');
                    this.cropCurrentTemplateImage();
                });
                console.log('‚úÖ Crop button listener added');
            }
            
            // Enhanced interface controls
            this.setupEnhancedTemplateCropControls();
            
            console.log('üéØ All enhanced modal listeners setup complete');
        }

        setupEnhancedTemplateCropControls() {
            console.log('üîß Setting up enhanced template crop controls...');

            // Template settings change handlers
            const templateCropMode = document.getElementById('templateCropMode');
            if (templateCropMode) {
                templateCropMode.addEventListener('change', () => {
                    console.log('üéØ Crop mode changed to:', templateCropMode.value);
                    this.updateTemplateCropMode(templateCropMode.value);
                });
            }

            const templateCropDPI = document.getElementById('templateCropDPI');
            if (templateCropDPI) {
                templateCropDPI.addEventListener('change', () => {
                    console.log('üìä DPI changed to:', templateCropDPI.value);
                    this.updateTemplateDPI(templateCropDPI.value);
                });
            }

            const templateCropBackground = document.getElementById('templateCropBackground');
            if (templateCropBackground) {
                templateCropBackground.addEventListener('change', () => {
                    console.log('üé® Background mode changed to:', templateCropBackground.value);
                    this.updateTemplateBgMode(templateCropBackground.value);
                });
            }

            // Enhanced Template Crop Section - Size Cards Event Listeners
            console.log('‚öôÔ∏è Thi·∫øt l·∫≠p event listeners cho Template Crop Section...');
            
            // Size card selection - Enhanced design
            const sizeCardsLarge = document.querySelectorAll('.size-card-large');
            const sizeCardsCompact = document.querySelectorAll('.size-card-compact');
            
            // Enhanced size cards (large)
            sizeCardsLarge.forEach(card => {
                card.addEventListener('click', () => {
                    // Remove active from all large cards
                    sizeCardsLarge.forEach(c => c.classList.remove('active'));
                    // Remove active from all compact cards  
                    sizeCardsCompact.forEach(c => c.classList.remove('active'));
                    
                    // Add active to clicked card
                    card.classList.add('active');
                    
                    const sizeValue = card.dataset.size;
                    console.log('‚úÖ Ch·ªçn k√≠ch th∆∞·ªõc t·ª´ card l·ªõn:', sizeValue);
                    if (this.updateTemplateCropInfo) this.updateTemplateCropInfo(sizeValue);
                    if (window.updateProgressSteps) window.updateProgressSteps(2); // Move to step 2 - Upload
                });
            });
            
            // Compact size cards  
            sizeCardsCompact.forEach(card => {
                card.addEventListener('click', () => {
                    // Remove active from all cards
                    sizeCardsLarge.forEach(c => c.classList.remove('active'));
                    sizeCardsCompact.forEach(c => c.classList.remove('active'));
                    
                    // Add active to clicked card
                    card.classList.add('active');
                    
                    const sizeValue = card.dataset.size;
                    console.log('‚úÖ Ch·ªçn k√≠ch th∆∞·ªõc t·ª´ card nh·ªè:', sizeValue);
                    if (this.updateTemplateCropInfo) this.updateTemplateCropInfo(sizeValue);
                    if (window.updateProgressSteps) window.updateProgressSteps(2);
                });
            });

            // Upload area interactions
            const uploadAreaModern = document.querySelector('.upload-area-modern');
            if (uploadAreaModern) {
                // Drag and drop handlers
                uploadAreaModern.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadAreaModern.classList.add('drag-over');
                });

                uploadAreaModern.addEventListener('dragleave', () => {
                    uploadAreaModern.classList.remove('drag-over');
                });

                uploadAreaModern.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadAreaModern.classList.remove('drag-over');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        if (window.handleTemplateCropUpload) window.handleTemplateCropUpload(files);
                        if (window.updateProgressSteps) window.updateProgressSteps(3); // Move to processing
                    }
                });

                // Click to upload
                uploadAreaModern.addEventListener('click', () => {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.multiple = true;
                    fileInput.accept = 'image/*';
                    fileInput.onchange = (e) => {
                        if (e.target.files.length > 0) {
                            if (window.handleTemplateCropUpload) window.handleTemplateCropUpload(e.target.files);
                            if (window.updateProgressSteps) window.updateProgressSteps(3);
                        }
                    };
                    fileInput.click();
                });
            }

            console.log('‚úÖ ƒê√£ thi·∫øt l·∫≠p Template Crop event listeners th√†nh c√¥ng');

            // Control buttons
            const templateCenter = document.getElementById('templateCenter');
            if (templateCenter) {
                templateCenter.addEventListener('click', () => {
                    console.log('üìç Center crop selection');
                    this.centerTemplateCropSelection();
                });
            }

            const templateReset = document.getElementById('templateReset');
            if (templateReset) {
                templateReset.addEventListener('click', () => {
                    console.log('üîÑ Reset crop selection');
                    this.resetTemplateCropSelection();
                });
            }

            // Toggle buttons
            const templateGrid = document.getElementById('templateGrid');
            if (templateGrid) {
                templateGrid.addEventListener('click', () => {
                    templateGrid.classList.toggle('active');
                    this.toggleTemplateGrid(templateGrid.classList.contains('active'));
                });
            }

            const templateGuides = document.getElementById('templateGuides');
            if (templateGuides) {
                templateGuides.addEventListener('click', () => {
                    templateGuides.classList.toggle('active');
                    this.toggleTemplateGuides(templateGuides.classList.contains('active'));
                });
            }

            const templateBorderPreview = document.getElementById('templateBorderPreview');
            if (templateBorderPreview) {
                templateBorderPreview.addEventListener('click', () => {
                    templateBorderPreview.classList.toggle('active');
                    this.toggleTemplateBorderPreview(templateBorderPreview.classList.contains('active'));
                });
            }

            // Workspace controls
            const templateFitToScreen = document.getElementById('templateFitToScreen');
            if (templateFitToScreen) {
                templateFitToScreen.addEventListener('click', () => {
                    console.log('üîç Fit to screen');
                    this.fitTemplateToScreen();
                });
            }

            const templateActualSize = document.getElementById('templateActualSize');
            if (templateActualSize) {
                templateActualSize.addEventListener('click', () => {
                    console.log('üìè Actual size');
                    this.showTemplateActualSize();
                });
            }

            // Process mode radio buttons
            const processRadios = document.querySelectorAll('input[name="templateProcessMode"]');
            processRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    if (radio.checked) {
                        console.log('‚ö° Process mode changed to:', radio.value);
                        // Update mode card active state
                        document.querySelectorAll('.mode-card').forEach(card => card.classList.remove('active'));
                        radio.closest('.mode-card').classList.add('active');
                        this.updateTemplateProcessMode(radio.value);
                    }
                });
            });

            console.log('‚úÖ Enhanced controls setup complete');
        }
        
        updateTemplateCropModalSpecs() {
            const dimensions = this.calculatePolaroidDimensions();
            const config = this.templateData.config;
            
            // Update current size
            const currentSizeEl = document.getElementById('templateCurrentSize');
            if (currentSizeEl) {
                currentSizeEl.textContent = `${config.polaroidSizeCm.width}√ó${config.polaroidSizeCm.height} cm`;
            }
            
            // Update borders
            const currentBordersEl = document.getElementById('templateCurrentBorders');
            if (currentBordersEl) {
                const b = config.border;
                currentBordersEl.textContent = `${b.topPx}-${b.leftPx}-${b.rightPx}-${b.bottomCaptionPx}px`;
            }
            
            // Calculate ideal aspect ratio
            const idealRatioEl = document.getElementById('templateIdealRatio');
            if (idealRatioEl && dimensions.isValid) {
                const imageAreaW = dimensions.canvasW - config.border.leftPx - config.border.rightPx;
                const imageAreaH = dimensions.canvasH - config.border.topPx - config.border.bottomCaptionPx;
                const aspectRatio = imageAreaW / imageAreaH;
                const ratioText = aspectRatio > 1 ? `${aspectRatio.toFixed(2)}:1 (Landscape)` : `1:${(1/aspectRatio).toFixed(2)} (Portrait)`;
                idealRatioEl.textContent = ratioText;
            }
        }

        updateTemplateConfigUI() {
            const config = this.templateData.config;

            // Update basic settings
            const templateDPI = document.getElementById('templateDPI');
            const templateWidth = document.getElementById('templateWidth');
            const templateHeight = document.getElementById('templateHeight');

            if (templateDPI) templateDPI.value = config.dpi;
            if (templateWidth) templateWidth.value = config.polaroidSizeCm.width;
            if (templateHeight) templateHeight.value = config.polaroidSizeCm.height;

            // Update border controls
            const borderControls = [
                { slider: 'borderTop', number: 'borderTopValue', value: config.border.topPx },
                { slider: 'borderLeft', number: 'borderLeftValue', value: config.border.leftPx },
                { slider: 'borderRight', number: 'borderRightValue', value: config.border.rightPx },
                { slider: 'borderBottom', number: 'borderBottomValue', value: config.border.bottomCaptionPx }
            ];

            borderControls.forEach(control => {
                const slider = document.getElementById(control.slider);
                const numberInput = document.getElementById(control.number);
                if (slider) slider.value = control.value;
                if (numberInput) numberInput.value = control.value;
            });

            // Update advanced settings
            const templateFitMode = document.getElementById('templateFitMode');
            const templateSafeArea = document.getElementById('templateSafeArea');
            const templateBgColor = document.getElementById('templateBgColor');
            const templateOverlay = document.getElementById('templateOverlay');

            if (templateFitMode) templateFitMode.value = config.fitMode;
            if (templateSafeArea) templateSafeArea.value = config.safeAreaPx;
            if (templateBgColor) templateBgColor.value = config.bgColor;
            if (templateOverlay) templateOverlay.checked = config.overlayFrame;

            // Update caption settings
            const captionText = document.getElementById('captionText');
            const captionFont = document.getElementById('captionFont');
            const captionFontSize = document.getElementById('captionFontSize');
            const captionColor = document.getElementById('captionColor');
            const captionAlign = document.getElementById('captionAlign');
            const captionMarginTop = document.getElementById('captionMarginTop');

            if (captionText) captionText.value = config.caption.text;
            if (captionFont) captionFont.value = config.caption.fontFamily;
            if (captionFontSize) captionFontSize.value = config.caption.fontSizePx;
            if (captionColor) captionColor.value = config.caption.color;
            if (captionAlign) captionAlign.value = config.caption.align;
            if (captionMarginTop) captionMarginTop.value = config.caption.marginTopPx;
        }

        // Enhanced Template Crop Control Functions
        updateTemplateCropMode(mode) {
            console.log('üéØ Updating crop mode to:', mode);
            // Store the crop mode for later use during cropping
            if (!this.templateCropData) this.templateCropData = {};
            this.templateCropData.cropMode = mode;
        }

        updateTemplateDPI(dpi) {
            console.log('üìä Updating DPI to:', dpi);
            if (!this.templateCropData) this.templateCropData = {};
            this.templateCropData.dpi = parseInt(dpi);
            this.updateEnhancedTemplateSpecs();
        }

        updateTemplateBgMode(bgMode) {
            console.log('üé® Updating background mode to:', bgMode);
            if (!this.templateCropData) this.templateCropData = {};
            this.templateCropData.backgroundMode = bgMode;
        }

        updateTemplateProcessMode(processMode) {
            console.log('‚ö° Updating process mode to:', processMode);
            if (!this.templateCropData) this.templateCropData = {};
            this.templateCropData.processMode = processMode;
        }

        centerTemplateCropSelection() {
            const canvas = document.getElementById('templateCropCanvas');
            const selection = document.getElementById('templateCropSelection');
            if (!canvas || !selection) return;

            const canvasRect = canvas.getBoundingClientRect();
            const container = document.getElementById('templateCropContainer');
            const containerRect = container.getBoundingClientRect();

            // Calculate center position
            const centerX = (canvasRect.width - selection.offsetWidth) / 2;
            const centerY = (canvasRect.height - selection.offsetHeight) / 2;

            selection.style.left = centerX + 'px';
            selection.style.top = centerY + 'px';

            console.log('üìç Crop selection centered');
        }

        resetTemplateCropSelection() {
            const canvas = document.getElementById('templateCropCanvas');
            const selection = document.getElementById('templateCropSelection');
            if (!canvas || !selection) return;

            // Reset to initial size and position based on template aspect ratio
            const config = this.templateData?.config;
            if (!config) return;

            const dimensions = this.calculatePolaroidDimensions();
            if (!dimensions.isValid) return;

            // Calculate ideal crop area
            const imageAreaW = dimensions.canvasW - config.border.leftPx - config.border.rightPx;
            const imageAreaH = dimensions.canvasH - config.border.topPx - config.border.bottomCaptionPx;
            const aspectRatio = imageAreaW / imageAreaH;

            const canvasRect = canvas.getBoundingClientRect();
            let selectionW, selectionH;

            if (canvasRect.width / canvasRect.height > aspectRatio) {
                selectionH = Math.min(canvasRect.height * 0.8, 400);
                selectionW = selectionH * aspectRatio;
            } else {
                selectionW = Math.min(canvasRect.width * 0.8, 600);
                selectionH = selectionW / aspectRatio;
            }

            selection.style.width = selectionW + 'px';
            selection.style.height = selectionH + 'px';
            
            // Center the selection
            const centerX = (canvasRect.width - selectionW) / 2;
            const centerY = (canvasRect.height - selectionH) / 2;
            selection.style.left = centerX + 'px';
            selection.style.top = centerY + 'px';

            console.log('üîÑ Crop selection reset to optimal size');
            this.updateTemplateSelectionInfo();
        }

        toggleTemplateGrid(enabled) {
            console.log('üìè Grid overlay:', enabled ? 'enabled' : 'disabled');
            const canvas = document.getElementById('templateCropCanvas');
            if (!canvas) return;

            if (enabled) {
                canvas.classList.add('show-grid');
            } else {
                canvas.classList.remove('show-grid');
            }
        }

        toggleTemplateGuides(enabled) {
            console.log('üìê Guides overlay:', enabled ? 'enabled' : 'disabled');
            const container = document.getElementById('templateCropContainer');
            if (!container) return;

            if (enabled) {
                container.classList.add('show-guides');
            } else {
                container.classList.remove('show-guides');
            }
        }

        toggleTemplateBorderPreview(enabled) {
            console.log('üñºÔ∏è Border preview:', enabled ? 'enabled' : 'disabled');
            const selection = document.getElementById('templateCropSelection');
            if (!selection) return;

            if (enabled) {
                selection.classList.add('show-border-preview');
                this.drawTemplateBorderPreview();
            } else {
                selection.classList.remove('show-border-preview');
            }
        }

        fitTemplateToScreen() {
            const canvas = document.getElementById('templateCropCanvas');
            const container = document.getElementById('templateCropContainer');
            if (!canvas || !container) return;

            const containerRect = container.getBoundingClientRect();
            const maxWidth = containerRect.width - 40; // padding
            const maxHeight = containerRect.height - 40;

            const img = canvas.imageData;
            if (!img) return;

            const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
            const newWidth = img.width * scale;
            const newHeight = img.height * scale;

            canvas.style.width = newWidth + 'px';
            canvas.style.height = newHeight + 'px';

            console.log('üîç Canvas fitted to screen');
        }

        showTemplateActualSize() {
            const canvas = document.getElementById('templateCropCanvas');
            if (!canvas) return;

            const img = canvas.imageData;
            if (!img) return;

            canvas.style.width = img.width + 'px';
            canvas.style.height = img.height + 'px';

            console.log('üìè Canvas set to actual size');
        }

        updateEnhancedTemplateSpecs() {
            const config = this.templateData?.config;
            if (!config) return;

            const dimensions = this.calculatePolaroidDimensions();
            
            // Update size details in sidebar
            const sizeDetail = document.getElementById('templateCurrentSizeDetail');
            if (sizeDetail) {
                sizeDetail.textContent = `${config.polaroidSizeCm.width}√ó${config.polaroidSizeCm.height} cm`;
            }

            const pixelDetail = document.getElementById('templateCurrentPixels');
            if (pixelDetail && dimensions.isValid) {
                const dpi = this.templateCropData?.dpi || 300;
                const pixelW = Math.round((config.polaroidSizeCm.width / 2.54) * dpi);
                const pixelH = Math.round((config.polaroidSizeCm.height / 2.54) * dpi);
                pixelDetail.textContent = `${pixelW}√ó${pixelH}px`;
            }

            // Update aspect ratio
            const aspectRatioEl = document.getElementById('templateAspectRatio');
            if (aspectRatioEl && dimensions.isValid) {
                const imageAreaW = dimensions.canvasW - config.border.leftPx - config.border.rightPx;
                const imageAreaH = dimensions.canvasH - config.border.topPx - config.border.bottomCaptionPx;
                const ratio = imageAreaW / imageAreaH;
                aspectRatioEl.textContent = ratio > 1 ? `${ratio.toFixed(2)}:1` : `1:${(1/ratio).toFixed(2)}`;
            }

            // Update border info
            const borderTLR = document.getElementById('templateBorderTLR');
            const borderBottom = document.getElementById('templateBorderBottom');
            if (borderTLR) {
                borderTLR.textContent = `${config.border.topPx}-${config.border.leftPx}-${config.border.rightPx}px`;
            }
            if (borderBottom) {
                borderBottom.textContent = `${config.border.bottomCaptionPx}px`;
            }
        }

        updateTemplateSelectionInfo() {
            const selection = document.getElementById('templateCropSelection');
            const selectionSize = document.getElementById('templateSelectionSize');
            const selectionStatus = document.getElementById('templateSelectionStatus');
            
            if (!selection || !selectionSize) return;

            const width = Math.round(selection.offsetWidth);
            const height = Math.round(selection.offsetHeight);
            selectionSize.textContent = `${width}√ó${height}px`;

            if (selectionStatus) {
                const config = this.templateData?.config;
                if (config) {
                    const dimensions = this.calculatePolaroidDimensions();
                    if (dimensions.isValid) {
                        const imageAreaW = dimensions.canvasW - config.border.leftPx - config.border.rightPx;
                        const imageAreaH = dimensions.canvasH - config.border.topPx - config.border.bottomCaptionPx;
                        const idealRatio = imageAreaW / imageAreaH;
                        const currentRatio = width / height;
                        
                        const isCorrectRatio = Math.abs(idealRatio - currentRatio) < 0.01;
                        selectionStatus.textContent = isCorrectRatio ? '‚úÖ T·ª∑ l·ªá chu·∫©n' : '‚ö†Ô∏è T·ª∑ l·ªá sai';
                        selectionStatus.style.background = isCorrectRatio ? '#d4edda' : '#f8d7da';
                        selectionStatus.style.color = isCorrectRatio ? '#155724' : '#721c24';
                    }
                }
            }
        }

        drawTemplateBorderPreview() {
            const miniPreview = document.getElementById('templateMiniPreview');
            if (!miniPreview) return;

            const config = this.templateData?.config;
            if (!config) return;

            const ctx = miniPreview.getContext('2d');
            const dimensions = this.calculatePolaroidDimensions();
            if (!dimensions.isValid) return;

            // Set mini preview size
            const scale = 0.3;
            miniPreview.width = dimensions.canvasW * scale;
            miniPreview.height = dimensions.canvasH * scale;

            // Draw Polaroid frame
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, miniPreview.width, miniPreview.height);

            // Draw image area
            const imageX = config.border.leftPx * scale;
            const imageY = config.border.topPx * scale;
            const imageW = (dimensions.canvasW - config.border.leftPx - config.border.rightPx) * scale;
            const imageH = (dimensions.canvasH - config.border.topPx - config.border.bottomCaptionPx) * scale;

            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(imageX, imageY, imageW, imageH);

            // Draw caption area
            const captionY = dimensions.canvasH - config.border.bottomCaptionPx;
            ctx.fillStyle = '#e8e8e8';
            ctx.fillRect(imageX, captionY * scale, imageW, config.border.bottomCaptionPx * scale);

            console.log('üñºÔ∏è Border preview drawn');
        }

        async handleTemplateFileSelect(files) {
            if (!files || files.length === 0) return;

            console.log(`üìÅ Processing ${files.length} files for template...`);
            this.showToast(`ƒêang x·ª≠ l√Ω ${files.length} ·∫£nh...`, 'info');

            let addedCount = 0;
            let duplicateCount = 0;

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    // Ki·ªÉm tra duplicate d·ª±a tr√™n t√™n file, k√≠ch th∆∞·ªõc v√† lastModified
                    const isDuplicate = this.templateData.images.some(existingImage =>
                        existingImage.filename === file.name &&
                        existingImage.file?.size === file.size &&
                        existingImage.file?.lastModified === file.lastModified
                    );

                    if (isDuplicate) {
                        console.log(`‚ö†Ô∏è B·ªè qua ·∫£nh tr√πng l·∫∑p: ${file.name}`);
                        duplicateCount++;
                        continue;
                    }

                    const imageData = await this.processTemplateImage(file);
                    if (imageData) {
                        this.templateData.images.push(imageData);
                        addedCount++;
                    }
                } catch (error) {
                    console.error('Error processing template image:', error);
                }
            }

            this.updateTemplateUI();

            // Hi·ªÉn th·ªã th√¥ng b√°o chi ti·∫øt
            if (duplicateCount > 0) {
                this.showToast(`‚úÖ ƒê√£ th√™m ${addedCount} ·∫£nh m·ªõi, b·ªè qua ${duplicateCount} ·∫£nh tr√πng l·∫∑p`, 'success');
            } else {
                this.showToast(`‚úÖ ƒê√£ t·∫£i ${addedCount} ·∫£nh th√†nh c√¥ng`, 'success');
            }
        }

        async processTemplateImage(file) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const imageData = {
                        file: file,
                        originalImage: img,
                        filename: file.name,
                        croppedDataURL: null,
                        cropSettings: {}
                    };
                    
                    // Process with current config
                    this.reprocessSingleTemplateImage(imageData);
                    resolve(imageData);
                };
                
                img.onerror = () => resolve(null);
                img.src = URL.createObjectURL(file);
            });
        }

        reprocessSingleTemplateImage(imageData) {
            if (!imageData || !imageData.originalImage) return;

            const dimensions = this.calculatePolaroidDimensions();
            if (!dimensions.isValid) return;

            const config = this.templateData.config;
            const img = imageData.originalImage;

            // Create canvas for image area only
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = dimensions.safeImageW;
            canvas.height = dimensions.safeImageH;

            // Calculate fit parameters
            const imgAspect = img.width / img.height;
            const targetAspect = dimensions.safeImageW / dimensions.safeImageH;

            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

            if (config.fitMode === 'contain') {
                // Contain mode - fit entire image with padding
                if (imgAspect > targetAspect) {
                    drawWidth = dimensions.safeImageW;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (dimensions.safeImageH - drawHeight) / 2;
                } else {
                    drawHeight = dimensions.safeImageH;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (dimensions.safeImageW - drawWidth) / 2;
                }
                
                // Fill background with template background color
                ctx.fillStyle = config.bgColor;
                ctx.fillRect(0, 0, dimensions.safeImageW, dimensions.safeImageH);
                
                ctx.drawImage(img, 0, 0, img.width, img.height, Math.round(offsetX), Math.round(offsetY), Math.round(drawWidth), Math.round(drawHeight));
            } else {
                // Cover mode - crop to fill
                if (imgAspect > targetAspect) {
                    drawHeight = img.height;
                    drawWidth = drawHeight * targetAspect;
                    offsetX = (img.width - drawWidth) / 2;
                } else {
                    drawWidth = img.width;
                    drawHeight = drawWidth / targetAspect;
                    offsetY = (img.height - drawHeight) / 2;
                }
                
                ctx.drawImage(img, Math.round(offsetX), Math.round(offsetY), Math.round(drawWidth), Math.round(drawHeight), 0, 0, dimensions.safeImageW, dimensions.safeImageH);
            }

            // Update image data
            imageData.croppedDataURL = canvas.toDataURL('image/jpeg', 1.0);
            imageData.cropSettings = { 
                offsetX: Math.round(offsetX), 
                offsetY: Math.round(offsetY), 
                drawWidth: Math.round(drawWidth), 
                drawHeight: Math.round(drawHeight), 
                mode: config.fitMode 
            };
        }

        async reprocessAllTemplateImages() {
            if (!this.templateData || !this.templateData.images) return;
            
            const dimensions = this.calculatePolaroidDimensions();
            if (!dimensions.isValid) {
                console.warn('Invalid template dimensions, skipping reprocess');
                return;
            }

            console.log('üîÑ Reprocessing all template images with new config...');
            
            // Reprocess all images
            this.templateData.images.forEach(imageData => {
                this.reprocessSingleTemplateImage(imageData);
            });

            // Update all UI elements with real-time sync
            await this.updateTemplatePreview();
            await this.updateTemplateGallery();
        }

        updateTemplateUI() {
            // Check if templateData is initialized
            if (!this.templateData || !this.templateData.images) return;

            // Update image count
            const templateImageCount = document.getElementById('templateImageCount');
            if (templateImageCount) {
                templateImageCount.textContent = this.templateData.images.length;
            }

            // Update navigation info
            const templateNavInfo = document.getElementById('templateNavInfo');
            if (templateNavInfo) {
                const total = this.templateData.images.length;
                const current = total > 0 ? this.templateData.currentIndex + 1 : 0;
                templateNavInfo.textContent = `${current} / ${total}`;
            }

            // Update navigation buttons
            const templatePrevBtn = document.getElementById('templatePrevBtn');
            const templateNextBtn = document.getElementById('templateNextBtn');

            if (templatePrevBtn) {
                templatePrevBtn.disabled = this.templateData.currentIndex <= 0;
            }
            if (templateNextBtn) {
                templateNextBtn.disabled = this.templateData.currentIndex >= this.templateData.images.length - 1;
            }

            // Update preview and gallery with async
            this.updateTemplatePreview();
            this.updateTemplateGallery();

            // Update frame preview visibility
            this.showTemplateFramePreview();

            // Show/hide crop controls
            const templateCropControls = document.getElementById('templateCropControls');
            if (templateCropControls) {
                templateCropControls.style.display = this.templateData.images.length > 0 ? 'block' : 'none';
            }
        }

        async updateTemplatePreview() {
            const polaroidImageArea = document.getElementById('polaroidImageArea');
            if (!polaroidImageArea) return;

            const framePreview = document.getElementById('templateFramePreview');
            const placeholder = document.getElementById('placeholderText');

            // Check if templateData is initialized
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                // Hide frame preview and show placeholder
                if (framePreview) framePreview.style.display = 'none';
                if (placeholder) {
                    placeholder.style.display = 'block';
                    placeholder.textContent = 'Ch·ªù ·∫£nh...';
                }
                // Remove any existing image preview
                const existingPreview = polaroidImageArea.querySelector('.image-preview-result');
                if (existingPreview) existingPreview.remove();
                return;
            }

            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage || !currentImage.croppedDataURL) return;

            // Hide frame preview and placeholder when showing image
            if (framePreview) framePreview.style.display = 'none';
            if (placeholder) placeholder.style.display = 'none';

            // Create full Polaroid preview that matches exactly with download
            try {
                const previewCanvas = await this.createPolaroidCanvas(currentImage);

                // Convert to data URL for display
                const previewDataURL = previewCanvas.toDataURL('image/jpeg', 1.0);

                // Update or create image preview
                let imagePreview = polaroidImageArea.querySelector('.image-preview-result');
                if (!imagePreview) {
                    imagePreview = document.createElement('img');
                    imagePreview.className = 'image-preview-result';
                    polaroidImageArea.appendChild(imagePreview);
                }

                imagePreview.src = previewDataURL;
                // CSS class handles responsive sizing
            } catch (error) {
                console.error('Error creating preview:', error);
                // Fallback to basic preview
                let imagePreview = polaroidImageArea.querySelector('.image-preview-result');
                if (!imagePreview) {
                    imagePreview = document.createElement('img');
                    imagePreview.className = 'image-preview-result';
                    polaroidImageArea.appendChild(imagePreview);
                }
                imagePreview.src = currentImage.croppedDataURL;
            }
        }

        async updateTemplateGallery() {
            const templateGrid = document.getElementById('templateGrid');
            const quickToPrintBtn = document.getElementById('quickToPrintBtn');

            if (!templateGrid) return;

            // Check if templateData is initialized
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                templateGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #6b7280; padding: 40px;">Ch∆∞a c√≥ ·∫£nh n√†o</div>';
                if (quickToPrintBtn) quickToPrintBtn.style.display = 'none';
                return;
            }

            // Show quick to print button if there are images
            if (quickToPrintBtn) {
                quickToPrintBtn.style.display = 'block';
            }

            // Create gallery with full Polaroid previews
            const galleryItems = await Promise.all(this.templateData.images.map(async (imageData, index) => {
                try {
                    // Create mini Polaroid preview
                    const polaroidCanvas = await this.createPolaroidCanvas(imageData);
                    const previewDataURL = polaroidCanvas.toDataURL('image/jpeg', 1.0);

                    return `
                        <div class="template-item ${index === this.templateData.currentIndex ? 'active' : ''}" onclick="imageConverter.selectTemplateImage(${index})">
                            <div class="template-item-preview">
                                <img src="${previewDataURL}" style="width: 100%; height: 100%; object-fit: contain; border-radius: 4px;">
                            </div>
                            <div class="template-item-name">${imageData.filename}</div>
                        </div>
                    `;
                } catch (error) {
                    console.error('Error creating gallery preview:', error);
                    // Fallback to basic preview
                    return `
                        <div class="template-item ${index === this.templateData.currentIndex ? 'active' : ''}" onclick="imageConverter.selectTemplateImage(${index})">
                            <div class="template-item-preview">
                                <img src="${imageData.croppedDataURL}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 4px;">
                            </div>
                            <div class="template-item-name">${imageData.filename}</div>
                        </div>
                    `;
                }
            }));

            templateGrid.innerHTML = galleryItems.join('');
        }

        selectTemplateImage(index) {
            if (!this.templateData || !this.templateData.images) return;
            
            if (index >= 0 && index < this.templateData.images.length) {
                this.templateData.currentIndex = index;
                this.updateTemplateUI();
            }
        }

        navigateTemplate(direction) {
            if (!this.templateData || !this.templateData.images) return;
            
            const newIndex = this.templateData.currentIndex + direction;
            if (newIndex >= 0 && newIndex < this.templateData.images.length) {
                this.templateData.currentIndex = newIndex;
                this.updateTemplateUI();
            }
        }

        resetTemplateCrop() {
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) return;
            
            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage) return;
            
            // Reset to original auto-crop settings
            this.reprocessCurrentTemplateImage();
            this.showToast('üîÑ ƒê√£ reset crop v·ªÅ center crop t·ª± ƒë·ªông', 'info');
        }

        centerTemplateCrop() {
            this.resetTemplateCrop(); // Same as reset for now
        }

        fitTemplateCrop() {
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) return;
            
            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage) return;
            
            // Fit entire image (may add borders)
            this.reprocessCurrentTemplateImage('fit');
            this.showToast('üì¶ ƒê√£ √°p d·ª•ng fit mode (gi·ªØ nguy√™n to√†n ·∫£nh)', 'info');
        }

        async reprocessCurrentTemplateImage(mode = 'fill') {
            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 669;
            canvas.height = 865;

            const img = currentImage.originalImage;
            const imgAspect = img.width / img.height;
            const targetAspect = 669 / 865;

            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

            if (mode === 'fit') {
                // Fit mode - show entire image with padding
                if (imgAspect > targetAspect) {
                    drawWidth = 669;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (865 - drawHeight) / 2;
                } else {
                    drawHeight = 865;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (669 - drawWidth) / 2;
                }
                
                // Fill background with white
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 669, 865);
                
                ctx.drawImage(img, 0, 0, img.width, img.height, offsetX, offsetY, drawWidth, drawHeight);
            } else {
                // Fill mode - crop to fill
                if (imgAspect > targetAspect) {
                    drawHeight = img.height;
                    drawWidth = drawHeight * targetAspect;
                    offsetX = (img.width - drawWidth) / 2;
                } else {
                    drawWidth = img.width;
                    drawHeight = drawWidth / targetAspect;
                    offsetY = (img.height - drawHeight) / 2;
                }
                
                ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight, 0, 0, 669, 865);
            }

            // Update image data
            currentImage.croppedDataURL = canvas.toDataURL('image/jpeg', 1.0);
            currentImage.cropSettings = { offsetX, offsetY, drawWidth, drawHeight, mode };

            this.updateTemplatePreview();
            this.updateTemplateGallery();
        }

        async exportCurrentPolaroid() {
            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage) {
                this.showToast('Kh√¥ng c√≥ ·∫£nh ƒë·ªÉ xu·∫•t', 'warning');
                return;
            }

            try {
                const polaroidCanvas = await this.createPolaroidCanvas(currentImage);
                
                // Convert to blob with DPI metadata and download
                polaroidCanvas.toBlob(async (blob) => {
                    try {
                        // LU√îN s·ª≠ d·ª•ng DPI = 300 cho ch·∫•t l∆∞·ª£ng cao
                        const blobWithDPI = await this.addDPIMetadata(blob, 300);
                        const filename = `Polaroid_${String(this.templateData.currentIndex + 1).padStart(3, '0')}.jpg`;
                        this.downloadBlob(blobWithDPI, filename);
                        this.showToast(`‚úÖ ƒê√£ xu·∫•t ${filename} (${this.templateData.config.polaroidSizeCm.width}√ó${this.templateData.config.polaroidSizeCm.height}cm @ 300 DPI)`, 'success');
                    } catch (error) {
                        // Fallback to original blob if DPI metadata fails
                        const filename = `Polaroid_${String(this.templateData.currentIndex + 1).padStart(3, '0')}.jpg`;
                        this.downloadBlob(blob, filename);
                        this.showToast(`‚úÖ ƒê√£ xu·∫•t ${filename}`, 'success');
                    }
                }, 'image/jpeg', 0.95);
            } catch (error) {
                console.error('Export error:', error);
                this.showToast('L·ªói khi xu·∫•t file', 'error');
            }
        }

        async quickTransferToPrint() {
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                this.showToast('‚ö†Ô∏è Ch∆∞a c√≥ ·∫£nh Polaroid n√†o ƒë·ªÉ chuy·ªÉn', 'warning');
                return;
            }

            try {
                this.showToast('üîÑ ƒêang chuy·ªÉn ·∫£nh sang Print Section...', 'info');

                // Ensure printData is initialized
                if (!this.printData) {
                    this.showToast('‚ùå Print Section ch∆∞a s·∫µn s√†ng', 'error');
                    return;
                }

                // Get Polaroid dimensions from template config
                const config = this.templateData.config;
                const polaroidWidth = config.polaroidSizeCm.width;
                const polaroidHeight = config.polaroidSizeCm.height;

                // Set photo size FIRST before converting images
                this.printData.config.photoSize = {
                    width: polaroidWidth,
                    height: polaroidHeight
                };

                // Update dropdown to match
                const photoSizeSelect = document.getElementById('photoSizeSelect');
                if (photoSizeSelect) {
                    photoSizeSelect.value = 'custom';
                }

                // Convert all template images to complete Polaroid format
                const printImages = [];
                for (let i = 0; i < this.templateData.images.length; i++) {
                    const imageData = this.templateData.images[i];

                    // Create full Polaroid canvas (already includes frame + photo)
                    const polaroidCanvas = await this.createPolaroidCanvas(imageData);

                    // Convert to blob with high quality
                    const blob = await new Promise(resolve => {
                        polaroidCanvas.toBlob(resolve, 'image/jpeg', 0.95);
                    });

                    // Add DPI metadata (300 DPI)
                    const blobWithDPI = await this.addDPIMetadata(blob, 300);

                    // Create file object with descriptive name
                    const filename = `Polaroid_${polaroidWidth}x${polaroidHeight}cm_${String(i + 1).padStart(3, '0')}.jpg`;
                    const file = new File([blobWithDPI], filename, { type: 'image/jpeg' });

                    printImages.push(file);
                }

                // Clear previous print data
                this.printData.selectedImages = [];
                this.printData.frontImages = {};
                this.printData.backImages = {};
                this.printData.currentPage = 0;

                // Add all Polaroid images to print list
                const loadPromises = printImages.map(file => {
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                this.printData.selectedImages.push({
                                    file: file,
                                    src: e.target.result,
                                    img: img,
                                    name: file.name
                                });
                                resolve();
                            };
                            img.src = e.target.result;
                        };
                        reader.readAsDataURL(file);
                    });
                });

                // Wait for all images to load
                await Promise.all(loadPromises);

                console.log(`‚úÖ Loaded ${printImages.length} Polaroid images into print data`);

                // Update displays
                this.updateSelectedImagesDisplay();
                this.updateImageDistributionDisplay();
                this.updateTotalPages();

                // Recalculate layout with new images
                const layout = this.calculateLayout();
                console.log('üìê Recalculated layout:', layout);

                // Switch to Print tab
                this.switchToTab('print');

                // Wait for tab switch and DOM update
                await new Promise(resolve => setTimeout(resolve, 500));

                // Update print preview multiple times to ensure it renders
                this.updatePreview();

                // Force another update after a short delay
                setTimeout(() => {
                    this.updatePreview();
                    console.log('üîÑ Force preview update completed');
                }, 200);

                this.showToast(`‚úÖ ƒê√£ chuy·ªÉn ${printImages.length} ·∫£nh Polaroid (${polaroidWidth}√ó${polaroidHeight}cm) sang Print Section`, 'success');
            } catch (error) {
                console.error('Quick transfer error:', error);
                this.showToast('‚ùå L·ªói khi chuy·ªÉn ·∫£nh sang Print: ' + error.message, 'error');
            }
        }

        async exportAllPolaroids() {
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                this.showToast('Kh√¥ng c√≥ ·∫£nh ƒë·ªÉ xu·∫•t', 'warning');
                return;
            }

            try {
                // Import JSZip
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                document.head.appendChild(script);

                await new Promise(resolve => script.onload = resolve);

                const zip = new JSZip();
                this.showToast(`üîÑ ƒêang t·∫°o ${this.templateData.images.length} Polaroid...`, 'info');

                for (let i = 0; i < this.templateData.images.length; i++) {
                    const imageData = this.templateData.images[i];
                    const polaroidCanvas = await this.createPolaroidCanvas(imageData);

                    const blob = await new Promise(resolve => {
                        polaroidCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                    });

                    // LU√îN s·ª≠ d·ª•ng DPI = 300 cho ch·∫•t l∆∞·ª£ng cao
                    const blobWithDPI = await this.addDPIMetadata(blob, 300);

                    const filename = `Polaroid_${String(i + 1).padStart(3, '0')}.jpg`;
                    zip.file(filename, blobWithDPI);
                }

                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                const zipFilename = `Polaroids_${timestamp}.zip`;

                this.downloadBlob(zipBlob, zipFilename);
                this.showToast(`‚úÖ ƒê√£ xu·∫•t ${this.templateData.images.length} Polaroid (ZIP)`, 'success');
            } catch (error) {
                console.error('Export all error:', error);
                this.showToast('L·ªói khi xu·∫•t t·∫•t c·∫£ file', 'error');
            }
        }

        async exportAllIndividualFiles() {
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                this.showToast('Kh√¥ng c√≥ ·∫£nh ƒë·ªÉ xu·∫•t', 'warning');
                return;
            }

            // Prevent multiple exports - disable button
            const exportBtn = document.getElementById('exportAllIndividual');
            if (exportBtn) {
                if (exportBtn.disabled) {
                    this.showToast('‚è≥ ƒêang xu·∫•t file... Vui l√≤ng ch·ªù!', 'warning');
                    return;
                }
                exportBtn.disabled = true;
                exportBtn.textContent = `üìÅ ƒêang xu·∫•t ${this.templateData.images.length} files...`;
            }

            try {
                const totalImages = this.templateData.images.length;
                let exportedCount = 0;

                this.showToast(`üîÑ B·∫Øt ƒë·∫ßu xu·∫•t ${totalImages} Polaroid t·ª´ng file ri√™ng...`, 'info');

                // Export each image individually with delay
                for (let i = 0; i < totalImages; i++) {
                    const imageData = this.templateData.images[i];
                    
                    try {
                        const polaroidCanvas = await this.createPolaroidCanvas(imageData);
                        
                        // Convert to blob with DPI metadata and download
                        await new Promise((resolve) => {
                            polaroidCanvas.toBlob(async (blob) => {
                                try {
                                    // LU√îN s·ª≠ d·ª•ng DPI = 300 cho ch·∫•t l∆∞·ª£ng t·ªëi ƒëa
                                    const blobWithDPI = await this.addDPIMetadata(blob, 300);
                                    const filename = `Polaroid_${String(i + 1).padStart(3, '0')}.jpg`;
                                    this.downloadBlob(blobWithDPI, filename);
                                } catch (error) {
                                    // Fallback to original blob if DPI metadata fails
                                    const filename = `Polaroid_${String(i + 1).padStart(3, '0')}.jpg`;
                                    this.downloadBlob(blob, filename);
                                }
                                
                                exportedCount++;
                                
                                // Update button text with progress
                                if (exportBtn) {
                                    exportBtn.textContent = `üìÅ ƒêang xu·∫•t ${exportedCount}/${totalImages}...`;
                                }
                                
                                resolve();
                            }, 'image/jpeg', 0.95);
                        });
                        
                        // Small delay between downloads to prevent browser blocking
                        await new Promise(resolve => setTimeout(resolve, 200));
                        
                    } catch (error) {
                        console.error(`Export error for image ${i + 1}:`, error);
                        // Continue with next image even if one fails
                        exportedCount++;
                        if (exportBtn) {
                            exportBtn.textContent = `üìÅ ƒêang xu·∫•t ${exportedCount}/${totalImages}...`;
                        }
                    }
                }

                // Success message
                this.showToast(`‚úÖ ƒê√£ xu·∫•t th√†nh c√¥ng ${exportedCount}/${totalImages} Polaroid t·ª´ng file ri√™ng!`, 'success');

            } catch (error) {
                console.error('Export individual files error:', error);
                this.showToast('‚ùå L·ªói khi xu·∫•t t·ª´ng file ri√™ng!', 'error');
            } finally {
                // Re-enable button
                if (exportBtn) {
                    setTimeout(() => {
                        exportBtn.disabled = false;
                        exportBtn.textContent = 'üìÅ Xu·∫•t t·ª´ng file ri√™ng';
                    }, 2000); // Wait 2 seconds after completion
                }
            }
        }

        // Border Template Export Functions
        async exportCurrentBorderTemplate() {
            this.showToast('üöß Ch·ª©c nƒÉng Border Template ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...', 'info');
        }

        async exportAllBorderTemplates() {
            this.showToast('üöß Ch·ª©c nƒÉng Border Template ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...', 'info');
        }

        async exportAllBorderIndividual() {
            this.showToast('üöß Ch·ª©c nƒÉng Border Template ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...', 'info');
        }

        // Strip Template Export Functions
        async exportCurrentStripTemplate() {
            this.showToast('üöß Ch·ª©c nƒÉng Strip Template ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...', 'info');
        }

        async exportAllStripTemplates() {
            this.showToast('üöß Ch·ª©c nƒÉng Strip Template ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...', 'info');
        }

        async exportAllStripIndividual() {
            this.showToast('üöß Ch·ª©c nƒÉng Strip Template ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn...', 'info');
        }

        // File System Controls Setup
        setupBorderFileSystemControls() {
            // Save to File System button
            const saveBorderBtn = document.getElementById('saveBorderToFileSystem');
            if (saveBorderBtn) {
                saveBorderBtn.addEventListener('click', () => this.saveBorderToFileSystem());
            }

            // Export options dropdown
            const dropdownToggle = document.getElementById('borderExportOptionsToggle');
            const dropdownContent = document.getElementById('borderExportOptionsContent');
            if (dropdownToggle && dropdownContent) {
                dropdownToggle.addEventListener('click', () => {
                    dropdownToggle.classList.toggle('active');
                    dropdownContent.classList.toggle('show');
                });
            }

            // Download options
            const downloadCurrent = document.getElementById('borderDownloadCurrent');
            const downloadIndividual = document.getElementById('borderDownloadIndividual');
            const downloadZIP = document.getElementById('borderDownloadZIP');

            if (downloadCurrent) {
                downloadCurrent.addEventListener('click', () => this.downloadBorderCurrent());
            }
            if (downloadIndividual) {
                downloadIndividual.addEventListener('click', () => this.downloadBorderIndividual());
            }
            if (downloadZIP) {
                downloadZIP.addEventListener('click', () => this.downloadBorderZIP());
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#borderExportOptions')) {
                    document.getElementById('borderExportOptionsToggle')?.classList.remove('active');
                    document.getElementById('borderExportOptionsContent')?.classList.remove('show');
                }
            });
        }

        setupStripFileSystemControls() {
            // Save to File System button
            const saveStripBtn = document.getElementById('saveStripToFileSystem');
            if (saveStripBtn) {
                saveStripBtn.addEventListener('click', () => this.saveStripToFileSystem());
            }

            // Export options dropdown
            const dropdownToggle = document.getElementById('stripExportOptionsToggle');
            const dropdownContent = document.getElementById('stripExportOptionsContent');
            if (dropdownToggle && dropdownContent) {
                dropdownToggle.addEventListener('click', () => {
                    dropdownToggle.classList.toggle('active');
                    dropdownContent.classList.toggle('show');
                });
            }

            // Download options
            const downloadCurrent = document.getElementById('stripDownloadCurrent');
            const downloadIndividual = document.getElementById('stripDownloadIndividual');
            const downloadZIP = document.getElementById('stripDownloadZIP');

            if (downloadCurrent) {
                downloadCurrent.addEventListener('click', () => this.downloadStripCurrent());
            }
            if (downloadIndividual) {
                downloadIndividual.addEventListener('click', () => this.downloadStripIndividual());
            }
            if (downloadZIP) {
                downloadZIP.addEventListener('click', () => this.downloadStripZIP());
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#stripExportOptions')) {
                    document.getElementById('stripExportOptionsToggle')?.classList.remove('active');
                    document.getElementById('stripExportOptionsContent')?.classList.remove('show');
                }
            });
        }

        // File System Save Methods
        async saveBorderToFileSystem() {
            const createSubfolder = document.getElementById('borderCreateSubfolder')?.checked;
            const subfolderName = document.getElementById('borderSubfolderName')?.value || 'Border_Templates';

            if (!this.fileSystemStorage?.directoryHandle) {
                this.showToast('‚ùå Ch∆∞a c·∫•p quy·ªÅn File System!', 'error');
                return;
            }

            if (!this.borderTemplateData?.images || this.borderTemplateData.images.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh Border ƒë·ªÉ l∆∞u!', 'warning');
                return;
            }

            this.showToast('üíæ ƒêang l∆∞u Border Templates v√†o File System...', 'info');

            try {
                let savedCount = 0;
                const totalImages = this.borderTemplateData.images.length;
                const folderName = createSubfolder ? subfolderName : null;

                for (let i = 0; i < totalImages; i++) {
                    const imageData = this.borderTemplateData.images[i];

                    try {
                        // T·∫°o Border canvas v·ªõi 300 DPI v√† ch·∫•t l∆∞·ª£ng t·ªëi ƒëa
                        const canvas = await this.createBorderCanvas(imageData);

                        // Convert canvas to blob v·ªõi ch·∫•t l∆∞·ª£ng 100% (kh√¥ng n√©n)
                        const blob = await new Promise((resolve, reject) => {
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('Failed to create blob'));
                                }
                            }, 'image/jpeg', 1.0); // Quality 1.0 = 100%, kh√¥ng n√©n
                        });

                        // Th√™m metadata 300 DPI
                        const enhancedBlob = await this.addDPIMetadata(blob, 300);

                        // T·∫°o t√™n file v·ªõi index
                        const fileName = `Border_${String(i + 1).padStart(3, '0')}.jpg`;

                        // L∆∞u v√†o File System
                        await this.fileSystemStorage.saveImageToFileSystem(
                            enhancedBlob,
                            fileName,
                            folderName
                        );

                        savedCount++;

                        // Update progress
                        this.showToast(`üíæ ƒê√£ l∆∞u ${savedCount}/${totalImages} Border...`, 'info');

                    } catch (error) {
                        console.error(`‚ùå L·ªói l∆∞u Border ${i + 1}:`, error);
                        // Continue with other images
                    }
                }

                // Success message
                if (savedCount > 0) {
                    const folderText = folderName ? ` trong th∆∞ m·ª•c "${folderName}"` : '';
                    this.showToast(`‚úÖ ƒê√£ l∆∞u th√†nh c√¥ng ${savedCount}/${totalImages} Border${folderText}!`, 'success');
                } else {
                    this.showToast('‚ùå Kh√¥ng th·ªÉ l∆∞u Border n√†o!', 'error');
                }

            } catch (error) {
                console.error('‚ùå L·ªói l∆∞u Border Templates:', error);
                this.showToast('‚ùå C√≥ l·ªói x·∫£y ra khi l∆∞u Border Templates!', 'error');
            }
        }

        async saveStripToFileSystem() {
            const createSubfolder = document.getElementById('stripCreateSubfolder')?.checked;
            const subfolderName = document.getElementById('stripSubfolderName')?.value || 'Strip_Templates';

            if (!this.fileSystemStorage?.directoryHandle) {
                this.showToast('‚ùå Ch∆∞a c·∫•p quy·ªÅn File System!', 'error');
                return;
            }

            if (!this.stripTemplateData?.strips || this.stripTemplateData.strips.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ Strip Template ƒë·ªÉ l∆∞u!', 'warning');
                return;
            }

            this.showToast('üíæ ƒêang l∆∞u Strip Templates v√†o File System...', 'info');

            try {
                let savedCount = 0;
                const totalStrips = this.stripTemplateData.strips.length;
                const folderName = createSubfolder ? subfolderName : null;

                for (let i = 0; i < totalStrips; i++) {
                    const stripData = this.stripTemplateData.strips[i];

                    try {
                        // T·∫°o Strip canvas v·ªõi 300 DPI v√† ch·∫•t l∆∞·ª£ng t·ªëi ƒëa
                        const canvas = await this.createStripCanvas(stripData);

                        // Convert canvas to blob v·ªõi ch·∫•t l∆∞·ª£ng 100% (kh√¥ng n√©n)
                        const blob = await new Promise((resolve, reject) => {
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('Failed to create blob'));
                                }
                            }, 'image/jpeg', 1.0); // Quality 1.0 = 100%, kh√¥ng n√©n
                        });

                        // Th√™m metadata 300 DPI
                        const enhancedBlob = await this.addDPIMetadata(blob, 300);

                        // T·∫°o t√™n file v·ªõi index
                        const fileName = `Strip_${String(i + 1).padStart(3, '0')}.jpg`;

                        // L∆∞u v√†o File System
                        await this.fileSystemStorage.saveImageToFileSystem(
                            enhancedBlob,
                            fileName,
                            folderName
                        );

                        savedCount++;

                        // Update progress
                        this.showToast(`üíæ ƒê√£ l∆∞u ${savedCount}/${totalStrips} Strip...`, 'info');

                    } catch (error) {
                        console.error(`‚ùå L·ªói l∆∞u Strip ${i + 1}:`, error);
                        // Continue with other strips
                    }
                }

                // Success message
                if (savedCount > 0) {
                    const folderText = folderName ? ` trong th∆∞ m·ª•c "${folderName}"` : '';
                    this.showToast(`‚úÖ ƒê√£ l∆∞u th√†nh c√¥ng ${savedCount}/${totalStrips} Strip${folderText}!`, 'success');
                } else {
                    this.showToast('‚ùå Kh√¥ng th·ªÉ l∆∞u Strip n√†o!', 'error');
                }

            } catch (error) {
                console.error('‚ùå L·ªói l∆∞u Strip Templates:', error);
                this.showToast('‚ùå C√≥ l·ªói x·∫£y ra khi l∆∞u Strip Templates!', 'error');
            }
        }

        // Download Methods
        async downloadBorderCurrent() {
            this.showToast('‚§ì ƒêang t·∫£i Border hi·ªán t·∫°i...', 'info');
            this.showToast('üöß T√≠nh nƒÉng ƒëang ph√°t tri·ªÉn...', 'info');
        }

        async downloadBorderIndividual() {
            this.showToast('üìÅ ƒêang xu·∫•t t·ª´ng Border file ri√™ng...', 'info');
            this.showToast('üöß T√≠nh nƒÉng ƒëang ph√°t tri·ªÉn...', 'info');
        }

        async downloadBorderZIP() {
            this.showToast('‚ñ¶ ƒêang t·∫°o file ZIP cho Border Templates...', 'info');
            this.showToast('üöß T√≠nh nƒÉng ƒëang ph√°t tri·ªÉn...', 'info');
        }

        async downloadStripCurrent() {
            this.showToast('‚§ì ƒêang t·∫£i Strip hi·ªán t·∫°i...', 'info');
            this.showToast('üöß T√≠nh nƒÉng ƒëang ph√°t tri·ªÉn...', 'info');
        }

        async downloadStripIndividual() {
            this.showToast('üìÅ ƒêang xu·∫•t t·ª´ng Strip file ri√™ng...', 'info');
            this.showToast('üöß T√≠nh nƒÉng ƒëang ph√°t tri·ªÉn...', 'info');
        }

        async downloadStripZIP() {
            this.showToast('‚ñ¶ ƒêang t·∫°o file ZIP cho Strip Templates...', 'info');
            this.showToast('üöß T√≠nh nƒÉng ƒëang ph√°t tri·ªÉn...', 'info');
        }

        async savePolaroidToFileSystem() {
            const createSubfolder = document.getElementById('enableSubfolder')?.checked;
            const subfolderName = document.getElementById('folderPrefix')?.value || 'Polaroid_Templates';

            if (!this.fileSystemStorage?.directoryHandle) {
                this.showToast('‚ùå Ch∆∞a c·∫•p quy·ªÅn File System!', 'error');
                return;
            }

            if (!this.templateData?.images || this.templateData.images.length === 0) {
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh Polaroid ƒë·ªÉ l∆∞u!', 'warning');
                return;
            }

            this.showToast('üíæ ƒêang l∆∞u Polaroid Templates v√†o File System...', 'info');

            try {
                let savedCount = 0;
                const totalImages = this.templateData.images.length;
                const folderName = createSubfolder ? subfolderName : null;

                for (let i = 0; i < totalImages; i++) {
                    const imageData = this.templateData.images[i];

                    try {
                        // T·∫°o Polaroid canvas v·ªõi 300 DPI v√† ch·∫•t l∆∞·ª£ng t·ªëi ƒëa
                        const canvas = await this.createPolaroidCanvas(imageData);

                        // Convert canvas to blob v·ªõi ch·∫•t l∆∞·ª£ng 100% (kh√¥ng n√©n)
                        const blob = await new Promise((resolve, reject) => {
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('Failed to create blob'));
                                }
                            }, 'image/jpeg', 1.0); // Quality 1.0 = 100%, kh√¥ng n√©n
                        });

                        // Th√™m metadata 300 DPI
                        const enhancedBlob = await this.addDPIMetadata(blob, 300);

                        // T·∫°o t√™n file v·ªõi index
                        const fileName = `Polaroid_${String(i + 1).padStart(3, '0')}.jpg`;

                        // L∆∞u v√†o File System
                        await this.fileSystemStorage.saveImageToFileSystem(
                            enhancedBlob,
                            fileName,
                            folderName
                        );

                        savedCount++;

                        // Update progress
                        this.showToast(`üíæ ƒê√£ l∆∞u ${savedCount}/${totalImages} Polaroid...`, 'info');

                    } catch (error) {
                        console.error(`‚ùå L·ªói l∆∞u Polaroid ${i + 1}:`, error);
                        // Continue with other images
                    }
                }

                // Success message
                if (savedCount > 0) {
                    const folderText = folderName ? ` trong th∆∞ m·ª•c "${folderName}"` : '';
                    this.showToast(`‚úÖ ƒê√£ l∆∞u th√†nh c√¥ng ${savedCount}/${totalImages} Polaroid${folderText}!`, 'success');
                } else {
                    this.showToast('‚ùå Kh√¥ng th·ªÉ l∆∞u Polaroid n√†o!', 'error');
                }

            } catch (error) {
                console.error('‚ùå L·ªói l∆∞u Polaroid Templates:', error);
                this.showToast('‚ùå C√≥ l·ªói x·∫£y ra khi l∆∞u Polaroid Templates!', 'error');
            }
        }

        async createPolaroidCanvas(imageData) {
            const config = this.templateData.config;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Check if using Polaroid 2 (overlay mode)
            if (config.templateType === 'type2' && config.overlayFrame && config.overlayPath) {
                // For Polaroid 2: Get canvas size from template config
                const templateConfig = this.getPolaroid2TemplateConfig();
                canvas.width = templateConfig.canvasSize.width;
                canvas.height = templateConfig.canvasSize.height;
                return this.createPolaroidWithOverlay(imageData, canvas, ctx, config);
            }

            // For Polaroid 1: Use calculated dimensions based on border settings
            const dimensions = this.calculatePolaroidDimensions();
            const border = config.border;

            // Set canvas to calculated Polaroid size
            canvas.width = dimensions.canvasW;
            canvas.height = dimensions.canvasH;

            // Polaroid 1 (Standard mode with borders)
            // Fill with background color
            ctx.fillStyle = config.bgColor;
            ctx.fillRect(0, 0, dimensions.canvasW, dimensions.canvasH);

            // Draw the image in the calculated area with borders
            const img = new Image();
            img.src = imageData.croppedDataURL;

            return new Promise((resolve) => {
                img.onload = () => {
                    // Calculate image position with safe area offset
                    const imageX = border.leftPx + config.safeAreaPx;
                    const imageY = border.topPx + config.safeAreaPx;

                    // Draw image
                    ctx.drawImage(img, imageX, imageY, dimensions.safeImageW, dimensions.safeImageH);

                    // Draw caption if text is provided
                    if (config.caption.text && config.caption.text.trim()) {
                        this.drawCaption(ctx, dimensions, config);
                    }

                    resolve(canvas);
                };
            });
        }

        async createPolaroidWithOverlay(imageData, canvas, ctx, config) {
            return new Promise(async (resolve, reject) => {
                try {
                    console.log('üñºÔ∏è Creating Polaroid 2 with overlay...');
                    console.log('Canvas size:', canvas.width, 'x', canvas.height);

                    // Fill canvas with white background first
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Load user image - Use ORIGINAL image for Polaroid 2
                    const userImg = new Image();
                    // Use original image instead of cropped version
                    userImg.src = imageData.originalImage ? imageData.originalImage.src : imageData.croppedDataURL;

                    await new Promise((res) => {
                        userImg.onload = res;
                        userImg.onerror = () => reject(new Error('Failed to load user image'));
                    });

                    console.log('User image loaded:', userImg.width, 'x', userImg.height);

                    // Get image area coordinates from config
                    // Default values for Polaroid template 650√ó1004px @ 300 DPI
                    const imageArea = config.imageArea || {
                        x: 36,
                        y: 63,
                        width: 576,
                        height: 785
                    };

                    console.log('Image area:', imageArea);

                    // Check if image has custom crop/zoom/pan settings
                    const cropSettings = imageData.cropSettings || {};
                    const zoom = cropSettings.zoom || 1.0;
                    const panX = cropSettings.panX || 0;
                    const panY = cropSettings.panY || 0;

                    // Draw user image with object-fit: cover + zoom/pan support
                    // Calculate how to crop the image to fill the area
                    const imgAspect = userImg.width / userImg.height;
                    const areaAspect = imageArea.width / imageArea.height;

                    let srcX = 0, srcY = 0, srcW = userImg.width, srcH = userImg.height;

                    if (imgAspect > areaAspect) {
                        // Image is wider, crop sides
                        srcW = userImg.height * areaAspect;
                        srcX = (userImg.width - srcW) / 2;
                    } else {
                        // Image is taller, crop top/bottom
                        srcH = userImg.width / areaAspect;
                        srcY = (userImg.height - srcH) / 2;
                    }

                    // Apply zoom (reduce source dimensions to create zoom effect)
                    srcW = srcW / zoom;
                    srcH = srcH / zoom;

                    // Apply pan (adjust source position)
                    srcX = srcX + panX;
                    srcY = srcY + panY;

                    // Ensure source coordinates are within image bounds
                    srcX = Math.max(0, Math.min(userImg.width - srcW, srcX));
                    srcY = Math.max(0, Math.min(userImg.height - srcH, srcY));

                    console.log('Drawing user image - src:', srcX, srcY, srcW, srcH);
                    console.log('Drawing user image - dest:', imageArea.x, imageArea.y, imageArea.width, imageArea.height);

                    // Draw cropped user image to fit the transparent area
                    ctx.drawImage(
                        userImg,
                        srcX, srcY, srcW, srcH,
                        imageArea.x, imageArea.y, imageArea.width, imageArea.height
                    );

                    // Load and draw overlay template on top
                    const overlayImg = new Image();
                    overlayImg.crossOrigin = 'anonymous'; // Enable CORS
                    overlayImg.src = config.overlayPath;

                    overlayImg.onload = () => {
                        console.log('Overlay loaded:', overlayImg.width, 'x', overlayImg.height);
                        // Draw overlay frame on top of user image
                        ctx.drawImage(overlayImg, 0, 0, canvas.width, canvas.height);
                        console.log('‚úÖ Polaroid 2 created successfully!');
                        resolve(canvas);
                    };

                    overlayImg.onerror = (err) => {
                        console.error('‚ùå Failed to load overlay template:', err);
                        console.error('Overlay path:', config.overlayPath);
                        resolve(canvas);
                    };

                } catch (error) {
                    console.error('Error creating Polaroid with overlay:', error);
                    reject(error);
                }
            });
        }

        drawCaption(ctx, dimensions, config) {
            const captionConfig = config.caption;
            const border = config.border;
            
            // Caption area: bottom area
            const captionY = dimensions.canvasH - border.bottomCaptionPx + captionConfig.marginTopPx;
            const captionWidth = dimensions.canvasW - (border.leftPx + border.rightPx);
            const captionX = border.leftPx;
            
            // Set font
            ctx.font = `${captionConfig.fontSizePx}px ${captionConfig.fontFamily}`;
            ctx.fillStyle = captionConfig.color;
            ctx.textBaseline = 'top';
            
            // Calculate text position based on alignment
            let textX;
            switch (captionConfig.align) {
                case 'left':
                    ctx.textAlign = 'left';
                    textX = captionX;
                    break;
                case 'right':
                    ctx.textAlign = 'right';
                    textX = captionX + captionWidth;
                    break;
                case 'center':
                default:
                    ctx.textAlign = 'center';
                    textX = captionX + (captionWidth / 2);
                    break;
            }
            
            // Draw text with word wrapping if needed
            this.drawWrappedText(ctx, captionConfig.text, textX, captionY, captionWidth, captionConfig.fontSizePx + 4);
        }

        drawWrappedText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let currentY = y;
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && i > 0) {
                    ctx.fillText(line.trim(), x, currentY);
                    line = words[i] + ' ';
                    currentY += lineHeight;
                } else {
                    line = testLine;
                }
            }
            
            if (line.trim()) {
                ctx.fillText(line.trim(), x, currentY);
            }
        }

        drawOverlayFrame(ctx, dimensions) {
            // Draw a simple frame overlay (could be replaced with PNG image)
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, dimensions.canvasW - 2, dimensions.canvasH - 2);
            
            // Draw corner markers
            const cornerSize = 10;
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            
            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(cornerSize, 1);
            ctx.lineTo(1, 1);
            ctx.lineTo(1, cornerSize);
            ctx.stroke();
            
            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(dimensions.canvasW - cornerSize, 1);
            ctx.lineTo(dimensions.canvasW - 1, 1);
            ctx.lineTo(dimensions.canvasW - 1, cornerSize);
            ctx.stroke();
            
            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(1, dimensions.canvasH - cornerSize);
            ctx.lineTo(1, dimensions.canvasH - 1);
            ctx.lineTo(cornerSize, dimensions.canvasH - 1);
            ctx.stroke();
            
            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(dimensions.canvasW - cornerSize, dimensions.canvasH - 1);
            ctx.lineTo(dimensions.canvasW - 1, dimensions.canvasH - 1);
            ctx.lineTo(dimensions.canvasW - 1, dimensions.canvasH - cornerSize);
            ctx.stroke();
        }

        async createBorderCanvas(imageData) {
            const config = this.borderTemplateData.config;

            // T√≠nh to√°n k√≠ch th∆∞·ªõc canvas theo DPI 300
            const canvasW = Math.round((config.templateSizeCm.width / 2.54) * 300);
            const canvasH = Math.round((config.templateSizeCm.height / 2.54) * 300);

            // T√≠nh to√°n k√≠ch th∆∞·ªõc border
            const borderThickness = Math.round((config.border.thickness / 10) * 300 / 2.54); // Convert mm to pixels

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = canvasW;
            canvas.height = canvasH;

            // Fill background v·ªõi m√†u border
            ctx.fillStyle = config.border.color;
            ctx.fillRect(0, 0, canvasW, canvasH);

            // T√≠nh to√°n v√πng ·∫£nh (tr·ª´ border)
            const imageX = borderThickness;
            const imageY = borderThickness;
            const imageW = canvasW - (2 * borderThickness);
            const imageH = canvasH - (2 * borderThickness);

            const img = new Image();
            img.src = imageData.croppedDataURL;

            return new Promise((resolve) => {
                img.onload = () => {
                    // Fill v√πng ·∫£nh v·ªõi background color
                    ctx.fillStyle = config.bgColor;
                    ctx.fillRect(imageX, imageY, imageW, imageH);

                    // T√≠nh to√°n fit mode
                    let drawX = imageX;
                    let drawY = imageY;
                    let drawW = imageW;
                    let drawH = imageH;

                    if (config.fitMode === 'cover') {
                        const scaleX = imageW / img.width;
                        const scaleY = imageH / img.height;
                        const scale = Math.max(scaleX, scaleY);

                        drawW = img.width * scale;
                        drawH = img.height * scale;
                        drawX = imageX + (imageW - drawW) / 2;
                        drawY = imageY + (imageH - drawH) / 2;
                    } else if (config.fitMode === 'contain') {
                        const scaleX = imageW / img.width;
                        const scaleY = imageH / img.height;
                        const scale = Math.min(scaleX, scaleY);

                        drawW = img.width * scale;
                        drawH = img.height * scale;
                        drawX = imageX + (imageW - drawW) / 2;
                        drawY = imageY + (imageH - drawH) / 2;
                    }

                    // Draw image
                    ctx.drawImage(img, drawX, drawY, drawW, drawH);

                    resolve(canvas);
                };
            });
        }

        async createStripCanvas(stripData) {
            const config = this.stripTemplateData.config;

            // T√≠nh to√°n k√≠ch th∆∞·ªõc canvas theo DPI 300
            const canvasW = Math.round((config.stripSizeCm.width / 2.54) * 300);
            const canvasH = Math.round((config.stripSizeCm.height / 2.54) * 300);

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = canvasW;
            canvas.height = canvasH;

            // Fill background
            ctx.fillStyle = config.bgColor;
            ctx.fillRect(0, 0, canvasW, canvasH);

            const frameCount = config.frameCount;
            const outerBorder = Math.round((config.spacing.outerBorder / 10) * 300 / 2.54); // mm to pixels
            const frameSpacing = Math.round((config.spacing.frameSpacing / 10) * 300 / 2.54); // mm to pixels
            const frameBorder = Math.round((config.spacing.frameBorder / 10) * 300 / 2.54); // mm to pixels

            // T√≠nh to√°n k√≠ch th∆∞·ªõc frame
            const availableWidth = canvasW - (2 * outerBorder);
            const availableHeight = canvasH - (2 * outerBorder);

            let frameW, frameH;
            if (frameCount <= 2) {
                // Horizontal layout cho 2 frame ho·∫∑c √≠t h∆°n
                frameW = Math.floor((availableWidth - frameSpacing * (frameCount - 1)) / frameCount);
                frameH = availableHeight;
            } else {
                // Vertical layout cho 3+ frames
                frameW = availableWidth;
                frameH = Math.floor((availableHeight - frameSpacing * (frameCount - 1)) / frameCount);
            }

            // Draw frames
            const images = stripData.images;
            for (let i = 0; i < Math.min(frameCount, images.length); i++) {
                const imageData = images[i];
                if (!imageData) continue;

                let frameX, frameY;
                if (frameCount <= 2) {
                    // Horizontal layout
                    frameX = outerBorder + i * (frameW + frameSpacing);
                    frameY = outerBorder;
                } else {
                    // Vertical layout
                    frameX = outerBorder;
                    frameY = outerBorder + i * (frameH + frameSpacing);
                }

                // Draw frame background (white border around image)
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(frameX, frameY, frameW, frameH);

                // Calculate image area (subtract frame border)
                const imgX = frameX + frameBorder;
                const imgY = frameY + frameBorder;
                const imgW = frameW - (2 * frameBorder);
                const imgH = frameH - (2 * frameBorder);

                // Load and draw image
                const img = new Image();
                img.src = imageData.croppedDataURL;

                await new Promise((resolve) => {
                    img.onload = () => {
                        // Calculate fit (cover mode ƒë·ªÉ fill to√†n b·ªô frame)
                        const scaleX = imgW / img.width;
                        const scaleY = imgH / img.height;
                        const scale = Math.max(scaleX, scaleY);

                        const drawW = img.width * scale;
                        const drawH = img.height * scale;
                        const drawX = imgX + (imgW - drawW) / 2;
                        const drawY = imgY + (imgH - drawH) / 2;

                        // Clip to image area
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(imgX, imgY, imgW, imgH);
                        ctx.clip();

                        ctx.drawImage(img, drawX, drawY, drawW, drawH);
                        ctx.restore();

                        resolve();
                    };
                });
            }

            return canvas;
        }

        // Template Crop Editor Functions (Copy Multi-crop approach)
        openTemplateCropEditor() {
            console.log('üöÄ openTemplateCropEditor() called');
            console.log('templateData:', this.templateData);
            
            if (!this.templateData || !this.templateData.images || this.templateData.images.length === 0) {
                console.log('‚ùå No images available for cropping');
                this.showToast('‚ùå Kh√¥ng c√≥ ·∫£nh ƒë·ªÉ ch·ªânh s·ª≠a crop!', 'error');
                return;
            }
            
            console.log('‚úÖ Images found, opening crop editor...');

            const currentImage = this.templateData.images[this.templateData.currentIndex];
            if (!currentImage) {
                this.showToast('‚ùå Kh√¥ng th·ªÉ t·∫£i ·∫£nh hi·ªán t·∫°i!', 'error');
                return;
            }

            // Setup templateCropData for modal
            this.templateCropData = {
                files: [{
                    name: currentImage.filename || 'Template Image',
                    file: null, // We have dataURL instead
                    dataURL: currentImage.originalDataURL || currentImage.croppedDataURL
                }],
                currentIndex: 0,
                config: {
                    width: this.templateData.config.polaroidSizeCm.width,
                    height: this.templateData.config.polaroidSizeCm.height,
                    unit: 'cm',
                    targetWidth: Math.round((this.templateData.config.polaroidSizeCm.width / 2.54) * 300),
                    targetHeight: Math.round((this.templateData.config.polaroidSizeCm.height / 2.54) * 300),
                    aspectRatio: this.templateData.config.polaroidSizeCm.height / this.templateData.config.polaroidSizeCm.width,
                    dpi: 300
                }
            };
            
            console.log('üìä Setup templateCropData:', this.templateCropData);

            // Show modal
            const modal = document.getElementById('templateCropModal');
            modal.style.display = 'block';
            
            // Setup modal click outside to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                    this.templateCropData = null;
                }
            });
            
            // Prevent modal content clicks from closing modal
            const modalContent = modal.querySelector('.template-crop-content');
            if (modalContent) {
                modalContent.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            
            // Setup modal button event listeners (after modal is shown)
            this.setupTemplateCropModalListeners();
            
            // Load image for cropping (using existing crop system)
            this.loadImageForTemplateCropping(0);
        }

        // End Template Crop Editor Functions

        // Image Rotation Functions
        async rotateImage(imageId, angle) {
            console.log('üîÑ Rotating image:', { imageId, angle });
            
            try {
                // Find the image in galleryImages
                const imageIndex = this.galleryImages.findIndex(img => img.id == imageId);
                if (imageIndex === -1) {
                    this.showToast('‚ùå Kh√¥ng t√¨m th·∫•y ·∫£nh ƒë·ªÉ xoay!', 'error');
                    return;
                }
                
                const imageData = this.galleryImages[imageIndex];
                
                // Create canvas for rotation
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Create image element
                const img = new Image();
                img.onload = () => {
                    // Calculate new dimensions after rotation
                    const isRotated90or270 = (angle === 90 || angle === 270);
                    canvas.width = isRotated90or270 ? img.height : img.width;
                    canvas.height = isRotated90or270 ? img.width : img.height;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Move to center and rotate
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate((angle * Math.PI) / 180);
                    
                    // Draw rotated image
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    ctx.restore();
                    
                    // Update image data with rotated version
                    imageData.data = canvas.toDataURL('image/jpeg', 1.0);
                    imageData.rotation = (imageData.rotation || 0) + angle;
                    imageData.rotation = imageData.rotation % 360; // Keep rotation within 0-359¬∞
                    
                    // Update UI
                    this.updateSourceGrid();
                    this.updateGalleryDisplay();
                    
                    // Show success message
                    this.showToast(`üîÑ ƒê√£ xoay ·∫£nh ${angle}¬∞ (T·ªïng: ${imageData.rotation}¬∞)`, 'success');
                };
                
                img.src = imageData.data;
                
            } catch (error) {
                console.error('Rotate image error:', error);
                this.showToast('‚ùå L·ªói khi xoay ·∫£nh!', 'error');
            }
        }

        // Image Duplication Function  
        async duplicateImage(imageId) {
            console.log('‚ßâ Duplicating image:', imageId);
            
            try {
                // Find the image in galleryImages
                const imageIndex = this.galleryImages.findIndex(img => img.id == imageId);
                if (imageIndex === -1) {
                    this.showToast('‚ùå Kh√¥ng t√¨m th·∫•y ·∫£nh ƒë·ªÉ nh√¢n b·∫£n!', 'error');
                    return;
                }
                
                const originalImage = this.galleryImages[imageIndex];
                
                // Create duplicate with new ID
                const duplicateImage = {
                    ...originalImage, // Copy all properties
                    id: Date.now() + Math.random(), // New unique ID
                    filename: `${originalImage.filename.replace(/\.[^/.]+$/, '')}_copy.jpg`, // Add "_copy" to filename
                    isOriginal: false // Mark as duplicate
                };
                
                // Add to galleryImages array (right after original)
                this.galleryImages.splice(imageIndex + 1, 0, duplicateImage);
                
                // Update UI
                this.updateSourceGrid();
                this.updateGalleryDisplay();
                
                // Show success message
                this.showToast(`‚ßâ ƒê√£ nh√¢n b·∫£n ·∫£nh: ${duplicateImage.filename}`, 'success');
                
                console.log('‚úÖ Image duplicated successfully:', {
                    original: originalImage.filename,
                    duplicate: duplicateImage.filename,
                    totalImages: this.galleryImages.length
                });
                
            } catch (error) {
                console.error('Duplicate image error:', error);
                this.showToast('‚ùå L·ªói khi nh√¢n b·∫£n ·∫£nh!', 'error');
            }
        }

        async generatePrintFiles() {
            // Ki·ªÉm tra c√≥ ·∫£nh ƒë·ªÉ in kh√¥ng (x·ª≠ l√Ω c·∫£ duplex v√† normal mode)
            let hasImages = false;
            
            if (this.printData.config.printMode === 'duplex') {
                // Duplex mode: ki·ªÉm tra frontImages v√† backImages
                hasImages = (this.printData.frontImages && this.printData.frontImages.length > 0) || 
                           (this.printData.backImages && this.printData.backImages.length > 0);
                
                if (!hasImages) {
                    this.showToast('Vui l√≤ng ph√¢n lo·∫°i ·∫£nh v√†o m·∫∑t tr∆∞·ªõc ho·∫∑c m·∫∑t sau ƒë·ªÉ in', 'warning');
                    return;
                }
                
                // T·ª± ƒë·ªông c·∫≠p nh·∫≠t selectedImages t·ª´ classified images
                this.updatePrintDataSelectedImages();
                
                console.log('üìä Duplex mode - Images ready:', {
                    frontCount: this.printData.frontImages?.length || 0,
                    backCount: this.printData.backImages?.length || 0,
                    selectedCount: this.printData.selectedImages?.length || 0,
                    frontImages: this.printData.frontImages,
                    backImages: this.printData.backImages,
                    selectedImages: this.printData.selectedImages
                });
            } else {
                // Normal mode: ki·ªÉm tra selectedImages v√† window.converter.printFiles
                const selectedImages = this.printData.selectedImages || [];
                const windowPrintFiles = (window.converter && window.converter.printFiles) ? window.converter.printFiles : [];

                hasImages = selectedImages.length > 0 || windowPrintFiles.length > 0;

                console.log('üîç Print DEBUG: selectedImages:', selectedImages.length, 'windowPrintFiles:', windowPrintFiles.length);

                if (!hasImages) {
                    this.showToast('Vui l√≤ng ch·ªçn ·∫£nh ƒë·ªÉ in', 'warning');
                    return;
                }

                // If we have files from File System fallback, use them
                if (windowPrintFiles.length > 0 && selectedImages.length === 0) {
                    console.log('‚úÖ Using files from File System fallback for printing');
                    this.printData.selectedImages = windowPrintFiles.map(f => ({
                        data: f.url || URL.createObjectURL(f.file),
                        name: f.name,
                        file: f.file
                    }));
                }
            }

            // Get export format from active tab instead of radio button
            const activeFormatTab = document.querySelector('.format-tab.active');
            const exportFormat = activeFormatTab ? activeFormatTab.dataset.format : 'jpg-individual';  // üîß Default to individual JPG
            const generateBtn = document.getElementById('generatePrintBtn');
            
            generateBtn.disabled = true;
            generateBtn.textContent = 'ƒêang t·∫°o...';

            try {
                switch (exportFormat) {
                    case 'jpg-zip':
                        await this.generateJPGPagesZip();
                        break;
                    case 'jpg-individual':
                        await this.generateJPGPagesIndividual();
                        break;
                    case 'pdf':
                        await this.generatePDFFile();
                        break;
                    case 'filesystem':
                        await this.saveToFileSystem();
                        break;
                    default:
                        await this.generateJPGPagesZip();
                }
            } catch (error) {
                console.error('Error generating print files:', error);
                this.showToast('L·ªói khi t·∫°o file in', 'error');
            }

            generateBtn.disabled = false;
            generateBtn.textContent = 'T·∫°o file in';
        }

        async generateJPGPagesZip() {
            const zip = new JSZip();
            const config = this.printData.config;
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;

            if (config.printMode === 'duplex') {
                // üîß FIX: Duplex LU√îN d√πng individual JPG, kh√¥ng ZIP
                console.log('üö´ Duplex mode - Redirecting to individual JPG export');
                await this.generateDuplexJPGIndividual();
                return;
            }
            
            for (let page = 0; page < this.printData.totalPages; page++) {
                // Use Master Canvas System for WYSIWYG export
                const masterCanvas = this.createMasterCanvas(page);
                
                // Convert master canvas to blob with maximum quality
                const blob = await new Promise(resolve => {
                    masterCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                });
                
                // Create descriptive filename with cutting guides info
                const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                                 config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
                const fileName = `page-${String(page + 1).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                zip.file(fileName, blob);
                
                // Show progress
                if (this.printData.totalPages > 1) {
                    const progress = ((page + 1) / this.printData.totalPages * 100).toFixed(0);
                    const generateBtn = document.getElementById('generatePrintBtn');
                    if (generateBtn) {
                        generateBtn.textContent = `ƒêang t·∫°o... ${progress}%`;
                    }
                }
            }

            const zipBlob = await zip.generateAsync({ type: 'blob' });
            
            // Create descriptive zip filename
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
            const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                             config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
            const zipFileName = `print-pages_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}_${timestamp}.zip`;
            
            this.downloadBlob(zipBlob, zipFileName);
            this.showToast(`‚úÖ ƒê√£ t·∫°o xong ${this.printData.totalPages} trang JPG ${dpi}DPI k√≠ch th∆∞·ªõc ${paperWidthMm}√ó${paperHeightMm}mm (ZIP)`, 'success');
        }

        async generateDuplexJPGZip() {
            // ‚ö†Ô∏è DEPRECATED: Function n√†y kh√¥ng c√≤n ƒë∆∞·ª£c d√πng n·ªØa
            // Duplex mode gi·ªù LU√îN xu·∫•t individual JPG thay v√¨ ZIP
            console.warn('‚ö†Ô∏è generateDuplexJPGZip() is deprecated - use generateDuplexJPGIndividual() instead');

            const frontZip = new JSZip();
            const backZip = new JSZip();
            const config = this.printData.config;
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            let frontPageCount = 0;
            let backPageCount = 0;
            
            // Generate front pages (even indexes: 0, 2, 4...)
            for (let page = 0; page < this.printData.totalPages; page += 2) {
                const masterCanvas = this.createMasterCanvas(page);
                const blob = await new Promise(resolve => {
                    masterCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                });
                
                const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                                 config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
                const fileName = `FRONT_page-${String(page + 1).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                frontZip.file(fileName, blob);
                frontPageCount++;
                
                // Progress for front pages
                const progress = (frontPageCount / Math.ceil(this.printData.totalPages / 2) * 50).toFixed(0);
                const generateBtn = document.getElementById('generatePrintBtn');
                if (generateBtn) {
                    generateBtn.textContent = `T·∫°o ZIP m·∫∑t tr∆∞·ªõc... ${progress}%`;
                }
            }
            
            // Generate back pages (odd indexes: 1, 3, 5...) with flipping
            for (let page = 1; page < this.printData.totalPages; page += 2) {
                const masterCanvas = this.createDuplexBackCanvas(page);
                const blob = await new Promise(resolve => {
                    masterCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                });
                
                const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                                 config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
                const fileName = `BACK_page-${String(page + 1).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                backZip.file(fileName, blob);
                backPageCount++;
                
                // Progress for back pages
                const progress = (50 + (backPageCount / Math.floor(this.printData.totalPages / 2) * 50)).toFixed(0);
                const generateBtn = document.getElementById('generatePrintBtn');
                if (generateBtn) {
                    generateBtn.textContent = `T·∫°o ZIP m·∫∑t sau... ${progress}%`;
                }
            }
            
            // Generate ZIP files
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
            const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                             config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
            
            const frontZipBlob = await frontZip.generateAsync({ type: 'blob' });
            const backZipBlob = await backZip.generateAsync({ type: 'blob' });
            
            const frontZipFileName = `FRONT_duplex-${config.duplexFlip}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}_${timestamp}.zip`;
            const backZipFileName = `BACK_duplex-${config.duplexFlip}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}_${timestamp}.zip`;
            
            // Download both ZIP files
            this.downloadBlob(frontZipBlob, frontZipFileName);
            
            // Small delay before second download
            await new Promise(resolve => setTimeout(resolve, 1000));
            this.downloadBlob(backZipBlob, backZipFileName);
            
            this.showToast(`‚úÖ ƒê√£ t·∫°o xong 2 file ZIP Duplex: ${frontPageCount} trang tr∆∞·ªõc + ${backPageCount} trang sau (${config.duplexFlip})`, 'success');
        }

        async generateJPGPagesIndividual() {
            const config = this.printData.config;
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            if (config.printMode === 'duplex') {
                await this.generateDuplexJPGIndividual();
                return;
            }
            
            for (let page = 0; page < this.printData.totalPages; page++) {
                // Use Master Canvas System for WYSIWYG export
                const masterCanvas = this.createMasterCanvas(page);
                
                // Convert master canvas to blob with maximum quality
                const blob = await new Promise(resolve => {
                    masterCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                });
                
                // Create descriptive filename with cutting guides info
                const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                                 config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
                const fileName = `page-${String(page + 1).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                
                // Download individual file
                this.downloadBlob(blob, fileName);
                
                // Show progress and small delay between downloads
                if (this.printData.totalPages > 1) {
                    const progress = ((page + 1) / this.printData.totalPages * 100).toFixed(0);
                    const generateBtn = document.getElementById('generatePrintBtn');
                    if (generateBtn) {
                        generateBtn.textContent = `ƒêang t·∫£i... ${progress}%`;
                    }
                    
                    // Small delay to prevent browser blocking multiple downloads
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            
            this.showToast(`‚úÖ ƒê√£ t·∫£i xong ${this.printData.totalPages} file JPG ${dpi}DPI k√≠ch th∆∞·ªõc ${paperWidthMm}√ó${paperHeightMm}mm (Ri√™ng l·∫ª)`, 'success');
        }

        async generateDuplexJPGIndividual() {
            // Prevent multiple simultaneous calls
            if (this.isGeneratingDuplexJPG) {
                console.log('Duplex JPG generation already in progress, ignoring...');
                return;
            }
            
            this.isGeneratingDuplexJPG = true;
            
            const config = this.printData.config;
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            console.log('Generating duplex JPG with classification:', {
                frontImages: this.printData.frontImages?.length || 0,
                backImages: this.printData.backImages?.length || 0,
                maxPhotosPerPage: this.printData.maxPhotosPerPage
            });

            try {
                // Check if we have classified images
                if (!this.printData.frontImages?.length && !this.printData.backImages?.length) {
                    this.showToast('‚ö†Ô∏è Ch∆∞a c√≥ ·∫£nh n√†o ƒë∆∞·ª£c ph√¢n lo·∫°i cho duplex!', 'error');
                    return;
                }

            // üìä Calculate pagination
            const maxPhotosPerPage = this.printData.maxPhotosPerPage || 1;
            const totalFrontPages = Math.ceil((this.printData.frontImages?.length || 0) / maxPhotosPerPage);
            const totalBackPages = Math.ceil((this.printData.backImages?.length || 0) / maxPhotosPerPage);
            const totalPages = Math.max(totalFrontPages, totalBackPages);

            console.log('üìÑ Duplex pagination:', {
                maxPhotosPerPage,
                totalFrontPages,
                totalBackPages,
                totalPages
            });

            if (totalPages === 0) {
                this.showToast('‚ö†Ô∏è Kh√¥ng c√≥ trang n√†o ƒë·ªÉ xu·∫•t!', 'error');
                return;
            }

            const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages ||
                             config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
            const generateBtn = document.getElementById('generatePrintBtn');
            let fileCount = 0;

            // üîÑ Loop qua t·ª´ng trang
            for (let pageIndex = 0; pageIndex < totalPages; pageIndex++) {
                const pageNumber = pageIndex + 1;
                const pageNumStr = String(pageNumber).padStart(3, '0');

                // üìÑ Generate FRONT page (n·∫øu c√≤n ·∫£nh front)
                if (pageIndex < totalFrontPages) {
                    console.log(`üñ®Ô∏è Generating FRONT page ${pageNumber}...`);

                    const frontCanvas = await this.createDuplexMasterCanvas('front', pageIndex);
                    if (frontCanvas) {
                        const blob = await new Promise(resolve => {
                            frontCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                        });

                        const fileName = `FRONT_page-${pageNumStr}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                        this.downloadBlob(blob, fileName);
                        fileCount++;

                        if (generateBtn) {
                            const progress = Math.round((fileCount / (totalFrontPages + totalBackPages)) * 100);
                            generateBtn.textContent = `T·∫°o file... ${progress}%`;
                        }

                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }

                // üìÑ Generate BACK page (n·∫øu c√≤n ·∫£nh back)
                if (pageIndex < totalBackPages) {
                    console.log(`üñ®Ô∏è Generating BACK page ${pageNumber}...`);

                    try {
                        const backCanvas = await this.createDuplexBackCanvasClassified(pageIndex);
                        if (backCanvas) {
                            const blob = await new Promise(resolve => {
                                backCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                            });

                            const fileName = `BACK_page-${pageNumStr}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                            this.downloadBlob(blob, fileName);
                            fileCount++;

                            if (generateBtn) {
                                const progress = Math.round((fileCount / (totalFrontPages + totalBackPages)) * 100);
                                generateBtn.textContent = `T·∫°o file... ${progress}%`;
                            }

                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    } catch (error) {
                        console.error(`Error creating back page ${pageNumber}:`, error);
                        this.showToast(`‚ö†Ô∏è L·ªói t·∫°o m·∫∑t sau trang ${pageNumber}`, 'error');
                    }
                }
            }

            if (generateBtn) {
                generateBtn.disabled = false;
                generateBtn.textContent = 'T·∫°o file JPG ri√™ng l·∫ª';
            }

            this.showToast(`‚úÖ ƒê√£ t·∫°o xong ${fileCount} file JPG duplex (${totalPages} trang, ${paperWidthMm}√ó${paperHeightMm}mm, ${dpi}DPI)`, 'success');
            
            } catch (error) {
                console.error('Error in generateDuplexJPGIndividual:', error);
                this.showToast('‚ö†Ô∏è L·ªói khi t·∫°o file JPG duplex!', 'error');
                
                const generateBtn = document.getElementById('generatePrintBtn');
                if (generateBtn) {
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'T·∫°o file JPG ri√™ng l·∫ª';
                }
            } finally {
                // Always reset protection flag
                this.isGeneratingDuplexJPG = false;
            }
        }


        renderPageToCanvasWithCoordinateMirroring(canvas, ctx, pageIndex, config) {
            // Render images on back side with coordinate mirroring (NO image flipping)
            const selectedImages = this.printData.selectedImages;
            if (!selectedImages || selectedImages.length === 0) return;

            // Calculate layout parameters
            const dpi = config.dpi;
            const paperWidthPx = canvas.width;
            const paperHeightPx = canvas.height;
            
            // C√îNG TH·ª®C CH√çNH X√ÅC: (k√≠ch_th∆∞·ªõc_cm √∑ 2.54) √ó 300
            const DPI = 300; // C·ªë ƒë·ªãnh DPI
            const photoWidthPx = Math.round((config.photoSize.width / 2.54) * DPI);  // (cm √∑ 2.54) √ó 300
            const photoHeightPx = Math.round((config.photoSize.height / 2.54) * DPI);
            const marginTopPx = Math.round(config.margins.top / 25.4 * dpi);
            const marginLeftPx = Math.round(config.margins.left / 25.4 * dpi);
            const gutterXPx = Math.round(config.gutter.x / 25.4 * dpi);
            const gutterYPx = Math.round(config.gutter.y / 25.4 * dpi);

            // Calculate grid layout
            const availableWidth = paperWidthPx - (config.margins.left + config.margins.right) / 25.4 * dpi;
            const availableHeight = paperHeightPx - (config.margins.top + config.margins.bottom) / 25.4 * dpi;
            const cols = Math.floor((availableWidth + gutterXPx) / (photoWidthPx + gutterXPx));
            const rows = Math.floor((availableHeight + gutterYPx) / (photoHeightPx + gutterYPx));
            
            // Start position
            const startXPx = marginLeftPx;
            const startYPx = marginTopPx;

            // Calculate page start index
            const maxPhotosPerPage = cols * rows;
            const pageStartIndex = pageIndex * maxPhotosPerPage;

            // Render images with coordinate mirroring
            let imageIndex = 0;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const globalIndex = pageStartIndex + imageIndex;
                    if (globalIndex >= selectedImages.length) break;

                    const imageData = selectedImages[globalIndex];
                    if (!imageData.img) continue;

                    // Calculate ORIGINAL position (nh∆∞ m·∫∑t tr∆∞·ªõc)
                    const originalX = startXPx + col * (photoWidthPx + gutterXPx);
                    const originalY = startYPx + row * (photoHeightPx + gutterYPx);

                    // ‚úÖ FIX: X·ª≠ l√Ω kh√°c nhau cho Portrait vs Landscape
                    let mirroredX, mirroredY;

                    if (config.orientation === 'portrait') {
                        // üìê PORTRAIT (d·ªçc): XOAY 180¬∞ (mirror c·∫£ X v√† Y)
                        const availableAreaCenterX = marginLeftPx + (canvas.width - 2 * marginLeftPx) / 2;
                        const availableAreaCenterY = marginTopPx + (canvas.height - 2 * marginTopPx) / 2;

                        // Xoay 180¬∞ = mirror c·∫£ X v√† Y qua center
                        const originalCenterX = originalX + photoWidthPx / 2;
                        const originalCenterY = originalY + photoHeightPx / 2;

                        const distanceFromCenterX = originalCenterX - availableAreaCenterX;
                        const distanceFromCenterY = originalCenterY - availableAreaCenterY;

                        const mirroredCenterX = availableAreaCenterX - distanceFromCenterX;
                        const mirroredCenterY = availableAreaCenterY - distanceFromCenterY;

                        mirroredX = mirroredCenterX - photoWidthPx / 2;
                        mirroredY = mirroredCenterY - photoHeightPx / 2;

                        console.log(`üîÑ PORTRAIT - Xoay 180¬∞: (${originalX.toFixed(0)}, ${originalY.toFixed(0)}) ‚Üí (${mirroredX.toFixed(0)}, ${mirroredY.toFixed(0)})`);
                    } else {
                        // üìê LANDSCAPE (ngang): Mirror theo duplexFlip
                        if (config.duplexFlip === 'long-edge') {
                            // Long-edge binding: mirror theo tr·ª•c X qua center
                            const availableAreaCenterX = marginLeftPx + (canvas.width - 2 * marginLeftPx) / 2;

                            const originalCenterX = originalX + photoWidthPx / 2;
                            const distanceFromCenter = originalCenterX - availableAreaCenterX;
                            const mirroredCenterX = availableAreaCenterX - distanceFromCenter;
                            mirroredX = mirroredCenterX - photoWidthPx / 2;
                            mirroredY = originalY; // Y kh√¥ng ƒë·ªïi
                        } else {
                            // Short-edge binding: mirror theo tr·ª•c Y qua center
                            const availableAreaCenterY = marginTopPx + (canvas.height - 2 * marginTopPx) / 2;

                            const originalCenterY = originalY + photoHeightPx / 2;
                            const distanceFromCenter = originalCenterY - availableAreaCenterY;
                            const mirroredCenterY = availableAreaCenterY - distanceFromCenter;
                            mirroredX = originalX; // X kh√¥ng ƒë·ªïi
                            mirroredY = mirroredCenterY - photoHeightPx / 2;

                            // Validation cho short-edge
                            const centerY = canvas.height / 2;
                            const frontDistFromCenterY = Math.abs(originalY + photoHeightPx/2 - centerY);
                            const backDistFromCenterY = Math.abs(mirroredY + photoHeightPx/2 - centerY);
                            console.log(`  ‚öñÔ∏è SHORT-EDGE Symmetry Y: Front(${frontDistFromCenterY.toFixed(1)}) vs Back(${backDistFromCenterY.toFixed(1)}) from center - ${Math.abs(frontDistFromCenterY - backDistFromCenterY) < 1 ? '‚úÖ SYMMETRIC' : '‚ùå NOT SYMMETRIC'}`);
                        }
                    }

                    console.log(`Image ${imageIndex}: Original(${originalX.toFixed(0)},${originalY.toFixed(0)}) -> Mirrored(${mirroredX.toFixed(0)},${mirroredY.toFixed(0)})`);
                    console.log(`  üìè Canvas: ${canvas.width}x${canvas.height}px, Photo: ${photoWidthPx}x${photoHeightPx}px, DPI: ${config.dpi}`);
                    
                    // üßÆ VERIFICATION: Ki·ªÉm tra c√¥ng th·ª©c c√≥ kh·ªõp kh√¥ng
                    if (config.duplexFlip === 'long-edge') {
                        const expectedX = canvas.width - (originalX + photoWidthPx);
                        const calculatedX = mirroredX;
                        console.log(`  üßÆ Formula Check: Expected(${expectedX.toFixed(0)}) vs Calculated(${calculatedX.toFixed(0)}) - ${Math.abs(expectedX - calculatedX) < 1 ? '‚úÖ MATCH' : '‚ùå MISMATCH'}`);
                        
                        // Ki·ªÉm tra t·ªça ƒë·ªô c√≥ ƒë·ªëi x·ª©ng kh√¥ng
                        const centerX = canvas.width / 2;
                        const frontDistFromCenter = Math.abs(originalX + photoWidthPx/2 - centerX);
                        const backDistFromCenter = Math.abs(mirroredX + photoWidthPx/2 - centerX);
                        console.log(`  ‚öñÔ∏è Symmetry: Front(${frontDistFromCenter.toFixed(1)}) vs Back(${backDistFromCenter.toFixed(1)}) from center - ${Math.abs(frontDistFromCenter - backDistFromCenter) < 1 ? '‚úÖ SYMMETRIC' : '‚ùå NOT SYMMETRIC'}`);
                        
                        // üéØ FINAL VALIDATION: ƒê·∫£m b·∫£o ·∫£nh kh√¥ng ra ngo√†i canvas
                        if (mirroredX < 0 || mirroredY < 0 || mirroredX + photoWidthPx > canvas.width || mirroredY + photoHeightPx > canvas.height) {
                            console.warn(`  ‚ö†Ô∏è WARNING: Mirrored image out of bounds! X:${mirroredX.toFixed(0)}-${(mirroredX + photoWidthPx).toFixed(0)} Y:${mirroredY.toFixed(0)}-${(mirroredY + photoHeightPx).toFixed(0)} Canvas:${canvas.width}x${canvas.height}`);
                            
                            // Auto-fix n·∫øu ra ngo√†i canvas
                            mirroredX = Math.max(0, Math.min(mirroredX, canvas.width - photoWidthPx));
                            mirroredY = Math.max(0, Math.min(mirroredY, canvas.height - photoHeightPx));
                            console.log(`  üîß AUTO-FIX: Adjusted to X:${mirroredX.toFixed(0)} Y:${mirroredY.toFixed(0)}`);
                        }
                    }

                    // V·∫Ω ·∫£nh ·ªü v·ªã tr√≠ ƒë√£ mirror (·∫£nh v·∫´n gi·ªØ nguy√™n orientation - KH√îNG FLIP!)
                    // T√≠nh to√°n ƒë·ªÉ fit ·∫£nh v√†o khung
                    const img = imageData.img;
                    const imgAspect = img.width / img.height;
                    const targetAspect = photoWidthPx / photoHeightPx;
                    
                    let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
                    
                    if (config.fitMode === 'fill') {
                        // Fill: Crop ƒë·ªÉ fill to√†n b·ªô khung
                        if (imgAspect > targetAspect) {
                            drawHeight = photoHeightPx;
                            drawWidth = drawHeight * imgAspect;
                            offsetX = (photoWidthPx - drawWidth) / 2;
                        } else {
                            drawWidth = photoWidthPx;
                            drawHeight = drawWidth / imgAspect;
                            offsetY = (photoHeightPx - drawHeight) / 2;
                        }
                    } else {
                        // Fit: Gi·ªØ t·ª∑ l·ªá, c√≥ th·ªÉ c√≥ vi·ªÅn tr·∫Øng
                        if (imgAspect > targetAspect) {
                            drawWidth = photoWidthPx;
                            drawHeight = drawWidth / imgAspect;
                            offsetY = (photoHeightPx - drawHeight) / 2;
                        } else {
                            drawHeight = photoHeightPx;
                            drawWidth = drawHeight * imgAspect;
                            offsetX = (photoWidthPx - drawWidth) / 2;
                        }
                    }

                    // V·∫Ω n·ªÅn tr·∫Øng cho khung ·∫£nh
                    ctx.fillStyle = 'white';
                    ctx.fillRect(mirroredX, mirroredY, photoWidthPx, photoHeightPx);

                    // ‚úÖ FIX: Portrait c·∫ßn xoay N·ªòI DUNG ·∫£nh 180¬∞
                    // Landscape th√¨ KH√îNG xoay (ch·ªâ mirror t·ªça ƒë·ªô)
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(mirroredX, mirroredY, photoWidthPx, photoHeightPx);
                    ctx.clip();

                    // üîÑ XOAY N·ªòI DUNG ·∫¢NH n·∫øu Portrait
                    if (config.orientation === 'portrait') {
                        // Xoay 180¬∞ qua t√¢m khung ·∫£nh
                        const imageCenterX = mirroredX + photoWidthPx / 2;
                        const imageCenterY = mirroredY + photoHeightPx / 2;
                        ctx.translate(imageCenterX, imageCenterY);
                        ctx.rotate(Math.PI); // 180¬∞
                        ctx.translate(-imageCenterX, -imageCenterY);
                        console.log(`üîÑ Rotating image content 180¬∞ for Portrait at (${mirroredX.toFixed(0)}, ${mirroredY.toFixed(0)})`);
                    }

                    // V·∫º ·∫¢NH
                    ctx.drawImage(img, mirroredX + offsetX, mirroredY + offsetY, drawWidth, drawHeight);
                    ctx.restore();

                    // V·∫Ω vi·ªÅn
                    ctx.strokeStyle = '#e2e8f0';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(mirroredX, mirroredY, photoWidthPx, photoHeightPx);

                    // üéØ DEBUG: V·∫Ω markers ƒë·ªÉ ki·ªÉm tra alignment
                    if (imageIndex < 3) { // Ch·ªâ v·∫Ω cho 3 ·∫£nh ƒë·∫ßu ƒë·ªÉ kh√¥ng qu√° r·ªëi
                        ctx.fillStyle = config.duplexFlip === 'long-edge' ? '#ff6b6b' : '#4ecdc4';
                        ctx.font = '12px Arial';
                        ctx.fillText(`${imageIndex}:${mirroredX.toFixed(0)},${mirroredY.toFixed(0)}`, 
                                    mirroredX + 5, mirroredY + 15);
                        
                        // V·∫Ω cross mark t·∫°i center c·ªßa ·∫£nh
                        const centerX = mirroredX + photoWidthPx/2;
                        const centerY = mirroredY + photoHeightPx/2;
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX - 10, centerY);
                        ctx.lineTo(centerX + 10, centerY);
                        ctx.moveTo(centerX, centerY - 10);
                        ctx.lineTo(centerX, centerY + 10);
                        ctx.stroke();
                    }
                    imageIndex++;
                }
                if (pageStartIndex + imageIndex >= selectedImages.length) break;
            }
        }

        // Create duplex back canvas for regular printing (not classified)
        createDuplexBackCanvas(pageIndex) {
            const config = this.printData.config;
            const dpi = config.dpi;
            
            // Calculate exact dimensions at full DPI
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            const paperWidthInches = paperWidthMm / 25.4;
            const paperHeightInches = paperHeightMm / 25.4;
            const exactWidthPx = Math.round(paperWidthInches * dpi);
            const exactHeightPx = Math.round(paperHeightInches * dpi);

            const canvas = document.createElement('canvas');
            canvas.width = exactWidthPx;
            canvas.height = exactHeightPx;
            const ctx = canvas.getContext('2d');

            // Enable high quality rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Render page with coordinate mirroring for duplex back
            this.renderBackPageToCanvas(canvas, ctx, pageIndex, config);

            // üö´ KH√îNG v·∫Ω cutting guides cho m·∫∑t sau (m·∫∑t tr∆∞·ªõc ƒë√£ c√≥ ƒë·ªß)
            // this.drawCuttingGuides(ctx, canvas, config);

            console.log(`Back duplex canvas created for page ${pageIndex} with coordinate mirroring`);
            return canvas;
        }

        async createDuplexBackCanvasClassified(pageIndex = 0) {
            console.log(`üé® Creating duplex back canvas for page ${pageIndex} with coordinate mirroring (NO image flipping)`);

            // === FIX: Ensure printData and arrays exist ===
            if (!this.printData) {
                console.error('‚ùå printData not initialized!');
                return null;
            }

            // Initialize arrays if they don't exist
            if (!this.printData.backImages) {
                this.printData.backImages = [];
                console.log('üîß Initialized empty backImages array');
            }

            const config = this.printData.config;
            const images = this.printData.backImages;

            console.log(`üì∏ Back images count: ${images.length} (page ${pageIndex})`);

            if (!images || images.length === 0) {
                console.log('‚ö†Ô∏è No back images to process');
                return null;
            }

            return new Promise((resolve) => {
                // Create proper img objects for each back image
                const processedImages = [];
                let loadedCount = 0;

                images.forEach((imgData, index) => {
                    console.log('üîç DEBUG Back image data:', {
                        index: index,
                        hasData: !!imgData.data,
                        hasSrc: !!imgData.src,
                        hasFilename: !!imgData.filename,
                        hasName: !!imgData.name,
                        dataLength: imgData.data ? imgData.data.length : 0,
                        srcValue: (imgData.data || imgData.src) ? (imgData.data || imgData.src).substring(0, 50) : 'EMPTY',
                        keys: Object.keys(imgData)
                    });

                    const img = new Image();
                    img.onload = () => {
                        processedImages[index] = {
                            src: imgData.data || imgData.src,  // üîß FIX: Gallery item uses 'data', not 'src'
                            img: img,
                            name: imgData.filename || imgData.name,  // üîß FIX: Gallery item uses 'filename', not 'name'
                            file: imgData.file
                        };
                        
                        loadedCount++;
                        if (loadedCount === images.length) {
                            // Create master canvas with exact dimensions
                            const dpi = config.dpi;
                            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
                            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
                            const paperWidthInches = paperWidthMm / 25.4;
                            const paperHeightInches = paperHeightMm / 25.4;
                            const exactWidthPx = Math.round(paperWidthInches * dpi);
                            const exactHeightPx = Math.round(paperHeightInches * dpi);

                            const masterCanvas = document.createElement('canvas');
                            masterCanvas.width = exactWidthPx;
                            masterCanvas.height = exactHeightPx;
                            const ctx = masterCanvas.getContext('2d');
                            
                            // Fill with white background
                            ctx.fillStyle = 'white';
                            ctx.fillRect(0, 0, masterCanvas.width, masterCanvas.height);
                            
                            // Temporarily replace selectedImages with back images
                            const originalSelectedImages = this.printData.selectedImages;
                            this.printData.selectedImages = processedImages;
                            
                            // Render page content with coordinate mirroring applied
                            // This will be handled in renderPageToCanvas with coordinate transformation
                            this.renderPageToCanvasWithCoordinateMirroring(masterCanvas, ctx, pageIndex, config);

                            // üö´ KH√îNG v·∫Ω cutting guides cho m·∫∑t sau (m·∫∑t tr∆∞·ªõc ƒë√£ c√≥ ƒë·ªß)
                            // this.drawCuttingGuides(ctx, masterCanvas, config);

                            // Restore original selectedImages
                            this.printData.selectedImages = originalSelectedImages;
                            
                            console.log('Back canvas created with coordinate mirroring only (no image flipping)');
                            resolve(masterCanvas);
                        }
                    };
                    img.onerror = () => {
                        console.error('Failed to load back image:', imgData.data || imgData.src);
                        loadedCount++;
                        if (loadedCount === images.length) {
                            resolve(null);
                        }
                    };
                    console.log('üîç Setting img.src for back image:', (imgData.data || imgData.src) ? (imgData.data || imgData.src).substring(0, 50) : 'UNDEFINED');
                    img.src = imgData.data || imgData.src;  // üîß FIX: Use 'data' field from gallery
                });
            });
        }

        async generatePDFFile() {
            const { jsPDF } = window.jspdf;
            const config = this.printData.config;
            
            if (config.printMode === 'duplex') {
                await this.generateDuplexPDF();
                return;
            }
            
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            
            // Create PDF with exact mm dimensions
            const pdf = new jsPDF({
                orientation: config.orientation === 'portrait' ? 'p' : 'l',
                unit: 'mm',
                format: [paperWidthMm, paperHeightMm]
            });

            for (let page = 0; page < this.printData.totalPages; page++) {
                if (page > 0) {
                    pdf.addPage();
                }
                
                // Use Master Canvas System for WYSIWYG export
                const masterCanvas = this.createMasterCanvas(page);
                const imgData = masterCanvas.toDataURL('image/jpeg', 1.0);
                pdf.addImage(imgData, 'JPEG', 0, 0, paperWidthMm, paperHeightMm);
                
                // Show progress
                if (this.printData.totalPages > 1) {
                    const progress = ((page + 1) / this.printData.totalPages * 100).toFixed(0);
                    const generateBtn = document.getElementById('generatePrintBtn');
                    if (generateBtn) {
                        generateBtn.textContent = `ƒêang t·∫°o PDF... ${progress}%`;
                    }
                }
            }

            // Create descriptive PDF filename
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
            const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages || 
                             config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';
            const pdfFileName = `print-layout_${paperWidthMm}x${paperHeightMm}mm_${config.dpi}DPI${guidesInfo}_${timestamp}.pdf`;
            
            pdf.save(pdfFileName);
            this.showToast(`‚úÖ ƒê√£ t·∫°o xong file PDF ${config.dpi}DPI k√≠ch th∆∞·ªõc ${paperWidthMm}√ó${paperHeightMm}mm (WYSIWYG)`, 'success');
        }

        async generateDuplexPDF() {
            const { jsPDF } = window.jspdf;
            const config = this.printData.config;

            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;

            console.log('Generating duplex PDF with classification:', {
                frontImages: this.printData.frontImages?.length || 0,
                backImages: this.printData.backImages?.length || 0,
                maxPhotosPerPage: this.printData.maxPhotosPerPage
            });

            // Check if we have classified images
            if (!this.printData.frontImages?.length && !this.printData.backImages?.length) {
                this.showToast('‚ö†Ô∏è Ch∆∞a c√≥ ·∫£nh n√†o ƒë∆∞·ª£c ph√¢n lo·∫°i cho duplex!', 'error');
                return;
            }

            // üìä Calculate pagination
            const maxPhotosPerPage = this.printData.maxPhotosPerPage || 1;
            const totalFrontPages = Math.ceil((this.printData.frontImages?.length || 0) / maxPhotosPerPage);
            const totalBackPages = Math.ceil((this.printData.backImages?.length || 0) / maxPhotosPerPage);

            console.log('üìÑ Duplex PDF pagination:', {
                maxPhotosPerPage,
                totalFrontPages,
                totalBackPages
            });

            if (totalFrontPages === 0 && totalBackPages === 0) {
                this.showToast('‚ö†Ô∏è Kh√¥ng c√≥ trang n√†o ƒë·ªÉ xu·∫•t!', 'error');
                return;
            }

            // Create separate PDFs for front and back sides (only if needed)
            const frontPdf = totalFrontPages > 0 ? new jsPDF({
                orientation: config.orientation === 'portrait' ? 'p' : 'l',
                unit: 'mm',
                format: [paperWidthMm, paperHeightMm]
            }) : null;

            const backPdf = totalBackPages > 0 ? new jsPDF({
                orientation: config.orientation === 'portrait' ? 'p' : 'l',
                unit: 'mm',
                format: [paperWidthMm, paperHeightMm]
            }) : null;

            const generateBtn = document.getElementById('generatePrintBtn');
            let frontPageCount = 0;
            let backPageCount = 0;
            
            // üìÑ Generate FRONT pages
            if (frontPdf && totalFrontPages > 0) {
                for (let pageIndex = 0; pageIndex < totalFrontPages; pageIndex++) {
                    if (frontPageCount > 0) {
                        frontPdf.addPage();
                    }

                    const frontCanvas = await this.createDuplexMasterCanvas('front', pageIndex);
                    if (frontCanvas) {
                        const imgData = frontCanvas.toDataURL('image/jpeg', 1.0);
                        frontPdf.addImage(imgData, 'JPEG', 0, 0, paperWidthMm, paperHeightMm);
                        frontPageCount++;

                        const progress = Math.round((frontPageCount / totalFrontPages) * 50);
                        if (generateBtn) generateBtn.textContent = `T·∫°o PDF m·∫∑t tr∆∞·ªõc... ${progress}%`;
                    }
                }
            }

            // üìÑ Generate BACK pages
            if (backPdf && totalBackPages > 0) {
                for (let pageIndex = 0; pageIndex < totalBackPages; pageIndex++) {
                    if (backPageCount > 0) {
                        backPdf.addPage();
                    }

                    const backCanvas = await this.createDuplexBackCanvasClassified(pageIndex);
                    if (backCanvas) {
                        const imgData = backCanvas.toDataURL('image/jpeg', 1.0);
                        backPdf.addImage(imgData, 'JPEG', 0, 0, paperWidthMm, paperHeightMm);
                        backPageCount++;

                        const progress = 50 + Math.round((backPageCount / totalBackPages) * 50);
                        if (generateBtn) generateBtn.textContent = `T·∫°o PDF m·∫∑t sau... ${progress}%`;
                    }
                }
            }

            // Generate filenames
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
            const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages ||
                             config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';

            // Save PDFs
            if (frontPdf) {
                const frontFileName = `FRONT_duplex-${config.duplexFlip}_${paperWidthMm}x${paperHeightMm}mm_${config.dpi}DPI${guidesInfo}_${timestamp}.pdf`;
                frontPdf.save(frontFileName);
            }

            if (backPdf) {
                // Small delay before second download
                await new Promise(resolve => setTimeout(resolve, 1000));
                const backFileName = `BACK_duplex-${config.duplexFlip}_${paperWidthMm}x${paperHeightMm}mm_${config.dpi}DPI${guidesInfo}_${timestamp}.pdf`;
                backPdf.save(backFileName);
            }

            if (generateBtn) {
                generateBtn.disabled = false;
                generateBtn.textContent = 'T·∫°o file PDF';
            }

            this.showToast(`‚úÖ ƒê√£ t·∫°o xong PDF Duplex: ${frontPageCount} trang tr∆∞·ªõc + ${backPageCount} trang sau`, 'success');
        }

        async saveToFileSystem() {
            // Ki·ªÉm tra h·ªó tr·ª£ File System Access API
            if (!('showDirectoryPicker' in window)) {
                this.showToast('‚ùå Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ File System Access API. Vui l√≤ng s·ª≠ d·ª•ng Chrome/Edge phi√™n b·∫£n m·ªõi', 'error');
                return;
            }

            const config = this.printData.config;
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
            const guidesInfo = config.cuttingGuides.outerCuttingLines || config.cuttingGuides.betweenImages ||
                             config.cuttingGuides.cornerMarks || config.cuttingGuides.gridHelperLines ? '_with-guides' : '';

            try {
                // Cho ph√©p ng∆∞·ªùi d√πng ch·ªçn th∆∞ m·ª•c
                const dirHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    startIn: 'documents'
                });

                const generateBtn = document.getElementById('generatePrintBtn');

                if (config.printMode === 'duplex') {
                    // Check if we have classified images
                    if (!this.printData.frontImages?.length && !this.printData.backImages?.length) {
                        this.showToast('‚ö†Ô∏è Ch∆∞a c√≥ ·∫£nh n√†o ƒë∆∞·ª£c ph√¢n lo·∫°i cho duplex!', 'error');
                        return;
                    }

                    // üìä Calculate pagination
                    const maxPhotosPerPage = this.printData.maxPhotosPerPage || 1;
                    const totalFrontPages = Math.ceil((this.printData.frontImages?.length || 0) / maxPhotosPerPage);
                    const totalBackPages = Math.ceil((this.printData.backImages?.length || 0) / maxPhotosPerPage);

                    console.log('üìÑ File System duplex pagination:', {
                        maxPhotosPerPage,
                        totalFrontPages,
                        totalBackPages
                    });

                    // T·∫°o th∆∞ m·ª•c con cho duplex
                    const folderName = `Duplex_${config.duplexFlip}_${timestamp}`;
                    const subDirHandle = await dirHandle.getDirectoryHandle(folderName, { create: true });

                    let fileCount = 0;

                    // üìÑ T·∫°o file m·∫∑t tr∆∞·ªõc
                    for (let pageIndex = 0; pageIndex < totalFrontPages; pageIndex++) {
                        const pageNumber = pageIndex + 1;
                        const frontCanvas = await this.createDuplexMasterCanvas('front', pageIndex);
                        if (frontCanvas) {
                            const blob = await new Promise(resolve => {
                                frontCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                            });

                            const fileName = `FRONT_page-${String(pageNumber).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                            const fileHandle = await subDirHandle.getFileHandle(fileName, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(blob);
                            await writable.close();

                            fileCount++;
                            const progress = Math.round((fileCount / (totalFrontPages + totalBackPages)) * 100);
                            if (generateBtn) generateBtn.textContent = `L∆∞u duplex... ${progress}%`;
                        }
                    }

                    // üìÑ T·∫°o file m·∫∑t sau
                    for (let pageIndex = 0; pageIndex < totalBackPages; pageIndex++) {
                        const pageNumber = pageIndex + 1;
                        const backCanvas = await this.createDuplexBackCanvasClassified(pageIndex);
                        if (backCanvas) {
                            const blob = await new Promise(resolve => {
                                backCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                            });

                            const fileName = `BACK_page-${String(pageNumber).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                            const fileHandle = await subDirHandle.getFileHandle(fileName, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(blob);
                            await writable.close();

                            fileCount++;
                            const progress = Math.round((fileCount / (totalFrontPages + totalBackPages)) * 100);
                            if (generateBtn) generateBtn.textContent = `L∆∞u duplex... ${progress}%`;
                        }
                    }

                    if (generateBtn) {
                        generateBtn.disabled = false;
                        generateBtn.textContent = 'L∆∞u v√†o File System';
                    }

                    this.showToast(`‚úÖ ƒê√£ l∆∞u ${fileCount} file duplex (${totalFrontPages} trang tr∆∞·ªõc + ${totalBackPages} trang sau) v√†o ${folderName}`, 'success');
                } else {
                    // Normal mode - l∆∞u tr·ª±c ti·∫øp v√†o th∆∞ m·ª•c ƒë√£ ch·ªçn
                    for (let page = 0; page < this.printData.totalPages; page++) {
                        const masterCanvas = this.createMasterCanvas(page);
                        const blob = await new Promise(resolve => {
                            masterCanvas.toBlob(resolve, 'image/jpeg', 1.0);
                        });

                        const fileName = `page-${String(page + 1).padStart(3, '0')}_${paperWidthMm}x${paperHeightMm}mm_${dpi}DPI${guidesInfo}.jpg`;
                        const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();

                        const progress = Math.round(((page + 1) / this.printData.totalPages) * 100);
                        if (generateBtn) generateBtn.textContent = `ƒêang l∆∞u... ${progress}%`;
                    }

                    this.showToast(`‚úÖ ƒê√£ l∆∞u ${this.printData.totalPages} trang JPG ${dpi}DPI v√†o File System`, 'success');
                }

            } catch (error) {
                if (error.name === 'AbortError') {
                    this.showToast('ƒê√£ h·ªßy ch·ªçn th∆∞ m·ª•c', 'info');
                } else {
                    console.error('L·ªói khi l∆∞u v√†o File System:', error);
                    this.showToast('‚ùå L·ªói khi l∆∞u file: ' + error.message, 'error');
                }
            }
        }

        generateCalibrationTest() {
            console.log('üìè Generating duplex calibration test...');

            const config = this.printData.config;
            const dpi = 300;

            // Create calibration canvas
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            const widthPx = Math.round(paperWidthMm / 25.4 * dpi);
            const heightPx = Math.round(paperHeightMm / 25.4 * dpi);

            // Front canvas
            const frontCanvas = document.createElement('canvas');
            frontCanvas.width = widthPx;
            frontCanvas.height = heightPx;
            const frontCtx = frontCanvas.getContext('2d');

            // Back canvas
            const backCanvas = document.createElement('canvas');
            backCanvas.width = widthPx;
            backCanvas.height = heightPx;
            const backCtx = backCanvas.getContext('2d');

            // Draw calibration pattern
            this.drawCalibrationPattern(frontCtx, frontCanvas, 'FRONT', config);
            this.drawCalibrationPattern(backCtx, backCanvas, 'BACK', config);

            // Download both files
            frontCanvas.toBlob(blob => {
                this.downloadBlob(blob, `Calibration_FRONT_${paperWidthMm}x${paperHeightMm}mm.jpg`);
            }, 'image/jpeg', 1.0);

            setTimeout(() => {
                backCanvas.toBlob(blob => {
                    this.downloadBlob(blob, `Calibration_BACK_${paperWidthMm}x${paperHeightMm}mm.jpg`);
                }, 'image/jpeg', 1.0);
            }, 500);

            this.showToast('üìè T·∫°o trang test th√†nh c√¥ng! In 2 file v√† ƒëo l·ªách.', 'success');
        }

        drawCalibrationPattern(ctx, canvas, label, config) {
            const dpi = 300;

            // White background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw border
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);

            // Draw center cross
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const crossSize = 50 * dpi / 25.4; // 50mm

            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;

            // Vertical line
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - crossSize);
            ctx.lineTo(centerX, centerY + crossSize);
            ctx.stroke();

            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(centerX - crossSize, centerY);
            ctx.lineTo(centerX + crossSize, centerY);
            ctx.stroke();

            // Draw grid (10mm spacing)
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 1;
            const gridSpacingPx = 10 / 25.4 * dpi; // 10mm

            for (let x = 0; x < canvas.width; x += gridSpacingPx) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y < canvas.height; y += gridSpacingPx) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw corner marks
            const markSize = 20;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;

            // Top-left
            ctx.beginPath();
            ctx.moveTo(30, 30);
            ctx.lineTo(30 + markSize, 30);
            ctx.moveTo(30, 30);
            ctx.lineTo(30, 30 + markSize);
            ctx.stroke();

            // Top-right
            ctx.beginPath();
            ctx.moveTo(canvas.width - 30, 30);
            ctx.lineTo(canvas.width - 30 - markSize, 30);
            ctx.moveTo(canvas.width - 30, 30);
            ctx.lineTo(canvas.width - 30, 30 + markSize);
            ctx.stroke();

            // Bottom-left
            ctx.beginPath();
            ctx.moveTo(30, canvas.height - 30);
            ctx.lineTo(30 + markSize, canvas.height - 30);
            ctx.moveTo(30, canvas.height - 30);
            ctx.lineTo(30, canvas.height - 30 - markSize);
            ctx.stroke();

            // Bottom-right
            ctx.beginPath();
            ctx.moveTo(canvas.width - 30, canvas.height - 30);
            ctx.lineTo(canvas.width - 30 - markSize, canvas.height - 30);
            ctx.moveTo(canvas.width - 30, canvas.height - 30);
            ctx.lineTo(canvas.width - 30, canvas.height - 30 - markSize);
            ctx.stroke();

            // Draw label
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, centerX, 80);

            // Draw instructions
            ctx.font = '24px Arial';
            ctx.fillText('In trang n√†y, l·∫≠t gi·∫•y, in trang kia', centerX, canvas.height - 50);
            ctx.fillText('ƒê·∫∑t ch·ªìng 2 trang l√™n nhau ƒë·ªÉ ƒëo l·ªách', centerX, canvas.height - 20);
        }

        renderPageToCanvas(canvas, ctx, pageIndex, config) {
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;

            // Enable high quality rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Clear canvas with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Use optimized layout dimensions
            const layout = this.printData.gridLayout;
            const photoWidthPx = Math.round(layout.photoWidth / 25.4 * dpi);
            const photoHeightPx = Math.round(layout.photoHeight / 25.4 * dpi);

            // Calculate positions with optimized spacing
            const marginLeftPx = Math.round(config.margins.left / 25.4 * dpi);
            const marginTopPx = Math.round(config.margins.top / 25.4 * dpi);
            const gutterXPx = Math.round(layout.actualSpacing.x / 25.4 * dpi);
            const gutterYPx = Math.round(layout.actualSpacing.y / 25.4 * dpi);

            // Calculate available area and center the grid
            const availableWidthPx = canvas.width - 2 * marginLeftPx;
            const availableHeightPx = canvas.height - 2 * marginTopPx;

            const totalGridWidth = layout.cols * photoWidthPx + (layout.cols - 1) * gutterXPx;
            const totalGridHeight = layout.rows * photoHeightPx + (layout.rows - 1) * gutterYPx;

            const startXPx = marginLeftPx + (availableWidthPx - totalGridWidth) / 2;
            const startYPx = marginTopPx + (availableHeightPx - totalGridHeight) / 2;

            const startIndex = pageIndex * this.printData.maxPhotosPerPage;
            const endIndex = Math.min(startIndex + this.printData.maxPhotosPerPage, this.printData.selectedImages.length);

            // üéØ Ki·ªÉm tra n·∫øu c√≥ exact positions (cho layout 6 ·∫£nh 5√ó15cm)
            if (layout.exactPositions && layout.exactPositions.length > 0) {
                console.log('üìç S·ª≠ d·ª•ng exact positions cho layout 6 ·∫£nh');

                let imageIndex = 0;
                for (let i = startIndex; i < endIndex && imageIndex < layout.exactPositions.length; i++) {
                    const imageData = this.printData.selectedImages[i];
                    if (!imageData || !imageData.img) continue;

                    const position = layout.exactPositions[imageIndex];
                    // Convert mm to px v√† offset v·ªõi margin + center
                    const xPx = startXPx + Math.round(position.x / 25.4 * dpi);
                    const yPx = startYPx + Math.round(position.y / 25.4 * dpi);
                    const wPx = Math.round(position.width / 25.4 * dpi);
                    const hPx = Math.round(position.height / 25.4 * dpi);

                    const actualRotation = position.rotation || 0;

                    console.log(`üìç ·∫¢nh ${imageIndex + 1}:`, {
                        x: position.x, y: position.y,
                        xPx, yPx, wPx, hPx,
                        rotation: actualRotation
                    });

                    // V·∫Ω ·∫£nh v·ªõi rotation ph√π h·ª£p - d√πng 'fit' ƒë·ªÉ kh√¥ng m√©o t·ª∑ l·ªá
                    const safeMode = 'fit'; // Force fit ƒë·ªÉ gi·ªØ t·ª∑ l·ªá ·∫£nh
                    if (actualRotation !== 0) {
                        console.log(`üîÑ Rendering v·ªõi rotation ${actualRotation}¬∞ cho ·∫£nh ${imageIndex + 1}`);
                        this.drawImageOnCanvasWithRotation(ctx, imageData.img, xPx, yPx, wPx, hPx, actualRotation, safeMode);
                    } else {
                        console.log(`‚û°Ô∏è Rendering kh√¥ng rotation cho ·∫£nh ${imageIndex + 1}`);
                        this.drawImageOnCanvas(ctx, imageData.img, xPx, yPx, wPx, hPx, safeMode);
                    }
                    imageIndex++;
                }
            } else {
                // Layout grid th√¥ng th∆∞·ªùng
                let imageIndex = 0;
                for (let i = startIndex; i < endIndex; i++) {
                    const imageData = this.printData.selectedImages[i];
                    if (!imageData || !imageData.img) continue;

                    const row = Math.floor(imageIndex / layout.cols);
                    const col = imageIndex % layout.cols;

                    const x = startXPx + col * (photoWidthPx + gutterXPx);
                    const y = startYPx + row * (photoHeightPx + gutterYPx);

                    this.drawImageOnCanvas(ctx, imageData.img, x, y, photoWidthPx, photoHeightPx, config.fitMode);
                    imageIndex++;
                }
            }
        }

        renderPageToCanvasWithCoordinateMirroring(canvas, ctx, pageIndex, config) {
            const dpi = config.dpi;
            const paperWidthMm = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMm = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;

            // Enable high quality rendering
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Clear canvas with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Use optimized layout dimensions
            const layout = this.printData.gridLayout;
            const photoWidthPx = Math.round(layout.photoWidth / 25.4 * dpi);
            const photoHeightPx = Math.round(layout.photoHeight / 25.4 * dpi);

            // Calculate positions with optimized spacing
            const marginLeftPx = Math.round(config.margins.left / 25.4 * dpi);
            const marginTopPx = Math.round(config.margins.top / 25.4 * dpi);
            const gutterXPx = Math.round(layout.actualSpacing.x / 25.4 * dpi);
            const gutterYPx = Math.round(layout.actualSpacing.y / 25.4 * dpi);

            // Calculate available area and center the grid
            const availableWidthPx = canvas.width - 2 * marginLeftPx;
            const availableHeightPx = canvas.height - 2 * marginTopPx;
            
            const totalGridWidth = layout.cols * photoWidthPx + (layout.cols - 1) * gutterXPx;
            const totalGridHeight = layout.rows * photoHeightPx + (layout.rows - 1) * gutterYPx;
            
            const startXPx = marginLeftPx + (availableWidthPx - totalGridWidth) / 2;
            const startYPx = marginTopPx + (availableHeightPx - totalGridHeight) / 2;

            const startIndex = pageIndex * this.printData.maxPhotosPerPage;
            const endIndex = Math.min(startIndex + this.printData.maxPhotosPerPage, this.printData.selectedImages.length);

            // üêõ DEBUG: Log render range
            console.log(`üñºÔ∏è Rendering page ${pageIndex}:`, {
                startIndex,
                endIndex,
                imagesInRange: endIndex - startIndex,
                maxPhotosPerPage: this.printData.maxPhotosPerPage,
                totalImages: this.printData.selectedImages.length
            });

            let imageIndex = 0;
            for (let i = startIndex; i < endIndex; i++) {
                const imageData = this.printData.selectedImages[i];
                if (!imageData || !imageData.img) continue;

                const row = Math.floor(imageIndex / layout.cols);
                const col = imageIndex % layout.cols;

                // Calculate original position
                const originalX = startXPx + col * (photoWidthPx + gutterXPx);
                const originalY = startYPx + row * (photoHeightPx + gutterYPx);

                // ‚úÖ FIX: X·ª≠ l√Ω kh√°c nhau cho Portrait vs Landscape
                let mirroredX, mirroredY;

                if (config.orientation === 'portrait') {
                    // üìê PORTRAIT (d·ªçc): XOAY 180¬∞ (mirror c·∫£ X v√† Y)
                    // Khi l·∫≠t gi·∫•y d·ªçc, c·∫ßn xoay 180¬∞ ch·ª© kh√¥ng ph·∫£i mirror ƒë∆°n gi·∫£n
                    const availableAreaCenterX = marginLeftPx + (canvas.width - 2 * marginLeftPx) / 2;
                    const availableAreaCenterY = marginTopPx + (canvas.height - 2 * marginTopPx) / 2;

                    // Xoay 180¬∞ = mirror c·∫£ X v√† Y qua center
                    const originalCenterX = originalX + photoWidthPx / 2;
                    const originalCenterY = originalY + photoHeightPx / 2;

                    const distanceFromCenterX = originalCenterX - availableAreaCenterX;
                    const distanceFromCenterY = originalCenterY - availableAreaCenterY;

                    const mirroredCenterX = availableAreaCenterX - distanceFromCenterX;
                    const mirroredCenterY = availableAreaCenterY - distanceFromCenterY;

                    mirroredX = mirroredCenterX - photoWidthPx / 2;
                    mirroredY = mirroredCenterY - photoHeightPx / 2;

                    console.log(`üîÑ PORTRAIT - Xoay 180¬∞: (${originalX.toFixed(0)}, ${originalY.toFixed(0)}) ‚Üí (${mirroredX.toFixed(0)}, ${mirroredY.toFixed(0)})`);
                } else {
                    // üìê LANDSCAPE (ngang): Mirror theo duplexFlip
                    if (config.duplexFlip === 'long-edge') {
                        // Long-edge binding: mirror theo tr·ª•c X qua center
                        const availableAreaCenterX = marginLeftPx + (canvas.width - 2 * marginLeftPx) / 2;

                        const originalCenterX = originalX + photoWidthPx / 2;
                        const distanceFromCenter = originalCenterX - availableAreaCenterX;
                        const mirroredCenterX = availableAreaCenterX - distanceFromCenter;
                        mirroredX = mirroredCenterX - photoWidthPx / 2;
                        mirroredY = originalY; // Y kh√¥ng ƒë·ªïi

                        console.log(`‚ÜîÔ∏è LANDSCAPE - Mirror X: (${originalX.toFixed(0)}, ${originalY.toFixed(0)}) ‚Üí (${mirroredX.toFixed(0)}, ${mirroredY.toFixed(0)})`);
                    } else {
                        // Short-edge binding: mirror theo tr·ª•c Y qua center
                        const availableAreaCenterY = marginTopPx + (canvas.height - 2 * marginTopPx) / 2;

                        const originalCenterY = originalY + photoHeightPx / 2;
                        const distanceFromCenter = originalCenterY - availableAreaCenterY;
                        const mirroredCenterY = availableAreaCenterY - distanceFromCenter;
                        mirroredX = originalX; // X kh√¥ng ƒë·ªïi
                        mirroredY = mirroredCenterY - photoHeightPx / 2;

                        console.log(`‚ÜïÔ∏è LANDSCAPE - Mirror Y: (${originalX.toFixed(0)}, ${originalY.toFixed(0)}) ‚Üí (${mirroredX.toFixed(0)}, ${mirroredY.toFixed(0)})`);
                    }
                }

                // ‚öôÔ∏è Apply physical offset (mm ‚Üí px)
                const offsetXPx = (config.duplexPhysicalOffset?.x || 0) * dpi / 25.4;
                const offsetYPx = (config.duplexPhysicalOffset?.y || 0) * dpi / 25.4;
                const finalX = mirroredX + offsetXPx;
                const finalY = mirroredY + offsetYPx;

                console.log(`Image ${i}: Original(${originalX.toFixed(0)},${originalY.toFixed(0)}) -> Mirrored(${mirroredX.toFixed(0)},${mirroredY.toFixed(0)}) -> Final(${finalX.toFixed(0)},${finalY.toFixed(0)}) [Offset: ${(config.duplexPhysicalOffset?.x || 0).toFixed(1)}mm, ${(config.duplexPhysicalOffset?.y || 0).toFixed(1)}mm]`);

                // V·∫Ω ·∫£nh ·ªü v·ªã tr√≠ ƒë√£ mirror + offset v·ªõi duplex transformation
                this.drawImageOnCanvasWithDuplexTransform(ctx, imageData.img, finalX, finalY, photoWidthPx, photoHeightPx, config.fitMode, config.duplexFlip);
                imageIndex++;
            }
        }

        // Helper function ƒë·ªÉ v·∫Ω ·∫£nh v·ªõi duplex transformation
        // ‚ö†Ô∏è L∆ØU √ù: T·ªça ƒë·ªô x,y ƒë√£ ƒë∆∞·ª£c mirror r·ªìi, CH·ªà v·∫Ω ·∫£nh b√¨nh th∆∞·ªùng
        // KH√îNG flip/rotate n·ªôi dung ·∫£nh (s·∫Ω l√†m ch·ªØ b·ªã ng∆∞·ª£c!)
        // ‚úÖ NEW: H·ªó tr·ª£ backSideBleed - ph√≥ng to ·∫£nh ƒë·ªÉ tr√°nh l·ªô vi·ªÅn tr·∫Øng
        drawImageOnCanvasWithDuplexTransform(ctx, img, x, y, width, height, fitMode, duplexFlip) {
            const config = this.printData.config;
            const imgAspect = img.width / img.height;
            const targetAspect = width / height;

            // üîç Calculate bleed (ph√≥ng to m·∫∑t sau)
            let bleedPx = 0;
            if (config.backSideBleedEnabled && config.backSideBleed > 0) {
                // Convert mm to px: (mm / 25.4) * dpi
                bleedPx = (config.backSideBleed / 25.4) * config.dpi;
                console.log(`üîç Applying bleed: ${config.backSideBleed}mm = ${bleedPx.toFixed(2)}px`);
            }

            // Calculate dimensions WITH bleed
            const targetWidthWithBleed = width + (bleedPx * 2);
            const targetHeightWithBleed = height + (bleedPx * 2);
            const targetAspectWithBleed = targetWidthWithBleed / targetHeightWithBleed;

            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;

            if (fitMode === 'fill') {
                if (imgAspect > targetAspectWithBleed) {
                    drawHeight = targetHeightWithBleed;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (targetWidthWithBleed - drawWidth) / 2;
                } else {
                    drawWidth = targetWidthWithBleed;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (targetHeightWithBleed - drawHeight) / 2;
                }
            } else {
                if (imgAspect > targetAspectWithBleed) {
                    drawWidth = targetWidthWithBleed;
                    drawHeight = drawWidth / imgAspect;
                    offsetY = (targetHeightWithBleed - drawHeight) / 2;
                } else {
                    drawHeight = targetHeightWithBleed;
                    drawWidth = drawHeight * imgAspect;
                    offsetX = (targetWidthWithBleed - drawWidth) / 2;
                }
            }

            // V·∫Ω n·ªÅn tr·∫Øng
            ctx.fillStyle = 'white';
            ctx.fillRect(x, y, width, height);

            // ‚úÖ FIX: Portrait c·∫ßn xoay N·ªòI DUNG ·∫£nh 180¬∞
            // Landscape th√¨ KH√îNG xoay (ch·ªâ mirror t·ªça ƒë·ªô)
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, width, height); // Clip v√†o khung g·ªëc
            ctx.clip();

            // üîÑ XOAY N·ªòI DUNG ·∫¢NH n·∫øu Portrait
            if (config.orientation === 'portrait') {
                // Xoay 180¬∞ qua t√¢m khung ·∫£nh
                const imageCenterX = x + width / 2;
                const imageCenterY = y + height / 2;
                ctx.translate(imageCenterX, imageCenterY);
                ctx.rotate(Math.PI); // 180¬∞
                ctx.translate(-imageCenterX, -imageCenterY);
                console.log(`üîÑ Rotating image content 180¬∞ for Portrait`);
            }

            // V·∫º ·∫¢NH (c√≥ bleed n·∫øu b·∫≠t)
            const drawX = x - bleedPx + offsetX;
            const drawY = y - bleedPx + offsetY;
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            ctx.restore();

            // V·∫Ω vi·ªÅn
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, width, height);
        }

        // Helper methods for compact interface
        applyPreset(preset) {
            console.log('üéØ Applying preset:', preset);
            
            const paperSizeSelect = document.getElementById('paperSizeSelect');
            const photoSizeSelect = document.getElementById('photoSizeSelect');
            const printModeSelect = document.getElementById('printModeSelect');
            const marginAll = document.getElementById('marginAll');
            
            switch(preset) {
                case 'standard-5.5x8.5':
                    if (paperSizeSelect) paperSizeSelect.value = 'a4';
                    if (photoSizeSelect) photoSizeSelect.value = '5.5x8.5';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 5;
                    this.printData.config.paperSize = { width: 210, height: 297 };
                    this.printData.config.photoSize = { width: 5.5, height: 8.5 };
                    this.printData.config.printMode = 'single';
                    this.printData.config.margins = { top: 5, bottom: 5, left: 5, right: 5 };
                    break;
                case 'standard-6x9':
                    if (paperSizeSelect) paperSizeSelect.value = 'a4';
                    if (photoSizeSelect) photoSizeSelect.value = '6x9';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 5;
                    this.printData.config.paperSize = { width: 210, height: 297 };
                    this.printData.config.photoSize = { width: 6, height: 9 };
                    this.printData.config.printMode = 'single';
                    this.printData.config.margins = { top: 5, bottom: 5, left: 5, right: 5 };
                    break;
                case 'standard-7x10':
                    if (paperSizeSelect) paperSizeSelect.value = 'a4';
                    if (photoSizeSelect) photoSizeSelect.value = '7x10';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 5;
                    this.printData.config.paperSize = { width: 210, height: 297 };
                    this.printData.config.photoSize = { width: 7, height: 10 };
                    this.printData.config.printMode = 'single';
                    this.printData.config.margins = { top: 5, bottom: 5, left: 5, right: 5 };
                    break;
                case 'standard-9.5x9.5':
                    if (paperSizeSelect) paperSizeSelect.value = 'a4';
                    if (photoSizeSelect) photoSizeSelect.value = '9.5x9.5';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 5;
                    this.printData.config.paperSize = { width: 297, height: 210 }; // A4 ngang (landscape)
                    this.printData.config.photoSize = { width: 9.5, height: 9.5 }; // ·∫¢nh vu√¥ng 9.5√ó9.5cm
                    this.printData.config.printMode = 'single';
                    this.printData.config.margins = { top: 5, bottom: 5, left: 5, right: 5 };
                    this.printData.config.orientation = 'landscape';
                    // C·∫≠p nh·∫≠t UI orientation buttons
                    document.querySelectorAll('.orient-btn, .orient-btn-elite').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.orient-btn[data-orientation="landscape"], .orient-btn-elite[data-orientation="landscape"]').forEach(b => b.classList.add('active'));
                    this.showToast('üìê A4 ngang - ·∫£nh 9.5√ó9.5cm vu√¥ng', 'success');
                    break;
                case 'paper-10x15':
                    if (paperSizeSelect) paperSizeSelect.value = 'custom';
                    if (photoSizeSelect) photoSizeSelect.value = 'custom';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 5;
                    this.printData.config.paperSize = { width: 100, height: 150 }; // 10√ó15cm = 100√ó150mm
                    this.printData.config.photoSize = { width: 9, height: 14 }; // ·∫¢nh v·ª´a v·ªõi l·ªÅ 5mm
                    this.printData.config.printMode = 'single';
                    this.printData.config.margins = { top: 5, bottom: 5, left: 5, right: 5 };
                    this.printData.config.orientation = 'portrait';
                    this.showToast('üìê Gi·∫•y 10√ó15cm - 1 ·∫£nh/trang', 'success');
                    break;
                case 'paper-a6':
                    if (paperSizeSelect) paperSizeSelect.value = 'custom';
                    if (photoSizeSelect) photoSizeSelect.value = 'custom';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 5;
                    this.printData.config.paperSize = { width: 105, height: 148 }; // A6 = 105√ó148mm
                    this.printData.config.photoSize = { width: 9.5, height: 13.8 }; // ·∫¢nh v·ª´a v·ªõi l·ªÅ 5mm
                    this.printData.config.printMode = 'single';
                    this.printData.config.margins = { top: 5, bottom: 5, left: 5, right: 5 };
                    this.printData.config.orientation = 'portrait';
                    this.showToast('üìê Gi·∫•y A6 (10.5√ó14.8cm) - 1 ·∫£nh/trang', 'success');
                    break;
                case 'paper-a5':
                    if (paperSizeSelect) paperSizeSelect.value = 'custom';
                    if (photoSizeSelect) photoSizeSelect.value = 'custom';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 5;
                    this.printData.config.paperSize = { width: 148, height: 210 }; // A5 = 148√ó210mm
                    this.printData.config.photoSize = { width: 6, height: 9 }; // ·∫¢nh 6√ó9cm ph√π h·ª£p
                    this.printData.config.printMode = 'single';
                    this.printData.config.margins = { top: 5, bottom: 5, left: 5, right: 5 };
                    this.printData.config.orientation = 'portrait';
                    this.showToast('üìê Gi·∫•y A5 (14.8√ó21cm) - t·ªëi ∆∞u ·∫£nh 6√ó9cm', 'success');
                    break;
                case 'sk316-namecard':
                    if (paperSizeSelect) paperSizeSelect.value = 'a4';
                    if (photoSizeSelect) photoSizeSelect.value = 'custom';
                    if (printModeSelect) printModeSelect.value = 'single';
                    if (marginAll) marginAll.value = 7.5;

                    // SK316 Standard: A4 D·ªåC, card 90√ó54mm NGANG, gutter 3mm c·ªë ƒë·ªãnh, grid 2√ó5
                    this.printData.config.paperSize = { width: 210, height: 297 }; // A4 portrait (d·ªçc)
                    this.printData.config.photoSize = { width: 9.0, height: 5.4 }; // 90√ó54mm namecard n·∫±m ngang
                    this.printData.config.printMode = 'single';

                    // T√≠nh to√°n margins ch√≠nh x√°c cho grid 2√ó5:
                    // Horizontal: (210 - (2*90 + 1*3)) / 2 = 13.5mm
                    // Vertical: (297 - (5*54 + 4*3)) / 2 = 7.5mm
                    this.printData.config.margins = {
                        top: 7.5,
                        bottom: 7.5,
                        left: 13.5,
                        right: 13.5
                    };
                    this.printData.config.orientation = 'portrait';

                    // Gutter 3mm c·ªë ƒë·ªãnh (blade spacing SK316)
                    this.printData.config.gutter = { x: 3, y: 3 };
                    const gutterXElem = document.getElementById('gutterX');
                    const gutterYElem = document.getElementById('gutterY');
                    if (gutterXElem) gutterXElem.value = 3;
                    if (gutterYElem) gutterYElem.value = 3;

                    // Update margin inputs v·ªõi gi√° tr·ªã ch√≠nh x√°c
                    const marginTopElem = document.getElementById('marginTop');
                    const marginBottomElem = document.getElementById('marginBottom');
                    const marginLeftElem = document.getElementById('marginLeft');
                    const marginRightElem = document.getElementById('marginRight');
                    if (marginTopElem) marginTopElem.value = 7.5;
                    if (marginBottomElem) marginBottomElem.value = 7.5;
                    if (marginLeftElem) marginLeftElem.value = 13.5;
                    if (marginRightElem) marginRightElem.value = 13.5;
                    if (marginAll) marginAll.value = 7.5; // Hi·ªÉn th·ªã margin nh·ªè nh·∫•t

                    // C·∫≠p nh·∫≠t UI orientation buttons
                    document.querySelectorAll('.orient-btn, .orient-btn-elite').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.orient-btn[data-orientation="portrait"], .orient-btn-elite[data-orientation="portrait"]').forEach(b => b.classList.add('active'));

                    this.showToast('‚úÇÔ∏è SK316: A4 d·ªçc, card 90√ó54mm, gutter 3mm, grid 2√ó5 = 10 cards', 'success');
                    break;
                case 'custom':
                    // Don't change anything, let user configure
                    this.showToast('üí° Ch·ªçn c√†i ƒë·∫∑t t√πy ch·ªânh - ƒëi·ªÅu ch·ªânh c√°c t√πy ch·ªçn b√™n d∆∞·ªõi', 'info');
                    break;
            }
            
            this.calculateLayout();
            this.showToast(`‚úÖ ƒê√£ √°p d·ª•ng preset: ${preset}`, 'success');
        }

        // Custom preset helpers
        getCurrentPrintConfigSnapshot() {
            const config = this.printData?.config || {};
            const marginAll = document.getElementById('marginAll');
            const marginValue = marginAll ? parseFloat(marginAll.value) : config.margins?.top || 0;
            return {
                id: Date.now(),
                name: '',
                paperSize: { ...config.paperSize },
                photoSize: { ...config.photoSize },
                margins: config.margins ? { ...config.margins } : { top: marginValue, bottom: marginValue, left: marginValue, right: marginValue },
                orientation: config.orientation || 'portrait',
                printMode: config.printMode || 'single',
                fitMode: config.fitMode || 'fill',
                duplexFlip: config.duplexFlip || 'long-edge',
                gutter: config.gutter ? { ...config.gutter } : { x: 5, y: 5 }
            };
        }

        loadCustomPresets() {
            try {
                const raw = localStorage.getItem('meu_print_custom_presets_v2');
                this.customPresets = raw ? JSON.parse(raw) : [];
            } catch (error) {
                console.warn('Cannot load custom presets:', error);
                this.customPresets = [];
            }
        }

        persistCustomPresets() {
            try {
                localStorage.setItem('meu_print_custom_presets_v2', JSON.stringify(this.customPresets || []));
            } catch (error) {
                console.warn('Cannot save custom presets:', error);
            }
        }

        renderCustomPresets() {
            const list = document.getElementById('customPresetsList');
            const empty = document.getElementById('customPresetsEmpty');
            if (!list) return;

            list.innerHTML = '';
            if (empty && empty.parentElement !== list) {
                list.appendChild(empty);
            }
            if (!this.customPresets || this.customPresets.length === 0) {
                if (empty) empty.style.display = 'inline';
                return;
            }
            if (empty) empty.style.display = 'none';

            this.customPresets.forEach(preset => {
                const pill = document.createElement('button');
                pill.type = 'button';
                pill.className = 'preset-pill custom-saved-pill';
                pill.textContent = preset.name || 'Preset';
                pill.title = 'Ap dung preset tuy chinh';
                pill.addEventListener('click', () => this.applyCustomPreset(preset));

                const removeBtn = document.createElement('span');
                removeBtn.className = 'remove-preset-btn';
                removeBtn.textContent = '√ó';
                removeBtn.title = 'Xoa preset';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteCustomPreset(preset.id);
                });

                pill.appendChild(removeBtn);
                list.appendChild(pill);
            });
        }

        saveCurrentCustomPreset() {
            if (!this.printData?.config) {
                this.showToast('Chua co cau hinh in de luu.', 'warning');
                return;
            }
            const name = prompt('Dat ten cho preset tuy chinh:');
            if (!name) return;

            const snapshot = this.getCurrentPrintConfigSnapshot();
            snapshot.id = Date.now();
            snapshot.name = name.trim();

            this.customPresets = this.customPresets || [];
            this.customPresets.unshift(snapshot);
            this.persistCustomPresets();
            this.renderCustomPresets();
            this.showToast('Da luu preset tuy chinh.', 'success');
        }

        applyCustomPreset(preset) {
            if (!preset) return;
            if (!this.printData?.config) {
                this.initializePrintSection();
            }

            this.printData.config.paperSize = { ...preset.paperSize };
            this.printData.config.photoSize = { ...preset.photoSize };
            this.printData.config.margins = { ...preset.margins };
            this.printData.config.orientation = preset.orientation || 'portrait';
            this.printData.config.printMode = preset.printMode || 'single';
            this.printData.config.fitMode = preset.fitMode || 'fill';
            this.printData.config.duplexFlip = preset.duplexFlip || this.printData.config.duplexFlip;
            if (preset.gutter) this.printData.config.gutter = { ...preset.gutter };

            const paperSizeSelect = document.getElementById('paperSizeSelect');
            if (paperSizeSelect) paperSizeSelect.value = 'custom';
            const photoSizeSelect = document.getElementById('photoSizeSelect');
            if (photoSizeSelect) photoSizeSelect.value = 'custom';

            const paperWidth = document.getElementById('paperWidth');
            const paperHeight = document.getElementById('paperHeight');
            if (paperWidth && paperHeight) {
                paperWidth.value = this.printData.config.paperSize.width;
                paperHeight.value = this.printData.config.paperSize.height;
            }

            const photoWidth = document.getElementById('previewCustomWidth') || document.getElementById('photoWidth');
            const photoHeight = document.getElementById('previewCustomHeight') || document.getElementById('photoHeight');
            if (photoWidth && photoHeight) {
                photoWidth.value = this.printData.config.photoSize.width;
                photoHeight.value = this.printData.config.photoSize.height;
            }

            const marginAllInput = document.getElementById('marginAll');
            if (marginAllInput && typeof this.printData.config.margins?.top === 'number') {
                marginAllInput.value = this.printData.config.margins.top;
            }
            const marginMap = { marginTop: 'top', marginBottom: 'bottom', marginLeft: 'left', marginRight: 'right' };
            Object.entries(marginMap).forEach(([id, key]) => {
                const input = document.getElementById(id);
                if (input && this.printData.config.margins && typeof this.printData.config.margins[key] === 'number') {
                    input.value = this.printData.config.margins[key];
                }
            });

            document.querySelectorAll('.orient-btn, .orient-btn-elite').forEach(b => b.classList.remove('active'));
            const orientSelector = `.orient-btn[data-orientation="${this.printData.config.orientation}"], .orient-btn-elite[data-orientation="${this.printData.config.orientation}"]`;
            document.querySelectorAll(orientSelector).forEach(b => b.classList.add('active'));

            const printModeSelect = document.getElementById('printModeSelect');
            if (printModeSelect) printModeSelect.value = this.printData.config.printMode;

            document.querySelectorAll('.fit-btn').forEach(b => b.classList.remove('active'));
            const fitBtn = document.querySelector(`.fit-btn[data-fit="${this.printData.config.fitMode}"]`);
            if (fitBtn) fitBtn.classList.add('active');

            this.toggleDuplexInterface(this.printData.config.printMode === 'duplex');
            this.calculateLayout();
            this.updatePreview();
            this.showToast(`Da ap dung preset: ${preset.name || 'Tuy chinh'}`, 'success');
        }

        deleteCustomPreset(id) {
            this.customPresets = (this.customPresets || []).filter(preset => preset.id !== id);
            this.persistCustomPresets();
            this.renderCustomPresets();
            this.showToast('Da xoa preset.', 'info');
        }

        // ============ SAVED PRESETS SECTION - NEW FEATURES ============

        setupSavedPresetsSection() {
            const section = document.getElementById('savedPresetsSection');
            if (!section) return;

            // Always show section (even when empty) so users can save first preset
            section.style.display = 'block';

            // Render saved presets as cards
            this.renderSavedPresetsCards();

            // Setup modal
            this.setupPresetModal();

            // Save new preset button
            const saveNewBtn = document.getElementById('saveNewPresetBtn');
            if (saveNewBtn) {
                saveNewBtn.addEventListener('click', () => this.showPresetModal());
            }

            // Import preset button
            const importBtn = document.getElementById('importPresetBtn');
            if (importBtn) {
                importBtn.addEventListener('click', () => this.importPresets());
            }

            // Export all presets button
            const exportAllBtn = document.getElementById('exportAllPresetsBtn');
            if (exportAllBtn) {
                exportAllBtn.addEventListener('click', () => this.exportAllPresets());
            }
        }

        renderSavedPresetsCards() {
            const grid = document.getElementById('savedPresetsGrid');
            const section = document.getElementById('savedPresetsSection');
            if (!grid) return;

            // Clear grid
            grid.innerHTML = '';

            // Check if there are presets
            if (!this.customPresets || this.customPresets.length === 0) {
                grid.innerHTML = `
                    <div class="no-presets-message">
                        <span class="no-preset-icon">üì≠</span>
                        <p>Ch∆∞a c√≥ preset n√†o ƒë∆∞·ª£c l∆∞u</p>
                        <small>Nh·∫•n "L∆∞u m·ªõi" ƒë·ªÉ l∆∞u c·∫•u h√¨nh hi·ªán t·∫°i</small>
                    </div>
                `;
                if (section) section.style.display = 'none';
                return;
            }

            // Show section
            if (section) section.style.display = 'block';

            // Render preset cards
            this.customPresets.forEach(preset => {
                const card = this.createPresetCard(preset);
                grid.appendChild(card);
            });
        }

        createPresetCard(preset) {
            const card = document.createElement('div');
            card.className = 'preset-card';
            card.dataset.presetId = preset.id;

            // Format display values
            const paperSize = `${preset.paperSize.width}√ó${preset.paperSize.height}mm`;
            const photoSize = `${preset.photoSize.width}√ó${preset.photoSize.height}cm`;
            const margins = `${preset.margins.top}mm`;
            const orientation = preset.orientation === 'portrait' ? 'D·ªçc' : 'Ngang';

            card.innerHTML = `
                <div class="preset-card-actions">
                    <button class="preset-card-action edit" title="Ch·ªânh s·ª≠a">‚úèÔ∏è</button>
                    <button class="preset-card-action duplicate" title="Sao ch√©p">üìã</button>
                    <button class="preset-card-action export" title="Export">üì§</button>
                    <button class="preset-card-action delete" title="X√≥a">üóëÔ∏è</button>
                </div>
                <div class="preset-card-header">
                    <div class="preset-icon">${preset.icon || 'üìÑ'}</div>
                    <div class="preset-info">
                        <div class="preset-name">${preset.name || 'Preset'}</div>
                        ${preset.description ? `<div class="preset-description">${preset.description}</div>` : ''}
                    </div>
                </div>
                <div class="preset-details">
                    <div class="preset-detail-item">
                        <span class="preset-detail-label">üìÑ Gi·∫•y:</span>
                        <span class="preset-detail-value">${paperSize}</span>
                    </div>
                    <div class="preset-detail-item">
                        <span class="preset-detail-label">üñºÔ∏è ·∫¢nh:</span>
                        <span class="preset-detail-value">${photoSize}</span>
                    </div>
                    <div class="preset-detail-item">
                        <span class="preset-detail-label">üìè L·ªÅ:</span>
                        <span class="preset-detail-value">${margins}</span>
                    </div>
                    <div class="preset-detail-item">
                        <span class="preset-detail-label">‚Üª H∆∞·ªõng:</span>
                        <span class="preset-detail-value">${orientation}</span>
                    </div>
                </div>
            `;

            // Click to apply preset
            card.addEventListener('click', (e) => {
                // Don't apply if clicking action buttons
                if (e.target.closest('.preset-card-action')) return;

                // Remove active from all cards
                document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');

                this.applyCustomPreset(preset);
            });

            // Setup action buttons
            const editBtn = card.querySelector('.preset-card-action.edit');
            const duplicateBtn = card.querySelector('.preset-card-action.duplicate');
            const exportBtn = card.querySelector('.preset-card-action.export');
            const deleteBtn = card.querySelector('.preset-card-action.delete');

            if (editBtn) {
                editBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.showPresetModal(preset);
                });
            }

            if (duplicateBtn) {
                duplicateBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.duplicatePreset(preset);
                });
            }

            if (exportBtn) {
                exportBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.exportPreset(preset);
                });
            }

            if (deleteBtn) {
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm(`X√≥a preset "${preset.name}"?`)) {
                        this.deleteCustomPreset(preset.id);
                        this.renderSavedPresetsCards();
                    }
                });
            }

            return card;
        }

        setupPresetModal() {
            const modal = document.getElementById('presetModal');
            const closeBtn = document.getElementById('closePresetModal');
            const cancelBtn = document.getElementById('cancelPresetSave');
            const confirmBtn = document.getElementById('confirmPresetSave');

            if (!modal) return;

            // Close modal handlers
            if (closeBtn) {
                closeBtn.addEventListener('click', () => this.hidePresetModal());
            }
            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => this.hidePresetModal());
            }

            // Confirm save
            if (confirmBtn) {
                confirmBtn.addEventListener('click', () => this.savePresetFromModal());
            }

            // Icon picker
            document.querySelectorAll('.icon-option').forEach(icon => {
                icon.addEventListener('click', () => {
                    document.querySelectorAll('.icon-option').forEach(i => i.classList.remove('active'));
                    icon.classList.add('active');
                });
            });

            // Click outside to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) this.hidePresetModal();
            });
        }

        showPresetModal(existingPreset = null) {
            const modal = document.getElementById('presetModal');
            const title = document.getElementById('presetModalTitle');
            const nameInput = document.getElementById('presetName');
            const descInput = document.getElementById('presetDescription');

            if (!modal) return;

            // Set modal mode
            this.editingPresetId = existingPreset ? existingPreset.id : null;

            // Update title
            if (title) {
                title.textContent = existingPreset ? '‚úèÔ∏è Ch·ªânh s·ª≠a preset' : 'üíæ L∆∞u preset m·ªõi';
            }

            // Fill form if editing
            if (existingPreset) {
                if (nameInput) nameInput.value = existingPreset.name || '';
                if (descInput) descInput.value = existingPreset.description || '';

                // Select icon
                document.querySelectorAll('.icon-option').forEach(icon => {
                    icon.classList.remove('active');
                    if (icon.dataset.icon === existingPreset.icon) {
                        icon.classList.add('active');
                    }
                });
            } else {
                if (nameInput) nameInput.value = '';
                if (descInput) descInput.value = '';
                document.querySelectorAll('.icon-option').forEach((icon, i) => {
                    icon.classList.remove('active');
                    if (i === 0) icon.classList.add('active');
                });
            }

            // Update preview
            this.updatePresetConfigPreview();

            // Show modal
            modal.style.display = 'flex';
        }

        hidePresetModal() {
            const modal = document.getElementById('presetModal');
            if (modal) modal.style.display = 'none';
            this.editingPresetId = null;
        }

        updatePresetConfigPreview() {
            const config = this.printData?.config;
            if (!config) return;

            const paperSize = `${config.paperSize.width}√ó${config.paperSize.height}mm`;
            const photoSize = `${config.photoSize.width}√ó${config.photoSize.height}cm`;
            const margins = `${config.margins.top}mm`;

            // Calculate grid
            const paperWidthMM = config.orientation === 'portrait' ? config.paperSize.width : config.paperSize.height;
            const paperHeightMM = config.orientation === 'portrait' ? config.paperSize.height : config.paperSize.width;
            const photoWidthMM = config.photoSize.width * 10;
            const photoHeightMM = config.photoSize.height * 10;
            const availableWidth = paperWidthMM - config.margins.left - config.margins.right;
            const availableHeight = paperHeightMM - config.margins.top - config.margins.bottom;
            const cols = Math.floor((availableWidth + config.gutter.x) / (photoWidthMM + config.gutter.x));
            const rows = Math.floor((availableHeight + config.gutter.y) / (photoHeightMM + config.gutter.y));
            const grid = `${cols}√ó${rows} (${cols * rows} ·∫£nh)`;

            document.getElementById('previewPaperSize').textContent = paperSize;
            document.getElementById('previewPhotoSize').textContent = photoSize;
            document.getElementById('previewMargins').textContent = margins;
            document.getElementById('previewGrid').textContent = grid;
        }

        savePresetFromModal() {
            const nameInput = document.getElementById('presetName');
            const descInput = document.getElementById('presetDescription');
            const selectedIcon = document.querySelector('.icon-option.active');

            const name = nameInput ? nameInput.value.trim() : '';
            if (!name) {
                this.showToast('Vui l√≤ng nh·∫≠p t√™n preset!', 'error');
                return;
            }

            const description = descInput ? descInput.value.trim() : '';
            const icon = selectedIcon ? selectedIcon.dataset.icon : 'üìÑ';

            // Get current config
            const snapshot = this.getCurrentPrintConfigSnapshot();
            snapshot.name = name;
            snapshot.description = description;
            snapshot.icon = icon;

            if (this.editingPresetId) {
                // Update existing preset
                const index = this.customPresets.findIndex(p => p.id === this.editingPresetId);
                if (index !== -1) {
                    snapshot.id = this.editingPresetId;
                    this.customPresets[index] = snapshot;
                    this.showToast('‚úÖ ƒê√£ c·∫≠p nh·∫≠t preset!', 'success');
                }
            } else {
                // Create new preset
                snapshot.id = Date.now();
                this.customPresets = this.customPresets || [];
                this.customPresets.unshift(snapshot);
                this.showToast('‚úÖ ƒê√£ l∆∞u preset m·ªõi!', 'success');
            }

            this.persistCustomPresets();
            this.renderSavedPresetsCards();
            this.hidePresetModal();
        }

        duplicatePreset(preset) {
            const newPreset = {
                ...preset,
                id: Date.now(),
                name: `${preset.name} (copy)`,
                paperSize: { ...preset.paperSize },
                photoSize: { ...preset.photoSize },
                margins: { ...preset.margins },
                gutter: preset.gutter ? { ...preset.gutter } : { x: 5, y: 5 }
            };

            this.customPresets = this.customPresets || [];
            this.customPresets.unshift(newPreset);
            this.persistCustomPresets();
            this.renderSavedPresetsCards();
            this.showToast('‚úÖ ƒê√£ sao ch√©p preset!', 'success');
        }

        exportPreset(preset) {
            const dataStr = JSON.stringify(preset, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `preset_${preset.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`;
            link.click();
            URL.revokeObjectURL(url);
            this.showToast('üì§ ƒê√£ export preset!', 'success');
        }

        exportAllPresets() {
            if (!this.customPresets || this.customPresets.length === 0) {
                this.showToast('Kh√¥ng c√≥ preset n√†o ƒë·ªÉ export!', 'warning');
                return;
            }

            const dataStr = JSON.stringify(this.customPresets, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `all_presets_${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
            this.showToast(`üì§ ƒê√£ export ${this.customPresets.length} preset!`, 'success');
        }

        importPresets() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    // Check if single preset or array
                    const presets = Array.isArray(data) ? data : [data];

                    // Validate presets
                    const validPresets = presets.filter(p =>
                        p.name && p.paperSize && p.photoSize && p.margins
                    );

                    if (validPresets.length === 0) {
                        this.showToast('File kh√¥ng h·ª£p l·ªá!', 'error');
                        return;
                    }

                    // Add new IDs to avoid conflicts
                    validPresets.forEach(p => {
                        p.id = Date.now() + Math.random();
                    });

                    // Merge with existing presets
                    this.customPresets = this.customPresets || [];
                    this.customPresets.unshift(...validPresets);
                    this.persistCustomPresets();
                    this.renderSavedPresetsCards();
                    this.showToast(`üì• ƒê√£ import ${validPresets.length} preset!`, 'success');

                } catch (error) {
                    console.error('Import error:', error);
                    this.showToast('L·ªói khi ƒë·ªçc file!', 'error');
                }
            };
            input.click();
        }

        // ============ END SAVED PRESETS SECTION ============

        applyCuttingPreset(cutting) {
            console.log('‚úÇÔ∏è Applying cutting preset:', cutting);
            
            const outerCuttingLines = document.getElementById('outerCuttingLines');
            const betweenImages = document.getElementById('betweenImages');
            const cornerMarks = document.getElementById('cornerMarks');
            const gridHelperLines = document.getElementById('gridHelperLines');
            
            switch(cutting) {
                case 'standard':
                    if (outerCuttingLines) outerCuttingLines.checked = true;
                    if (betweenImages) betweenImages.checked = true;
                    if (cornerMarks) cornerMarks.checked = false;
                    // Sync preview button
                    const previewCornerBtn1 = document.getElementById('previewCornerMarks');
                    if (previewCornerBtn1) previewCornerBtn1.classList.remove('active');
                    if (gridHelperLines) gridHelperLines.checked = false;
                    this.printData.config.cuttingGuides = {
                        ...this.printData.config.cuttingGuides,
                        outerCuttingLines: true,
                        betweenImages: true,
                        cornerMarks: false,
                        gridHelperLines: false
                    };
                    break;
                case 'minimal':
                    if (outerCuttingLines) outerCuttingLines.checked = true;
                    if (betweenImages) betweenImages.checked = false;
                    if (cornerMarks) cornerMarks.checked = false;
                    // Sync preview button
                    const previewCornerBtn2 = document.getElementById('previewCornerMarks');
                    if (previewCornerBtn2) previewCornerBtn2.classList.remove('active');
                    if (gridHelperLines) gridHelperLines.checked = false;
                    this.printData.config.cuttingGuides = {
                        ...this.printData.config.cuttingGuides,
                        outerCuttingLines: true,
                        betweenImages: false,
                        cornerMarks: false,
                        gridHelperLines: false
                    };
                    break;
                case 'detailed':
                    if (outerCuttingLines) outerCuttingLines.checked = true;
                    if (betweenImages) betweenImages.checked = true;
                    if (cornerMarks) cornerMarks.checked = true;
                    // Sync preview button
                    const previewCornerBtn3 = document.getElementById('previewCornerMarks');
                    if (previewCornerBtn3) previewCornerBtn3.classList.add('active');
                    if (gridHelperLines) gridHelperLines.checked = true;
                    this.printData.config.cuttingGuides = {
                        ...this.printData.config.cuttingGuides,
                        outerCuttingLines: true,
                        betweenImages: true,
                        cornerMarks: true,
                        gridHelperLines: true
                    };
                    break;
                case 'custom':
                    // Show custom options
                    const customOptions = document.getElementById('cuttingCustomOptions');
                    if (customOptions) {
                        customOptions.style.display = customOptions.style.display === 'none' ? 'block' : 'none';
                    }
                    break;
            }
            
            this.updateMasterCanvas();
            this.showToast(`‚úÖ ƒê√£ √°p d·ª•ng c√†i ƒë·∫∑t ƒë∆∞·ªùng c·∫Øt: ${cutting}`, 'success');
        }

        generatePreview() {
            console.log('üîç Generating preview');
            
            if (!this.printData.selectedImages || this.printData.selectedImages.length === 0) {
                this.showToast('‚ö†Ô∏è Ch∆∞a c√≥ ·∫£nh n√†o ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ xem tr∆∞·ªõc!', 'warning');
                return;
            }
            
            // Show preview container
            const previewContainer = document.getElementById('printPreviewContainer');
            if (previewContainer) {
                previewContainer.style.display = 'block';
                this.updateMasterCanvas();
                this.showToast('‚úÖ ƒê√£ t·∫°o b·∫£n xem tr∆∞·ªõc!', 'success');
                
                // Scroll to preview
                previewContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
            
            // Enable generate print button
            const generatePrintBtn = document.getElementById('generatePrintBtn');
            if (generatePrintBtn) {
                generatePrintBtn.disabled = false;
            }
        }

        resetToDefaults() {
            console.log('üîÑ Resetting to defaults');
            
            // Reset config to defaults
            this.printData.config = {
                paperSize: { width: 210, height: 297 }, // A4
                photoSize: { width: 5.5, height: 8.5 },
                margins: { top: 5, bottom: 5, left: 5, right: 5 },
                gutter: { x: 5, y: 5 },
                dpi: 300,
                orientation: 'portrait',
                fitMode: 'fill',
                printMode: 'single',
                duplexFlip: 'long-edge',
                cuttingGuides: {
                    outerCuttingLines: true,
                    betweenImages: true,
                    cornerMarks: false,
                    gridHelperLines: false,
                    color: '#000000',
                    thickness: 0.5,
                    lineStyle: 'solid'
                }
            };
            
            // Reset UI elements
            const paperSizeSelect = document.getElementById('paperSizeSelect');
            const photoSizeSelect = document.getElementById('photoSizeSelect');
            const printModeSelect = document.getElementById('printModeSelect');
            const marginAll = document.getElementById('marginAll');
            
            if (paperSizeSelect) paperSizeSelect.value = 'a4';
            if (photoSizeSelect) photoSizeSelect.value = '5.5x8.5';
            if (printModeSelect) printModeSelect.value = 'single';
            if (marginAll) marginAll.value = 10;
            
            // Reset active states
            document.querySelectorAll('.preset-pill').forEach(c => c.classList.remove('active'));
            document.querySelector('.preset-pill[data-preset="standard-5.5x8.5"]')?.classList.add('active');
            
            document.querySelectorAll('.orient-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.orient-btn[data-orientation="portrait"]')?.classList.add('active');
            
            document.querySelectorAll('.fit-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.fit-btn[data-fit="fill"]')?.classList.add('active');
            
            this.calculateLayout();
            this.showToast('üîÑ ƒê√£ reset v·ªÅ c√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh!', 'success');
        }

        toggleDuplexInterface(isDuplex) {
            console.log('üîÑ toggleDuplexInterface called with isDuplex:', isDuplex);

            const duplexConfig = document.getElementById('duplexConfigCompact');
            const duplexConfigInline = document.getElementById('duplexConfigInline');
            const duplexSection = document.getElementById('duplexClassificationSection');
            const duplexCanvasContainer = document.getElementById('duplexCanvasContainer');
            const singleCanvasContainer = document.getElementById('canvasContainer');
            const duplexOffsetSection = document.getElementById('duplexOffsetSection');

            // Distribution sections
            const singleDistSection = document.getElementById('imageDistributionSection');
            const duplexDistSection = document.getElementById('duplexDistributionSection');

            if (isDuplex) {
                // Show inline duplex config (new compact layout)
                if (duplexConfigInline) duplexConfigInline.style.display = 'block';

                // Show old duplex config (in ƒê∆∞·ªùng c·∫Øt section)
                if (duplexConfig) duplexConfig.style.display = 'block';

                // === IMPORTANT: DO NOT show legacy sections - using Unified Workspace now ===
                // if (duplexSection) duplexSection.style.display = 'block';  // DISABLED - use unified workspace
                if (duplexOffsetSection) duplexOffsetSection.style.display = 'flex'; // Keep offset controls

                // Hide distribution sections - unified workspace has its own
                if (singleDistSection) singleDistSection.style.display = 'none';
                // if (duplexDistSection) duplexDistSection.style.display = 'block';  // DISABLED - use unified workspace

                // === FIX: Immediately show duplex canvas ===
                if (singleCanvasContainer) {
                    singleCanvasContainer.style.display = 'none';
                    console.log('‚úÖ Single canvas hidden');
                }
                if (duplexCanvasContainer) {
                    duplexCanvasContainer.style.display = 'flex';
                    console.log('‚úÖ Duplex canvas shown (from toggleDuplexInterface)');
                }

                // === FIX: Call showDuplexMode to initialize properly ===
                // Reset flag to allow re-initialization
                this._duplexModeInitialized = false;
                console.log('‚úÖ Calling showDuplexMode to initialize duplex V2');
                this.showDuplexMode();
            } else {
                // Hide inline duplex config
                if (duplexConfigInline) duplexConfigInline.style.display = 'none';

                if (duplexConfig) duplexConfig.style.display = 'none';
                if (duplexSection) duplexSection.style.display = 'none';
                if (duplexOffsetSection) duplexOffsetSection.style.display = 'none';

                // Hide duplex distribution, show single distribution (if needed)
                if (duplexDistSection) duplexDistSection.style.display = 'none';
                // singleDistSection will be shown by updateImageDistributionDisplay() if needed

                // Call hideDuplexMode to cleanup
                this.hideDuplexMode();
            }

            // Update distribution stats
            if (isDuplex) {
                this.updateDuplexDistributionStats();
            }
        }

        downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Progress bar management functions
        showProgress(fileId, text = 'ƒêang x·ª≠ l√Ω...') {
            const progressEl = document.getElementById(`progress-${fileId}`);
            if (progressEl) {
                progressEl.classList.add('show');
                this.updateProgress(fileId, 0, text);
            }
        }

        hideProgress(fileId) {
            const progressEl = document.getElementById(`progress-${fileId}`);
            if (progressEl) {
                progressEl.classList.remove('show');
            }
        }

        updateProgress(fileId, percentage, text, timeInfo = '') {
            const fillEl = document.getElementById(`progress-fill-${fileId}`);
            const textEl = document.getElementById(`progress-text-${fileId}`);
            const timeEl = document.getElementById(`progress-time-${fileId}`);

            if (fillEl) fillEl.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
            if (textEl) textEl.textContent = text;
            if (timeEl) timeEl.textContent = timeInfo;
        }

        formatTimeRemaining(seconds) {
            if (seconds < 60) return `~${Math.ceil(seconds)}s`;
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.ceil(seconds % 60);
            return `~${minutes}m ${remainingSeconds}s`;
        }

        // Global HEIC check function
        isHEICFile(file) {
            if (!file || !file.name) return false;
            const fileName = file.name.toLowerCase();
            return (fileName.endsWith('.heic') || fileName.endsWith('.heif')) && 
                   (!file.type || !file.type.startsWith('image/') || 
                    file.type === 'image/heic' || file.type === 'image/heif');
        }

        // Safe create object URL - returns null for HEIC files
        safeCreateObjectURL(file) {
            if (!file) {
                console.warn('safeCreateObjectURL called with null file');
                return null;
            }
            if (this.isHEICFile(file)) {
                console.log('Skipping blob URL creation for HEIC file:', file.name);
                return null;
            }
            return URL.createObjectURL(file);
        }

        // Upload Progress Management
        showUploadProgress(totalFiles) {
            const overlay = document.getElementById('uploadProgressOverlay');
            const currentFile = document.getElementById('uploadCurrentFile');
            const overallText = document.getElementById('uploadOverallText');
            const overallFill = document.getElementById('uploadOverallFill');
            
            if (overlay) overlay.classList.add('show');
            if (currentFile) currentFile.textContent = 'ƒêang chu·∫©n b·ªã...';
            if (overallText) overallText.textContent = `ƒêang x·ª≠ l√Ω 0/${totalFiles} files`;
            if (overallFill) overallFill.style.width = '0%';
            
            this.uploadProgress = {
                total: totalFiles,
                completed: 0,
                startTime: Date.now(),
                currentIndex: 0
            };
        }

        updateSingleUploadProgress(fileName, status, currentIndex, stepProgress = 0) {
            const currentFile = document.getElementById('uploadCurrentFile');
            const overallText = document.getElementById('uploadOverallText');
            const overallFill = document.getElementById('uploadOverallFill');
            const overallTime = document.getElementById('uploadOverallTime');
            
            // Update current file display with styling
            if (currentFile) {
                const statusIcon = this.getStatusIcon(status);
                currentFile.textContent = `${statusIcon} ${fileName} - ${status}`;
                
                // Update CSS classes based on status
                currentFile.className = 'upload-current-file';
                if (status.includes('‚úÖ') || status.includes('Ho√†n th√†nh')) {
                    currentFile.classList.add('success');
                } else if (status.includes('‚ùå') || status.includes('Kh√¥ng h·ª£p l·ªá')) {
                    currentFile.classList.add('error');
                } else if (status.includes('‚ö†Ô∏è') || status.includes('tr√πng l·∫∑p')) {
                    currentFile.classList.add('error');
                } else {
                    currentFile.classList.add('processing');
                }
            }
            
            // Calculate overall progress
            const baseProgress = (currentIndex / this.uploadProgress.total) * 100;
            const stepProgressPercent = (stepProgress / this.uploadProgress.total) * 100;
            const totalProgress = Math.min(100, baseProgress + stepProgressPercent);
            
            // Update overall progress
            if (overallText) {
                const completed = status.includes('‚úÖ') || status.includes('Ho√†n th√†nh') ? 
                    currentIndex + 1 : currentIndex;
                overallText.textContent = `ƒêang x·ª≠ l√Ω ${completed}/${this.uploadProgress.total} files`;
            }
            
            if (overallFill) {
                overallFill.style.width = `${totalProgress}%`;
            }
            
            // Calculate time remaining
            if (overallTime && totalProgress > 5) {
                const elapsedTime = (Date.now() - this.uploadProgress.startTime) / 1000;
                const estimatedTotal = (elapsedTime * 100) / totalProgress;
                const remaining = Math.max(0, estimatedTotal - elapsedTime);
                
                if (remaining > 1) {
                    overallTime.textContent = `C√≤n l·∫°i: ${this.formatTimeRemaining(remaining)}`;
                }
            }
        }

        getStatusIcon(status) {
            if (status.includes('Ho√†n th√†nh') || status.includes('‚úÖ')) return '‚úÖ';
            if (status.includes('tr√πng l·∫∑p') || status.includes('‚ö†Ô∏è')) return '‚ö†Ô∏è';
            if (status.includes('Kh√¥ng h·ª£p l·ªá') || status.includes('‚ùå')) return '‚ùå';
            if (status.includes('ch·∫•t l∆∞·ª£ng')) return 'üîç';
            if (status.includes('hash')) return 'üîë';
            if (status.includes('validate')) return 'üìù';
            return '‚è≥';
        }

        hideUploadProgress() {
            const overlay = document.getElementById('uploadProgressOverlay');
            if (overlay) {
                setTimeout(() => {
                    overlay.classList.remove('show');
                }, 2000); // Hide after 2 seconds
            }
        }

        // Initialize upload progress modal interactions
        initUploadProgressModal() {
            const overlay = document.getElementById('uploadProgressOverlay');
            const modal = document.querySelector('.upload-progress-modal');
            const closeBtn = document.getElementById('uploadCloseBtn');
            
            if (overlay && modal) {
                // Close on overlay click (but not modal click)
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        overlay.classList.remove('show');
                        overlay.style.display = 'none';
                    }
                });
                
                // Prevent modal click from closing overlay
                modal.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                // Close button click handler
                if (closeBtn) {
                    closeBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Close button clicked');
                        overlay.classList.remove('show');
                        overlay.style.display = 'none';
                    });
                }
            }
        }

        completeUploadProgress() {
            const overallText = document.getElementById('uploadOverallText');
            const overallFill = document.getElementById('uploadOverallFill');
            const overallTime = document.getElementById('uploadOverallTime');
            const closeBtn = document.getElementById('uploadCloseBtn');
            const titleSpan = document.querySelector('.upload-progress-title span');
            
            if (overallText) overallText.textContent = `‚úì Ho√†n th√†nh ${this.uploadProgress?.total || 0} files`;
            if (overallFill) overallFill.style.width = '100%';
            if (overallTime) {
                const totalTime = (Date.now() - (this.uploadProgress?.startTime || Date.now())) / 1000;
                overallTime.textContent = `Ho√†n th√†nh trong ${totalTime.toFixed(1)}s`;
            }
            if (titleSpan) titleSpan.textContent = '‚úì T·∫£i l√™n ho√†n th√†nh';
            if (closeBtn) {
                closeBtn.style.display = 'block'; // Show close button
                
                // Remove any existing listeners and add new one
                closeBtn.replaceWith(closeBtn.cloneNode(true));
                const newCloseBtn = document.getElementById('uploadCloseBtn');
                newCloseBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Close button clicked - hiding overlay');
                    const overlay = document.getElementById('uploadProgressOverlay');
                    if (overlay) {
                        overlay.classList.remove('show');
                        overlay.style.display = 'none';
                    }
                });
            }
            
            // Don't auto-hide anymore - let user close manually
        }

        // HEIC to Image conversion using client-side library
        async convertHEICToImage(heicFile) {
            try {
                console.log('Converting HEIC file:', heicFile.name);
                
                // Read HEIC file as array buffer
                const arrayBuffer = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(heicFile);
                });
                
                // Simple HEIC to JPEG conversion using canvas approach
                // Note: This is a fallback method, real HEIC decoding requires WebAssembly
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // Try to use heic2any library if available globally
                if (typeof heic2any !== 'undefined') {
                    const convertedBlob = await heic2any({
                        blob: heicFile,
                        toType: 'image/jpeg',
                        quality: 1.0 // Maximum quality - no compression
                    });
                    
                    // Create image from converted blob
                    const img = new Image();
                    const url = URL.createObjectURL(convertedBlob);
                    
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            URL.revokeObjectURL(url);
                            resolve();
                        };
                        img.onerror = reject;
                        img.src = url;
                    });
                    
                    return img;
                } else {
                    // Fallback: Show message about HEIC support
                    throw new Error('HEIC format requires additional library. Please convert HEIC to JPG using your device first.');
                }
                
            } catch (error) {
                console.error('HEIC conversion failed:', error);
                // Fallback: Try to load as regular image (might work in some browsers)
                const img = new Image();
                const url = URL.createObjectURL(heicFile);
                
                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        URL.revokeObjectURL(url);
                        resolve(img);
                    };
                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('HEIC format not supported. Please convert to JPG/PNG first or use Safari/Chrome browser.'));
                    };
                    img.src = url;
                });
            }
        }
        
        getCurrentActiveTab() {
            // Check which tab is currently active
            const tabs = ['crop', 'gallery', 'print'];
            for (const tabName of tabs) {
                const tabElement = document.getElementById(`${tabName}Tab`);
                if (tabElement && tabElement.classList.contains('active')) {
                    return tabName;
                }
            }
            return 'gallery'; // Default fallback
        }
        
        // Border Template functionality
        initializeBorderTemplateMode() {
            console.log('üîß Initializing Border Template Mode...');
            
            // Initialize border template data with configuration
            this.borderTemplateData = {
                images: [],
                currentIndex: 0,
                config: {
                    dpi: 300,
                    templateSizeCm: { width: 10, height: 15 },
                    border: {
                        enabled: true,
                        thickness: 5,
                        color: '#FFFFFF',
                        cornerRadius: 0
                    },
                    fitMode: 'cover',
                    safeAreaPx: 0,
                    bgColor: '#FFFFFF',
                    dropShadow: false
                }
            };
            
            // Setup event listeners for border template controls
            this.setupBorderTemplateControls();
            this.updateBorderTemplateSpecs();
            
            console.log('‚úÖ Border Template Mode initialized');
        }
        
        setupBorderTemplateControls() {
            const borderTemplateDPI = document.getElementById('borderTemplateDPI');
            const borderTemplateWidth = document.getElementById('borderTemplateWidth');
            const borderTemplateHeight = document.getElementById('borderTemplateHeight');
            
            if (borderTemplateDPI) {
                // C·ªë ƒë·ªãnh DPI = 300, kh√¥ng cho ph√©p thay ƒë·ªïi
                borderTemplateDPI.value = 300;
                borderTemplateDPI.disabled = true;
                this.borderTemplateData.config.dpi = 300;

                borderTemplateDPI.addEventListener('change', (e) => {
                    // Lu√¥n gi·ªØ DPI = 300
                    e.target.value = 300;
                    this.borderTemplateData.config.dpi = 300;
                    this.updateBorderTemplateSpecs();
                    this.reprocessAllBorderTemplateImages();
                });
            }
            
            if (borderTemplateWidth) {
                borderTemplateWidth.addEventListener('input', (e) => {
                    this.borderTemplateData.config.templateSizeCm.width = parseFloat(e.target.value);
                    this.updateBorderTemplateSpecs();
                    this.reprocessAllBorderTemplateImages();
                });
            }
            
            if (borderTemplateHeight) {
                borderTemplateHeight.addEventListener('input', (e) => {
                    this.borderTemplateData.config.templateSizeCm.height = parseFloat(e.target.value);
                    this.updateBorderTemplateSpecs();
                    this.reprocessAllBorderTemplateImages();
                });
            }
            
            // Border controls
            const borderThickness = document.getElementById('borderThickness');
            const borderThicknessValue = document.getElementById('borderThicknessValue');
            const borderTemplateColor = document.getElementById('borderTemplateColor');
            const borderCornerRadius = document.getElementById('borderCornerRadius');
            const borderCornerRadiusValue = document.getElementById('borderCornerRadiusValue');
            
            if (borderThickness && borderThicknessValue) {
                borderThickness.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    borderThicknessValue.value = value;
                    this.borderTemplateData.config.border.thickness = value;
                    this.updateBorderTemplateSpecs();
                    this.reprocessAllBorderTemplateImages();
                });
                
                borderThicknessValue.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    borderThickness.value = value;
                    this.borderTemplateData.config.border.thickness = value;
                    this.updateBorderTemplateSpecs();
                    this.reprocessAllBorderTemplateImages();
                });
            }
            
            if (borderTemplateColor) {
                borderTemplateColor.addEventListener('change', (e) => {
                    this.borderTemplateData.config.border.color = e.target.value;
                    this.reprocessAllBorderTemplateImages();
                });
            }
            
            // File upload
            const borderTemplateFileInput = document.getElementById('borderTemplateFileInput');
            if (borderTemplateFileInput) {
                borderTemplateFileInput.addEventListener('change', (e) => {
                    this.handleBorderTemplateFiles(e.target.files);
                });
            }
        }
        
        updateBorderTemplateSpecs() {
            const config = this.borderTemplateData.config;
            // C√îNG TH·ª®C CH√çNH X√ÅC: C·ªë ƒë·ªãnh DPI = 300
            const DPI = 300;
            const sizeCm = config.templateSizeCm;
            
            // LU√îN s·ª≠ d·ª•ng Math.round() cho pixel cu·ªëi c√πng
            const canvasW = Math.round((sizeCm.width / 2.54) * DPI);
            const canvasH = Math.round((sizeCm.height / 2.54) * DPI);
            
            const specsDisplay = document.getElementById('borderTemplateSpecsDisplay');
            if (!specsDisplay) return;

            // Convert canvas to cm for display
            const canvasCmW = (canvasW / 300 * 2.54).toFixed(1);
            const canvasCmH = (canvasH / 300 * 2.54).toFixed(1);
            
            specsDisplay.innerHTML = `
                <table class="specs-table">
                    <tbody>
                        <tr>
                            <td class="spec-key">‚ñ¶ Canvas</td>
                            <td class="spec-value highlight">${canvasW} √ó ${canvasH}<span class="spec-unit">px</span></td>
                        </tr>
                        <tr>
                            <td class="spec-key">‚ñ° V√πng ·∫£nh</td>
                            <td class="spec-value highlight">
                                ${canvasCmW} √ó ${canvasCmH}<span class="spec-unit">cm</span>
                                <span class="spec-detail">(t·∫°i 300 DPI)</span>
                                <button class="quick-crop-btn" onclick="window.converter.quickCropToSize(${canvasCmW}, ${canvasCmH})">
                                    <span class="btn-icon">‚úÇ</span>
                                    <span>C·∫Øt ·∫£nh nhanh</span>
                                </button>
                            </td>
                        </tr>
                        <tr>
                            <td class="spec-key">‚§¢ Fit Mode</td>
                            <td class="spec-value">Cover (c·∫Øt ·∫£nh)</td>
                        </tr>
                        <tr>
                            <td class="spec-key">‚óà M√†u n·ªÅn</td>
                            <td class="spec-value">
                                <span class="spec-color-indicator" style="background: ${config.border.color};"></span>Vi·ªÅn ${config.border.thickness}mm
                            </td>
                        </tr>
                    </tbody>
                </table>
            `;
        }
        
        async handleBorderTemplateFiles(files) {
            if (!files || files.length === 0) return;
            
            console.log(`üîß Processing ${files.length} files for border template...`);
            
            for (const file of files) {
                try {
                    const imageData = await this.processBorderTemplateImage(file);
                    if (imageData) {
                        this.borderTemplateData.images.push(imageData);
                    }
                } catch (error) {
                    console.error('Error processing border template image:', error);
                }
            }
            
            this.updateBorderTemplateUI();
            this.showToast(`‚úÖ ƒê√£ t·∫£i ${this.borderTemplateData.images.length} ·∫£nh vi·ªÅn th∆∞·ªùng`, 'success');
        }
        
        async processBorderTemplateImage(file) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const imageData = {
                        file: file,
                        originalImage: img,
                        filename: file.name
                    };
                    resolve(imageData);
                };
                img.onerror = () => resolve(null);
                img.src = URL.createObjectURL(file);
            });
        }
        
        updateBorderTemplateUI() {
            const borderTemplateImageCount = document.getElementById('borderTemplateImageCount');
            if (borderTemplateImageCount) {
                borderTemplateImageCount.textContent = this.borderTemplateData.images.length;
            }
        }
        
        reprocessAllBorderTemplateImages() {
            // Placeholder for reprocessing logic
            console.log('Reprocessing all border template images...');
        }
        
        // Strip Template functionality
        initializeStripTemplateMode() {
            console.log('üîß Initializing Strip Template Mode...');
            
            // Initialize strip template data with configuration
            this.stripTemplateData = {
                images: [],
                strips: [], // Each strip contains 4 images
                currentStripIndex: 0,
                config: {
                    dpi: 300,
                    stripSizeCm: { width: 5, height: 15 },
                    frameCount: 4,
                    frameRatio: '4:3',
                    spacing: {
                        outerBorder: 5,
                        frameSpacing: 2,
                        frameBorder: 1
                    },
                    colors: {
                        stripBorder: '#FFFFFF',
                        frameBorder: '#FFFFFF',
                        background: '#000000'
                    }
                }
            };
            
            // Setup event listeners for strip template controls
            this.setupStripTemplateControls();
            this.updateStripTemplateSpecs();
            
            console.log('‚úÖ Strip Template Mode initialized');
        }
        
        setupStripTemplateControls() {
            const stripTemplateDPI = document.getElementById('stripTemplateDPI');
            const stripTemplateWidth = document.getElementById('stripTemplateWidth');
            const stripTemplateHeight = document.getElementById('stripTemplateHeight');
            const stripFrameCount = document.getElementById('stripFrameCount');
            const stripFrameRatio = document.getElementById('stripFrameRatio');
            
            if (stripTemplateDPI) {
                // C·ªë ƒë·ªãnh DPI = 300, kh√¥ng cho ph√©p thay ƒë·ªïi
                stripTemplateDPI.value = 300;
                stripTemplateDPI.disabled = true;
                this.stripTemplateData.config.dpi = 300;

                stripTemplateDPI.addEventListener('change', (e) => {
                    // Lu√¥n gi·ªØ DPI = 300
                    e.target.value = 300;
                    this.stripTemplateData.config.dpi = 300;
                    this.updateStripTemplateSpecs();
                    this.reprocessAllStripTemplates();
                });
            }
            
            if (stripTemplateWidth) {
                stripTemplateWidth.addEventListener('input', (e) => {
                    this.stripTemplateData.config.stripSizeCm.width = parseFloat(e.target.value);
                    this.updateStripTemplateSpecs();
                    this.reprocessAllStripTemplates();
                });
            }
            
            if (stripTemplateHeight) {
                stripTemplateHeight.addEventListener('input', (e) => {
                    this.stripTemplateData.config.stripSizeCm.height = parseFloat(e.target.value);
                    this.updateStripTemplateSpecs();
                    this.reprocessAllStripTemplates();
                });
            }
            
            if (stripFrameCount) {
                stripFrameCount.addEventListener('change', (e) => {
                    this.stripTemplateData.config.frameCount = parseInt(e.target.value);
                    this.updateStripFramesDisplay();
                    this.updateStripTemplateSpecs();
                });
            }
            
            if (stripFrameRatio) {
                stripFrameRatio.addEventListener('change', (e) => {
                    this.stripTemplateData.config.frameRatio = e.target.value;
                    this.updateStripFramesDisplay();
                    this.updateStripTemplateSpecs();
                });
            }
            
            // Spacing controls
            const stripOuterBorder = document.getElementById('stripOuterBorder');
            const stripOuterBorderValue = document.getElementById('stripOuterBorderValue');
            const stripFrameSpacing = document.getElementById('stripFrameSpacing');
            const stripFrameSpacingValue = document.getElementById('stripFrameSpacingValue');
            
            if (stripOuterBorder && stripOuterBorderValue) {
                stripOuterBorder.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    stripOuterBorderValue.value = value;
                    this.stripTemplateData.config.spacing.outerBorder = value;
                    this.updateStripTemplateSpecs();
                });
                
                stripOuterBorderValue.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    stripOuterBorder.value = value;
                    this.stripTemplateData.config.spacing.outerBorder = value;
                    this.updateStripTemplateSpecs();
                });
            }
            
            // File upload
            const stripTemplateFileInput = document.getElementById('stripTemplateFileInput');
            if (stripTemplateFileInput) {
                stripTemplateFileInput.addEventListener('change', (e) => {
                    this.handleStripTemplateFiles(e.target.files);
                });
            }
        }
        
        updateStripTemplateSpecs() {
            const config = this.stripTemplateData.config;
            // C√îNG TH·ª®C CH√çNH X√ÅC: C·ªë ƒë·ªãnh DPI = 300
            const DPI = 300;
            const sizeCm = config.stripSizeCm;
            
            // LU√îN s·ª≠ d·ª•ng Math.round() cho pixel cu·ªëi c√πng
            const stripW = Math.round((sizeCm.width / 2.54) * DPI);
            const stripH = Math.round((sizeCm.height / 2.54) * DPI);
            
            // Calculate frame dimensions
            const frameHeight = Math.round((stripH - (config.spacing.outerBorder * 2) - (config.spacing.frameSpacing * (config.frameCount - 1))) / config.frameCount);
            const frameWidth = Math.round(stripW - (config.spacing.outerBorder * 2));
            
            const specsDisplay = document.getElementById('stripTemplateSpecsDisplay');
            if (!specsDisplay) return;

            // Convert frame size to cm
            const frameCmW = (frameWidth / 300 * 2.54).toFixed(2);
            const frameCmH = (frameHeight / 300 * 2.54).toFixed(2);
            
            specsDisplay.innerHTML = `
                <table class="specs-table">
                    <tbody>
                        <tr>
                            <td class="spec-key">‚ñ¶ Canvas</td>
                            <td class="spec-value highlight">${stripW} √ó ${stripH}<span class="spec-unit">px</span></td>
                        </tr>
                        <tr>
                            <td class="spec-key">‚ñ° V√πng ·∫£nh</td>
                            <td class="spec-value highlight">
                                ${frameCmW} √ó ${frameCmH}<span class="spec-unit">cm</span>
                                <span class="spec-detail">(${frameWidth} √ó ${frameHeight} px √ó ${config.frameCount} khung)</span>
                                <button class="quick-crop-btn" onclick="window.converter.quickCropToSize(${frameCmW}, ${frameCmH})">
                                    <span class="btn-icon">‚úÇ</span>
                                    <span>C·∫Øt ·∫£nh nhanh</span>
                                </button>
                            </td>
                        </tr>
                        <tr>
                            <td class="spec-key">‚§¢ Fit Mode</td>
                            <td class="spec-value">Cover (c·∫Øt ·∫£nh)</td>
                        </tr>
                        <tr>
                            <td class="spec-key">‚óà M√†u n·ªÅn</td>
                            <td class="spec-value">
                                <span class="spec-color-indicator" style="background: white;"></span>Tr·∫Øng (T·ª∑ l·ªá ${config.frameRatio})
                            </td>
                        </tr>
                    </tbody>
                </table>
            `;
        }
        
        updateStripFramesDisplay() {
            const frameCount = this.stripTemplateData.config.frameCount;
            const stripTemplateFrame = document.getElementById('stripTemplateFrame');
            
            if (!stripTemplateFrame) return;
            
            // Clear existing frames
            stripTemplateFrame.innerHTML = '';
            
            // Create new frames
            for (let i = 1; i <= frameCount; i++) {
                const frame = document.createElement('div');
                frame.className = 'strip-frame';
                frame.id = `stripFrame${i}`;
                frame.innerHTML = `<div class="placeholder-text">Khung ${i}</div>`;
                stripTemplateFrame.appendChild(frame);
            }
        }
        
        async handleStripTemplateFiles(files) {
            if (!files || files.length === 0) return;
            
            console.log(`üîß Processing ${files.length} files for strip template...`);
            
            for (const file of files) {
                try {
                    const imageData = await this.processStripTemplateImage(file);
                    if (imageData) {
                        this.stripTemplateData.images.push(imageData);
                    }
                } catch (error) {
                    console.error('Error processing strip template image:', error);
                }
            }
            
            // Create strips from images (4 images per strip)
            this.createStripsFromImages();
            this.updateStripTemplateUI();
            this.showToast(`‚úÖ ƒê√£ t·∫£i ${this.stripTemplateData.images.length} ·∫£nh cho Strip Layout`, 'success');
        }
        
        async processStripTemplateImage(file) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const imageData = {
                        file: file,
                        originalImage: img,
                        filename: file.name
                    };
                    resolve(imageData);
                };
                img.onerror = () => resolve(null);
                img.src = URL.createObjectURL(file);
            });
        }
        
        createStripsFromImages() {
            const images = this.stripTemplateData.images;
            const frameCount = this.stripTemplateData.config.frameCount;
            const strips = [];
            
            for (let i = 0; i < images.length; i += frameCount) {
                const stripImages = images.slice(i, i + frameCount);
                if (stripImages.length > 0) {
                    strips.push({
                        id: strips.length,
                        images: stripImages,
                        timestamp: Date.now()
                    });
                }
            }
            
            this.stripTemplateData.strips = strips;
            console.log(`Created ${strips.length} strips from ${images.length} images`);
        }
        
        updateStripTemplateUI() {
            const stripTemplateImageCount = document.getElementById('stripTemplateImageCount');
            if (stripTemplateImageCount) {
                stripTemplateImageCount.textContent = this.stripTemplateData.strips.length;
            }
            
            // Update preview with first strip
            if (this.stripTemplateData.strips.length > 0) {
                this.displayStripPreview(0);
            }
        }
        
        displayStripPreview(stripIndex) {
            const strip = this.stripTemplateData.strips[stripIndex];
            if (!strip) return;
            
            strip.images.forEach((imageData, frameIndex) => {
                const frameElement = document.getElementById(`stripFrame${frameIndex + 1}`);
                if (frameElement && imageData) {
                    frameElement.innerHTML = '';
                    const img = document.createElement('img');
                    img.src = URL.createObjectURL(imageData.file);
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    frameElement.appendChild(img);
                }
            });
        }
        
        reprocessAllStripTemplates() {
            // Placeholder for reprocessing logic
            console.log('Reprocessing all strip templates...');
        }
        
        // Template Sub-tab Management
        switchTemplateSubTab(subTabName) {
            console.log(`Switching to template sub-tab: ${subTabName}`);
            
            // Remove active class from all sub-tabs and content
            document.querySelectorAll('.sub-tab-button').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.template-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected sub-tab and content
            if (subTabName === 'polaroid') {
                document.getElementById('polaroidSubTab').classList.add('active');
                document.getElementById('polaroidTemplateContent').classList.add('active');
                this.initializeTemplateMode();
            } else if (subTabName === 'border') {
                document.getElementById('borderSubTab').classList.add('active');
                document.getElementById('borderTemplateContent').classList.add('active');
                this.initializeBorderTemplateMode();
            } else if (subTabName === 'strip') {
                document.getElementById('stripSubTab').classList.add('active');
                document.getElementById('stripTemplateContent').classList.add('active');
                this.initializeStripTemplateMode();
            }
        }
        
        initializeActiveTemplate() {
            // Initialize the currently active template sub-tab
            const activeSubTab = document.querySelector('.sub-tab-button.active');
            if (activeSubTab) {
                const subTabId = activeSubTab.id;
                if (subTabId === 'polaroidSubTab') {
                    this.initializeTemplateMode();
                } else if (subTabId === 'borderSubTab') {
                    this.initializeBorderTemplateMode();
                } else if (subTabId === 'stripSubTab') {
                    this.initializeStripTemplateMode();
                }
            } else {
                // Default to Polaroid if no active sub-tab
                this.switchTemplateSubTab('polaroid');
            }
        }
        }

        // Initialize the converter
        const converter = new BatchImageConverter();
        window.converter = converter;
        
        // Initialize upload progress modal
        converter.initUploadProgressModal();

        // Cleanup all blob URLs when page unloads to prevent memory leaks
        window.addEventListener('beforeunload', () => {
            // Cleanup all file preview URLs
            if (converter && converter.files) {
                converter.files.forEach(file => {
                    if (file.previewUrl) {
                        URL.revokeObjectURL(file.previewUrl);
                    }
                });
            }
        });

        // ============================================
        // SK316 CALIBRATION SYSTEM
        // ============================================

        class SK316CalibrationSystem {
            constructor() {
                this.profiles = [];
                this.currentProfile = null;
                this.currentGridSize = { rows: 5, cols: 5 };
                this.currentCardSize = '90x54';
                this.offsetData = {};

                this.loadProfilesFromStorage();
                this.init();
            }

            init() {
                console.log('üéØ Kh·ªüi t·∫°o SK316 Calibration System');

                // Setup event listeners
                this.setupEventListeners();

                // Generate initial table
                this.generateInputTable();

                // Render profiles list
                this.renderProfilesList();

                // Update UI
                this.updateUI();
            }

            setupEventListeners() {
                // Grid size change
                const gridSizeSelect = document.getElementById('sk316GridSize');
                if (gridSizeSelect) {
                    gridSizeSelect.addEventListener('change', (e) => {
                        const [rows, cols] = e.target.value.split('x').map(Number);
                        this.currentGridSize = { rows, cols };
                        this.generateInputTable();
                        this.updateHeatmap();
                    });
                }

                // Card size change
                const cardSizeSelect = document.getElementById('sk316CardSize');
                if (cardSizeSelect) {
                    cardSizeSelect.addEventListener('change', (e) => {
                        this.currentCardSize = e.target.value;
                    });
                }

                // Generate test sheet
                const generateBtn = document.getElementById('sk316GenerateBtn');
                if (generateBtn) {
                    generateBtn.addEventListener('click', () => this.generateTestSheet());
                }

                // Reset table
                const resetBtn = document.getElementById('sk316ResetTableBtn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.resetTable());
                }

                // Fill zero
                const fillZeroBtn = document.getElementById('sk316FillZeroBtn');
                if (fillZeroBtn) {
                    fillZeroBtn.addEventListener('click', () => this.fillZero());
                }

                // Save profile
                const saveBtn = document.getElementById('sk316SaveBtn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', () => this.saveProfile());
                }

                // Export JSON
                const exportBtn = document.getElementById('sk316ExportBtn');
                if (exportBtn) {
                    exportBtn.addEventListener('click', () => this.exportProfile());
                }

                // Import JSON
                const importBtn = document.getElementById('sk316ImportBtn');
                if (importBtn) {
                    importBtn.addEventListener('click', () => this.importProfile());
                }

                // New profile
                const newBtn = document.getElementById('sk316NewProfileBtn');
                if (newBtn) {
                    newBtn.addEventListener('click', () => this.newProfile());
                }

                // Profile select
                const profileSelect = document.getElementById('sk316ProfileSelect');
                if (profileSelect) {
                    profileSelect.addEventListener('change', (e) => {
                        this.loadProfile(e.target.value);
                    });
                }

                // Gutter Test Event Listeners
                this.setupGutterTestListeners();
            }

            setupGutterTestListeners() {
                // Update gutter test preview when range changes
                const gutterMin = document.getElementById('gutterMin');
                const gutterMax = document.getElementById('gutterMax');
                const gutterStep = document.getElementById('gutterStep');

                [gutterMin, gutterMax, gutterStep].forEach(input => {
                    if (input) {
                        input.addEventListener('input', () => this.updateGutterTestPreview());
                    }
                });

                // Generate gutter tests button
                const generateGutterTestsBtn = document.getElementById('generateGutterTestsBtn');
                if (generateGutterTestsBtn) {
                    generateGutterTestsBtn.addEventListener('click', () => this.generateGutterTests());
                }

                // Change gutter button
                const changeGutterBtn = document.getElementById('changeGutterBtn');
                if (changeGutterBtn) {
                    changeGutterBtn.addEventListener('click', () => {
                        document.getElementById('gutterSelectionSection').style.display = 'block';
                        document.getElementById('selectedGutterDisplay').style.display = 'none';
                    });
                }
            }

            updateGutterTestPreview() {
                const min = parseFloat(document.getElementById('gutterMin').value) || 0;
                const max = parseFloat(document.getElementById('gutterMax').value) || 0;
                const step = parseFloat(document.getElementById('gutterStep').value) || 0.1;

                if (min >= max || step <= 0) {
                    document.getElementById('gutterTestPreview').innerHTML =
                        '‚ö†Ô∏è <strong>Gi√° tr·ªã kh√¥ng h·ª£p l·ªá</strong>';
                    return;
                }

                const values = [];
                for (let v = min; v <= max; v += step) {
                    values.push(v.toFixed(1) + 'mm');
                }

                const count = values.length;
                const valueList = values.join(', ');

                document.getElementById('gutterTestPreview').innerHTML =
                    `‚Üí S·∫Ω t·∫°o <strong>${count} test sheets</strong>: ${valueList}`;
            }

            generateInputTable() {
                const tbody = document.getElementById('sk316TableBody');
                if (!tbody) return;

                tbody.innerHTML = '';

                const { rows, cols } = this.currentGridSize;
                let cellIndex = 1;

                for (let r = 1; r <= rows; r++) {
                    for (let c = 1; c <= cols; c++) {
                        const key = `r${r}c${c}`;
                        const tr = document.createElement('tr');

                        tr.innerHTML = `
                            <td>${key}</td>
                            <td>
                                <input
                                    type="number"
                                    step="0.1"
                                    min="-5"
                                    max="5"
                                    value="0.0"
                                    data-key="${key}"
                                    data-axis="x"
                                    class="sk316-offset-input"
                                >
                            </td>
                            <td>
                                <input
                                    type="number"
                                    step="0.1"
                                    min="-5"
                                    max="5"
                                    value="0.0"
                                    data-key="${key}"
                                    data-axis="y"
                                    class="sk316-offset-input"
                                >
                            </td>
                        `;

                        tbody.appendChild(tr);
                        cellIndex++;
                    }
                }

                // Add change listeners
                tbody.querySelectorAll('.sk316-offset-input').forEach(input => {
                    input.addEventListener('input', () => {
                        this.updateOffsetData();
                        this.updateHeatmap();
                        this.updateStatistics();
                    });
                });

                console.log(`‚úÖ ƒê√£ t·∫°o input table ${rows}√ó${cols}`);
            }

            updateOffsetData() {
                this.offsetData = {};

                document.querySelectorAll('.sk316-offset-input').forEach(input => {
                    const key = input.dataset.key;
                    const axis = input.dataset.axis;
                    const value = parseFloat(input.value) || 0;

                    if (!this.offsetData[key]) {
                        this.offsetData[key] = { x: 0, y: 0 };
                    }

                    this.offsetData[key][axis] = value;
                });
            }

            resetTable() {
                document.querySelectorAll('.sk316-offset-input').forEach(input => {
                    input.value = '0.0';
                });
                this.updateOffsetData();
                this.updateHeatmap();
                this.updateStatistics();
                this.showToast('‚Ü∫ ƒê√£ reset t·∫•t c·∫£ v·ªÅ 0', 'info');
            }

            fillZero() {
                this.resetTable();
            }

            updateHeatmap() {
                const heatmapDiv = document.getElementById('sk316Heatmap');
                if (!heatmapDiv) return;

                const { rows, cols } = this.currentGridSize;
                heatmapDiv.className = `sk316-heatmap grid-${rows}x${cols}`;
                heatmapDiv.innerHTML = '';

                // Calculate max offset for color scaling
                const offsets = Object.values(this.offsetData);
                const maxOffset = Math.max(...offsets.map(o => Math.sqrt(o.x * o.x + o.y * o.y)), 0.01);

                for (let r = 1; r <= rows; r++) {
                    for (let c = 1; c <= cols; c++) {
                        const key = `r${r}c${c}`;
                        const offset = this.offsetData[key] || { x: 0, y: 0 };
                        const magnitude = Math.sqrt(offset.x * offset.x + offset.y * offset.y);

                        // Color: green (low) ‚Üí yellow ‚Üí red (high)
                        const ratio = magnitude / maxOffset;
                        let color;
                        if (ratio < 0.5) {
                            // Green to yellow
                            const r = Math.round(34 + (245 - 34) * (ratio * 2));
                            color = `rgb(${r}, 197, 94)`;
                        } else {
                            // Yellow to red
                            const g = Math.round(197 - (197 - 68) * ((ratio - 0.5) * 2));
                            color = `rgb(239, ${g}, 68)`;
                        }

                        const cell = document.createElement('div');
                        cell.className = 'heatmap-cell';
                        cell.style.background = color;
                        cell.textContent = magnitude.toFixed(2);
                        cell.title = `${key}: X=${offset.x.toFixed(2)}mm, Y=${offset.y.toFixed(2)}mm`;

                        heatmapDiv.appendChild(cell);
                    }
                }
            }

            updateStatistics() {
                const offsets = Object.values(this.offsetData);
                if (offsets.length === 0) return;

                const avgX = offsets.reduce((sum, o) => sum + o.x, 0) / offsets.length;
                const avgY = offsets.reduce((sum, o) => sum + o.y, 0) / offsets.length;
                const maxOffset = Math.max(...offsets.map(o => Math.sqrt(o.x * o.x + o.y * o.y)));

                const avgXEl = document.getElementById('sk316AvgX');
                const avgYEl = document.getElementById('sk316AvgY');
                const maxEl = document.getElementById('sk316MaxOffset');

                if (avgXEl) avgXEl.textContent = `${avgX.toFixed(2)}mm`;
                if (avgYEl) avgYEl.textContent = `${avgY.toFixed(2)}mm`;
                if (maxEl) maxEl.textContent = `${maxOffset.toFixed(2)}mm`;
            }

            generateTestSheet() {
                console.log('üñ®Ô∏è T·∫°o test sheet...');

                const { rows, cols } = this.currentGridSize;
                const [cardW, cardH] = this.currentCardSize.split('x').map(Number);

                // A4 size at 300 DPI
                const dpi = 300;
                const a4WidthMm = 210;
                const a4HeightMm = 297;
                const a4WidthPx = (a4WidthMm / 25.4) * dpi;
                const a4HeightPx = (a4HeightMm / 25.4) * dpi;

                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = a4WidthPx;
                canvas.height = a4HeightPx;
                const ctx = canvas.getContext('2d');

                // White background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Card dimensions in pixels
                const cardWidthPx = (cardW / 25.4) * dpi;
                const cardHeightPx = (cardH / 25.4) * dpi;

                // Calculate grid layout
                const margin = 20 * (dpi / 25.4); // 20mm margin
                const availableWidth = a4WidthPx - (2 * margin);
                const availableHeight = a4HeightPx - (2 * margin);

                const gutterX = (availableWidth - (cols * cardWidthPx)) / (cols - 1 || 1);
                const gutterY = (availableHeight - (rows * cardHeightPx)) / (rows - 1 || 1);

                // Draw grid
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.font = `${24 * (dpi / 72)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                let cellNum = 1;
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const x = margin + c * (cardWidthPx + gutterX);
                        const y = margin + r * (cardHeightPx + gutterY);

                        // Draw card border
                        ctx.strokeRect(x, y, cardWidthPx, cardHeightPx);

                        // Draw crop marks
                        const markLen = 10 * (dpi / 25.4);
                        // Top-left
                        ctx.beginPath();
                        ctx.moveTo(x - markLen, y);
                        ctx.lineTo(x, y);
                        ctx.lineTo(x, y - markLen);
                        ctx.stroke();

                        // Top-right
                        ctx.beginPath();
                        ctx.moveTo(x + cardWidthPx + markLen, y);
                        ctx.lineTo(x + cardWidthPx, y);
                        ctx.lineTo(x + cardWidthPx, y - markLen);
                        ctx.stroke();

                        // Bottom-left
                        ctx.beginPath();
                        ctx.moveTo(x - markLen, y + cardHeightPx);
                        ctx.lineTo(x, y + cardHeightPx);
                        ctx.lineTo(x, y + cardHeightPx + markLen);
                        ctx.stroke();

                        // Bottom-right
                        ctx.beginPath();
                        ctx.moveTo(x + cardWidthPx + markLen, y + cardHeightPx);
                        ctx.lineTo(x + cardWidthPx, y + cardHeightPx);
                        ctx.lineTo(x + cardWidthPx, y + cardHeightPx + markLen);
                        ctx.stroke();

                        // Draw cell number
                        ctx.fillStyle = '#000';
                        const key = `r${r+1}c${c+1}`;
                        ctx.fillText(key, x + cardWidthPx / 2, y + cardHeightPx / 2);

                        cellNum++;
                    }
                }

                // Add title
                ctx.font = `bold ${32 * (dpi / 72)}px Arial`;
                ctx.fillText(`SK316 Test Sheet - ${this.currentCardSize}mm - ${rows}√ó${cols}`, a4WidthPx / 2, margin / 2);

                // Convert to JPG and download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `SK316_TestSheet_${this.currentCardSize}_${rows}x${cols}.jpg`;
                    a.click();
                    URL.revokeObjectURL(url);

                    this.showToast('‚úÖ ƒê√£ t·∫£i test sheet JPG', 'success');
                }, 'image/jpeg', 1.0); // 100% quality
            }

            async generateGutterTests() {
                console.log('üîß T·∫°o Gutter Test Sheets...');

                const min = parseFloat(document.getElementById('gutterMin').value) || 0;
                const max = parseFloat(document.getElementById('gutterMax').value) || 0;
                const step = parseFloat(document.getElementById('gutterStep').value) || 0.1;

                const cardSizeSelect = document.getElementById('gutterTestCardSize');
                const gridSelect = document.getElementById('gutterTestGrid');
                const cardSize = cardSizeSelect ? cardSizeSelect.value : '90x54';
                const gridValue = gridSelect ? gridSelect.value : '3x5';

                if (min >= max || step <= 0) {
                    this.showToast('‚ö†Ô∏è Gi√° tr·ªã gutter range kh√¥ng h·ª£p l·ªá', 'error');
                    return;
                }

                const [cardW, cardH] = cardSize.split('x').map(Number);
                const [rows, cols] = gridValue.split('x').map(Number);

                // Generate test values
                const gutterValues = [];
                for (let v = min; v <= max; v += step) {
                    gutterValues.push(parseFloat(v.toFixed(1)));
                }

                console.log(`S·∫Ω t·∫°o ${gutterValues.length} test sheets:`, gutterValues);

                // Generate each test sheet
                for (const gutterMm of gutterValues) {
                    await this.generateSingleGutterTestSheet(cardW, cardH, rows, cols, gutterMm);
                    // Small delay between downloads
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                // Show gutter selection section
                this.showGutterSelectionOptions(gutterValues);

                this.showToast(`‚úÖ ƒê√£ t·∫°o ${gutterValues.length} gutter test sheets`, 'success');
            }

            generateSingleGutterTestSheet(cardW, cardH, rows, cols, gutterMm) {
                return new Promise((resolve) => {
                    console.log(`T·∫°o test sheet v·ªõi gutter = ${gutterMm}mm`);

                    // A4 size at 300 DPI
                    const dpi = 300;
                    const a4WidthMm = 210;
                    const a4HeightMm = 297;
                    const a4WidthPx = (a4WidthMm / 25.4) * dpi;
                    const a4HeightPx = (a4HeightMm / 25.4) * dpi;

                    // Create canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = a4WidthPx;
                    canvas.height = a4HeightPx;
                    const ctx = canvas.getContext('2d');

                    // White background
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Card dimensions in pixels
                    const cardWidthPx = (cardW / 25.4) * dpi;
                    const cardHeightPx = (cardH / 25.4) * dpi;

                    // Convert gutter from mm to px
                    const gutterPx = (gutterMm / 25.4) * dpi;

                    // Calculate layout with FIXED GUTTER
                    const totalCardsWidth = cols * cardWidthPx;
                    const totalGuttersWidth = (cols - 1) * gutterPx;
                    const totalCardsHeight = rows * cardHeightPx;
                    const totalGuttersHeight = (rows - 1) * gutterPx;

                    // Calculate margin to center the grid
                    const marginX = (a4WidthPx - totalCardsWidth - totalGuttersWidth) / 2;
                    const marginY = (a4HeightPx - totalCardsHeight - totalGuttersHeight) / 2;

                    // Draw grid
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.font = `${20 * (dpi / 72)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const x = marginX + c * (cardWidthPx + gutterPx);
                            const y = marginY + r * (cardHeightPx + gutterPx);

                            // Draw card border
                            ctx.strokeRect(x, y, cardWidthPx, cardHeightPx);

                            // Draw crop marks
                            const markLen = 10 * (dpi / 25.4);
                            ctx.lineWidth = 1;

                            // Top-left
                            ctx.beginPath();
                            ctx.moveTo(x - markLen, y);
                            ctx.lineTo(x, y);
                            ctx.lineTo(x, y - markLen);
                            ctx.stroke();

                            // Top-right
                            ctx.beginPath();
                            ctx.moveTo(x + cardWidthPx + markLen, y);
                            ctx.lineTo(x + cardWidthPx, y);
                            ctx.lineTo(x + cardWidthPx, y - markLen);
                            ctx.stroke();

                            // Bottom-left
                            ctx.beginPath();
                            ctx.moveTo(x - markLen, y + cardHeightPx);
                            ctx.lineTo(x, y + cardHeightPx);
                            ctx.lineTo(x, y + cardHeightPx + markLen);
                            ctx.stroke();

                            // Bottom-right
                            ctx.beginPath();
                            ctx.moveTo(x + cardWidthPx + markLen, y + cardHeightPx);
                            ctx.lineTo(x + cardWidthPx, y + cardHeightPx);
                            ctx.lineTo(x + cardWidthPx, y + cardHeightPx + markLen);
                            ctx.stroke();

                            ctx.lineWidth = 2;

                            // Draw cell label
                            ctx.fillStyle = '#666';
                            const label = `${r+1}-${c+1}`;
                            ctx.fillText(label, x + cardWidthPx / 2, y + cardHeightPx / 2);
                        }
                    }

                    // Add title with gutter value
                    ctx.fillStyle = '#000';
                    ctx.font = `bold ${36 * (dpi / 72)}px Arial`;
                    ctx.fillText(`SK316 Gutter Test - ${gutterMm}mm`, a4WidthPx / 2, marginY / 2);

                    // Add info text
                    ctx.font = `${20 * (dpi / 72)}px Arial`;
                    ctx.fillText(`Card: ${cardW}√ó${cardH}mm | Grid: ${rows}√ó${cols} | Gutter: ${gutterMm}mm`,
                                 a4WidthPx / 2, marginY / 2 + 50);

                    // Convert to JPG and download
                    canvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `SK316_GutterTest_${gutterMm}mm_${cardW}x${cardH}_${rows}x${cols}.jpg`;
                        a.click();
                        URL.revokeObjectURL(url);
                        resolve();
                    }, 'image/jpeg', 1.0); // 100% quality
                });
            }

            showGutterSelectionOptions(gutterValues) {
                const optionsGrid = document.getElementById('gutterOptionsGrid');
                const selectionSection = document.getElementById('gutterSelectionSection');

                if (!optionsGrid || !selectionSection) return;

                selectionSection.style.display = 'block';
                optionsGrid.innerHTML = '';

                gutterValues.forEach(value => {
                    const option = document.createElement('div');
                    option.className = 'gutter-option';
                    option.dataset.gutter = value;
                    option.innerHTML = `
                        <div class="value">${value}mm</div>
                        <div class="label">Gutter</div>
                    `;

                    option.addEventListener('click', () => this.selectGutter(value));

                    optionsGrid.appendChild(option);
                });
            }

            selectGutter(gutterValue) {
                console.log(`ƒê√£ ch·ªçn gutter: ${gutterValue}mm`);

                // Update UI
                document.querySelectorAll('.gutter-option').forEach(opt => {
                    opt.classList.remove('selected');
                });

                const selectedOpt = document.querySelector(`[data-gutter="${gutterValue}"]`);
                if (selectedOpt) {
                    selectedOpt.classList.add('selected');
                }

                // Store selected gutter (will be saved with profile)
                this.selectedGutter = gutterValue;

                // Show selected display
                document.getElementById('selectedGutterValue').textContent = `${gutterValue}mm`;
                document.getElementById('selectedGutterDisplay').style.display = 'flex';

                this.showToast(`‚úÖ ƒê√£ ch·ªçn gutter = ${gutterValue}mm`, 'success');
            }

            saveProfile() {
                const nameInput = document.getElementById('sk316ProfileName');
                const name = nameInput ? nameInput.value.trim() : '';

                if (!name) {
                    this.showToast('‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n profile', 'error');
                    return;
                }

                this.updateOffsetData();

                // Calculate statistics
                const offsets = Object.values(this.offsetData);
                const avgX = offsets.reduce((sum, o) => sum + o.x, 0) / offsets.length;
                const avgY = offsets.reduce((sum, o) => sum + o.y, 0) / offsets.length;
                const maxOffsetX = Math.max(...offsets.map(o => Math.abs(o.x)));
                const maxOffsetY = Math.max(...offsets.map(o => Math.abs(o.y)));
                const minOffsetX = Math.min(...offsets.map(o => o.x));
                const minOffsetY = Math.min(...offsets.map(o => o.y));

                const profile = {
                    id: `sk316-${this.currentCardSize}-${this.currentGridSize.rows}x${this.currentGridSize.cols}-${Date.now()}`,
                    name: name,
                    cardSize: this.currentCardSize,
                    gridSize: {
                        rows: this.currentGridSize.rows,
                        cols: this.currentGridSize.cols
                    },
                    gutter: this.selectedGutter || null, // L∆∞u gutter t·ªëi ∆∞u (mm)
                    createdAt: new Date().toISOString(),
                    lastUsed: new Date().toISOString(),
                    offsetData: { ...this.offsetData },
                    statistics: {
                        avgOffsetX: parseFloat(avgX.toFixed(3)),
                        avgOffsetY: parseFloat(avgY.toFixed(3)),
                        maxOffsetX: parseFloat(maxOffsetX.toFixed(3)),
                        maxOffsetY: parseFloat(maxOffsetY.toFixed(3)),
                        minOffsetX: parseFloat(minOffsetX.toFixed(3)),
                        minOffsetY: parseFloat(minOffsetY.toFixed(3)),
                        totalCells: this.currentGridSize.rows * this.currentGridSize.cols
                    }
                };

                this.profiles.push(profile);
                this.saveProfilesToStorage();
                this.renderProfilesList();
                this.updateProfileSelect();

                // Auto-select the new profile
                this.currentProfile = profile;
                this.updateStatusBadge();

                this.showToast('üíæ ƒê√£ l∆∞u profile th√†nh c√¥ng', 'success');

                // Clear name input
                if (nameInput) nameInput.value = '';
            }

            exportProfile() {
                this.updateOffsetData();

                if (Object.keys(this.offsetData).length === 0) {
                    this.showToast('‚ö†Ô∏è Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t', 'error');
                    return;
                }

                const nameInput = document.getElementById('sk316ProfileName');
                const name = nameInput ? nameInput.value.trim() : 'SK316_Profile';

                // Calculate statistics
                const offsets = Object.values(this.offsetData);
                const avgX = offsets.reduce((sum, o) => sum + o.x, 0) / offsets.length;
                const avgY = offsets.reduce((sum, o) => sum + o.y, 0) / offsets.length;
                const maxOffsetX = Math.max(...offsets.map(o => Math.abs(o.x)));
                const maxOffsetY = Math.max(...offsets.map(o => Math.abs(o.y)));

                const profile = {
                    id: `sk316-${this.currentCardSize}-${this.currentGridSize.rows}x${this.currentGridSize.cols}-${Date.now()}`,
                    name: name || 'SK316 Profile',
                    cardSize: this.currentCardSize,
                    gridSize: this.currentGridSize,
                    createdAt: new Date().toISOString(),
                    offsetData: this.offsetData,
                    statistics: {
                        avgOffsetX: parseFloat(avgX.toFixed(3)),
                        avgOffsetY: parseFloat(avgY.toFixed(3)),
                        maxOffsetX: parseFloat(maxOffsetX.toFixed(3)),
                        maxOffsetY: parseFloat(maxOffsetY.toFixed(3)),
                        totalCells: this.currentGridSize.rows * this.currentGridSize.cols
                    }
                };

                const json = JSON.stringify(profile, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${profile.name.replace(/\s+/g, '_')}_${profile.cardSize}.json`;
                a.click();
                URL.revokeObjectURL(url);

                this.showToast('üì§ ƒê√£ xu·∫•t JSON th√†nh c√¥ng', 'success');
            }

            importProfile() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';

                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const profile = JSON.parse(event.target.result);

                            // Validate profile
                            if (!profile.id || !profile.cardSize || !profile.gridSize || !profile.offsetData) {
                                throw new Error('File JSON kh√¥ng h·ª£p l·ªá');
                            }

                            // Add to profiles
                            profile.lastUsed = new Date().toISOString();
                            this.profiles.push(profile);
                            this.saveProfilesToStorage();
                            this.renderProfilesList();
                            this.updateProfileSelect();

                            this.showToast('üì• ƒê√£ nh·∫≠p profile th√†nh c√¥ng', 'success');

                        } catch (err) {
                            console.error('Import error:', err);
                            this.showToast('‚ùå L·ªói: ' + err.message, 'error');
                        }
                    };

                    reader.readAsText(file);
                };

                input.click();
            }

            newProfile() {
                // Reset current data
                this.currentProfile = null;
                this.offsetData = {};
                this.resetTable();
                this.updateHeatmap();
                this.updateStatistics();
                this.updateStatusBadge();

                const profileSelect = document.getElementById('sk316ProfileSelect');
                if (profileSelect) profileSelect.value = '';

                const nameInput = document.getElementById('sk316ProfileName');
                if (nameInput) nameInput.value = '';

                this.showToast('üìù ƒê√£ t·∫°o profile m·ªõi', 'info');
            }

            loadProfile(profileId) {
                if (!profileId) {
                    this.newProfile();
                    return;
                }

                const profile = this.profiles.find(p => p.id === profileId);
                if (!profile) return;

                // Validate profile matches current config
                if (profile.cardSize !== this.currentCardSize) {
                    this.showToast(
                        `‚ö†Ô∏è Profile kh√¥ng ph√π h·ª£p!\nProfile: ${profile.cardSize}\nHi·ªán t·∫°i: ${this.currentCardSize}`,
                        'error'
                    );
                    return;
                }

                if (profile.gridSize.rows !== this.currentGridSize.rows ||
                    profile.gridSize.cols !== this.currentGridSize.cols) {
                    this.showToast(
                        `‚ö†Ô∏è Grid size kh√¥ng kh·ªõp!\nProfile: ${profile.gridSize.rows}√ó${profile.gridSize.cols}\nHi·ªán t·∫°i: ${this.currentGridSize.rows}√ó${this.currentGridSize.cols}`,
                        'error'
                    );
                    return;
                }

                // Load profile data
                this.currentProfile = profile;
                this.offsetData = { ...profile.offsetData };

                // Load gutter if available
                if (profile.gutter !== null && profile.gutter !== undefined) {
                    this.selectedGutter = profile.gutter;
                    document.getElementById('selectedGutterValue').textContent = `${profile.gutter}mm`;
                    document.getElementById('selectedGutterDisplay').style.display = 'flex';
                } else {
                    this.selectedGutter = null;
                    document.getElementById('selectedGutterDisplay').style.display = 'none';
                }

                // Update inputs
                Object.keys(this.offsetData).forEach(key => {
                    const offset = this.offsetData[key];
                    const xInput = document.querySelector(`input[data-key="${key}"][data-axis="x"]`);
                    const yInput = document.querySelector(`input[data-key="${key}"][data-axis="y"]`);

                    if (xInput) xInput.value = offset.x.toFixed(1);
                    if (yInput) yInput.value = offset.y.toFixed(1);
                });

                // Update UI
                this.updateHeatmap();
                this.updateStatistics();
                this.updateStatusBadge();

                // Update name input
                const nameInput = document.getElementById('sk316ProfileName');
                if (nameInput) nameInput.value = profile.name;

                // Update last used
                profile.lastUsed = new Date().toISOString();
                this.saveProfilesToStorage();

                this.showToast('‚úÖ ƒê√£ t·∫£i profile: ' + profile.name, 'success');
            }

            renderProfilesList() {
                const grid = document.getElementById('sk316ProfilesGrid');
                const list = document.getElementById('sk316ProfilesList');
                if (!grid || !list) return;

                if (this.profiles.length === 0) {
                    list.style.display = 'none';
                    return;
                }

                list.style.display = 'block';
                grid.innerHTML = '';

                this.profiles.forEach(profile => {
                    const card = document.createElement('div');
                    card.className = 'profile-card';
                    if (this.currentProfile && this.currentProfile.id === profile.id) {
                        card.classList.add('active');
                    }

                    const createdDate = new Date(profile.createdAt).toLocaleDateString('vi-VN');

                    card.innerHTML = `
                        <div class="profile-card-header">
                            <div class="profile-name">${profile.name}</div>
                        </div>
                        <div class="profile-meta">
                            Card: ${profile.cardSize}mm | Grid: ${profile.gridSize.rows}√ó${profile.gridSize.cols}
                        </div>
                        <div class="profile-meta">
                            T·∫°o: ${createdDate}
                        </div>
                        <div class="profile-meta">
                            Avg: X=${profile.statistics.avgOffsetX.toFixed(2)}mm, Y=${profile.statistics.avgOffsetY.toFixed(2)}mm
                        </div>
                        <div class="profile-actions">
                            <button class="profile-action-btn use" data-id="${profile.id}">S·ª≠ d·ª•ng</button>
                            <button class="profile-action-btn export" data-id="${profile.id}">Xu·∫•t</button>
                            <button class="profile-action-btn delete" data-id="${profile.id}">X√≥a</button>
                        </div>
                    `;

                    // Use button
                    card.querySelector('.use').addEventListener('click', () => {
                        const select = document.getElementById('sk316ProfileSelect');
                        if (select) select.value = profile.id;
                        this.loadProfile(profile.id);
                    });

                    // Export button
                    card.querySelector('.export').addEventListener('click', () => {
                        const json = JSON.stringify(profile, null, 2);
                        const blob = new Blob([json], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${profile.name.replace(/\s+/g, '_')}.json`;
                        a.click();
                        URL.revokeObjectURL(url);
                        this.showToast('üì§ ƒê√£ xu·∫•t profile', 'success');
                    });

                    // Delete button
                    card.querySelector('.delete').addEventListener('click', () => {
                        if (confirm(`X√≥a profile "${profile.name}"?`)) {
                            this.profiles = this.profiles.filter(p => p.id !== profile.id);
                            this.saveProfilesToStorage();
                            this.renderProfilesList();
                            this.updateProfileSelect();

                            if (this.currentProfile && this.currentProfile.id === profile.id) {
                                this.newProfile();
                            }

                            this.showToast('üóëÔ∏è ƒê√£ x√≥a profile', 'info');
                        }
                    });

                    grid.appendChild(card);
                });
            }

            updateProfileSelect() {
                const select = document.getElementById('sk316ProfileSelect');
                if (!select) return;

                const currentValue = select.value;
                select.innerHTML = '<option value="">-- Ch·ªçn profile --</option>';

                this.profiles.forEach(profile => {
                    const option = document.createElement('option');
                    option.value = profile.id;
                    option.textContent = `${profile.name} (${profile.cardSize}mm, ${profile.gridSize.rows}√ó${profile.gridSize.cols})`;
                    select.appendChild(option);
                });

                select.value = currentValue;
            }

            updateStatusBadge() {
                const badge = document.getElementById('sk316StatusBadge');
                if (badge) {
                    if (this.currentProfile) {
                        badge.textContent = '‚úì ƒêang s·ª≠ d·ª•ng: ' + this.currentProfile.name;
                        badge.className = 'status-badge active';
                    } else {
                        badge.textContent = '‚óã Ch∆∞a k√≠ch ho·∫°t';
                        badge.className = 'status-badge inactive';
                    }
                }

                // Update preview metric card
                this.updatePreviewMetric();

                // Update export status badge
                this.updateExportStatus();
            }

            updatePreviewMetric() {
                const metricCard = document.getElementById('sk316MetricCard');
                const metricIcon = document.getElementById('sk316MetricIcon');
                const metricValue = document.getElementById('sk316MetricValue');
                const metricLabel = document.getElementById('sk316MetricLabel');

                if (!metricCard) return;

                if (this.currentProfile) {
                    metricCard.className = 'metric-card sk316-metric active';
                    if (metricIcon) metricIcon.textContent = '‚úì';
                    if (metricValue) metricValue.textContent = 'SK316';
                    if (metricLabel) metricLabel.textContent = 'B·∫¨T';
                    metricCard.title = `SK316: ${this.currentProfile.name}\n${this.currentProfile.cardSize} | ${this.currentProfile.gridSize.rows}√ó${this.currentProfile.gridSize.cols}`;
                } else {
                    metricCard.className = 'metric-card sk316-metric inactive';
                    if (metricIcon) metricIcon.textContent = '‚óã';
                    if (metricValue) metricValue.textContent = 'SK316';
                    if (metricLabel) metricLabel.textContent = 'T·∫ÆT';
                    metricCard.title = 'Tr·∫°ng th√°i hi·ªáu chu·∫©n SK316';
                }
            }

            updateExportStatus() {
                const statusBadge = document.getElementById('sk316ExportBadge');
                const profileInfo = document.getElementById('sk316ProfileInfo');
                const profileName = document.getElementById('sk316ExportProfileName');
                const profileDetails = document.getElementById('sk316ExportProfileDetails');

                if (!statusBadge) return;

                if (this.currentProfile) {
                    // Active state
                    statusBadge.className = 'sk316-status-badge active';
                    statusBadge.innerHTML = `
                        <span class="status-icon">‚úì</span>
                        <span class="status-text">SK316: B·∫¨T</span>
                    `;

                    // Show profile info
                    if (profileInfo) profileInfo.style.display = 'block';
                    if (profileName) profileName.textContent = `Profile: ${this.currentProfile.name}`;

                    if (profileDetails) {
                        const avgX = Object.values(this.currentProfile.offsetData)
                            .reduce((sum, o) => sum + o.x, 0) / Object.keys(this.currentProfile.offsetData).length;
                        const avgY = Object.values(this.currentProfile.offsetData)
                            .reduce((sum, o) => sum + o.y, 0) / Object.keys(this.currentProfile.offsetData).length;

                        let detailsHTML = `
                            <strong>${this.currentProfile.cardSize}</strong> | Grid: <strong>${this.currentProfile.gridSize.rows}√ó${this.currentProfile.gridSize.cols}</strong><br>
                            Offset TB: X=${avgX.toFixed(2)}mm, Y=${avgY.toFixed(2)}mm
                        `;

                        // Add gutter if available
                        if (this.currentProfile.gutter !== null && this.currentProfile.gutter !== undefined) {
                            detailsHTML += `<br>Gutter t·ªëi ∆∞u: <strong>${this.currentProfile.gutter}mm</strong>`;
                        }

                        profileDetails.innerHTML = detailsHTML;
                    }
                } else {
                    // Inactive state
                    statusBadge.className = 'sk316-status-badge inactive';
                    statusBadge.innerHTML = `
                        <span class="status-icon">‚óã</span>
                        <span class="status-text">SK316: T·∫ÆT</span>
                    `;

                    // Hide profile info
                    if (profileInfo) profileInfo.style.display = 'none';
                }
            }

            updateUI() {
                this.updateHeatmap();
                this.updateStatistics();
                this.updateStatusBadge();
                this.updateProfileSelect();
            }

            saveProfilesToStorage() {
                try {
                    localStorage.setItem('sk316Profiles', JSON.stringify(this.profiles));
                } catch (err) {
                    console.error('Error saving to localStorage:', err);
                }
            }

            loadProfilesFromStorage() {
                try {
                    const data = localStorage.getItem('sk316Profiles');
                    if (data) {
                        this.profiles = JSON.parse(data);
                    }
                } catch (err) {
                    console.error('Error loading from localStorage:', err);
                    this.profiles = [];
                }
            }

            showToast(message, type = 'info') {
                // Reuse converter toast if available
                if (window.converter && typeof window.converter.showToast === 'function') {
                    window.converter.showToast(message, type);
                } else {
                    alert(message);
                }
            }

            // Apply offset to layout (called from print export)
            applyOffsetToLayout(row, col, baseX, baseY, dpi) {
                if (!this.currentProfile) {
                    return { x: baseX, y: baseY };
                }

                const key = `r${row + 1}c${col + 1}`;
                const offsetMm = this.currentProfile.offsetData[key];

                if (!offsetMm) {
                    return { x: baseX, y: baseY };
                }

                // Convert mm to px
                const offsetPx = {
                    x: (offsetMm.x / 25.4) * dpi,
                    y: (offsetMm.y / 25.4) * dpi
                };

                return {
                    x: baseX + offsetPx.x,
                    y: baseY + offsetPx.y
                };
            }

            // Get active profile for print export
            getActiveProfile() {
                return this.currentProfile;
            }

            getOptimalGutter() {
                // Return gutter t·ª´ active profile (mm)
                if (this.currentProfile && this.currentProfile.gutter !== null) {
                    return this.currentProfile.gutter;
                }
                return null; // No gutter optimization set
            }
        }

        // Initialize SK316 system
        const sk316System = new SK316CalibrationSystem();
        window.sk316System = sk316System;

        // Add click listener to SK316 metric card to switch to SK316 tab
        const sk316MetricCard = document.getElementById('sk316MetricCard');
        if (sk316MetricCard) {
            sk316MetricCard.addEventListener('click', () => {
                const sk316Tab = document.getElementById('sk316Tab');
                if (sk316Tab) {
                    sk316Tab.click();
                }
            });
        }

        // Enhanced Template Crop Functions - Progress Steps & Upload Handling
        window.updateProgressSteps = function(currentStep) {
            console.log('üìä C·∫≠p nh·∫≠t b∆∞·ªõc ti·∫øn tr√¨nh:', currentStep);
            
            const progressSteps = document.querySelectorAll('.progress-step');
            progressSteps.forEach((step, index) => {
                step.classList.remove('active', 'completed');
                
                if (index + 1 < currentStep) {
                    step.classList.add('completed');
                } else if (index + 1 === currentStep) {
                    step.classList.add('active');
                }
            });
            
            // Show/hide sections based on current step
            const sectionModern = document.querySelector('.size-selection-modern');
            const uploadArea = document.querySelector('.upload-area-modern');
            const processingArea = document.querySelector('.processing-area');
            const resultsSection = document.querySelector('.crop-results');
            
            if (sectionModern) sectionModern.style.display = currentStep === 1 ? 'block' : 'none';
            if (uploadArea) uploadArea.style.display = currentStep === 2 ? 'block' : 'none';  
            if (processingArea) processingArea.style.display = currentStep === 3 ? 'block' : 'none';
            if (resultsSection) resultsSection.style.display = currentStep === 4 ? 'block' : 'none';
            
            // Also show the crop results section when we have cropped images
            const cropResults = document.getElementById('cropResults');
            if (cropResults && currentStep === 4) {
                cropResults.style.display = 'block';
            }
        };

        // Handle Template Crop Upload
        window.handleTemplateCropUpload = function(files) {
            console.log('üì§ X·ª≠ l√Ω upload ·∫£nh cho template crop:', files.length, 'files');
            
            const processingArea = document.querySelector('.processing-area');
            const progressBar = document.querySelector('.progress-bar');
            const processedCount = document.querySelector('.processed-count');
            const totalCount = document.querySelector('.total-count');
            
            if (processingArea) processingArea.style.display = 'block';
            if (totalCount) totalCount.textContent = files.length;
            
            let processed = 0;
            const total = files.length;
            
            Array.from(files).forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // Simulate processing
                    setTimeout(() => {
                        processed++;
                        const progress = (processed / total) * 100;
                        
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (processedCount) processedCount.textContent = processed;
                        
                        // When complete, move to results
                        if (processed === total) {
                            setTimeout(() => {
                                window.updateProgressSteps(4);
                                window.showTemplateCropResults(files);
                            }, 500);
                        }
                    }, (index + 1) * 300); // Stagger processing for visual effect
                };
                reader.readAsDataURL(file);
            });
        };

        // Show Template Crop Results
        window.showTemplateCropResults = function(files) {
            console.log('üìä Hi·ªÉn th·ªã k·∫øt qu·∫£ template crop');
            
            const resultsGrid = document.querySelector('.results-grid');
            const totalImages = document.querySelector('.total-images');
            const processedImagesSpan = document.querySelector('.processed-images');
            
            if (totalImages) totalImages.textContent = files.length;
            if (processedImagesSpan) processedImagesSpan.textContent = files.length;
            
            if (resultsGrid) {
                resultsGrid.innerHTML = '';
                
                Array.from(files).forEach(file => {
                    const resultItem = document.createElement('div');
                    resultItem.className = 'result-item';
                    resultItem.innerHTML = `
                        <img src="${URL.createObjectURL(file)}" alt="${file.name}">
                        <div class="result-name">${file.name}</div>
                        <div class="result-actions">
                            <button class="action-btn">üíæ T·∫£i v·ªÅ</button>
                            <button class="action-btn">üëÅÔ∏è Xem</button>
                        </div>
                    `;
                    resultsGrid.appendChild(resultItem);
                });
            }
        };

        // Function to show crop results section with downloaded images
        window.showCropResultsSection = function() {
            console.log('üìä Hi·ªÉn th·ªã section k·∫øt qu·∫£ crop');
            
            const cropResults = document.getElementById('cropResults');
            if (cropResults) {
                cropResults.style.display = 'block';
                
                // Update results summary if available
                const processedImages = document.querySelector('.processed-images');
                const totalImages = document.querySelector('.total-images');
                
                // Try to get count from converter or other sources
                if (window.converter && window.converter.files) {
                    const croppedCount = window.converter.files.filter(f => f.cropped).length;
                    if (processedImages) processedImages.textContent = croppedCount;
                    if (totalImages) totalImages.textContent = croppedCount;
                } else {
                    // Fallback to show the section anyway
                    if (processedImages) processedImages.textContent = '?';
                    if (totalImages) totalImages.textContent = '?';
                }
                
                console.log('‚úÖ Crop results section is now visible');
            } else {
                console.warn('‚ùå Kh√¥ng t√¨m th·∫•y crop results section');
            }
        };

        // Auto-show crop results when there are cropped images
        window.checkAndShowCropResults = function() {
            if (window.converter && window.converter.files) {
                const hasCroppedImages = window.converter.files.some(f => f.cropped);
                if (hasCroppedImages) {
                    window.showCropResultsSection();
                }
            }
            
            // Also check converter crop data
            if (window.converter && (window.converter.cropProcessedFiles?.length > 0 || window.converter.cropData?.croppedImages?.length > 0)) {
                window.showCropResultsSection();
            }
            
            // Also check for any existing cropped files in gallery or other sources
            if (window.layoutManager && window.layoutManager.galleryImages) {
                const hasGalleryImages = window.layoutManager.galleryImages.length > 0;
                if (hasGalleryImages) {
                    window.showCropResultsSection();
                }
            }
        };

        // Call this periodically to check for cropped images
        setInterval(() => {
            window.checkAndShowCropResults();
        }, 2000);

        // Also check immediately when page loads
        setTimeout(() => {
            window.checkAndShowCropResults();
        }, 1000);

        console.log('‚úÖ Enhanced Template Crop functions loaded successfully');

        // üìÇ T·∫°o folder structure cho filesystem modal
        const generateModalFolderStructure = function(images) {
            // Nh√≥m ·∫£nh theo th∆∞ m·ª•c
            const folderMap = {};

            images.forEach(img => {
                const folderPath = img.folder || 'Th∆∞ m·ª•c g·ªëc';
                if (!folderMap[folderPath]) {
                    folderMap[folderPath] = [];
                }
                folderMap[folderPath].push(img);
            });

            // T·∫°o HTML cho t·ª´ng folder
            let folderHTML = '';
            const folderKeys = Object.keys(folderMap).sort();

            folderKeys.forEach(folderPath => {
                const images = folderMap[folderPath];
                const folderName = folderPath === 'Th∆∞ m·ª•c g·ªëc' ? 'üìÅ Th∆∞ m·ª•c g·ªëc' : 'üìÅ ' + folderPath.split('/').pop();
                const folderId = 'modal-folder-' + folderPath.replace(/[^a-zA-Z0-9]/g, '-');

                folderHTML +=
                    '<div class="fs-modal-folder-group">' +
                        '<div class="fs-modal-folder-header" data-folder="' + folderId + '">' +
                            '<span class="fs-modal-folder-toggle">‚ñº</span>' +
                            '<span class="fs-modal-folder-name">' + folderName + '</span>' +
                            '<span class="fs-modal-folder-count">(' + images.length + ' ·∫£nh)</span>' +
                        '</div>' +
                        '<div class="fs-modal-folder-content" id="' + folderId + '">' +
                            '<div class="fs-modal-images-grid">' +
                                images.map(img =>
                                    '<div class="filesystem-image-item" data-file-name="' + img.name + '">' +
                                        '<div class="filesystem-image-preview">' +
                                            '<img src="' + img.url + '" alt="' + img.name + '" loading="lazy">' +
                                            '<div class="filesystem-image-overlay">' +
                                                '<div class="filesystem-image-info">' +
                                                    '<div class="filesystem-image-name">' + img.name + '</div>' +
                                                    '<div class="filesystem-image-details">' + img.sizeFormatted + ' ‚Ä¢ ' + img.dateFormatted + '</div>' +
                                                '</div>' +
                                            '</div>' +
                                        '</div>' +
                                        '<div class="filesystem-image-checkbox">' +
                                            '<input type="checkbox" id="fs-img-' + img.name + '" value="' + img.name + '">' +
                                            '<label for="fs-img-' + img.name + '">‚úì</label>' +
                                        '</div>' +
                                    '</div>'
                                ).join('') +
                            '</div>' +
                        '</div>' +
                    '</div>';
            });

            return folderHTML;
        };

        // üìÇ File System Image Picker Modal
        window.createFileSystemImagePicker = async function(options = {}) {
            const {
                title = 'Ch·ªçn ·∫£nh t·ª´ File System',
                multiple = true,
                onSelect = null,
                maxSelection = null
            } = options;

            // Ki·ªÉm tra quy·ªÅn File System
            if (!window.converter?.fileSystemStorage?.directoryHandle) {
                if (window.converter && typeof window.converter.showToast === 'function') {
                    window.converter.showToast('‚ùå Ch∆∞a c·∫•p quy·ªÅn File System!', 'error');
                } else {
                    alert('‚ùå Ch∆∞a c·∫•p quy·ªÅn File System!');
                }
                return null;
            }

            try {
                // L·∫•y danh s√°ch ·∫£nh
                const images = await window.converter.fileSystemStorage.getImagesList();

                if (images.length === 0) {
                    if (window.converter && typeof window.converter.showToast === 'function') {
                        window.converter.showToast('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ·∫£nh n√†o trong th∆∞ m·ª•c!', 'warning');
                    } else {
                        alert('‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y ·∫£nh n√†o trong th∆∞ m·ª•c!');
                    }
                    return null;
                }

                // T·∫°o modal
                const modal = document.createElement('div');
                modal.className = 'filesystem-modal-overlay';
                modal.innerHTML =
                    '<div class="filesystem-modal">' +
                        '<div class="filesystem-modal-header">' +
                            '<h3>' + title + '</h3>' +
                            '<button class="filesystem-modal-close">‚úï</button>' +
                        '</div>' +
                        '<div class="filesystem-modal-content">' +
                            '<div class="filesystem-stats">' +
                                'üìÅ T√¨m th·∫•y <strong>' + images.length + '</strong> ·∫£nh trong th∆∞ m·ª•c <strong>' + window.converter.fileSystemStorage.directoryHandle.name + '</strong>' +
                                '<div style="margin-top: 8px; font-size: 0.85rem; opacity: 0.8; font-weight: normal;">' +
                                    'üí° M·∫πo: Click ƒë·ªÉ ch·ªçn ‚Ä¢ Double-click ƒë·ªÉ xem nhanh ‚Ä¢ Hover ƒë·ªÉ th·∫•y th√¥ng tin' +
                                '</div>' +
                            '</div>' +
                            '<div class="filesystem-images-grid" id="filesystemImagesGrid">' +
                                generateModalFolderStructure(images) +
                            '</div>' +
                        '</div>' +
                        '<div class="filesystem-modal-footer">' +
                            '<div class="filesystem-selection-info">' +
                                'ƒê√£ ch·ªçn: <span id="filesystemSelectionCount">0</span> ·∫£nh' +
                            '</div>' +
                            '<div class="filesystem-modal-actions">' +
                                '<button class="filesystem-btn secondary" id="filesystemSelectAllBtn">Ch·ªçn t·∫•t c·∫£</button>' +
                                '<button class="filesystem-btn secondary" id="filesystemDeselectAllBtn" style="display: none;">B·ªè ch·ªçn t·∫•t c·∫£</button>' +
                                '<button class="filesystem-btn secondary" id="filesystemCancelBtn">H·ªßy</button>' +
                                '<button class="filesystem-btn primary" id="filesystemSelectBtn" disabled>Ch·ªçn ·∫£nh</button>' +
                            '</div>' +
                        '</div>' +
                    '</div>';

                // Th√™m CSS cho modal
                if (!document.getElementById('filesystem-modal-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'filesystem-modal-styles';
                    styles.textContent = `
                        .filesystem-modal-overlay {
                            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                            background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center;
                            z-index: 10000; backdrop-filter: blur(5px);
                        }
                        .filesystem-modal {
                            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
                            border-radius: 20px; max-width: 95vw; max-height: 95vh;
                            width: 900px; display: flex; flex-direction: column;
                            box-shadow: 0 25px 50px rgba(0,0,0,0.25), 0 0 0 1px rgba(255,255,255,0.5);
                            border: 2px solid rgba(255,255,255,0.2);
                        }
                        .filesystem-modal-header {
                            padding: 24px 28px; border-bottom: 2px solid #e2e8f0;
                            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
                            display: flex; justify-content: space-between; align-items: center;
                            border-radius: 18px 18px 0 0;
                        }
                        .filesystem-modal-header h3 {
                            margin: 0; font-size: 1.4rem; font-weight: 700;
                            color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        }
                        .filesystem-modal-close {
                            background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3);
                            font-size: 1.5rem; cursor: pointer; padding: 8px 12px;
                            border-radius: 50%; color: white; font-weight: bold;
                            transition: all 0.3s ease; backdrop-filter: blur(10px);
                        }
                        .filesystem-modal-close:hover {
                            background: rgba(255,255,255,0.3); transform: scale(1.1);
                            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                        }
                        .filesystem-modal-content {
                            padding: 24px 28px; flex: 1; overflow-y: auto;
                            background: linear-gradient(135deg, #fefefe 0%, #f8fafc 100%);
                        }
                        .filesystem-stats {
                            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
                            padding: 16px 20px; border-radius: 12px; margin-bottom: 24px;
                            font-size: 1rem; font-weight: 600; color: #1e40af;
                            border: 2px solid #93c5fd; box-shadow: 0 4px 12px rgba(59,130,246,0.1);
                            text-align: center;
                        }
                        .filesystem-images-grid {
                            display: block !important;
                            width: 100% !important;
                        }
                        .filesystem-image-item {
                            position: relative; border-radius: 12px; overflow: hidden; cursor: pointer;
                            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                            border: 3px solid transparent; background: white;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
                        }
                        .filesystem-image-item:hover {
                            transform: translateY(-4px) scale(1.02);
                            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
                            border-color: #60a5fa;
                        }
                        .filesystem-image-preview {
                            position: relative; aspect-ratio: 1; background: #f8fafc;
                            border-radius: 8px; overflow: hidden; margin: 6px;
                        }
                        .filesystem-image-preview img {
                            width: 100%; height: 100%; object-fit: cover;
                            transition: all 0.3s ease;
                        }
                        .filesystem-image-item:hover .filesystem-image-preview img {
                            transform: scale(1.05);
                        }
                        .filesystem-image-overlay {
                            position: absolute; bottom: 0; left: 0; right: 0;
                            background: linear-gradient(transparent, rgba(0,0,0,0.9));
                            color: white; padding: 12px 8px; font-size: 0.8rem;
                            transform: translateY(100%); transition: all 0.3s ease;
                        }
                        .filesystem-image-item:hover .filesystem-image-overlay {
                            transform: translateY(0);
                        }
                        .filesystem-image-name {
                            font-weight: 600; margin-bottom: 3px; font-size: 0.75rem;
                            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
                        }
                        .filesystem-image-details {
                            opacity: 0.9; font-size: 0.7rem;
                        }
                        .filesystem-image-checkbox {
                            position: absolute; top: 10px; right: 10px; z-index: 10;
                        }
                        .filesystem-image-checkbox input { display: none; }
                        .filesystem-image-checkbox label {
                            display: flex; width: 32px; height: 32px;
                            background: rgba(255,255,255,0.9); backdrop-filter: blur(10px);
                            border: 2px solid #e2e8f0; border-radius: 50%;
                            align-items: center; justify-content: center;
                            color: #64748b; font-size: 16px; font-weight: bold;
                            cursor: pointer; transition: all 0.3s ease;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                        }
                        .filesystem-image-checkbox label:hover {
                            background: rgba(59,130,246,0.1); border-color: #3b82f6;
                            color: #3b82f6; transform: scale(1.1);
                        }
                        .filesystem-image-checkbox input:checked + label {
                            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                            border-color: #059669; color: white; transform: scale(1.15);
                            box-shadow: 0 4px 15px rgba(16,185,129,0.4);
                        }
                        .filesystem-image-item.selected {
                            border-color: #10b981; background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
                            box-shadow: 0 8px 25px rgba(16,185,129,0.2);
                        }
                        .filesystem-image-item.selected .filesystem-image-preview {
                            border: 2px solid #10b981;
                        }
                        .filesystem-modal-footer {
                            padding: 24px 28px; border-top: 2px solid #e2e8f0;
                            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                            display: flex; justify-content: space-between; align-items: center;
                            box-shadow: 0 -4px 20px rgba(0,0,0,0.05);
                        }
                        .filesystem-selection-info {
                            font-size: 1rem; font-weight: 600; color: #475569;
                            padding: 8px 16px; background: rgba(255,255,255,0.8);
                            border-radius: 20px; border: 2px solid #cbd5e1;
                        }
                        .filesystem-modal-actions {
                            display: flex; gap: 12px; align-items: center;
                        }
                        .filesystem-btn {
                            padding: 12px 24px; border-radius: 25px; font-weight: 600;
                            cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                            border: 2px solid transparent; font-size: 0.95rem;
                            position: relative; overflow: hidden;
                        }
                        .filesystem-btn::before {
                            content: ''; position: absolute; top: 0; left: -100%;
                            width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
                            transition: left 0.5s ease;
                        }
                        .filesystem-btn:hover::before { left: 100%; }
                        .filesystem-btn.secondary {
                            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
                            color: #475569; border-color: #cbd5e1;
                        }
                        .filesystem-btn.secondary:hover {
                            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
                            transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                            border-color: #94a3b8;
                        }
                        .filesystem-btn.primary {
                            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                            color: white; border-color: #059669;
                            box-shadow: 0 4px 15px rgba(16,185,129,0.3);
                        }
                        .filesystem-btn.primary:hover:not(:disabled) {
                            background: linear-gradient(135deg, #059669 0%, #047857 100%);
                            transform: translateY(-3px); box-shadow: 0 8px 25px rgba(16,185,129,0.4);
                            border-color: #047857;
                        }
                        .filesystem-btn.primary:disabled {
                            background: linear-gradient(135deg, #d1d5db 0%, #9ca3af 100%);
                            cursor: not-allowed; transform: none; box-shadow: none;
                            border-color: #9ca3af;
                        }
                        /* Enhanced Folder organization - Si√™u t√¢m l√Ω ng∆∞·ªùi d√πng */
                        .fs-modal-folder-group {
                            margin-bottom: 24px; border: 2px solid #e5e7eb; border-radius: 12px;
                            overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.06);
                            transition: all 0.3s ease;
                        }
                        .fs-modal-folder-group:hover {
                            border-color: #3b82f6; box-shadow: 0 4px 12px rgba(59,130,246,0.1);
                        }
                        .fs-modal-folder-header {
                            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
                            padding: 16px 20px; display: flex; align-items: center; gap: 12px;
                            cursor: pointer; user-select: none; border-bottom: 2px solid #e2e8f0;
                            transition: all 0.3s ease; position: relative;
                        }
                        .fs-modal-folder-header:hover {
                            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
                            transform: translateY(-1px);
                        }
                        .fs-modal-folder-header::before {
                            content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 4px;
                            background: #3b82f6; transition: all 0.3s ease; opacity: 0;
                        }
                        .fs-modal-folder-header:hover::before { opacity: 1; }
                        .fs-modal-folder-toggle {
                            font-size: 16px; font-weight: bold; transition: all 0.3s ease;
                            color: #3b82f6; width: 24px; text-align: center;
                        }
                        .fs-modal-folder-header.collapsed .fs-modal-folder-toggle {
                            transform: rotate(-90deg); color: #6b7280;
                        }
                        .fs-modal-folder-name {
                            font-weight: 700; font-size: 1.1rem; color: #1e293b; flex: 1;
                            text-shadow: 0 1px 2px rgba(0,0,0,0.05);
                        }
                        .fs-modal-folder-count {
                            font-size: 0.9rem; font-weight: 600; color: #3b82f6;
                            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
                            padding: 6px 12px; border-radius: 20px; border: 2px solid #93c5fd;
                            box-shadow: 0 2px 4px rgba(59,130,246,0.1);
                        }
                        .fs-modal-folder-content {
                            padding: 20px; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                            background: #fafbfc;
                        }
                        .fs-modal-folder-content.collapsed {
                            display: none;
                        }
                        .fs-modal-images-grid {
                            display: grid !important;
                            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)) !important;
                            gap: 12px !important;
                            padding: 8px !important;
                            width: 100% !important;
                            justify-items: center !important;
                        }
                        @media (max-width: 600px) {
                            .fs-modal-images-grid {
                                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)) !important;
                                gap: 8px !important;
                            }
                        }
                    `;
                    document.head.appendChild(styles);
                }

                // Th√™m modal v√†o DOM
                document.body.appendChild(modal);

                // Logic x·ª≠ l√Ω
                let selectedImages = [];
                const grid = modal.querySelector('#filesystemImagesGrid');
                const countSpan = modal.querySelector('#filesystemSelectionCount');
                const selectBtn = modal.querySelector('#filesystemSelectBtn');

                // Update selection count and enable/disable button
                const updateSelectionCount = () => {
                    const count = selectedImages.length;
                    const totalImages = images.length;
                    const selectAllBtn = modal.querySelector('#filesystemSelectAllBtn');
                    const deselectAllBtn = modal.querySelector('#filesystemDeselectAllBtn');

                    if (countSpan) {
                        countSpan.textContent = count;
                    }
                    if (selectBtn) {
                        selectBtn.disabled = count === 0;
                        selectBtn.textContent = count > 0 ? `Ch·ªçn ${count} ·∫£nh` : 'Ch·ªçn ·∫£nh';
                    }

                    // Show/hide select all / deselect all buttons
                    if (selectAllBtn) {
                        selectAllBtn.style.display = count === totalImages ? 'none' : 'inline-block';
                    }
                    if (deselectAllBtn) {
                        deselectAllBtn.style.display = count > 0 ? 'inline-block' : 'none';
                    }
                };

                // Initialize selection state
                updateSelectionCount();

                // X·ª≠ l√Ω folder toggle
                grid.addEventListener('click', (e) => {
                    const folderHeader = e.target.closest('.fs-modal-folder-header');
                    if (folderHeader) {
                        const folderId = folderHeader.dataset.folder;
                        const folderContent = modal.querySelector('#' + folderId);

                        if (folderContent) {
                            const isCollapsed = folderContent.classList.contains('collapsed');

                            if (isCollapsed) {
                                // M·ªü folder
                                folderContent.classList.remove('collapsed');
                                folderHeader.classList.remove('collapsed');
                            } else {
                                // ƒê√≥ng folder
                                folderContent.classList.add('collapsed');
                                folderHeader.classList.add('collapsed');
                            }
                        }
                        return; // NgƒÉn event bubbling
                    }
                });

                // Th√™m quick preview khi double-click
                grid.addEventListener('dblclick', (e) => {
                    const item = e.target.closest('.filesystem-image-item');
                    if (!item) return;

                    const imgSrc = item.querySelector('img').src;
                    const fileName = item.dataset.fileName;

                    // T·∫°o preview overlay
                    const preview = document.createElement('div');
                    preview.className = 'quick-preview-overlay';
                    preview.innerHTML = `
                        <div class="quick-preview-content">
                            <div class="quick-preview-header">
                                <h4>üëÅÔ∏è Xem nhanh: ${fileName}</h4>
                                <button class="quick-preview-close">‚úï</button>
                            </div>
                            <div class="quick-preview-image">
                                <img src="${imgSrc}" alt="${fileName}">
                            </div>
                        </div>
                    `;

                    // Th√™m CSS cho preview
                    if (!document.getElementById('quick-preview-styles')) {
                        const previewStyles = document.createElement('style');
                        previewStyles.id = 'quick-preview-styles';
                        previewStyles.textContent =
                            '.quick-preview-overlay {' +
                                'position: fixed; top: 0; left: 0; right: 0; bottom: 0;' +
                                'background: rgba(0,0,0,0.9); z-index: 15000;' +
                                'display: flex; align-items: center; justify-content: center;' +
                                'animation: fadeIn 0.3s ease;' +
                            '}' +
                            '.quick-preview-content {' +
                                'max-width: 90vw; max-height: 90vh; background: white;' +
                                'border-radius: 12px; overflow: hidden; animation: scaleIn 0.3s ease;' +
                            '}' +
                            '.quick-preview-header {' +
                                'padding: 16px 20px; background: #1e293b; color: white;' +
                                'display: flex; justify-content: space-between; align-items: center;' +
                            '}' +
                            '.quick-preview-close {' +
                                'background: rgba(255,255,255,0.2); border: none; color: white;' +
                                'border-radius: 50%; width: 32px; height: 32px; cursor: pointer;' +
                                'transition: all 0.3s ease;' +
                            '}' +
                            '.quick-preview-close:hover { background: rgba(255,255,255,0.3); transform: scale(1.1); }' +
                            '.quick-preview-image { padding: 20px; text-align: center; }' +
                            '.quick-preview-image img { max-width: 100%; max-height: 70vh; border-radius: 8px; }' +
                            '@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }' +
                            '@keyframes scaleIn { from { transform: scale(0.9); } to { transform: scale(1); } }';
                        document.head.appendChild(previewStyles);
                    }

                    document.body.appendChild(preview);

                    // Close preview
                    const closePreview = () => preview.remove();
                    preview.querySelector('.quick-preview-close').onclick = closePreview;
                    preview.onclick = (e) => e.target === preview && closePreview();

                    e.stopPropagation();
                });

                // X·ª≠ l√Ω ch·ªçn ·∫£nh
                grid.addEventListener('click', (e) => {
                    const item = e.target.closest('.filesystem-image-item');
                    if (!item) return;

                    const checkbox = item.querySelector('input[type="checkbox"]');
                    const fileName = item.dataset.fileName;

                    if (!multiple && selectedImages.length > 0 && !checkbox.checked) {
                        // Uncheck other images for single selection
                        modal.querySelectorAll('.filesystem-image-item input[type="checkbox"]').forEach(cb => {
                            cb.checked = false;
                            cb.closest('.filesystem-image-item').classList.remove('selected');
                        });
                        selectedImages = [];
                    }

                    checkbox.checked = !checkbox.checked;
                    item.classList.toggle('selected', checkbox.checked);

                    if (checkbox.checked) {
                        if (!multiple) selectedImages = [fileName];
                        else if (!selectedImages.includes(fileName)) {
                            if (!maxSelection || selectedImages.length < maxSelection) {
                                selectedImages.push(fileName);
                            } else {
                                checkbox.checked = false;
                                item.classList.remove('selected');
                                if (window.converter && typeof window.converter.showToast === 'function') {
                                    window.converter.showToast('‚ùå Ch·ªâ c√≥ th·ªÉ ch·ªçn t·ªëi ƒëa ' + maxSelection + ' ·∫£nh!', 'warning');
                                } else {
                                    alert('‚ùå Ch·ªâ c√≥ th·ªÉ ch·ªçn t·ªëi ƒëa ' + maxSelection + ' ·∫£nh!');
                                }
                                return;
                            }
                        }
                    } else {
                        selectedImages = selectedImages.filter(name => name !== fileName);
                    }

                    // Update count and button state
                    updateSelectionCount();
                });

                // X·ª≠ l√Ω n√∫t
                const closeModal = () => {
                    // Cleanup URLs
                    images.forEach(img => URL.revokeObjectURL(img.url));
                    modal.remove();
                };

                modal.querySelector('.filesystem-modal-close').addEventListener('click', closeModal);
                modal.querySelector('#filesystemCancelBtn').addEventListener('click', closeModal);

                // Select All button event listener
                modal.querySelector('#filesystemSelectAllBtn').addEventListener('click', () => {
                    // Select all images
                    const imageItems = modal.querySelectorAll('.filesystem-image-item');
                    imageItems.forEach(item => {
                        const fileName = item.dataset.fileName;
                        const checkbox = item.querySelector('input[type="checkbox"]');

                        if (!selectedImages.includes(fileName)) {
                            selectedImages.push(fileName);
                            item.classList.add('selected');
                            if (checkbox) checkbox.checked = true;
                        }
                    });

                    // Update selection count and button state
                    updateSelectionCount();

                    // Show toast
                    if (window.converter && typeof window.converter.showToast === 'function') {
                        window.converter.showToast(`‚úÖ ƒê√£ ch·ªçn t·∫•t c·∫£ ${selectedImages.length} ·∫£nh`, 'success');
                    }
                });

                // Deselect All button event listener
                modal.querySelector('#filesystemDeselectAllBtn').addEventListener('click', () => {
                    // Deselect all images
                    const imageItems = modal.querySelectorAll('.filesystem-image-item');
                    imageItems.forEach(item => {
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        item.classList.remove('selected');
                        if (checkbox) checkbox.checked = false;
                    });

                    // Clear selection array
                    selectedImages = [];

                    // Update selection count and button state
                    updateSelectionCount();

                    // Show toast
                    if (window.converter && typeof window.converter.showToast === 'function') {
                        window.converter.showToast('‚úÖ ƒê√£ b·ªè ch·ªçn t·∫•t c·∫£ ·∫£nh', 'success');
                    }
                });

                modal.querySelector('#filesystemSelectBtn').addEventListener('click', async () => {
                    try {
                        const selectedFiles = [];
                        for (const fileName of selectedImages) {
                            const file = await window.converter.fileSystemStorage.getImageFile(fileName);
                            selectedFiles.push({ name: fileName, file });
                        }

                        closeModal();

                        if (onSelect) {
                            onSelect(selectedFiles);
                        }

                        return selectedFiles;
                    } catch (error) {
                        console.error('L·ªói l·∫•y file:', error);
                        if (window.converter && typeof window.converter.showToast === 'function') {
                            window.converter.showToast('‚ùå L·ªói l·∫•y file: ' + error.message, 'error');
                        } else {
                            alert('‚ùå L·ªói l·∫•y file: ' + error.message);
                        }
                    }
                });

                // Click overlay to close
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeModal();
                });

            } catch (error) {
                console.error('L·ªói t·∫°o file picker:', error);
                if (window.converter && typeof window.converter.showToast === 'function') {
                    window.converter.showToast('‚ùå L·ªói: ' + error.message, 'error');
                } else {
                    alert('‚ùå L·ªói: ' + error.message);
                }
                return null;
            }
        };

        // üîó Load Images From File System - Universal function
        window.loadImagesFromFileSystem = async function(section) {
            try {
                // Ki·ªÉm tra quy·ªÅn File System
                if (!window.converter?.fileSystemStorage?.directoryHandle) {
                    if (window.converter && typeof window.converter.showToast === 'function') {
                        window.converter.showToast('‚ùå Ch∆∞a c·∫•p quy·ªÅn File System! H√£y nh·∫•n n√∫t ·ªü header.', 'error');
                    } else {
                        alert('‚ùå Ch∆∞a c·∫•p quy·ªÅn File System! H√£y nh·∫•n n√∫t ·ªü header.');
                    }
                    return;
                }

                // C·∫•u h√¨nh theo section
                const configs = {
                    convert: {
                        title: 'Ch·ªçn ·∫£nh ƒë·ªÉ chuy·ªÉn ƒë·ªïi',
                        multiple: true,
                        onSelect: (files) => {
                            // Th√™m files v√†o Convert section
                            if (window.converter && typeof window.converter.handleFileSelect === 'function') {
                                const fileList = files.map(f => f.file);
                                window.converter.handleFileSelect(fileList);
                                if (typeof window.converter.showToast === 'function') {
                                    window.converter.showToast('‚úÖ ƒê√£ t·∫£i ' + files.length + ' ·∫£nh t·ª´ File System!', 'success');
                                }
                            } else {
                                // Fallback: create proper fileData objects and assign to converter.files
                                if (window.converter) {
                                    // Initialize files array if not exists
                                    if (!window.converter.files) window.converter.files = [];

                                    // Create proper fileData objects
                                    files.forEach((f, index) => {
                                        const fileData = {
                                            id: `file_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`,
                                            file: f.file,
                                            name: f.name,
                                            size: f.file.size,
                                            type: f.file.type,
                                            hash: `hash_${Date.now()}_${index}`,
                                            lastModified: f.file.lastModified,
                                            quality: { score: 80, issues: [] },
                                            status: 'pending'
                                        };
                                        window.converter.files.push(fileData);
                                    });

                                    // ALSO assign to this.files if context exists
                                    if (window.converter.files && typeof window.converter.files.push === 'function') {
                                        console.log('‚úÖ Successfully added to window.converter.files, length:', window.converter.files.length);
                                    }

                                    // Manually trigger file processing and UI updates
                                    setTimeout(() => {
                                        // Try to trigger UI update methods
                                        if (typeof window.converter.updateFileList === 'function') {
                                            window.converter.updateFileList();
                                        }
                                        if (typeof window.converter.updateStats === 'function') {
                                            window.converter.updateStats();
                                        }
                                        // Force refresh convert section display
                                        const convertBtn = document.querySelector('#convertAllBtn');
                                        if (convertBtn) {
                                            convertBtn.disabled = false;
                                            convertBtn.textContent = `Chuy·ªÉn ƒë·ªïi ${window.converter.files.length} ·∫£nh`;
                                        }

                                        // Show toast
                                        if (window.converter && typeof window.converter.showToast === 'function') {
                                            window.converter.showToast('‚úÖ ƒê√£ t·∫£i ' + files.length + ' ·∫£nh t·ª´ File System!', 'success');
                                        }
                                    }, 100);

                                    console.log('Files assigned directly to converter.files with proper fileData objects');
                                    console.log('üîç DEBUG: converter.files array length:', window.converter.files ? window.converter.files.length : 'undefined');
                                    console.log('üîç DEBUG: converter.files content:', window.converter.files);
                                }
                                console.log('handleFileSelect method not available, used enhanced fallback');
                            }
                        }
                    },
                    crop: {
                        title: 'Ch·ªçn ·∫£nh ƒë·ªÉ c·∫Øt',
                        multiple: true,
                        onSelect: (files) => {
                            // Th√™m files v√†o Crop section
                            if (window.converter && typeof window.converter.handleCropFileSelect === 'function') {
                                const fileList = files.map(f => f.file);
                                window.converter.handleCropFileSelect(fileList);
                                if (typeof window.converter.showToast === 'function') {
                                    window.converter.showToast('‚úÖ ƒê√£ t·∫£i ' + files.length + ' ·∫£nh v√†o Crop!', 'success');
                                }
                            } else {
                                // Fallback: create proper cropFiles objects and assign
                                if (window.converter) {
                                    if (!window.converter.cropFiles) window.converter.cropFiles = [];

                                    files.forEach(f => {
                                        // Check if file already exists to avoid duplicates
                                        const exists = window.converter.cropFiles.some(cf => cf.name === f.name && cf.size === f.file.size);
                                        if (!exists) {
                                            const fileData = {
                                                file: f.file,
                                                name: f.name,
                                                size: f.file.size,
                                                type: f.file.type,
                                                preview: null,
                                                id: Date.now() + Math.random()
                                            };

                                            // Generate preview
                                            const reader = new FileReader();
                                            reader.onload = (e) => {
                                                fileData.preview = e.target.result;
                                                // Update UI after preview is generated
                                                if (typeof window.converter.updateCropFilesDisplay === 'function') {
                                                    window.converter.updateCropFilesDisplay();
                                                } else if (typeof window.converter.populateCropFileGrid === 'function') {
                                                    window.converter.populateCropFileGrid();
                                                }
                                            };
                                            reader.readAsDataURL(f.file);

                                            window.converter.cropFiles.push(fileData);
                                        }
                                    });

                                    // Update crop file count
                                    const cropFileCount = document.getElementById('cropFileCount');
                                    if (cropFileCount) {
                                        cropFileCount.textContent = window.converter.cropFiles.length;
                                    }

                                    // Manually trigger crop UI updates
                                    setTimeout(() => {
                                        // Try to update crop UI
                                        if (typeof window.converter.updateCropFilesDisplay === 'function') {
                                            window.converter.updateCropFilesDisplay();
                                        } else if (typeof window.converter.populateCropFileGrid === 'function') {
                                            window.converter.populateCropFileGrid();
                                        }

                                        // Update crop button
                                        const cropBtn = document.querySelector('#startCroppingPage');
                                        if (cropBtn) {
                                            cropBtn.disabled = false;
                                            cropBtn.textContent = `B·∫Øt ƒë·∫ßu c·∫Øt ${window.converter.cropFiles.length} ·∫£nh`;
                                        }

                                        // Show toast
                                        if (window.converter && typeof window.converter.showToast === 'function') {
                                            window.converter.showToast('‚úÖ ƒê√£ t·∫£i ' + files.length + ' ·∫£nh v√†o Crop!', 'success');
                                        }
                                    }, 200); // Increased timeout for preview generation

                                    console.log('Files assigned directly to converter.cropFiles with proper cropFile objects');
                                    console.log('üîç DEBUG: converter.cropFiles array length:', window.converter.cropFiles ? window.converter.cropFiles.length : 'undefined');
                                    console.log('üîç DEBUG: converter.cropFiles content:', window.converter.cropFiles);
                                }
                                console.log('handleCropFileSelect method not available, used enhanced fallback');
                            }
                        }
                    },
                    templates: {
                        title: 'Ch·ªçn ·∫£nh cho template',
                        multiple: true,
                        onSelect: (files) => {
                            // Th√™m files v√†o Templates section
                            if (window.converter && typeof window.converter.handleTemplateFileSelect === 'function') {
                                const fileList = files.map(f => f.file);
                                window.converter.handleTemplateFileSelect(fileList);
                                if (typeof window.converter.showToast === 'function') {
                                    window.converter.showToast('‚úÖ ƒê√£ t·∫£i ' + files.length + ' ·∫£nh v√†o Templates!', 'success');
                                }
                            } else {
                                // Fallback for Templates section
                                if (window.converter) {
                                    // Store files in a temporary array for templates
                                    if (!window.converter.templateFiles) window.converter.templateFiles = [];
                                    files.forEach(f => {
                                        window.converter.templateFiles.push({
                                            file: f.file,
                                            name: f.name,
                                            url: URL.createObjectURL(f.file)
                                        });
                                    });

                                    // Try to update template UI
                                    setTimeout(() => {
                                        // Force update template display
                                        const templateGrid = document.querySelector('.template-upload-grid, .source-images');
                                        if (templateGrid) {
                                            // Add template images to grid manually
                                            files.forEach(f => {
                                                const img = document.createElement('div');
                                                img.className = 'template-image-item';
                                                img.innerHTML = `<img src="${URL.createObjectURL(f.file)}" alt="${f.name}"><span>${f.name}</span>`;
                                                templateGrid.appendChild(img);
                                            });
                                        }
                                    }, 100);

                                    console.log('Files assigned to template fallback with UI update');
                                }
                                console.warn('handleTemplateFileSelect method not available, used fallback');
                            }
                        }
                    },
                    gallery: {
                        title: 'Ch·ªçn ·∫£nh th√™m v√†o kho',
                        multiple: true,
                        onSelect: async (files) => {
                            // Th√™m files v√†o Gallery
                            if (window.converter && typeof window.converter.addImageToGallery === 'function') {
                                for (const f of files) {
                                    // Convert File to data URL for gallery
                                    const reader = new FileReader();
                                    reader.onload = async (e) => {
                                        await window.converter.addImageToGallery(e.target.result, f.name, false);
                                    };
                                    reader.readAsDataURL(f.file);
                                }
                                if (typeof window.converter.showToast === 'function') {
                                    window.converter.showToast('‚úÖ ƒê√£ th√™m ' + files.length + ' ·∫£nh v√†o kho!', 'success');
                                }
                            } else {
                                // Fallback for Gallery section
                                if (window.converter) {
                                    // Try to add images to gallery storage directly
                                    for (const f of files) {
                                        const reader = new FileReader();
                                        reader.onload = (e) => {
                                            // Try to save to localStorage as fallback
                                            const imageData = {
                                                name: f.name,
                                                data: e.target.result,
                                                timestamp: Date.now()
                                            };

                                            // Save to localStorage gallery
                                            const galleryImages = JSON.parse(localStorage.getItem('galleryImages') || '[]');
                                            galleryImages.push(imageData);
                                            localStorage.setItem('galleryImages', JSON.stringify(galleryImages));

                                            // Try to update gallery UI
                                            const galleryGrid = document.querySelector('.gallery-images-grid, #galleryImagesGrid');
                                            if (galleryGrid) {
                                                const imgElement = document.createElement('div');
                                                imgElement.className = 'gallery-image-item';
                                                imgElement.innerHTML = `
                                                    <img src="${e.target.result}" alt="${f.name}">
                                                    <div class="image-info">
                                                        <span class="image-name">${f.name}</span>
                                                    </div>
                                                `;
                                                galleryGrid.appendChild(imgElement);
                                            }
                                        };
                                        reader.readAsDataURL(f.file);
                                    }

                                    // Show toast
                                    setTimeout(() => {
                                        if (window.converter && typeof window.converter.showToast === 'function') {
                                            window.converter.showToast('‚úÖ ƒê√£ th√™m ' + files.length + ' ·∫£nh v√†o kho! (fallback)', 'success');
                                        }
                                    }, 500);

                                    console.log('Gallery fallback used to store images');
                                } else {
                                    console.warn('addImageToGallery method not available and no fallback');
                                }
                            }
                        }
                    },
                    print: {
                        title: 'Ch·ªçn ·∫£nh ƒë·ªÉ in',
                        multiple: true,
                        onSelect: (files) => {
                            // Th√™m files v√†o Print section
                            if (window.converter) {
                                // Try calling handlePrintFiles method directly
                                try {
                                    const fileObjects = files.map(f => f.file);
                                    if (typeof window.converter.handlePrintFiles === 'function') {
                                        window.converter.handlePrintFiles(fileObjects);
                                    } else {
                                        // Call addImageToPrintList directly for each file
                                        fileObjects.forEach(file => {
                                            if (file.type.startsWith('image/') && typeof window.converter.addImageToPrintList === 'function') {
                                                window.converter.addImageToPrintList(file);
                                            }
                                        });
                                    }

                                    if (typeof window.converter.showToast === 'function') {
                                        window.converter.showToast('‚úÖ ƒê√£ t·∫£i ' + files.length + ' ·∫£nh ƒë·ªÉ in!', 'success');
                                    }
                                } catch (methodError) {
                                    console.log('Direct method call failed, using fallback:', methodError);

                                    // Fallback: Store files for printing
                                    if (!window.converter.printFiles) window.converter.printFiles = [];
                                    files.forEach(f => {
                                        window.converter.printFiles.push({
                                            file: f.file,
                                            name: f.name,
                                            size: f.file.size,
                                            url: URL.createObjectURL(f.file),
                                            id: Date.now() + Math.random()
                                        });
                                    });

                                    // Update print UI
                                    setTimeout(() => {
                                        const printFileCount = document.querySelector('#printFileCount');
                                        if (printFileCount) {
                                            printFileCount.textContent = window.converter.printFiles.length;
                                        }

                                        if (typeof window.converter.showToast === 'function') {
                                            window.converter.showToast('‚úÖ ƒê√£ t·∫£i ' + files.length + ' ·∫£nh ƒë·ªÉ in!', 'success');
                                        }
                                    }, 100);
                                }
                            } else {
                                console.warn('window.converter not available');
                            }
                        }
                    }
                };

                const config = configs[section];
                if (!config) {
                    console.error('Invalid section:', section);
                    return;
                }

                // M·ªü File System Image Picker
                await window.createFileSystemImagePicker(config);

            } catch (error) {
                console.error('L·ªói t·∫£i ·∫£nh t·ª´ File System cho ' + section + ':', error);
                if (window.converter && typeof window.converter.showToast === 'function') {
                    window.converter.showToast('‚ùå L·ªói: ' + error.message, 'error');
                } else {
                    alert('‚ùå L·ªói: ' + error.message);
                }
            }
        };

        // üìÅ File System Section Logic
        let fileSystemImages = [];
        let filteredImages = [];
        let selectedFileSystemImages = [];
        let currentViewMode = 'grid';

        // Qu√©t v√† hi·ªÉn th·ªã t·∫•t c·∫£ ·∫£nh t·ª´ th∆∞ m·ª•c ƒë√£ c·∫•p quy·ªÅn
        async function scanFileSystemImages() {
            const imagesGrid = document.getElementById('fsImagesGrid');
            const emptyState = document.getElementById('fsEmptyState');
            const statusCards = {
                total: document.getElementById('fsImageCount'),
                granted: document.getElementById('fsDirectoryName'),
                selected: document.getElementById('fsSelectedCount')
            };

            if (!window.converter || !window.converter.fileSystemStorage || !window.converter.fileSystemStorage.directoryHandle) {
                if (window.converter && typeof window.converter.showToast === 'function') {
                    window.converter.showToast('‚ùå Ch∆∞a c·∫•p quy·ªÅn truy c·∫≠p th∆∞ m·ª•c!', 'warning');
                } else {
                    alert('‚ùå Ch∆∞a c·∫•p quy·ªÅn truy c·∫≠p th∆∞ m·ª•c!');
                }
                return;
            }

            try {
                // Hi·ªÉn th·ªã loading state
                if (emptyState) {
                    emptyState.innerHTML = '<div class="loading-spinner"></div><div class="empty-title">ƒêang qu√©t ·∫£nh v√† th∆∞ m·ª•c...</div><div class="empty-message">ƒêang qu√©t c√°c th∆∞ m·ª•c con (t·ªëi ƒëa 3 c·∫•p)</div>';
                    emptyState.style.display = 'flex';
                }

                // Qu√©t ·∫£nh recursive v·ªõi metadata m·ªü r·ªông
                const scannedImages = await window.converter.fileSystemStorage.scanImagesRecursive();
                fileSystemImages = scannedImages;
                filteredImages = [...fileSystemImages];

                // C·∫≠p nh·∫≠t status cards
                if (statusCards.total) statusCards.total.textContent = fileSystemImages.length;
                if (statusCards.granted) statusCards.granted.textContent = '‚úÖ ƒê√£ c·∫•p quy·ªÅn';
                if (statusCards.selected) statusCards.selected.textContent = selectedFileSystemImages.length;

                // C·∫≠p nh·∫≠t folder filter options
                updateFolderFilterOptions(fileSystemImages);

                // C·∫≠p nh·∫≠t folder tree view
                updateFolderTreeView(fileSystemImages);

                // Hi·ªÉn th·ªã ·∫£nh
                displayFileSystemImages();

                // T√≠nh t·ªïng size v√† c·∫≠p nh·∫≠t UI
                const totalSize = fileSystemImages.reduce((sum, img) => sum + img.size, 0);
                const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(1);
                const totalSizeElement = document.getElementById('fsTotalSize');
                if (totalSizeElement) {
                    totalSizeElement.textContent = totalSizeMB + ' MB';
                }

                // C·∫≠p nh·∫≠t folder count
                const folderCountElement = document.getElementById('fsFolderCount');
                if (folderCountElement) {
                    const uniqueFolders = [...new Set(fileSystemImages.map(img => img.folder))].length;
                    folderCountElement.textContent = uniqueFolders;
                }

                // Enable controls
                enableFileSystemControls();

                if (window.converter && typeof window.converter.showToast === 'function') {
                    const uniqueFolders = [...new Set(fileSystemImages.map(img => img.folder))].length;
                    window.converter.showToast('‚úÖ ƒê√£ qu√©t ' + fileSystemImages.length + ' ·∫£nh t·ª´ ' + uniqueFolders + ' th∆∞ m·ª•c!', 'success');
                }

            } catch (error) {
                console.error('L·ªói qu√©t ·∫£nh:', error);
                if (window.converter && typeof window.converter.showToast === 'function') {
                    window.converter.showToast('‚ùå L·ªói qu√©t ·∫£nh: ' + error.message, 'error');
                }
                if (emptyState) {
                    emptyState.innerHTML = '<div class="empty-visual">√ó</div><h3>L·ªói qu√©t ·∫£nh</h3><p>' + error.message + '</p>';
                    emptyState.style.display = 'flex';
                }
            }
        }

        // Hi·ªÉn th·ªã danh s√°ch ·∫£nh v·ªõi ph√¢n lo·∫°i theo th∆∞ m·ª•c
        function displayFileSystemImages() {
            const imagesGrid = document.getElementById('fsImagesGrid');
            const emptyState = document.getElementById('fsEmptyState');

            if (filteredImages.length === 0) {
                if (emptyState) {
                    emptyState.innerHTML = '<div class="empty-visual">‚ñ°</div><h3>Kh√¥ng t√¨m th·∫•y ·∫£nh</h3><p>Th·ª≠ qu√©t l·∫°i ho·∫∑c ki·ªÉm tra th∆∞ m·ª•c ƒë√£ ch·ªçn</p>';
                    emptyState.style.display = 'flex';
                }
                if (imagesGrid) {
                    imagesGrid.innerHTML = '';
                }
                return;
            }

            if (emptyState) {
                emptyState.style.display = 'none';
            }

            // Group images by folder for organized display
            const imagesByFolder = {};
            filteredImages.forEach(image => {
                // Ensure we have folder info, fallback to 'Root'
                const folderPath = (image.folder && image.folder.trim()) ? image.folder : 'Root';
                if (!imagesByFolder[folderPath]) {
                    imagesByFolder[folderPath] = [];
                }
                imagesByFolder[folderPath].push(image);
            });

            console.log('üîç Images by folder:', imagesByFolder);

            // Sort folders: Root first, then alphabetically
            const sortedFolders = Object.keys(imagesByFolder).sort((a, b) => {
                if (a === 'Root') return -1;
                if (b === 'Root') return 1;
                return a.localeCompare(b);
            });

            // Utility function for file size formatting
            const formatBytes = (bytes) => {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            };

            // Create folder sections
            const folderSectionsHTML = sortedFolders.map(folderPath => {
                const folderImages = imagesByFolder[folderPath];
                const folderDisplayName = folderPath === 'Root' ? 'Th∆∞ m·ª•c g·ªëc' : folderPath;
                const totalSize = folderImages.reduce((sum, img) => sum + img.size, 0);

                const imagesHTML = folderImages.map(image => {
                    const isSelected = selectedFileSystemImages.includes(image.name);

                    return '<div class="fs-image-item ' + (isSelected ? 'selected' : '') + '" data-filename="' + image.name + '" data-folder="' + image.folder + '" data-category="' + image.category + '">' +
                        '<div class="fs-image-preview">' +
                            '<input type="checkbox" class="fs-checkbox" ' + (isSelected ? 'checked' : '') + '>' +
                            '<img src="' + image.url + '" alt="' + image.name + '" loading="lazy">' +
                            '<div class="fs-image-overlay">' +
                                '<div class="fs-image-actions">' +
                                    '<button class="fs-action-btn" title="Xem chi ti·∫øt">‚ãØ</button>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                        '<div class="fs-image-info">' +
                            '<div class="fs-image-name" title="' + image.path + '">' + image.name.substring(0, 18) + (image.name.length > 18 ? '...' : '') + '</div>' +
                            '<div class="fs-image-meta">' +
                                '<span class="fs-size">' + formatBytes(image.size) + '</span>' +
                                '<span class="fs-category">' + image.category + '</span>' +
                            '</div>' +
                        '</div>' +
                    '</div>';
                }).join('');

                return '<div class="fs-folder-section">' +
                    '<div class="fs-folder-header">' +
                        '<div class="fs-folder-info">' +
                            '<h4 class="fs-folder-name">' +
                                '<span class="fs-folder-icon">' + (folderPath === 'Root' ? '‚óâ' : '‚óà') + '</span>' +
                                folderDisplayName +
                            '</h4>' +
                            '<div class="fs-folder-stats">' +
                                '<span class="fs-folder-count">' + folderImages.length + ' ·∫£nh</span>' +
                                '<span class="fs-folder-size">' + formatBytes(totalSize) + '</span>' +
                            '</div>' +
                        '</div>' +
                        '<div class="fs-folder-actions">' +
                            '<button class="fs-folder-btn" onclick="toggleFolderSelection(\'' + folderPath.replace(/'/g, "\\'") + '\')" title="Ch·ªçn/b·ªè ch·ªçn t·∫•t c·∫£ ·∫£nh trong th∆∞ m·ª•c">' +
                                'Ch·ªçn th∆∞ m·ª•c' +
                            '</button>' +
                            '<button class="fs-folder-btn collapse" onclick="toggleFolderCollapse(\'' + folderPath.replace(/'/g, "\\'") + '\')" title="Thu g·ªçn/m·ªü r·ªông">' +
                                '‚àí' +
                            '</button>' +
                        '</div>' +
                    '</div>' +
                    '<div class="fs-folder-content" id="folder-' + folderPath.replace(/[^a-zA-Z0-9]/g, '_') + '">' +
                        '<div class="fs-folder-grid">' + imagesHTML + '</div>' +
                    '</div>' +
                '</div>';
            }).join('');

            const gridHTML = '<div class="fs-organized-view">' + folderSectionsHTML + '</div>';

            if (imagesGrid) {
                console.log('üîç Setting File System HTML:', gridHTML.substring(0, 200) + '...');
                console.log('üîç Number of folders:', sortedFolders.length);
                console.log('üîç Folders:', sortedFolders);

                imagesGrid.innerHTML = gridHTML;

                // Remove any existing grid styling that might conflict
                imagesGrid.style.display = 'block';
                imagesGrid.style.gridTemplateColumns = 'none';

                // Add click event listeners
                const imageItems = imagesGrid.querySelectorAll('.fs-image-item');
                imageItems.forEach(item => {
                    const checkbox = item.querySelector('.fs-checkbox');
                    const filename = item.dataset.filename;

                    // Click on item to toggle selection
                    item.addEventListener('click', (e) => {
                        if (e.target.type !== 'checkbox' && !e.target.classList.contains('fs-action-btn')) {
                            checkbox.checked = !checkbox.checked;
                            toggleFileSystemImageSelection(filename);
                        }
                    });

                    // Checkbox change event
                    checkbox.addEventListener('change', () => {
                        toggleFileSystemImageSelection(filename);
                    });
                });
            }

        }

        // Toggle ch·ªçn ·∫£nh File System
        function toggleFileSystemImageSelection(fileName) {
            const item = document.querySelector('.fs-image-item[data-filename="' + fileName + '"]');
            const checkbox = item ? item.querySelector('.fs-checkbox') : null;

            if (!checkbox) return;

            const isSelected = checkbox.checked;

            if (isSelected) {
                if (!selectedFileSystemImages.includes(fileName)) {
                    selectedFileSystemImages.push(fileName);
                }
                item.classList.add('selected');
                checkbox.checked = true;
            } else {
                selectedFileSystemImages = selectedFileSystemImages.filter(name => name !== fileName);
                item.classList.remove('selected');
                checkbox.checked = false;
            }

            // C·∫≠p nh·∫≠t UI
            updateSelectionSummary();
        }

        // C·∫≠p nh·∫≠t th√¥ng tin selection
        function updateSelectionSummary() {
            const selectedCount = document.getElementById('fsSelectedCount');
            const selectedSize = document.getElementById('fsSelectedSize');
            const selectionBar = document.getElementById('fsSelectionBar');

            if (selectedCount) {
                selectedCount.textContent = selectedFileSystemImages.length;
            }

            if (selectedSize) {
                const totalSize = selectedFileSystemImages.reduce((sum, img) => sum + (img.size || 0), 0);
                if (window.converter && typeof window.converter.formatFileSize === 'function') {
                    selectedSize.textContent = window.converter.formatFileSize(totalSize);
                } else {
                    // Fallback formatFileSize function
                    selectedSize.textContent = (totalSize < 1024 * 1024 ? Math.round(totalSize / 1024) + ' KB' : Math.round(totalSize / (1024 * 1024)) + ' MB');
                }
            }

            // Show/hide selection bar
            if (selectionBar) {
                if (selectedFileSystemImages.length > 0) {
                    selectionBar.style.display = 'flex';
                } else {
                    selectionBar.style.display = 'none';
                }
            }

            // Enable/disable action buttons
            const actionButtons = document.querySelectorAll('.selection-btn');
            actionButtons.forEach(btn => {
                btn.disabled = selectedFileSystemImages.length === 0;
                btn.style.opacity = selectedFileSystemImages.length === 0 ? '0.5' : '1';
            });
        }

        // T√¨m ki·∫øm v√† l·ªçc ·∫£nh
        function filterFileSystemImages(searchTerm = '') {
            if (searchTerm.trim() === '') {
                filteredImages = [...fileSystemImages];
            } else {
                const term = searchTerm.toLowerCase();
                filteredImages = fileSystemImages.filter(image =>
                    image.name.toLowerCase().includes(term)
                );
            }
            displayFileSystemImages();
        }

        // Ch·ªçn t·∫•t c·∫£ ·∫£nh hi·ªán t·∫°i
        function selectAllFileSystemImages() {
            filteredImages.forEach(image => {
                if (!selectedFileSystemImages.includes(image.name)) {
                    selectedFileSystemImages.push(image.name);
                }
            });
            displayFileSystemImages();
            updateSelectionSummary();
        }

        // B·ªè ch·ªçn t·∫•t c·∫£
        function clearFileSystemSelection() {
            selectedFileSystemImages = [];
            displayFileSystemImages();
            updateSelectionSummary();
        }

        // Toggle folder selection (ch·ªçn/b·ªè ch·ªçn t·∫•t c·∫£ ·∫£nh trong folder)
        function toggleFolderSelection(folderPath) {
            const folderImages = filteredImages.filter(img => (img.folder || 'Root') === folderPath);
            const folderImageNames = folderImages.map(img => img.name);

            // Check if all images in folder are selected
            const allSelected = folderImageNames.every(name => selectedFileSystemImages.includes(name));

            if (allSelected) {
                // Deselect all images in folder
                selectedFileSystemImages = selectedFileSystemImages.filter(name => !folderImageNames.includes(name));
            } else {
                // Select all images in folder
                folderImageNames.forEach(name => {
                    if (!selectedFileSystemImages.includes(name)) {
                        selectedFileSystemImages.push(name);
                    }
                });
            }

            // Update UI
            displayFileSystemImages();
            updateSelectionSummary();

            // Show toast
            if (window.converter && typeof window.converter.showToast === 'function') {
                const action = allSelected ? 'b·ªè ch·ªçn' : 'ch·ªçn';
                window.converter.showToast(`‚úÖ ƒê√£ ${action} ${folderImageNames.length} ·∫£nh trong th∆∞ m·ª•c "${folderPath === 'Root' ? 'g·ªëc' : folderPath}"`, 'success');
            }
        }

        // Toggle folder collapse/expand
        function toggleFolderCollapse(folderPath) {
            const folderId = 'folder-' + folderPath.replace(/[^a-zA-Z0-9]/g, '_');
            const folderContent = document.getElementById(folderId);
            const collapseBtn = document.querySelector(`[onclick="toggleFolderCollapse('${folderPath}')"]`);

            if (folderContent && collapseBtn) {
                const isCollapsed = folderContent.style.display === 'none';
                folderContent.style.display = isCollapsed ? 'block' : 'none';
                collapseBtn.textContent = isCollapsed ? '‚àí' : '+';
                collapseBtn.title = isCollapsed ? 'Thu g·ªçn' : 'M·ªü r·ªông';
            }
        }

        // G·ª≠i ·∫£nh ƒë√£ ch·ªçn t·ªõi section kh√°c
        async function sendToSection(targetSection) {
            if (selectedFileSystemImages.length === 0) {
                if (window.converter && typeof window.converter.showToast === 'function') {
                    window.converter.showToast('‚ùå Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt ·∫£nh!', 'warning');
                } else {
                    alert('‚ùå Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt ·∫£nh!');
                }
                return;
            }

            try {
                // Chuy·ªÉn ƒë·∫øn section tr∆∞·ªõc ƒë·ªÉ kh·ªüi t·∫°o methods
                if (window.converter && typeof window.converter.switchToTab === 'function') {
                    window.converter.switchToTab(targetSection);
                }

                // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ section ƒë∆∞·ª£c kh·ªüi t·∫°o ho√†n to√†n
                await new Promise(resolve => setTimeout(resolve, 500));

                const selectedFiles = [];
                for (const fileName of selectedFileSystemImages) {
                    const file = await window.converter.fileSystemStorage.getImageFile(fileName);
                    selectedFiles.push({ name: fileName, file });
                }

                // G·ªçi h√†m loadImagesFromFileSystem v·ªõi section ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o
                await loadImagesFromFileSystem(targetSection, selectedFiles);

                if (window.converter && typeof window.converter.showToast === 'function') {
                    window.converter.showToast('‚úÖ ƒê√£ g·ª≠i ' + selectedFiles.length + ' ·∫£nh t·ªõi ' + getSectionDisplayName(targetSection) + '!', 'success');
                }

            } catch (error) {
                console.error('L·ªói g·ª≠i ·∫£nh:', error);
                if (window.converter && typeof window.converter.showToast === 'function') {
                    window.converter.showToast('‚ùå L·ªói g·ª≠i ·∫£nh: ' + error.message, 'error');
                } else {
                    alert('‚ùå L·ªói g·ª≠i ·∫£nh: ' + error.message);
                }
            }
        }

        // L·∫•y t√™n hi·ªÉn th·ªã c·ªßa section
        function getSectionDisplayName(section) {
            const names = {
                'convert': 'Convert',
                'crop': 'Crop',
                'templates': 'Templates',
                'gallery': 'Gallery',
                'print': 'Print'
            };
            return names[section] || section;
        }

        // ===== NEW FOLDER STRUCTURE FUNCTIONS =====

        // C·∫≠p nh·∫≠t folder filter options
        function updateFolderFilterOptions(images) {
            const folderSelect = document.getElementById('folderFilterSelect');
            if (!folderSelect) return;

            // L·∫•y danh s√°ch unique folders
            const folders = [...new Set(images.map(img => img.folder))].sort();

            // Clear current options v√† th√™m "all"
            folderSelect.innerHTML = '<option value="all">üìÅ T·∫•t c·∫£ th∆∞ m·ª•c</option>';

            folders.forEach(folder => {
                const count = images.filter(img => img.folder === folder).length;
                const option = document.createElement('option');
                option.value = folder;
                option.textContent = `üìÅ ${folder} (${count})`;
                folderSelect.appendChild(option);
            });

            // Enable dropdown
            folderSelect.disabled = false;
        }

        // C·∫≠p nh·∫≠t folder tree view
        function updateFolderTreeView(images) {
            const treeContainer = document.getElementById('filesystemTreeContainer');
            const treeContent = document.getElementById('filesystemTreeContent');
            const treeStats = document.getElementById('treeStatsText');

            if (!treeContainer || !treeContent || !treeStats) return;

            // Group images by folder
            const folderGroups = {};
            images.forEach(img => {
                if (!folderGroups[img.folder]) {
                    folderGroups[img.folder] = [];
                }
                folderGroups[img.folder].push(img);
            });

            const uniqueFolders = Object.keys(folderGroups).length;
            const totalImages = images.length;
            treeStats.textContent = `${uniqueFolders} th∆∞ m·ª•c, ${totalImages} ·∫£nh`;

            // Generate tree HTML
            let treeHTML = '';
            Object.keys(folderGroups).sort().forEach(folder => {
                const folderImages = folderGroups[folder];
                const folderId = 'folder-' + folder.replace(/[^a-zA-Z0-9]/g, '-');

                treeHTML += `
                    <div class="tree-folder">
                        <div class="folder-header" onclick="toggleFolderExpansion('${folderId}')">
                            <div class="folder-info">
                                <span class="folder-name">üìÅ ${folder}</span>
                                <span class="folder-count">${folderImages.length}</span>
                            </div>
                            <button class="folder-toggle" id="toggle-${folderId}">‚ñ∂</button>
                        </div>
                        <div class="folder-content" id="${folderId}">
                            <div class="folder-image-list">
                                ${folderImages.map(img => `
                                    <div class="folder-image-item" onclick="selectImageFromTree('${img.name}')" title="${img.name}">
                                        <img src="${img.url}" alt="${img.name}">
                                        <div class="folder-image-category">${getCategoryIcon(img.category)}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            });

            treeContent.innerHTML = treeHTML;

            // Enable tree toggle button
            const treeToggleBtn = document.getElementById('folderTreeToggleBtn');
            if (treeToggleBtn) {
                treeToggleBtn.disabled = false;
            }
        }

        // Helper function ƒë·ªÉ l·∫•y category icon
        function getCategoryIcon(category) {
            const icons = {
                convert: 'üîÑ',
                crop: '‚úÇÔ∏è',
                template: 'üìù',
                gallery: 'üñºÔ∏è',
                print: 'üñ®Ô∏è',
                work: 'üíº',
                archive: 'üì¶',
                other: 'üìÅ'
            };
            return icons[category] || 'üìÅ';
        }

        // Toggle folder expansion in tree view
        function toggleFolderExpansion(folderId) {
            const folderContent = document.getElementById(folderId);
            const toggleBtn = document.getElementById('toggle-' + folderId);

            if (!folderContent || !toggleBtn) return;

            if (folderContent.classList.contains('expanded')) {
                folderContent.classList.remove('expanded');
                toggleBtn.textContent = '‚ñ∂';
                toggleBtn.classList.remove('expanded');
            } else {
                folderContent.classList.add('expanded');
                toggleBtn.textContent = '‚ñº';
                toggleBtn.classList.add('expanded');
            }
        }

        // Select image from tree view
        function selectImageFromTree(imageName) {
            const isCurrentlySelected = selectedFileSystemImages.includes(imageName);
            toggleImageSelection(imageName, !isCurrentlySelected);
        }

        // Toggle tree view visibility
        function toggleTreeView() {
            const treeContainer = document.getElementById('filesystemTreeContainer');
            const toggleBtn = document.getElementById('folderTreeToggleBtn');
            const icon = toggleBtn.querySelector('.btn-icon');

            if (!treeContainer || !toggleBtn || !icon) return;

            if (treeContainer.style.display === 'none' || !treeContainer.style.display) {
                treeContainer.style.display = 'block';
                icon.textContent = 'üôà';
                toggleBtn.querySelector('.btn-text').textContent = '·∫®n c√¢y';
            } else {
                treeContainer.style.display = 'none';
                icon.textContent = 'üå≥';
                toggleBtn.querySelector('.btn-text').textContent = 'C√¢y th∆∞ m·ª•c';
            }
        }

        // Filter by folder
        function filterByFolder(selectedFolder) {
            if (selectedFolder === 'all' || !selectedFolder) {
                filteredImages = [...fileSystemImages];
            } else {
                filteredImages = fileSystemImages.filter(img => img.folder === selectedFolder);
            }
            displayFileSystemImages();
        }

        // Filter by category
        function filterByCategory(selectedCategory) {
            if (selectedCategory === 'all' || !selectedCategory) {
                filteredImages = [...fileSystemImages];
            } else {
                filteredImages = fileSystemImages.filter(img => img.category === selectedCategory);
            }
            displayFileSystemImages();
        }

        // Enable File System controls
        function enableFileSystemControls() {
            const controls = [
                'fsSearchInput',
                'fsFormatFilter',
                'fsFolderFilter',
                'fsCategoryFilter',
                'fsTreeView',
                'fsSelectAllBtn',
                'fsExportBtn',
                'fsClearSelectionBtn',
                'fsSizeSlider'
            ];

            controls.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.disabled = false;
                }
            });
        }

    </script>

            <!-- File System Section -->
            <div class="function-section" id="filesystemSection">
                <div class="fs-container">
                    <!-- Main Header -->
                    <div class="fs-header">
                        <div class="fs-title">
                            <h2>File System Manager</h2>
                            <div class="fs-subtitle">Qu√©t v√† qu·∫£n l√Ω ·∫£nh t·ª´ th∆∞ m·ª•c h·ªá th·ªëng</div>
                        </div>
                        <div class="fs-status" id="fsStatus">
                            <div class="status-indicator" id="fsStatusIndicator">‚óè</div>
                            <span id="fsStatusText">Ch∆∞a k·∫øt n·ªëi</span>
                        </div>
                    </div>

                    <!-- Directory Info Card -->
                    <div class="fs-directory-card" id="fsDirectoryCard">
                        <div class="dir-main">
                            <div class="dir-info">
                                <div class="dir-name" id="fsDirectoryName">Ch∆∞a ch·ªçn th∆∞ m·ª•c</div>
                                <div class="dir-path" id="fsDirectoryPath">Nh·∫•n "Ch·ªçn th∆∞ m·ª•c" ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
                            </div>
                            <div class="dir-actions">
                                <button class="fs-btn primary" id="fsSelectDirectoryBtn">Ch·ªçn th∆∞ m·ª•c</button>
                                <button class="fs-btn secondary" id="fsScanBtn" disabled>Qu√©t ·∫£nh</button>
                            </div>
                        </div>
                        <div class="dir-stats" id="fsDirectoryStats" style="display: none;">
                            <div class="stat">
                                <span class="stat-number" id="fsImageCount">0</span>
                                <span class="stat-label">·∫£nh</span>
                            </div>
                            <div class="stat">
                                <span class="stat-number" id="fsFolderCount">0</span>
                                <span class="stat-label">th∆∞ m·ª•c</span>
                            </div>
                            <div class="stat">
                                <span class="stat-number" id="fsTotalSize">0 MB</span>
                                <span class="stat-label">dung l∆∞·ª£ng</span>
                            </div>
                        </div>
                    </div>

                    <!-- Search & Filter Bar -->
                    <div class="fs-toolbar" id="fsToolbar" style="display: none;">
                        <div class="toolbar-left">
                            <div class="search-container">
                                <input type="text" id="fsSearchInput" placeholder="T√¨m ki·∫øm ·∫£nh..." class="fs-search" disabled>
                                <div class="search-results" id="fsSearchResults"></div>
                            </div>
                            <select id="fsFormatFilter" class="fs-select" disabled>
                                <option value="all">T·∫•t c·∫£ ƒë·ªãnh d·∫°ng</option>
                                <option value="jpg">JPG/JPEG</option>
                                <option value="png">PNG</option>
                                <option value="webp">WEBP</option>
                                <option value="gif">GIF</option>
                                <option value="heic">HEIC</option>
                            </select>
                        </div>

                        <div class="toolbar-center">
                            <select id="fsFolderFilter" class="fs-select" disabled>
                                <option value="all">T·∫•t c·∫£ th∆∞ m·ª•c</option>
                            </select>
                            <select id="fsCategoryFilter" class="fs-select" disabled>
                                <option value="all">T·∫•t c·∫£ lo·∫°i</option>
                                <option value="convert">Convert</option>
                                <option value="crop">Crop</option>
                                <option value="template">Template</option>
                                <option value="gallery">Gallery</option>
                                <option value="print">Print</option>
                                <option value="work">Work</option>
                                <option value="archive">Archive</option>
                                <option value="other">Other</option>
                            </select>
                        </div>

                        <div class="toolbar-right">
                            <div class="view-controls">
                                <button class="view-btn active" id="fsGridView" title="L∆∞·ªõi">‚äû</button>
                                <button class="view-btn" id="fsListView" title="Danh s√°ch">‚ò∞</button>
                                <button class="view-btn" id="fsTreeView" title="C√¢y th∆∞ m·ª•c">‚Äª</button>
                            </div>
                            <div class="size-control">
                                <input type="range" id="fsSizeSlider" min="80" max="240" value="120" step="20" disabled>
                                <span id="fsSizeValue">120px</span>
                            </div>
                        </div>
                    </div>

                    <!-- Main Content Area -->
                    <div class="fs-content" id="fsContent">
                        <!-- Tree View -->
                        <div class="fs-tree-view" id="fsTreeContainer" style="display: none;">
                            <div class="tree-header">
                                <h4>C·∫•u tr√∫c th∆∞ m·ª•c</h4>
                                <div class="tree-stats" id="fsTreeStats">0 th∆∞ m·ª•c, 0 ·∫£nh</div>
                            </div>
                            <div class="tree-content" id="fsTreeContent">
                                <!-- Tree structure populated here -->
                            </div>
                        </div>

                        <!-- Images Grid/List -->
                        <div class="fs-images-container" id="fsImagesContainer">
                            <div class="fs-images-grid" id="fsImagesGrid">
                                <div class="fs-empty-state" id="fsEmptyState">
                                    <div class="empty-visual">‚ñ°</div>
                                    <h3>Ch∆∞a c√≥ ·∫£nh</h3>
                                    <p>Ch·ªçn th∆∞ m·ª•c v√† qu√©t ·∫£nh ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
                                    <button class="fs-btn primary" onclick="document.getElementById('fsSelectDirectoryBtn').click()">
                                        Ch·ªçn th∆∞ m·ª•c ngay
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Selection Bar -->
                    <div class="fs-selection-bar" id="fsSelectionBar" style="display: none;">
                        <div class="selection-info">
                            <span class="selection-text">
                                ƒê√£ ch·ªçn <strong id="fsSelectedCount">0</strong> ·∫£nh
                                (<strong id="fsSelectedSize">0 MB</strong>)
                            </span>
                        </div>
                        <div class="selection-actions">
                            <button class="action-btn" onclick="sendToSection('convert')" title="Chuy·ªÉn ƒë·ªïi ƒë·ªãnh d·∫°ng">
                                Convert
                            </button>
                            <button class="action-btn" onclick="sendToSection('crop')" title="C·∫Øt theo k√≠ch th∆∞·ªõc">
                                Crop
                            </button>
                            <button class="action-btn" onclick="sendToSection('templates')" title="T·∫°o template">
                                Templates
                            </button>
                            <button class="action-btn" onclick="sendToSection('gallery')" title="Th√™m v√†o kho">
                                Gallery
                            </button>
                            <button class="action-btn" onclick="sendToSection('print')" title="In ·∫£nh">
                                Print
                            </button>
                            <button class="action-btn secondary" onclick="clearFileSystemSelection()">
                                B·ªè ch·ªçn
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- SK316 Calibration Section -->
            <div class="function-section" id="sk316Section">
                <div class="sk316-container">
                    <!-- Header -->
                    <div class="sk316-header">
                        <div class="sk316-title">
                            <h2>üéØ H·ªá th·ªëng hi·ªáu chu·∫©n SK316</h2>
                            <div class="sk316-subtitle">Hi·ªáu ch·ªânh ƒë·ªô l·ªách m√°y c·∫Øt t·ª± ƒë·ªông SK316</div>
                        </div>
                        <div class="sk316-status" id="sk316Status">
                            <div class="status-badge" id="sk316StatusBadge">‚óã Ch∆∞a k√≠ch ho·∫°t</div>
                        </div>
                    </div>

                    <!-- Machine Profile Selector -->
                    <div class="sk316-profile-selector">
                        <label>Profile m√°y:</label>
                        <select id="sk316ProfileSelect" class="sk316-select">
                            <option value="">-- Ch·ªçn profile --</option>
                        </select>
                        <button class="sk316-btn primary" id="sk316NewProfileBtn">+ T·∫°o m·ªõi</button>
                        <button class="sk316-btn secondary" id="sk316ImportBtn">üì• Nh·∫≠p JSON</button>
                    </div>

                    <!-- Step 0: Gutter Optimization -->
                    <div class="sk316-card gutter-test-card">
                        <div class="sk316-card-header">
                            <h3>üîß B∆∞·ªõc 0: T√¨m Gutter T·ªëi ∆Øu</h3>
                            <div class="step-badge optional">T√πy ch·ªçn</div>
                        </div>
                        <div class="sk316-card-content">
                            <div class="sk316-instructions">
                                <div class="instruction-icon">üí°</div>
                                <div class="instruction-text">
                                    <strong>Gutter</strong> l√† kho·∫£ng tr·ªëng gi·ªØa c√°c card ƒë·ªÉ dao c·∫Øt SK316 ch·∫°y qua (l∆∞·ª°i dao 3mm).
                                    T·∫°o nhi·ªÅu test sheets v·ªõi gutter kh√°c nhau ƒë·ªÉ t√¨m gi√° tr·ªã t·ªëi ∆∞u cho m√°y c·ªßa b·∫°n.
                                </div>
                            </div>

                            <div class="gutter-test-config">
                                <div class="config-row">
                                    <div class="config-item">
                                        <label>Card size:</label>
                                        <select id="gutterTestCardSize" class="sk316-select">
                                            <option value="90x54" selected>90√ó54mm (SK316 standard)</option>
                                            <option value="85x55">85√ó55mm</option>
                                        </select>
                                    </div>
                                    <div class="config-item">
                                        <label>Grid test:</label>
                                        <select id="gutterTestGrid" class="sk316-select">
                                            <option value="3x5" selected>3√ó5 (15 cards/A4)</option>
                                            <option value="3x4">3√ó4 (12 cards/A4)</option>
                                            <option value="2x4">2√ó4 (8 cards/A4)</option>
                                        </select>
                                    </div>
                                </div>

                                <div class="gutter-range-config">
                                    <h4>üìä Kho·∫£ng test gutter:</h4>
                                    <div class="range-inputs">
                                        <div class="range-item">
                                            <label>Min:</label>
                                            <input type="number" id="gutterMin" value="2.5" step="0.1" min="0" max="10" class="sk316-input small">
                                            <span class="unit">mm</span>
                                        </div>
                                        <div class="range-item">
                                            <label>Max:</label>
                                            <input type="number" id="gutterMax" value="4.0" step="0.1" min="0" max="10" class="sk316-input small">
                                            <span class="unit">mm</span>
                                        </div>
                                        <div class="range-item">
                                            <label>Step:</label>
                                            <input type="number" id="gutterStep" value="0.5" step="0.1" min="0.1" max="2" class="sk316-input small">
                                            <span class="unit">mm</span>
                                        </div>
                                    </div>
                                    <div class="test-preview" id="gutterTestPreview">
                                        ‚Üí S·∫Ω t·∫°o <strong>4 test sheets</strong>: 2.5mm, 3.0mm, 3.5mm, 4.0mm
                                    </div>
                                </div>

                                <button class="sk316-btn large primary" id="generateGutterTestsBtn">
                                    <svg class="svg-icon"><use href="#icon-download"></use></svg>
                                    T·∫°o Gutter Test Sheets
                                </button>
                            </div>

                            <!-- Gutter Selection After Testing -->
                            <div class="gutter-selection" id="gutterSelectionSection" style="display: none;">
                                <div class="selection-divider"></div>
                                <h4>‚úì Sau khi in & c·∫Øt th·ª≠, ch·ªçn gutter t·ªët nh·∫•t:</h4>
                                <div class="gutter-options" id="gutterOptionsGrid">
                                    <!-- Will be populated dynamically -->
                                </div>
                                <div class="selected-gutter-display" id="selectedGutterDisplay" style="display: none;">
                                    <div class="selected-label">Gutter ƒë√£ ch·ªçn:</div>
                                    <div class="selected-value" id="selectedGutterValue">3.5mm</div>
                                    <button class="sk316-btn small secondary" id="changeGutterBtn">Thay ƒë·ªïi</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Step 1: Configure Test Sheet -->
                    <div class="sk316-card">
                        <div class="sk316-card-header">
                            <h3>B∆∞·ªõc 1: T·∫°o offset test sheet</h3>
                            <div class="step-badge">1/3</div>
                        </div>
                        <div class="sk316-card-content">
                            <div class="sk316-config-row">
                                <div class="config-item">
                                    <label>K√≠ch th∆∞·ªõc card:</label>
                                    <select id="sk316CardSize" class="sk316-select">
                                        <option value="90x54" selected>90√ó54mm (Ti√™u chu·∫©n)</option>
                                        <option value="85x55">85√ó55mm</option>
                                    </select>
                                </div>
                                <div class="config-item">
                                    <label>L∆∞·ªõi ki·ªÉm tra:</label>
                                    <select id="sk316GridSize" class="sk316-select">
                                        <option value="5x5" selected>5√ó5 (25 √¥)</option>
                                        <option value="4x4">4√ó4 (16 √¥)</option>
                                        <option value="3x3">3√ó3 (9 √¥)</option>
                                    </select>
                                </div>
                            </div>
                            <div class="sk316-instructions">
                                <div class="instruction-icon">‚ÑπÔ∏è</div>
                                <div class="instruction-text">
                                    Test sheet s·∫Ω t·∫°o l∆∞·ªõi √¥ ƒë√°nh s·ªë tr√™n kh·ªï A4. In test sheet ‚Üí C·∫Øt b·∫±ng SK316 ‚Üí ƒêo ƒë·ªô l·ªách m·ªói √¥.
                                </div>
                            </div>
                            <button class="sk316-btn large primary" id="sk316GenerateBtn">
                                <svg class="svg-icon"><use href="#icon-download"></use></svg>
                                T·∫°o & T·∫£i test sheet JPG
                            </button>
                        </div>
                    </div>

                    <!-- Step 2: Input Measurements -->
                    <div class="sk316-card">
                        <div class="sk316-card-header">
                            <h3>B∆∞·ªõc 2: Nh·∫≠p s·ªë li·ªáu ƒëo</h3>
                            <div class="step-badge">2/3</div>
                        </div>
                        <div class="sk316-card-content">
                            <div class="sk316-instructions">
                                <div class="instruction-icon">üìè</div>
                                <div class="instruction-text">
                                    Sau khi c·∫Øt, ƒëo ƒë·ªô l·ªách (mm) c·ªßa m·ªói √¥ so v·ªõi v·ªã tr√≠ chu·∫©n. Nh·∫≠p gi√° tr·ªã √¢m n·∫øu l·ªách tr√°i/xu·ªëng, d∆∞∆°ng n·∫øu l·ªách ph·∫£i/l√™n.
                                </div>
                            </div>
                            <div class="sk316-table-container">
                                <table class="sk316-table" id="sk316Table">
                                    <thead>
                                        <tr>
                                            <th>√î</th>
                                            <th>X (mm)</th>
                                            <th>Y (mm)</th>
                                        </tr>
                                    </thead>
                                    <tbody id="sk316TableBody">
                                        <!-- Rows will be generated dynamically -->
                                    </tbody>
                                </table>
                            </div>
                            <div class="sk316-table-actions">
                                <button class="sk316-btn secondary" id="sk316ResetTableBtn">‚Ü∫ Reset t·∫•t c·∫£</button>
                                <button class="sk316-btn secondary" id="sk316FillZeroBtn">0 ƒêi·ªÅn s·ªë 0</button>
                            </div>
                        </div>
                    </div>

                    <!-- Step 3: Preview & Save -->
                    <div class="sk316-card">
                        <div class="sk316-card-header">
                            <h3>B∆∞·ªõc 3: Xem tr∆∞·ªõc & L∆∞u</h3>
                            <div class="step-badge">3/3</div>
                        </div>
                        <div class="sk316-card-content">
                            <div class="sk316-heatmap-container">
                                <h4>üî• B·∫£n ƒë·ªì nhi·ªát ƒë·ªô l·ªách:</h4>
                                <div class="sk316-heatmap" id="sk316Heatmap">
                                    <!-- Heatmap grid will be generated -->
                                </div>
                                <div class="heatmap-legend">
                                    <span>Th·∫•p</span>
                                    <div class="legend-gradient"></div>
                                    <span>Cao</span>
                                </div>
                            </div>
                            <div class="sk316-statistics">
                                <div class="stat-item">
                                    <span class="stat-label">TB l·ªách X:</span>
                                    <span class="stat-value" id="sk316AvgX">0.00mm</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">TB l·ªách Y:</span>
                                    <span class="stat-value" id="sk316AvgY">0.00mm</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">L·ªách t·ªëi ƒëa:</span>
                                    <span class="stat-value" id="sk316MaxOffset">0.00mm</span>
                                </div>
                            </div>
                            <div class="sk316-save-section">
                                <div class="save-input-group">
                                    <label>T√™n profile:</label>
                                    <input type="text" id="sk316ProfileName" class="sk316-input" placeholder="VD: SK316 Main - 2025">
                                </div>
                                <div class="save-actions">
                                    <button class="sk316-btn large primary" id="sk316SaveBtn">
                                        <svg class="svg-icon"><use href="#icon-folder"></use></svg>
                                        L∆∞u profile
                                    </button>
                                    <button class="sk316-btn large secondary" id="sk316ExportBtn">
                                        <svg class="svg-icon"><use href="#icon-download"></use></svg>
                                        Xu·∫•t JSON
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Saved Profiles List -->
                    <div class="sk316-profiles-list" id="sk316ProfilesList" style="display: none;">
                        <h3>üìÅ Profiles ƒë√£ l∆∞u</h3>
                        <div class="profiles-grid" id="sk316ProfilesGrid">
                            <!-- Profile cards will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Upload Progress Overlay -->
    <div class="upload-progress-overlay" id="uploadProgressOverlay">
        <div class="upload-progress-modal">
            <div class="upload-progress-title">
                <span>‚áà ƒêang t·∫£i ·∫£nh l√™n</span>
                <button class="upload-close-btn" id="uploadCloseBtn" style="display: none;">‚úï</button>
            </div>
            
            <!-- Current file being processed -->
            <div class="upload-current-file" id="uploadCurrentFile">
                ƒêang chu·∫©n b·ªã...
            </div>
            
            <!-- Single progress bar -->
            <div class="upload-overall-progress">
                <div class="upload-overall-text" id="uploadOverallText">ƒêang x·ª≠ l√Ω 0/0 files</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="uploadOverallFill"></div>
                </div>
                <div class="progress-time" id="uploadOverallTime"></div>
            </div>
        </div>
    </div>

    <script>
        // Event Handlers cho File System Section
        window.addEventListener('load', function() {
            // Initialize File System Section Event Handlers

            // Header buttons
            const grantPermissionBtn = document.getElementById('filesystemPermissionBtn');
            const scanImagesBtn = document.getElementById('filesystemScanBtn');
            const fsSelectDirectoryBtn = document.getElementById('fsSelectDirectoryBtn');
            const fsScanBtn = document.getElementById('fsScanBtn');
            const clearAllDataBtn = document.getElementById('clearAllDataBtn');

            // New File System buttons
            if (fsSelectDirectoryBtn) {
                fsSelectDirectoryBtn.addEventListener('click', async () => {
                    try {
                        if (!window.converter) {
                            window.converter = {};
                        }
                        if (!window.converter.fileSystemStorage) {
                            try {
                                if (typeof window.FileSystemStorage === 'function') {
                                    window.converter.fileSystemStorage = new window.FileSystemStorage();
                                } else {
                                    throw new Error('FileSystemStorage class ch∆∞a ƒë∆∞·ª£c load');
                                }
                            } catch (error) {
                                throw new Error('Kh√¥ng th·ªÉ kh·ªüi t·∫°o FileSystemStorage: ' + error.message);
                            }
                        }

                        await window.converter.fileSystemStorage.init();

                        // Update UI
                        const dirName = document.getElementById('fsDirectoryName');
                        const dirPath = document.getElementById('fsDirectoryPath');
                        const fsStatus = document.getElementById('fsStatus');
                        const fsToolbar = document.getElementById('fsToolbar');
                        const fsDirectoryStats = document.getElementById('fsDirectoryStats');
                        const fsScanBtn = document.getElementById('fsScanBtn');

                        if (dirName) dirName.textContent = 'ƒê√£ ch·ªçn th∆∞ m·ª•c';
                        if (dirPath) dirPath.textContent = 'ƒê√£ c·∫•p quy·ªÅn truy c·∫≠p th∆∞ m·ª•c';
                        if (fsStatus) {
                            fsStatus.className = 'fs-status connected';
                            const statusText = document.getElementById('fsStatusText');
                            if (statusText) statusText.textContent = 'ƒê√£ k·∫øt n·ªëi';
                        }
                        if (fsToolbar) fsToolbar.style.display = 'flex';
                        if (fsDirectoryStats) fsDirectoryStats.style.display = 'flex';
                        if (fsScanBtn) fsScanBtn.disabled = false;

                        // Auto scan after granting permission
                        setTimeout(() => {
                            if (typeof scanFileSystemImages === 'function') {
                                scanFileSystemImages();
                            }
                        }, 500);

                    } catch (error) {
                        console.error('L·ªói c·∫•p quy·ªÅn:', error);
                        if (window.converter && typeof window.converter.showToast === 'function') {
                            if (error.name === 'AbortError') {
                                window.converter.showToast('ƒê√£ h·ªßy ch·ªçn th∆∞ m·ª•c', 'warning');
                            } else {
                                window.converter.showToast('‚ùå L·ªói c·∫•p quy·ªÅn: ' + error.message, 'error');
                            }
                        }
                    }
                });
            }

            if (fsScanBtn) {
                fsScanBtn.addEventListener('click', () => {
                    if (typeof scanFileSystemImages === 'function') {
                        scanFileSystemImages();
                    }
                });
            }

            // Clear All Data Button - X√≥a to√†n b·ªô localStorage
            if (clearAllDataBtn) {
                clearAllDataBtn.addEventListener('click', async () => {
                    // Hi·ªÉn th·ªã x√°c nh·∫≠n tr∆∞·ªõc khi x√≥a
                    const confirmMessage = '‚ö†Ô∏è B·∫†N CH·∫ÆC CH·∫ÆN MU·ªêN X√ìA TO√ÄN B·ªò D·ªÆ LI·ªÜU?\n\n' +
                        'H√†nh ƒë·ªông n√†y s·∫Ω x√≥a:\n' +
                        '‚Ä¢ T·∫•t c·∫£ ·∫£nh trong kho (Gallery)\n' +
                        '‚Ä¢ D·ªØ li·ªáu ·∫£nh ƒë√£ convert\n' +
                        '‚Ä¢ T·∫•t c·∫£ settings v√† c·∫•u h√¨nh\n' +
                        '‚Ä¢ Cache v√† temporary data\n\n' +
                        'D·ªØ li·ªáu s·∫Ω KH√îNG TH·ªÇ KH√îI PH·ª§C!';

                    if (!confirm(confirmMessage)) {
                        return;
                    }

                    // X√°c nh·∫≠n l·∫ßn 2
                    if (!confirm('X√°c nh·∫≠n l·∫ßn cu·ªëi: X√ìA TO√ÄN B·ªò D·ªÆ LI·ªÜU?')) {
                        return;
                    }

                    try {
                        // ƒê·∫øm s·ªë items tr∆∞·ªõc khi x√≥a
                        const itemCount = localStorage.length;
                        const keys = Object.keys(localStorage);

                        console.log('üóëÔ∏è B·∫Øt ƒë·∫ßu x√≥a to√†n b·ªô localStorage...');
                        console.log('üìä T·ªïng s·ªë items:', itemCount);
                        console.log('üîë Keys:', keys);

                        // X√≥a to√†n b·ªô localStorage
                        localStorage.clear();

                        console.log('‚úÖ ƒê√£ x√≥a to√†n b·ªô localStorage');

                        // X√≥a galleryImages n·∫øu c√≥
                        if (window.converter && window.converter.galleryImages) {
                            window.converter.galleryImages = [];
                            console.log('‚úÖ ƒê√£ x√≥a galleryImages');
                        }

                        // Reset c√°c data structures kh√°c
                        if (window.converter) {
                            window.converter.files = [];
                            window.converter.cropFiles = [];
                            console.log('‚úÖ ƒê√£ reset files v√† cropFiles');
                        }

                        // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
                        if (window.imageConverter && typeof window.imageConverter.showToast === 'function') {
                            window.imageConverter.showToast(`‚úÖ ƒê√£ x√≥a ${itemCount} items kh·ªèi LocalStorage!`, 'success');
                        } else {
                            alert(`‚úÖ ƒê√£ x√≥a to√†n b·ªô d·ªØ li·ªáu!\n\nƒê√£ x√≥a ${itemCount} items.`);
                        }

                        // Reload trang sau 1.5s
                        setTimeout(() => {
                            console.log('üîÑ Reloading page...');
                            window.location.reload();
                        }, 1500);

                    } catch (error) {
                        console.error('‚ùå L·ªói khi x√≥a localStorage:', error);
                        if (window.imageConverter && typeof window.imageConverter.showToast === 'function') {
                            window.imageConverter.showToast('‚ùå L·ªói khi x√≥a d·ªØ li·ªáu: ' + error.message, 'error');
                        } else {
                            alert('‚ùå L·ªói khi x√≥a d·ªØ li·ªáu:\n' + error.message);
                        }
                    }
                });
            }

            if (grantPermissionBtn) {
                grantPermissionBtn.addEventListener('click', async () => {
                    try {
                        if (!window.converter) {
                            window.converter = {};
                        }
                        if (!window.converter.fileSystemStorage) {
                            try {
                                if (typeof window.FileSystemStorage === 'function') {
                                    window.converter.fileSystemStorage = new window.FileSystemStorage();
                                } else {
                                    throw new Error('FileSystemStorage class ch∆∞a ƒë∆∞·ª£c load');
                                }
                            } catch (error) {
                                throw new Error('Kh√¥ng th·ªÉ kh·ªüi t·∫°o FileSystemStorage: ' + error.message);
                            }
                        }

                        await window.converter.fileSystemStorage.init();

                        // Update status v√† UI
                        const statusElement = document.getElementById('fsDirectoryName');
                        if (statusElement) {
                            statusElement.textContent = '‚úÖ ƒê√£ c·∫•p quy·ªÅn';
                        }
                        grantPermissionBtn.textContent = '‚úÖ ƒê√£ c·∫•p quy·ªÅn';
                        grantPermissionBtn.disabled = true;

                        // Auto scan after granting permission
                        setTimeout(() => {
                            if (typeof scanFileSystemImages === 'function') {
                                scanFileSystemImages();
                            }
                        }, 500);

                    } catch (error) {
                        console.error('L·ªói c·∫•p quy·ªÅn:', error);
                        if (window.converter && typeof window.converter.showToast === 'function') {
                            window.converter.showToast('‚ùå L·ªói c·∫•p quy·ªÅn: ' + error.message, 'error');
                        } else {
                            alert('‚ùå L·ªói c·∫•p quy·ªÅn: ' + error.message);
                        }
                    }
                });
            }

            if (scanImagesBtn) {
                scanImagesBtn.addEventListener('click', () => {
                    if (typeof scanFileSystemImages === 'function') {
                        scanFileSystemImages();
                    }
                });
            }

            // Search input
            const searchInput = document.getElementById('fsSearchInput');
            if (searchInput) {
                let searchTimeout;
                searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        if (typeof filterFileSystemImages === 'function') {
                            filterFileSystemImages(e.target.value);
                        }
                    }, 300);
                });
            }

            // Filter select
            const filterSelect = document.getElementById('fsFormatFilter');
            if (filterSelect) {
                filterSelect.addEventListener('change', (e) => {
                    const filterType = e.target.value;
                    if (filterType === 'all') {
                        filteredImages = [...fileSystemImages];
                    } else {
                        filteredImages = fileSystemImages.filter(img => {
                            const ext = img.name.toLowerCase().split('.').pop();
                            if (filterType === 'jpg') return ['jpg', 'jpeg'].includes(ext);
                            return ext === filterType;
                        });
                    }
                    if (typeof displayFileSystemImages === 'function') {
                        displayFileSystemImages();
                    }
                });
            }

            // Folder filter select
            const folderFilterSelect = document.getElementById('folderFilterSelect');
            if (folderFilterSelect) {
                folderFilterSelect.addEventListener('change', (e) => {
                    if (typeof filterByFolder === 'function') {
                        filterByFolder(e.target.value);
                    }
                });
            }

            // Category filter select
            const categoryFilterSelect = document.getElementById('categoryFilterSelect');
            if (categoryFilterSelect) {
                categoryFilterSelect.addEventListener('change', (e) => {
                    if (typeof filterByCategory === 'function') {
                        filterByCategory(e.target.value);
                    }
                });
            }

            // Folder tree toggle button
            const folderTreeToggleBtn = document.getElementById('folderTreeToggleBtn');
            if (folderTreeToggleBtn) {
                folderTreeToggleBtn.addEventListener('click', () => {
                    if (typeof toggleTreeView === 'function') {
                        toggleTreeView();
                    }
                });
            }

            // View toggle buttons
            const gridViewBtn = document.getElementById('filesystemGridView');
            const listViewBtn = document.getElementById('filesystemListView');

            if (gridViewBtn) {
                gridViewBtn.addEventListener('click', () => {
                    currentViewMode = 'grid';
                    setActiveViewMode('grid');
                    if (typeof displayFileSystemImages === 'function') {
                        displayFileSystemImages();
                    }
                });
            }

            if (listViewBtn) {
                listViewBtn.addEventListener('click', () => {
                    currentViewMode = 'list';
                    setActiveViewMode('list');
                    if (typeof displayFileSystemImages === 'function') {
                        displayFileSystemImages();
                    }
                });
            }

            // Selection control buttons
            const selectAllBtn = document.getElementById('filesystemSelectAllBtn');
            const refreshBtn = document.getElementById('filesystemRefreshBtn');

            if (selectAllBtn) {
                selectAllBtn.addEventListener('click', () => {
                    if (typeof selectAllFileSystemImages === 'function') {
                        selectAllFileSystemImages();
                    }
                });
            }


            if (refreshBtn) {
                refreshBtn.addEventListener('click', () => {
                    // Clear current data
                    fileSystemImages = [];
                    filteredImages = [];
                    selectedFileSystemImages = [];

                    // Rescan
                    if (typeof scanFileSystemImages === 'function') {
                        scanFileSystemImages();
                    }
                });
            }

            // Check if permission already granted on page load
            setTimeout(() => {
                if (window.converter && window.converter.fileSystemStorage && window.converter.fileSystemStorage.directoryHandle) {
                    const statusElement = document.getElementById('fsDirectoryName');
                    if (statusElement) {
                        statusElement.textContent = '‚úÖ ƒê√£ c·∫•p quy·ªÅn';
                    }
                    if (grantPermissionBtn) {
                        grantPermissionBtn.textContent = '‚úÖ ƒê√£ c·∫•p quy·ªÅn';
                        grantPermissionBtn.disabled = true;
                    }
                }
            }, 1000);
        });

        // Helper functions for UI updates
        function setActiveViewMode(mode) {
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            const modeMap = {
                'grid': 'filesystemGridView',
                'list': 'filesystemListView'
            };
            const activeBtn = document.getElementById(modeMap[mode]);
            if (activeBtn) activeBtn.classList.add('active');
        }
    </script>

    <script type="text/javascript" src="instant_fix.js"></script>
</body>
</html>
